{"snippet": "abc.ABC", "intent": "A helper class that has ABCMeta as its metaclass.", "question_id": 0}
{"snippet": "abc.ABCMeta", "intent": "Metaclass for defining Abstract Base Classes (ABCs).", "question_id": 1}
{"snippet": "abc_meta.register(subclass)", "intent": "Register `subclass` as a \u201c virtual subclass \u201d of this ABC .", "question_id": 2}
{"snippet": "abc_meta.__subclasshook__(subclass)", "intent": "( Must be defined as a class method . ) Check whether `subclass` is considered a subclass of this ABC .", "question_id": 3}
{"snippet": "@abc.abstractmethod", "intent": "A decorator indicating abstract methods.", "question_id": 4}
{"snippet": "@abc.abstractclassmethod", "intent": "A subclass of the built-in classmethod(), indicating an abstract classmethod.", "question_id": 5}
{"snippet": "@abc.abstractstaticmethod", "intent": "A subclass of the built-in staticmethod(), indicating an abstract staticmethod.", "question_id": 6}
{"snippet": "@abc.abstractproperty", "intent": "A subclass of the built-in property(), indicating an abstract property.", "question_id": 7}
{"snippet": "abc.get_cache_token()", "intent": "Returns the current abstract base class cache token .", "question_id": 8}
{"snippet": "aifc.open(file)", "intent": "Open an AIFF or AIFF-C `file` and return an object instance with methods that are described below .", "question_id": 9}
{"snippet": "aifc.open(file, mode=None)", "intent": "Open an AIFF or AIFF-C `file` and return an object instance with methods that are described below . `mode` must be ' r ' or 'rb ' when the file must be opened for reading , or ' w ' or 'wb ' when the file must be opened for writing .", "question_id": 10}
{"snippet": "aifc.getnchannels()", "intent": "Return the number of audio channels ( 1 for mono , 2 for stereo ) .", "question_id": 11}
{"snippet": "aifc.getsampwidth()", "intent": "Return the size in bytes of individual samples .", "question_id": 12}
{"snippet": "aifc.getframerate()", "intent": "Return the sampling rate ( number of audio frames per second ) .", "question_id": 13}
{"snippet": "aifc.getnframes()", "intent": "Return the number of audio frames in the file .", "question_id": 14}
{"snippet": "aifc.getcomptype()", "intent": "Return a bytes array of length 4 describing the type of compression used in the audio file .", "question_id": 15}
{"snippet": "aifc.getcompname()", "intent": "Return a bytes array convertible to a human-readable description of the type of compression used in the audio file .", "question_id": 16}
{"snippet": "aifc.getparams()", "intent": "Returns a namedtuple ( ) ( nchannels , sampwidth , framerate , nframes , comptype , compname ) , equivalent to output of the get* ( ) methods .", "question_id": 17}
{"snippet": "aifc.getmarkers()", "intent": "Return a list of markers in the audio file .", "question_id": 18}
{"snippet": "aifc.getmark(id)", "intent": "Return the tuple as described in getmarkers ( ) for the mark with the given `id` .", "question_id": 19}
{"snippet": "aifc.readframes(nframes)", "intent": "Read and return the next `nframes` frames from the audio file .", "question_id": 20}
{"snippet": "aifc.rewind()", "intent": "Rewind the read pointer .", "question_id": 21}
{"snippet": "aifc.setpos(pos)", "intent": "Seek to the specified frame number . With arguments `pos`.", "question_id": 22}
{"snippet": "aifc.tell()", "intent": "Return the current frame number .", "question_id": 23}
{"snippet": "aifc.close()", "intent": "Close the AIFF file .", "question_id": 24}
{"snippet": "aifc.aiff()", "intent": "Create an AIFF file .", "question_id": 25}
{"snippet": "aifc.aifc()", "intent": "Create an AIFF-C file .", "question_id": 26}
{"snippet": "aifc.setnchannels(nchannels)", "intent": "Specify the number of channels in the audio file . With arguments `nchannels`.", "question_id": 27}
{"snippet": "aifc.setsampwidth(width)", "intent": "Specify the size in bytes of audio samples . With arguments `width`.", "question_id": 28}
{"snippet": "aifc.setframerate(rate)", "intent": "Specify the sampling frequency in frames per second . With arguments `rate`.", "question_id": 29}
{"snippet": "aifc.setnframes(nframes)", "intent": "Specify the number of frames that are to be written to the audio file . With arguments `nframes`.", "question_id": 30}
{"snippet": "aifc.setcomptype(type, name)", "intent": "Specify the compression `type` . The `name` parameter should be a human-readable description of the compression type as a bytes array , the type parameter should be a bytes array of length 4 .", "question_id": 31}
{"snippet": "aifc.setparams(nchannels, sampwidth, framerate, comptype, compname)", "intent": "Set all the above parameters at once . With arguments `nchannels`, `sampwidth`, `framerate`, `comptype`, `compname`.", "question_id": 32}
{"snippet": "aifc.setmark(id, pos, name)", "intent": "Add a mark with the given `id` ( larger than 0 ) , and the given `name` at the given position . With arguments `pos`.", "question_id": 33}
{"snippet": "aifc.tell()", "intent": "Return the current write position in the output file .", "question_id": 34}
{"snippet": "aifc.writeframes(data)", "intent": "Write `data` to the output file .", "question_id": 35}
{"snippet": "aifc.writeframesraw(data)", "intent": "Like writeframes ( ) , except that the header of the audio file is not updated . With arguments `data`.", "question_id": 36}
{"snippet": "aifc.close()", "intent": "Close the AIFF file .", "question_id": 37}
{"snippet": "argparse.ArgumentParser()", "intent": "Create a new ArgumentParser object .", "question_id": 38}
{"snippet": "argparse.ArgumentParser(prog=None)", "intent": "Create a new ArgumentParser object . With arguments `prog`.", "question_id": 39}
{"snippet": "argparse.ArgumentParser(usage=None)", "intent": "Create a new ArgumentParser object . With arguments `usage`.", "question_id": 40}
{"snippet": "argparse.ArgumentParser(description=None)", "intent": "Create a new ArgumentParser object . Each parameter has its own more detailed `description` below , but in short they are :", "question_id": 41}
{"snippet": "argparse.ArgumentParser(epilog=None)", "intent": "Create a new ArgumentParser object . With arguments `epilog`.", "question_id": 42}
{"snippet": "argparse.ArgumentParser(parents=)", "intent": "Create a new ArgumentParser object . With arguments `parents`.", "question_id": 43}
{"snippet": "argparse.ArgumentParser(formatter_class=argparse.HelpFormatter)", "intent": "Create a new ArgumentParser object . With arguments `formatter_class`.", "question_id": 44}
{"snippet": "argparse.ArgumentParser(prefix_chars='-')", "intent": "Create a new ArgumentParser object . With arguments `prefix_chars`.", "question_id": 45}
{"snippet": "argparse.ArgumentParser(fromfile_prefix_chars=None)", "intent": "Create a new ArgumentParser object . With arguments `fromfile_prefix_chars`.", "question_id": 46}
{"snippet": "argparse.ArgumentParser(argument_default=None)", "intent": "Create a new ArgumentParser object . With arguments `argument_default`.", "question_id": 47}
{"snippet": "argparse.ArgumentParser()", "intent": "Create a new ArgumentParser object .", "question_id": 48}
{"snippet": "argparse.ArgumentParser(prog=None)", "intent": "Create a new ArgumentParser object . With arguments `prog`.", "question_id": 49}
{"snippet": "argparse.ArgumentParser(usage=None)", "intent": "Create a new ArgumentParser object . With arguments `usage`.", "question_id": 50}
{"snippet": "argparse.ArgumentParser(description=None)", "intent": "Create a new ArgumentParser object . Each parameter has its own more detailed `description` below , but in short they are :", "question_id": 51}
{"snippet": "argparse.ArgumentParser(epilog=None)", "intent": "Create a new ArgumentParser object . With arguments `epilog`.", "question_id": 52}
{"snippet": "argparse.ArgumentParser(parents=)", "intent": "Create a new ArgumentParser object . With arguments `parents`.", "question_id": 53}
{"snippet": "argparse.ArgumentParser(formatter_class=argparse.HelpFormatter)", "intent": "Create a new ArgumentParser object . With arguments `formatter_class`.", "question_id": 54}
{"snippet": "argparse.ArgumentParser(prefix_chars='-')", "intent": "Create a new ArgumentParser object . With arguments `prefix_chars`.", "question_id": 55}
{"snippet": "argparse.ArgumentParser(fromfile_prefix_chars=None)", "intent": "Create a new ArgumentParser object . With arguments `fromfile_prefix_chars`.", "question_id": 56}
{"snippet": "argparse.ArgumentParser(argument_default=None)", "intent": "Create a new ArgumentParser object . With arguments `argument_default`.", "question_id": 57}
{"snippet": "ArgumentParser.add_argument(name or flags..., action, nargs, const, default, type, choices, required, help, metavar, dest)", "intent": "Define how a single command-line argument should be parsed . With arguments `name or flags...`, `action`, `nargs`, `const`, `default`, `type`, `choices`, `required`, `help`, `metavar`, `dest`.", "question_id": 58}
{"snippet": "ArgumentParser.add_argument(name or flags..., action, nargs, const, default, type, choices, required, help, metavar)", "intent": "Define how a single command-line argument should be parsed . With arguments `name or flags...`, `action`, `nargs`, `const`, `default`, `type`, `choices`, `required`, `help`, `metavar`.", "question_id": 59}
{"snippet": "ArgumentParser.add_argument(name or flags..., action, nargs, const, default, type, choices, required, help)", "intent": "Define how a single command-line argument should be parsed . With arguments `name or flags...`, `action`, `nargs`, `const`, `default`, `type`, `choices`, `required`, `help`.", "question_id": 60}
{"snippet": "ArgumentParser.add_argument(name or flags..., action, nargs, const, default, type, choices, required)", "intent": "Define how a single command-line argument should be parsed . With arguments `name or flags...`, `action`, `nargs`, `const`, `default`, `type`, `choices`, `required`.", "question_id": 61}
{"snippet": "ArgumentParser.add_argument(name or flags..., action, nargs, const, default, type, choices)", "intent": "Define how a single command-line argument should be parsed . With arguments `name or flags...`, `action`, `nargs`, `const`, `default`, `type`, `choices`.", "question_id": 62}
{"snippet": "ArgumentParser.add_argument(name or flags..., action, nargs, const, default, type)", "intent": "Define how a single command-line argument should be parsed . With arguments `name or flags...`, `action`, `nargs`, `const`, `default`, `type`.", "question_id": 63}
{"snippet": "ArgumentParser.add_argument(name or flags..., action, nargs, const, default)", "intent": "Define how a single command-line argument should be parsed . With arguments `name or flags...`, `action`, `nargs`, `const`, `default`.", "question_id": 64}
{"snippet": "ArgumentParser.add_argument(name or flags..., action, nargs, const)", "intent": "Define how a single command-line argument should be parsed . With arguments `name or flags...`, `action`, `nargs`, `const`.", "question_id": 65}
{"snippet": "ArgumentParser.add_argument(name or flags..., action, nargs)", "intent": "Define how a single command-line argument should be parsed . With arguments `name or flags...`, `action`, `nargs`.", "question_id": 66}
{"snippet": "ArgumentParser.add_argument(name or flags..., action)", "intent": "Define how a single command-line argument should be parsed . With arguments `name or flags...`, `action`.", "question_id": 67}
{"snippet": "ArgumentParser.add_argument(name or flags...)", "intent": "Define how a single command-line argument should be parsed . With arguments `name or flags...`.", "question_id": 68}
{"snippet": "ArgumentParser.parse_args()", "intent": "Convert argument strings to objects and assign them as attributes of the `namespace` .", "question_id": 69}
{"snippet": "ArgumentParser.parse_args(args=None)", "intent": "Convert argument strings to objects and assign them as attributes of the `namespace` . With arguments `args`.", "question_id": 70}
{"snippet": "ArgumentParser.parse_args(namespace=None)", "intent": "Convert argument strings to objects and assign them as attributes of the `namespace` .", "question_id": 71}
{"snippet": "ArgumentParser.parse_args(args=None, namespace=None)", "intent": "Convert argument strings to objects and assign them as attributes of the `namespace` . With arguments `args`.", "question_id": 72}
{"snippet": "argparse.Namespace", "intent": "Simple class used by default by parse_args() to create an object holding attributes and return it.", "question_id": 73}
{"snippet": "ArgumentParser.add_subparsers(title, description, prog, parser_class, action, option_string, dest, required, help, metavar)", "intent": "Many programs split up their functionality into a number of sub-commands , for example , the svn program can invoke sub-commands like svn checkout , svn update , and svn commit . The add_subparsers ( ) method also supports `title` and `description` keyword arguments . The add_subparsers ( ) method is normally called with no arguments and returns a special `action` object . However , if it is necessary to check the name of the subparser that was invoked , the `dest` keyword argument to the add_subparsers ( ) call will work : Similarly , when a `help` message is requested from a subparser , only the help for that particular parser will be printed . With arguments `prog`, `parser_class`, `option_string`, `required`, `metavar`.", "question_id": 74}
{"snippet": "ArgumentParser.add_subparsers(title, description, prog, parser_class, action, option_string, dest, required, help)", "intent": "Many programs split up their functionality into a number of sub-commands , for example , the svn program can invoke sub-commands like svn checkout , svn update , and svn commit . The add_subparsers ( ) method also supports `title` and `description` keyword arguments . The add_subparsers ( ) method is normally called with no arguments and returns a special `action` object . However , if it is necessary to check the name of the subparser that was invoked , the `dest` keyword argument to the add_subparsers ( ) call will work : Similarly , when a `help` message is requested from a subparser , only the help for that particular parser will be printed . With arguments `prog`, `parser_class`, `option_string`, `required`.", "question_id": 75}
{"snippet": "ArgumentParser.add_subparsers(title, description, prog, parser_class, action, option_string, dest, required)", "intent": "Many programs split up their functionality into a number of sub-commands , for example , the svn program can invoke sub-commands like svn checkout , svn update , and svn commit . The add_subparsers ( ) method also supports `title` and `description` keyword arguments . The add_subparsers ( ) method is normally called with no arguments and returns a special `action` object . However , if it is necessary to check the name of the subparser that was invoked , the `dest` keyword argument to the add_subparsers ( ) call will work : With arguments `prog`, `parser_class`, `option_string`, `required`.", "question_id": 76}
{"snippet": "ArgumentParser.add_subparsers(title, description, prog, parser_class, action, option_string, dest)", "intent": "Many programs split up their functionality into a number of sub-commands , for example , the svn program can invoke sub-commands like svn checkout , svn update , and svn commit . The add_subparsers ( ) method also supports `title` and `description` keyword arguments . The add_subparsers ( ) method is normally called with no arguments and returns a special `action` object . However , if it is necessary to check the name of the subparser that was invoked , the `dest` keyword argument to the add_subparsers ( ) call will work : With arguments `prog`, `parser_class`, `option_string`.", "question_id": 77}
{"snippet": "ArgumentParser.add_subparsers(title, description, prog, parser_class, action, option_string)", "intent": "Many programs split up their functionality into a number of sub-commands , for example , the svn program can invoke sub-commands like svn checkout , svn update , and svn commit . The add_subparsers ( ) method also supports `title` and `description` keyword arguments . The add_subparsers ( ) method is normally called with no arguments and returns a special `action` object . With arguments `prog`, `parser_class`, `option_string`.", "question_id": 78}
{"snippet": "ArgumentParser.add_subparsers(title, description, prog, parser_class, action)", "intent": "Many programs split up their functionality into a number of sub-commands , for example , the svn program can invoke sub-commands like svn checkout , svn update , and svn commit . The add_subparsers ( ) method also supports `title` and `description` keyword arguments . The add_subparsers ( ) method is normally called with no arguments and returns a special `action` object . With arguments `prog`, `parser_class`.", "question_id": 79}
{"snippet": "ArgumentParser.add_subparsers(title, description, prog, parser_class)", "intent": "Many programs split up their functionality into a number of sub-commands , for example , the svn program can invoke sub-commands like svn checkout , svn update , and svn commit . The add_subparsers ( ) method also supports `title` and `description` keyword arguments . With arguments `prog`, `parser_class`.", "question_id": 80}
{"snippet": "ArgumentParser.add_subparsers(title, description, prog)", "intent": "Many programs split up their functionality into a number of sub-commands , for example , the svn program can invoke sub-commands like svn checkout , svn update , and svn commit . The add_subparsers ( ) method also supports `title` and `description` keyword arguments . With arguments `prog`.", "question_id": 81}
{"snippet": "ArgumentParser.add_subparsers(title, description)", "intent": "Many programs split up their functionality into a number of sub-commands , for example , the svn program can invoke sub-commands like svn checkout , svn update , and svn commit . The add_subparsers ( ) method also supports `title` and `description` keyword arguments .", "question_id": 82}
{"snippet": "ArgumentParser.add_subparsers(title)", "intent": "Many programs split up their functionality into a number of sub-commands , for example , the svn program can invoke sub-commands like svn checkout , svn update , and svn commit . The add_subparsers ( ) method also supports `title` and `description` keyword arguments .", "question_id": 83}
{"snippet": "ArgumentParser.add_subparsers()", "intent": "Many programs split up their functionality into a number of sub-commands , for example , the svn program can invoke sub-commands like svn checkout , svn update , and svn commit .", "question_id": 84}
{"snippet": "argparse.FileType()", "intent": "The FileType factory creates objects that can be passed to the type argument of ArgumentParser.add_argument ( ) .", "question_id": 85}
{"snippet": "argparse.FileType(mode='r')", "intent": "The FileType factory creates objects that can be passed to the type argument of ArgumentParser.add_argument ( ) . With arguments `mode`.", "question_id": 86}
{"snippet": "argparse.FileType(bufsize=-1)", "intent": "The FileType factory creates objects that can be passed to the type argument of ArgumentParser.add_argument ( ) . With arguments `bufsize`.", "question_id": 87}
{"snippet": "argparse.FileType(encoding=None)", "intent": "The FileType factory creates objects that can be passed to the type argument of ArgumentParser.add_argument ( ) . With arguments `encoding`.", "question_id": 88}
{"snippet": "argparse.FileType(errors=None)", "intent": "The FileType factory creates objects that can be passed to the type argument of ArgumentParser.add_argument ( ) . With arguments `errors`.", "question_id": 89}
{"snippet": "argparse.FileType(mode='r', bufsize=-1)", "intent": "The FileType factory creates objects that can be passed to the type argument of ArgumentParser.add_argument ( ) . With arguments `mode`, `bufsize`.", "question_id": 90}
{"snippet": "argparse.FileType(mode='r', encoding=None)", "intent": "The FileType factory creates objects that can be passed to the type argument of ArgumentParser.add_argument ( ) . With arguments `mode`, `encoding`.", "question_id": 91}
{"snippet": "argparse.FileType(mode='r', errors=None)", "intent": "The FileType factory creates objects that can be passed to the type argument of ArgumentParser.add_argument ( ) . With arguments `mode`, `errors`.", "question_id": 92}
{"snippet": "argparse.FileType(bufsize=-1, encoding=None)", "intent": "The FileType factory creates objects that can be passed to the type argument of ArgumentParser.add_argument ( ) . With arguments `bufsize`, `encoding`.", "question_id": 93}
{"snippet": "argparse.FileType(bufsize=-1, errors=None)", "intent": "The FileType factory creates objects that can be passed to the type argument of ArgumentParser.add_argument ( ) . With arguments `bufsize`, `errors`.", "question_id": 94}
{"snippet": "ArgumentParser.add_argument_group()", "intent": "By default , ArgumentParser groups command-line arguments into \u201c positional arguments \u201d and \u201c optional arguments \u201d when displaying help messages .", "question_id": 95}
{"snippet": "ArgumentParser.add_argument_group(title=None)", "intent": "By default , ArgumentParser groups command-line arguments into \u201c positional arguments \u201d and \u201c optional arguments \u201d when displaying help messages . The add_argument_group ( ) method accepts `title` and `description` arguments which can be used to customize this display :", "question_id": 96}
{"snippet": "ArgumentParser.add_argument_group(description=None)", "intent": "By default , ArgumentParser groups command-line arguments into \u201c positional arguments \u201d and \u201c optional arguments \u201d when displaying help messages . The add_argument_group ( ) method accepts `title` and `description` arguments which can be used to customize this display :", "question_id": 97}
{"snippet": "ArgumentParser.add_argument_group(title=None, description=None)", "intent": "By default , ArgumentParser groups command-line arguments into \u201c positional arguments \u201d and \u201c optional arguments \u201d when displaying help messages . The add_argument_group ( ) method accepts `title` and `description` arguments which can be used to customize this display :", "question_id": 98}
{"snippet": "ArgumentParser.add_mutually_exclusive_group()", "intent": "Create a mutually exclusive group .", "question_id": 99}
{"snippet": "ArgumentParser.add_mutually_exclusive_group(required=False)", "intent": "Create a mutually exclusive group . The add_mutually_exclusive_group ( ) method also accepts a `required` argument , to indicate that at least one of the mutually exclusive arguments is required :", "question_id": 100}
{"snippet": "ArgumentParser.set_defaults(**kwargs)", "intent": "Most of the time , the attributes of the object returned by parse_args ( ) will be fully determined by inspecting the command-line arguments and the argument actions . With arguments `**kwargs`.", "question_id": 101}
{"snippet": "ArgumentParser.get_default(dest)", "intent": "Get the default value for a namespace attribute , as set by either add_argument ( ) or by set_defaults ( ) : With arguments `dest`.", "question_id": 102}
{"snippet": "ArgumentParser.print_usage()", "intent": "Print a brief description of how the ArgumentParser should be invoked on the command line .", "question_id": 103}
{"snippet": "ArgumentParser.print_usage(file=None)", "intent": "Print a brief description of how the ArgumentParser should be invoked on the command line . If `file` is None , sys.stdout is assumed .", "question_id": 104}
{"snippet": "ArgumentParser.print_help()", "intent": "Print a help message , including the program usage and information about the arguments registered with the ArgumentParser .", "question_id": 105}
{"snippet": "ArgumentParser.print_help(file=None)", "intent": "Print a help message , including the program usage and information about the arguments registered with the ArgumentParser . If `file` is None , sys.stdout is assumed .", "question_id": 106}
{"snippet": "ArgumentParser.format_usage()", "intent": "Return a string containing a brief description of how the ArgumentParser should be invoked on the command line .", "question_id": 107}
{"snippet": "ArgumentParser.format_help()", "intent": "Return a string containing a help message , including the program usage and information about the arguments registered with the ArgumentParser .", "question_id": 108}
{"snippet": "ArgumentParser.convert_arg_line_to_args(arg_line)", "intent": "Arguments that are read from a file ( see the fromfile_prefix_chars keyword argument to the ArgumentParser constructor ) are read one argument per line . This method takes a single argument `arg_line` which is a string read from the argument file .", "question_id": 109}
{"snippet": "ArgumentParser.exit()", "intent": "This method terminates the program , exiting with the specified `status` and , if given , it prints a `message` before that .", "question_id": 110}
{"snippet": "ArgumentParser.exit(status=0)", "intent": "This method terminates the program , exiting with the specified `status` and , if given , it prints a `message` before that .", "question_id": 111}
{"snippet": "ArgumentParser.exit(message=None)", "intent": "This method terminates the program , exiting with the specified `status` and , if given , it prints a `message` before that .", "question_id": 112}
{"snippet": "ArgumentParser.exit(status=0, message=None)", "intent": "This method terminates the program , exiting with the specified `status` and , if given , it prints a `message` before that .", "question_id": 113}
{"snippet": "ArgumentParser.error(message)", "intent": "This method prints a usage `message` including the message to the standard error and terminates the program with a status code of 2 .", "question_id": 114}
{"snippet": "array.array(typecode, initializer)", "intent": "A new array whose items are restricted by `typecode` , and initialized from the optional `initializer` value , which must be a list , a bytes-like object , or iterable over elements of the appropriate type .", "question_id": 115}
{"snippet": "array.array(typecode)", "intent": "A new array whose items are restricted by `typecode` , and initialized from the optional `initializer` value , which must be a list , a bytes-like object , or iterable over elements of the appropriate type .", "question_id": 116}
{"snippet": "array.typecodes", "intent": "A string with all available type codes.", "question_id": 117}
{"snippet": "array.typecode", "intent": "The typecode character used to create the array.", "question_id": 118}
{"snippet": "array.itemsize", "intent": "The length in bytes of one array item in the internal representation.", "question_id": 119}
{"snippet": "array.append(x)", "intent": "Append a new item with value `x` to the end of the array .", "question_id": 120}
{"snippet": "array.buffer_info()", "intent": "Return a tuple ( address , length ) giving the current memory address and the length in elements of the buffer used to hold array \u2019 s contents .", "question_id": 121}
{"snippet": "array.byteswap()", "intent": "\u201c Byteswap \u201d all items of the array .", "question_id": 122}
{"snippet": "array.count(x)", "intent": "Return the number of occurrences of `x` in the array .", "question_id": 123}
{"snippet": "array.extend(iterable)", "intent": "Append items from `iterable` to the end of the array .", "question_id": 124}
{"snippet": "array.frombytes(s)", "intent": "Appends items from the string , interpreting the string as an array of machine values ( as if it had been read from a file using the fromfile ( ) method ) . With arguments `s`.", "question_id": 125}
{"snippet": "array.fromfile(f, n)", "intent": "Read `n` items ( as machine values ) from the file object `f` and append them to the end of the array .", "question_id": 126}
{"snippet": "array.fromlist(list)", "intent": "Append items from the `list` .", "question_id": 127}
{"snippet": "array.fromstring()", "intent": "Deprecated alias for frombytes ( ) .", "question_id": 128}
{"snippet": "array.fromunicode(s)", "intent": "Extends this array with data from the given unicode string . With arguments `s`.", "question_id": 129}
{"snippet": "array.index(x)", "intent": "Return the smallest i such that i is the index of the first occurrence of `x` in the array .", "question_id": 130}
{"snippet": "array.insert(i, x)", "intent": "Insert a new item with value `x` in the array before position `i` .", "question_id": 131}
{"snippet": "array.pop(i)", "intent": "Removes the item with the index `i` from the array and returns it .", "question_id": 132}
{"snippet": "array.pop()", "intent": "Removes the item with the index `i` from the array and returns it .", "question_id": 133}
{"snippet": "array.remove(x)", "intent": "Remove the first occurrence of `x` from the array .", "question_id": 134}
{"snippet": "array.reverse()", "intent": "Reverse the order of the items in the array .", "question_id": 135}
{"snippet": "array.tobytes()", "intent": "Convert the array to an array of machine values and return the bytes representation ( the same sequence of bytes that would be written to a file by the tofile ( ) method . )", "question_id": 136}
{"snippet": "array.tofile(f)", "intent": "Write all items ( as machine values ) to the file object `f` .", "question_id": 137}
{"snippet": "array.tolist()", "intent": "Convert the array to an ordinary list with the same items .", "question_id": 138}
{"snippet": "array.tostring()", "intent": "Deprecated alias for tobytes ( ) .", "question_id": 139}
{"snippet": "array.tounicode()", "intent": "Convert the array to a unicode string .", "question_id": 140}
{"snippet": "ast.AST", "intent": "This is the base of all AST node classes.", "question_id": 141}
{"snippet": "ast._fields", "intent": "Each concrete class has an attribute _fields which gives the names of all child nodes.", "question_id": 142}
{"snippet": "ast.lineno", "intent": "Instances of ast.expr and ast.stmt subclasses have lineno and col_offset attributes.", "question_id": 143}
{"snippet": "ast.col_offset", "intent": "Instances of ast.expr and ast.stmt subclasses have lineno and col_offset attributes.", "question_id": 144}
{"snippet": "ast.parse(source)", "intent": "Parse the `source` into an AST node .", "question_id": 145}
{"snippet": "ast.parse(source, filename='<unknown>')", "intent": "Parse the `source` into an AST node . Equivalent to compile ( source , `filename` , `mode` , ast.PyCF_ONLY_AST ) .", "question_id": 146}
{"snippet": "ast.parse(source, mode='exec')", "intent": "Parse the `source` into an AST node . Equivalent to compile ( source , `filename` , `mode` , ast.PyCF_ONLY_AST ) .", "question_id": 147}
{"snippet": "ast.parse(source, filename='<unknown>', mode='exec')", "intent": "Parse the `source` into an AST node . Equivalent to compile ( source , `filename` , `mode` , ast.PyCF_ONLY_AST ) .", "question_id": 148}
{"snippet": "ast.literal_eval(node_or_string)", "intent": "Safely evaluate an expression node or a string containing a Python literal or container display . With arguments `node_or_string`.", "question_id": 149}
{"snippet": "ast.get_docstring(node)", "intent": "Return the docstring of the given `node` ( which must be a FunctionDef , AsyncFunctionDef , ClassDef , or Module node ) , or None if it has no docstring .", "question_id": 150}
{"snippet": "ast.get_docstring(node, clean=True)", "intent": "Return the docstring of the given `node` ( which must be a FunctionDef , AsyncFunctionDef , ClassDef , or Module node ) , or None if it has no docstring . If `clean` is true , clean up the docstring \u2019 s indentation with inspect.cleandoc ( ) .", "question_id": 151}
{"snippet": "ast.fix_missing_locations(node)", "intent": "When you compile a `node` tree with compile ( ) , the compiler expects lineno and col_offset attributes for every node that supports them .", "question_id": 152}
{"snippet": "ast.increment_lineno(node)", "intent": "Increment the line number of each `node` in the tree starting at node by n. This is useful to \u201c move code \u201d to a different location in a file .", "question_id": 153}
{"snippet": "ast.increment_lineno(node, n=1)", "intent": "Increment the line number of each `node` in the tree starting at node by n. This is useful to \u201c move code \u201d to a different location in a file . With arguments `n`.", "question_id": 154}
{"snippet": "ast.copy_location(new_node, old_node)", "intent": "Copy source location ( lineno and col_offset ) from `old_node` to `new_node` if possible , and return new_node .", "question_id": 155}
{"snippet": "ast.iter_fields(node)", "intent": "Yield a tuple of ( fieldname , value ) for each field in node._fields that is present on `node` .", "question_id": 156}
{"snippet": "ast.iter_child_nodes(node)", "intent": "Yield all direct child nodes of `node` , that is , all fields that are nodes and all items of fields that are lists of nodes .", "question_id": 157}
{"snippet": "ast.walk(node)", "intent": "Recursively yield all descendant nodes in the tree starting at `node` ( including node itself ) , in no specified order .", "question_id": 158}
{"snippet": "ast.NodeVisitor", "intent": "A node visitor base class that walks the abstract syntax tree and calls a visitor function for every node found.", "question_id": 159}
{"snippet": "node_visitor.visit(node)", "intent": "Visit a `node` .", "question_id": 160}
{"snippet": "node_visitor.generic_visit(node)", "intent": "This visitor calls visit ( ) on all children of the `node` .", "question_id": 161}
{"snippet": "ast.NodeTransformer", "intent": "A NodeVisitor subclass that walks the abstract syntax tree and allows modification of nodes.", "question_id": 162}
{"snippet": "ast.dump(node)", "intent": "Return a formatted dump of the tree in `node` .", "question_id": 163}
{"snippet": "ast.dump(node, annotate_fields=True)", "intent": "Return a formatted dump of the tree in `node` . If `annotate_fields` is true ( by default ) , the returned string will show the names and the values for fields .", "question_id": 164}
{"snippet": "ast.dump(node, include_attributes=False)", "intent": "Return a formatted dump of the tree in `node` . If this is wanted , `include_attributes` can be set to true .", "question_id": 165}
{"snippet": "ast.dump(node, annotate_fields=True, include_attributes=False)", "intent": "Return a formatted dump of the tree in `node` . If `annotate_fields` is true ( by default ) , the returned string will show the names and the values for fields . If this is wanted , `include_attributes` can be set to true .", "question_id": 166}
{"snippet": "asynchat.async_chat", "intent": "This class is an abstract subclass of asyncore.dispatcher.", "question_id": 167}
{"snippet": "ac_in_buffer_size", "intent": "The asynchronous input buffer size (default 4096).", "question_id": 168}
{"snippet": "ac_out_buffer_size", "intent": "The asynchronous output buffer size (default 4096).", "question_id": 169}
{"snippet": "async_chat.close_when_done()", "intent": "Pushes a None on to the producer queue .", "question_id": 170}
{"snippet": "async_chat.collect_incoming_data(data)", "intent": "Called with `data` holding an arbitrary amount of received data .", "question_id": 171}
{"snippet": "async_chat.discard_buffers()", "intent": "In emergencies this method will discard any data held in the input and/or output buffers and the producer queue .", "question_id": 172}
{"snippet": "async_chat.found_terminator()", "intent": "Called when the incoming data stream matches the termination condition set by set_terminator ( ) .", "question_id": 173}
{"snippet": "async_chat.get_terminator()", "intent": "Returns the current terminator for the channel .", "question_id": 174}
{"snippet": "async_chat.push(data)", "intent": "Pushes `data` on to the channel \u2019 s queue to ensure its transmission .", "question_id": 175}
{"snippet": "async_chat.push_with_producer(producer)", "intent": "Takes a `producer` object and adds it to the producer queue associated with the channel .", "question_id": 176}
{"snippet": "async_chat.set_terminator(term)", "intent": "Sets the terminating condition to be recognized on the channel . `term` may be any of three types of value , corresponding to three different ways to handle incoming protocol data .", "question_id": 177}
{"snippet": "asyncio.get_running_loop()", "intent": "Return the running event loop in the current OS thread .", "question_id": 178}
{"snippet": "asyncio.get_event_loop()", "intent": "Get the current event loop .", "question_id": 179}
{"snippet": "asyncio.set_event_loop(loop)", "intent": "Set `loop` as a current event loop for the current OS thread .", "question_id": 180}
{"snippet": "asyncio.new_event_loop()", "intent": "Create a new event loop object .", "question_id": 181}
{"snippet": "loop.run_until_complete(future)", "intent": "Run until the `future` ( an instance of Future ) has completed .", "question_id": 182}
{"snippet": "loop.run_forever()", "intent": "Run the event loop until stop ( ) is called .", "question_id": 183}
{"snippet": "loop.stop()", "intent": "Stop the event loop .", "question_id": 184}
{"snippet": "loop.is_running()", "intent": "Return True if the event loop is currently running .", "question_id": 185}
{"snippet": "loop.is_closed()", "intent": "Return True if the event loop was closed .", "question_id": 186}
{"snippet": "loop.close()", "intent": "Close the event loop .", "question_id": 187}
{"snippet": "loop.shutdown_asyncgens()", "intent": "Schedule all currently open asynchronous generator objects to close with an aclose ( ) call .", "question_id": 188}
{"snippet": "loop.call_soon(callback, *args)", "intent": "Schedule a `callback` to be called with args arguments at the next iteration of the event loop . With arguments `*args`.", "question_id": 189}
{"snippet": "loop.call_soon(callback, *args, context=None)", "intent": "Schedule a `callback` to be called with args arguments at the next iteration of the event loop . An optional keyword-only `context` argument allows specifying a custom contextvars.Context for the callback to run in . With arguments `*args`.", "question_id": 190}
{"snippet": "loop.call_soon_threadsafe(callback, *args)", "intent": "A thread-safe variant of call_soon ( ) . With arguments `callback`, `*args`.", "question_id": 191}
{"snippet": "loop.call_soon_threadsafe(callback, *args, context=None)", "intent": "A thread-safe variant of call_soon ( ) . With arguments `callback`, `*args`, `context`.", "question_id": 192}
{"snippet": "loop.call_later(delay, callback, *args)", "intent": "Schedule `callback` to be called after the given `delay` number of seconds ( can be either an int or a float ) . With arguments `*args`.", "question_id": 193}
{"snippet": "loop.call_later(delay, callback, *args, context=None)", "intent": "Schedule `callback` to be called after the given `delay` number of seconds ( can be either an int or a float ) . An optional keyword-only `context` argument allows specifying a custom contextvars.Context for the callback to run in . With arguments `*args`.", "question_id": 194}
{"snippet": "loop.call_at(when, callback, *args)", "intent": "Schedule `callback` to be called at the given absolute timestamp `when` ( an int or a float ) , using the same time reference as loop.time ( ) . With arguments `*args`.", "question_id": 195}
{"snippet": "loop.call_at(when, callback, *args, context=None)", "intent": "Schedule `callback` to be called at the given absolute timestamp `when` ( an int or a float ) , using the same time reference as loop.time ( ) . With arguments `*args`, `context`.", "question_id": 196}
{"snippet": "loop.time()", "intent": "Return the current time , as a float value , according to the event loop \u2019 s internal monotonic clock .", "question_id": 197}
{"snippet": "loop.create_future()", "intent": "Create an asyncio.Future object attached to the event loop .", "question_id": 198}
{"snippet": "loop.create_task(coro)", "intent": "Schedule the execution of a Coroutines . With arguments `coro`.", "question_id": 199}
{"snippet": "loop.set_task_factory(factory)", "intent": "Set a task `factory` that will be used by loop.create_task ( ) .", "question_id": 200}
{"snippet": "loop.get_task_factory()", "intent": "Return a task factory or None if the default one is in use .", "question_id": 201}
{"snippet": "loop.create_connection(protocol_factory)", "intent": "Open a streaming transport connection to a given address specified by `host` and `port` . `protocol_factory` must be a callable returning an asyncio protocol implementation .", "question_id": 202}
{"snippet": "loop.create_connection(protocol_factory, host=None)", "intent": "Open a streaming transport connection to a given address specified by `host` and `port` . `protocol_factory` must be a callable returning an asyncio protocol implementation .", "question_id": 203}
{"snippet": "loop.create_connection(protocol_factory, port=None)", "intent": "Open a streaming transport connection to a given address specified by `host` and `port` . `protocol_factory` must be a callable returning an asyncio protocol implementation .", "question_id": 204}
{"snippet": "loop.create_connection(protocol_factory, ssl=None)", "intent": "Open a streaming transport connection to a given address specified by `host` and `port` . `protocol_factory` must be a callable returning an asyncio protocol implementation . With arguments `ssl`.", "question_id": 205}
{"snippet": "loop.create_connection(protocol_factory, family=0)", "intent": "Open a streaming transport connection to a given address specified by `host` and `port` . `protocol_factory` must be a callable returning an asyncio protocol implementation . The socket `family` can be either AF_INET or AF_INET6 depending on host ( or the family argument , if provided ) .", "question_id": 206}
{"snippet": "loop.create_connection(protocol_factory, proto=0)", "intent": "Open a streaming transport connection to a given address specified by `host` and `port` . `protocol_factory` must be a callable returning an asyncio protocol implementation . With arguments `proto`.", "question_id": 207}
{"snippet": "loop.create_connection(protocol_factory, flags=0)", "intent": "Open a streaming transport connection to a given address specified by `host` and `port` . `protocol_factory` must be a callable returning an asyncio protocol implementation . With arguments `flags`.", "question_id": 208}
{"snippet": "loop.create_connection(protocol_factory, sock=None)", "intent": "Open a streaming transport connection to a given address specified by `host` and `port` . `protocol_factory` must be a callable returning an asyncio protocol implementation . With arguments `sock`.", "question_id": 209}
{"snippet": "loop.create_connection(protocol_factory, local_addr=None)", "intent": "Open a streaming transport connection to a given address specified by `host` and `port` . `protocol_factory` must be a callable returning an asyncio protocol implementation . With arguments `local_addr`.", "question_id": 210}
{"snippet": "loop.create_connection(protocol_factory, server_hostname=None)", "intent": "Open a streaming transport connection to a given address specified by `host` and `port` . `protocol_factory` must be a callable returning an asyncio protocol implementation . With arguments `server_hostname`.", "question_id": 211}
{"snippet": "loop.create_datagram_endpoint(protocol_factory)", "intent": "Create a datagram connection . `protocol_factory` must be a callable returning a protocol implementation .", "question_id": 212}
{"snippet": "loop.create_datagram_endpoint(protocol_factory, local_addr=None)", "intent": "Create a datagram connection . `protocol_factory` must be a callable returning a protocol implementation . With arguments `local_addr`.", "question_id": 213}
{"snippet": "loop.create_datagram_endpoint(protocol_factory, remote_addr=None)", "intent": "Create a datagram connection . `protocol_factory` must be a callable returning a protocol implementation . With arguments `remote_addr`.", "question_id": 214}
{"snippet": "loop.create_datagram_endpoint(protocol_factory, family=0)", "intent": "Create a datagram connection . `protocol_factory` must be a callable returning a protocol implementation . The socket `family` can be either AF_INET , AF_INET6 , or AF_UNIX , depending on host ( or the family argument , if provided ) .", "question_id": 215}
{"snippet": "loop.create_datagram_endpoint(protocol_factory, proto=0)", "intent": "Create a datagram connection . `protocol_factory` must be a callable returning a protocol implementation . With arguments `proto`.", "question_id": 216}
{"snippet": "loop.create_datagram_endpoint(protocol_factory, flags=0)", "intent": "Create a datagram connection . `protocol_factory` must be a callable returning a protocol implementation . With arguments `flags`.", "question_id": 217}
{"snippet": "loop.create_datagram_endpoint(protocol_factory, reuse_address=None)", "intent": "Create a datagram connection . `protocol_factory` must be a callable returning a protocol implementation . With arguments `reuse_address`.", "question_id": 218}
{"snippet": "loop.create_datagram_endpoint(protocol_factory, reuse_port=None)", "intent": "Create a datagram connection . `protocol_factory` must be a callable returning a protocol implementation . With arguments `reuse_port`.", "question_id": 219}
{"snippet": "loop.create_datagram_endpoint(protocol_factory, allow_broadcast=None)", "intent": "Create a datagram connection . `protocol_factory` must be a callable returning a protocol implementation . With arguments `allow_broadcast`.", "question_id": 220}
{"snippet": "loop.create_datagram_endpoint(protocol_factory, sock=None)", "intent": "Create a datagram connection . `protocol_factory` must be a callable returning a protocol implementation . With arguments `sock`.", "question_id": 221}
{"snippet": "loop.create_unix_connection(protocol_factory)", "intent": "Create a Unix connection . With arguments `protocol_factory`.", "question_id": 222}
{"snippet": "loop.create_unix_connection(protocol_factory, path=None)", "intent": "Create a Unix connection . `path` is the name of a Unix domain socket and is required , unless a `sock` parameter is specified . With arguments `protocol_factory`.", "question_id": 223}
{"snippet": "loop.create_unix_connection(protocol_factory, ssl=None)", "intent": "Create a Unix connection . With arguments `protocol_factory`, `ssl`.", "question_id": 224}
{"snippet": "loop.create_unix_connection(protocol_factory, sock=None)", "intent": "Create a Unix connection . `path` is the name of a Unix domain socket and is required , unless a `sock` parameter is specified . With arguments `protocol_factory`.", "question_id": 225}
{"snippet": "loop.create_unix_connection(protocol_factory, server_hostname=None)", "intent": "Create a Unix connection . With arguments `protocol_factory`, `server_hostname`.", "question_id": 226}
{"snippet": "loop.create_unix_connection(protocol_factory, ssl_handshake_timeout=None)", "intent": "Create a Unix connection . With arguments `protocol_factory`, `ssl_handshake_timeout`.", "question_id": 227}
{"snippet": "loop.create_unix_connection(protocol_factory, path=None, ssl=None)", "intent": "Create a Unix connection . `path` is the name of a Unix domain socket and is required , unless a `sock` parameter is specified . With arguments `protocol_factory`, `ssl`.", "question_id": 228}
{"snippet": "loop.create_unix_connection(protocol_factory, path=None, sock=None)", "intent": "Create a Unix connection . `path` is the name of a Unix domain socket and is required , unless a `sock` parameter is specified . With arguments `protocol_factory`.", "question_id": 229}
{"snippet": "loop.create_unix_connection(protocol_factory, path=None, server_hostname=None)", "intent": "Create a Unix connection . `path` is the name of a Unix domain socket and is required , unless a `sock` parameter is specified . With arguments `protocol_factory`, `server_hostname`.", "question_id": 230}
{"snippet": "loop.create_unix_connection(protocol_factory, path=None, ssl_handshake_timeout=None)", "intent": "Create a Unix connection . `path` is the name of a Unix domain socket and is required , unless a `sock` parameter is specified . With arguments `protocol_factory`, `ssl_handshake_timeout`.", "question_id": 231}
{"snippet": "loop.create_server(protocol_factory)", "intent": "Create a TCP server ( socket type SOCK_STREAM ) listening on `port` of the `host` address . With arguments `protocol_factory`.", "question_id": 232}
{"snippet": "loop.create_server(protocol_factory, host=None)", "intent": "Create a TCP server ( socket type SOCK_STREAM ) listening on `port` of the `host` address . With arguments `protocol_factory`.", "question_id": 233}
{"snippet": "loop.create_server(protocol_factory, port=None)", "intent": "Create a TCP server ( socket type SOCK_STREAM ) listening on `port` of the `host` address . With arguments `protocol_factory`.", "question_id": 234}
{"snippet": "loop.create_server(protocol_factory, family=socket.AF_UNSPEC)", "intent": "Create a TCP server ( socket type SOCK_STREAM ) listening on `port` of the `host` address . With arguments `protocol_factory`, `family`.", "question_id": 235}
{"snippet": "loop.create_server(protocol_factory, flags=socket.AI_PASSIVE)", "intent": "Create a TCP server ( socket type SOCK_STREAM ) listening on `port` of the `host` address . With arguments `protocol_factory`, `flags`.", "question_id": 236}
{"snippet": "loop.create_server(protocol_factory, sock=None)", "intent": "Create a TCP server ( socket type SOCK_STREAM ) listening on `port` of the `host` address . With arguments `protocol_factory`, `sock`.", "question_id": 237}
{"snippet": "loop.create_server(protocol_factory, backlog=100)", "intent": "Create a TCP server ( socket type SOCK_STREAM ) listening on `port` of the `host` address . With arguments `protocol_factory`, `backlog`.", "question_id": 238}
{"snippet": "loop.create_server(protocol_factory, ssl=None)", "intent": "Create a TCP server ( socket type SOCK_STREAM ) listening on `port` of the `host` address . With arguments `protocol_factory`, `ssl`.", "question_id": 239}
{"snippet": "loop.create_server(protocol_factory, reuse_address=None)", "intent": "Create a TCP server ( socket type SOCK_STREAM ) listening on `port` of the `host` address . With arguments `protocol_factory`, `reuse_address`.", "question_id": 240}
{"snippet": "loop.create_server(protocol_factory, reuse_port=None)", "intent": "Create a TCP server ( socket type SOCK_STREAM ) listening on `port` of the `host` address . With arguments `protocol_factory`, `reuse_port`.", "question_id": 241}
{"snippet": "loop.create_unix_server(protocol_factory)", "intent": "Similar to loop.create_server ( ) but works with the AF_UNIX socket family . With arguments `protocol_factory`.", "question_id": 242}
{"snippet": "loop.create_unix_server(protocol_factory, path=None)", "intent": "Similar to loop.create_server ( ) but works with the AF_UNIX socket family . `path` is the name of a Unix domain socket , and is required , unless a `sock` argument is provided . With arguments `protocol_factory`.", "question_id": 243}
{"snippet": "loop.create_unix_server(protocol_factory, sock=None)", "intent": "Similar to loop.create_server ( ) but works with the AF_UNIX socket family . `path` is the name of a Unix domain socket , and is required , unless a `sock` argument is provided . With arguments `protocol_factory`.", "question_id": 244}
{"snippet": "loop.create_unix_server(protocol_factory, backlog=100)", "intent": "Similar to loop.create_server ( ) but works with the AF_UNIX socket family . With arguments `protocol_factory`, `backlog`.", "question_id": 245}
{"snippet": "loop.create_unix_server(protocol_factory, ssl=None)", "intent": "Similar to loop.create_server ( ) but works with the AF_UNIX socket family . With arguments `protocol_factory`, `ssl`.", "question_id": 246}
{"snippet": "loop.create_unix_server(protocol_factory, ssl_handshake_timeout=None)", "intent": "Similar to loop.create_server ( ) but works with the AF_UNIX socket family . With arguments `protocol_factory`, `ssl_handshake_timeout`.", "question_id": 247}
{"snippet": "loop.create_unix_server(protocol_factory, start_serving=True)", "intent": "Similar to loop.create_server ( ) but works with the AF_UNIX socket family . With arguments `protocol_factory`, `start_serving`.", "question_id": 248}
{"snippet": "loop.create_unix_server(protocol_factory, path=None, sock=None)", "intent": "Similar to loop.create_server ( ) but works with the AF_UNIX socket family . `path` is the name of a Unix domain socket , and is required , unless a `sock` argument is provided . With arguments `protocol_factory`.", "question_id": 249}
{"snippet": "loop.create_unix_server(protocol_factory, path=None, backlog=100)", "intent": "Similar to loop.create_server ( ) but works with the AF_UNIX socket family . `path` is the name of a Unix domain socket , and is required , unless a `sock` argument is provided . With arguments `protocol_factory`, `backlog`.", "question_id": 250}
{"snippet": "loop.create_unix_server(protocol_factory, path=None, ssl=None)", "intent": "Similar to loop.create_server ( ) but works with the AF_UNIX socket family . `path` is the name of a Unix domain socket , and is required , unless a `sock` argument is provided . With arguments `protocol_factory`, `ssl`.", "question_id": 251}
{"snippet": "loop.connect_accepted_socket(protocol_factory, sock)", "intent": "Wrap an already accepted connection into a transport/protocol pair . With arguments `protocol_factory`, `sock`.", "question_id": 252}
{"snippet": "loop.connect_accepted_socket(protocol_factory, sock, ssl=None)", "intent": "Wrap an already accepted connection into a transport/protocol pair . With arguments `protocol_factory`, `sock`, `ssl`.", "question_id": 253}
{"snippet": "loop.connect_accepted_socket(protocol_factory, sock, ssl_handshake_timeout=None)", "intent": "Wrap an already accepted connection into a transport/protocol pair . With arguments `protocol_factory`, `sock`, `ssl_handshake_timeout`.", "question_id": 254}
{"snippet": "loop.connect_accepted_socket(protocol_factory, sock, ssl=None, ssl_handshake_timeout=None)", "intent": "Wrap an already accepted connection into a transport/protocol pair . With arguments `protocol_factory`, `sock`, `ssl`, `ssl_handshake_timeout`.", "question_id": 255}
{"snippet": "loop.sendfile(transport, file)", "intent": "Send a `file` over a `transport` .", "question_id": 256}
{"snippet": "loop.sendfile(transport, file, offset=0)", "intent": "Send a `file` over a `transport` . `offset` tells from where to start reading the file .", "question_id": 257}
{"snippet": "loop.sendfile(transport, file, count=None)", "intent": "Send a `file` over a `transport` . If specified , `count` is the total number of bytes to transmit as opposed to sending the file until EOF is reached .", "question_id": 258}
{"snippet": "loop.sendfile(transport, file, fallback=True)", "intent": "Send a `file` over a `transport` . `fallback` set to True makes asyncio to manually read and send the file when the platform does not support the sendfile system call ( e.g .", "question_id": 259}
{"snippet": "loop.sendfile(transport, file, offset=0, count=None)", "intent": "Send a `file` over a `transport` . `offset` tells from where to start reading the file . If specified , `count` is the total number of bytes to transmit as opposed to sending the file until EOF is reached .", "question_id": 260}
{"snippet": "loop.sendfile(transport, file, offset=0, fallback=True)", "intent": "Send a `file` over a `transport` . `offset` tells from where to start reading the file . `fallback` set to True makes asyncio to manually read and send the file when the platform does not support the sendfile system call ( e.g .", "question_id": 261}
{"snippet": "loop.sendfile(transport, file, count=None, fallback=True)", "intent": "Send a `file` over a `transport` . If specified , `count` is the total number of bytes to transmit as opposed to sending the file until EOF is reached . `fallback` set to True makes asyncio to manually read and send the file when the platform does not support the sendfile system call ( e.g .", "question_id": 262}
{"snippet": "loop.sendfile(transport, file, offset=0, count=None, fallback=True)", "intent": "Send a `file` over a `transport` . `offset` tells from where to start reading the file . If specified , `count` is the total number of bytes to transmit as opposed to sending the file until EOF is reached . `fallback` set to True makes asyncio to manually read and send the file when the platform does not support the sendfile system call ( e.g .", "question_id": 263}
{"snippet": "loop.start_tls(transport, protocol, sslcontext)", "intent": "Upgrade an existing transport-based connection to TLS . Return a new `transport` instance , that the `protocol` must start using immediately after the await . With arguments `sslcontext`.", "question_id": 264}
{"snippet": "loop.start_tls(transport, protocol, sslcontext, server_side=False)", "intent": "Upgrade an existing transport-based connection to TLS . Return a new `transport` instance , that the `protocol` must start using immediately after the await . With arguments `sslcontext`, `server_side`.", "question_id": 265}
{"snippet": "loop.start_tls(transport, protocol, sslcontext, server_hostname=None)", "intent": "Upgrade an existing transport-based connection to TLS . Return a new `transport` instance , that the `protocol` must start using immediately after the await . With arguments `sslcontext`, `server_hostname`.", "question_id": 266}
{"snippet": "loop.start_tls(transport, protocol, sslcontext, ssl_handshake_timeout=None)", "intent": "Upgrade an existing transport-based connection to TLS . Return a new `transport` instance , that the `protocol` must start using immediately after the await . With arguments `sslcontext`, `ssl_handshake_timeout`.", "question_id": 267}
{"snippet": "loop.start_tls(transport, protocol, sslcontext, server_side=False, server_hostname=None)", "intent": "Upgrade an existing transport-based connection to TLS . Return a new `transport` instance , that the `protocol` must start using immediately after the await . With arguments `sslcontext`, `server_side`, `server_hostname`.", "question_id": 268}
{"snippet": "loop.start_tls(transport, protocol, sslcontext, server_side=False, ssl_handshake_timeout=None)", "intent": "Upgrade an existing transport-based connection to TLS . Return a new `transport` instance , that the `protocol` must start using immediately after the await . With arguments `sslcontext`, `server_side`, `ssl_handshake_timeout`.", "question_id": 269}
{"snippet": "loop.start_tls(transport, protocol, sslcontext, server_hostname=None, ssl_handshake_timeout=None)", "intent": "Upgrade an existing transport-based connection to TLS . Return a new `transport` instance , that the `protocol` must start using immediately after the await . With arguments `sslcontext`, `server_hostname`, `ssl_handshake_timeout`.", "question_id": 270}
{"snippet": "loop.start_tls(transport, protocol, sslcontext, server_side=False, server_hostname=None, ssl_handshake_timeout=None)", "intent": "Upgrade an existing transport-based connection to TLS . Return a new `transport` instance , that the `protocol` must start using immediately after the await . With arguments `sslcontext`, `server_side`, `server_hostname`, `ssl_handshake_timeout`.", "question_id": 271}
{"snippet": "loop.add_reader(fd, callback, *args)", "intent": "Start monitoring the `fd` file descriptor for read availability and invoke `callback` with the specified arguments once fd is available for reading . With arguments `*args`.", "question_id": 272}
{"snippet": "loop.remove_reader(fd)", "intent": "Stop monitoring the `fd` file descriptor for read availability .", "question_id": 273}
{"snippet": "loop.add_writer(fd, callback, *args)", "intent": "Start monitoring the `fd` file descriptor for write availability and invoke `callback` with the specified arguments once fd is available for writing . With arguments `*args`.", "question_id": 274}
{"snippet": "loop.remove_writer(fd)", "intent": "Stop monitoring the `fd` file descriptor for write availability .", "question_id": 275}
{"snippet": "loop.sock_recv(sock, nbytes)", "intent": "Receive up to `nbytes` from `sock` .", "question_id": 276}
{"snippet": "loop.sock_recv_into(sock, buf)", "intent": "Receive data from `sock` into the `buf` buffer .", "question_id": 277}
{"snippet": "loop.sock_sendall(sock, data)", "intent": "Send `data` to the `sock` socket .", "question_id": 278}
{"snippet": "loop.sock_connect(sock, address)", "intent": "Connect `sock` to a remote socket at `address` .", "question_id": 279}
{"snippet": "loop.sock_accept(sock)", "intent": "Accept a connection . `sock` must be a non-blocking socket .", "question_id": 280}
{"snippet": "loop.sock_sendfile(sock, file)", "intent": "Send a `file` using high-performance os.sendfile if possible . `sock` must be a non-blocking socket.SOCK_STREAM socket .", "question_id": 281}
{"snippet": "loop.sock_sendfile(sock, file, offset=0)", "intent": "Send a `file` using high-performance os.sendfile if possible . `sock` must be a non-blocking socket.SOCK_STREAM socket . `offset` tells from where to start reading the file .", "question_id": 282}
{"snippet": "loop.sock_sendfile(sock, file, count=None)", "intent": "Send a `file` using high-performance os.sendfile if possible . `sock` must be a non-blocking socket.SOCK_STREAM socket . If specified , `count` is the total number of bytes to transmit as opposed to sending the file until EOF is reached .", "question_id": 283}
{"snippet": "loop.sock_sendfile(sock, file, fallback=True)", "intent": "Send a `file` using high-performance os.sendfile if possible . `sock` must be a non-blocking socket.SOCK_STREAM socket . `fallback` , when set to True , makes asyncio manually read and send the file when the platform does not support the sendfile syscall ( e.g .", "question_id": 284}
{"snippet": "loop.sock_sendfile(sock, file, offset=0, count=None)", "intent": "Send a `file` using high-performance os.sendfile if possible . `sock` must be a non-blocking socket.SOCK_STREAM socket . `offset` tells from where to start reading the file . If specified , `count` is the total number of bytes to transmit as opposed to sending the file until EOF is reached .", "question_id": 285}
{"snippet": "loop.sock_sendfile(sock, file, offset=0, fallback=True)", "intent": "Send a `file` using high-performance os.sendfile if possible . `sock` must be a non-blocking socket.SOCK_STREAM socket . `offset` tells from where to start reading the file . `fallback` , when set to True , makes asyncio manually read and send the file when the platform does not support the sendfile syscall ( e.g .", "question_id": 286}
{"snippet": "loop.sock_sendfile(sock, file, count=None, fallback=True)", "intent": "Send a `file` using high-performance os.sendfile if possible . `sock` must be a non-blocking socket.SOCK_STREAM socket . If specified , `count` is the total number of bytes to transmit as opposed to sending the file until EOF is reached . `fallback` , when set to True , makes asyncio manually read and send the file when the platform does not support the sendfile syscall ( e.g .", "question_id": 287}
{"snippet": "loop.sock_sendfile(sock, file, offset=0, count=None, fallback=True)", "intent": "Send a `file` using high-performance os.sendfile if possible . `sock` must be a non-blocking socket.SOCK_STREAM socket . `offset` tells from where to start reading the file . If specified , `count` is the total number of bytes to transmit as opposed to sending the file until EOF is reached . `fallback` , when set to True , makes asyncio manually read and send the file when the platform does not support the sendfile syscall ( e.g .", "question_id": 288}
{"snippet": "loop.getaddrinfo(host, port)", "intent": "Asynchronous version of socket.getaddrinfo ( ) . With arguments `host`, `port`.", "question_id": 289}
{"snippet": "loop.getaddrinfo(host, port, family=0)", "intent": "Asynchronous version of socket.getaddrinfo ( ) . With arguments `host`, `port`, `family`.", "question_id": 290}
{"snippet": "loop.getaddrinfo(host, port, type=0)", "intent": "Asynchronous version of socket.getaddrinfo ( ) . With arguments `host`, `port`, `type`.", "question_id": 291}
{"snippet": "loop.getaddrinfo(host, port, proto=0)", "intent": "Asynchronous version of socket.getaddrinfo ( ) . With arguments `host`, `port`, `proto`.", "question_id": 292}
{"snippet": "loop.getaddrinfo(host, port, flags=0)", "intent": "Asynchronous version of socket.getaddrinfo ( ) . With arguments `host`, `port`, `flags`.", "question_id": 293}
{"snippet": "loop.getaddrinfo(host, port, family=0, type=0)", "intent": "Asynchronous version of socket.getaddrinfo ( ) . With arguments `host`, `port`, `family`, `type`.", "question_id": 294}
{"snippet": "loop.getaddrinfo(host, port, family=0, proto=0)", "intent": "Asynchronous version of socket.getaddrinfo ( ) . With arguments `host`, `port`, `family`, `proto`.", "question_id": 295}
{"snippet": "loop.getaddrinfo(host, port, family=0, flags=0)", "intent": "Asynchronous version of socket.getaddrinfo ( ) . With arguments `host`, `port`, `family`, `flags`.", "question_id": 296}
{"snippet": "loop.getaddrinfo(host, port, type=0, proto=0)", "intent": "Asynchronous version of socket.getaddrinfo ( ) . With arguments `host`, `port`, `type`, `proto`.", "question_id": 297}
{"snippet": "loop.getaddrinfo(host, port, type=0, flags=0)", "intent": "Asynchronous version of socket.getaddrinfo ( ) . With arguments `host`, `port`, `type`, `flags`.", "question_id": 298}
{"snippet": "loop.getnameinfo(sockaddr)", "intent": "Asynchronous version of socket.getnameinfo ( ) . With arguments `sockaddr`.", "question_id": 299}
{"snippet": "loop.getnameinfo(sockaddr, flags=0)", "intent": "Asynchronous version of socket.getnameinfo ( ) . With arguments `sockaddr`, `flags`.", "question_id": 300}
{"snippet": "loop.connect_read_pipe(protocol_factory, pipe)", "intent": "Register the read end of `pipe` in the event loop . `protocol_factory` must be a callable returning an asyncio protocol implementation .", "question_id": 301}
{"snippet": "loop.connect_write_pipe(protocol_factory, pipe)", "intent": "Register the write end of `pipe` in the event loop . `protocol_factory` must be a callable returning an asyncio protocol implementation .", "question_id": 302}
{"snippet": "loop.add_signal_handler(signum, callback, *args)", "intent": "Set `callback` as the handler for the `signum` signal . With arguments `*args`.", "question_id": 303}
{"snippet": "loop.remove_signal_handler(sig)", "intent": "Remove the handler for the `sig` signal .", "question_id": 304}
{"snippet": "loop.run_in_executor(executor, func, *args)", "intent": "Arrange for `func` to be called in the specified `executor` . With arguments `*args`.", "question_id": 305}
{"snippet": "loop.set_default_executor(executor)", "intent": "Set `executor` as the default executor used by run_in_executor ( ) .", "question_id": 306}
{"snippet": "loop.set_exception_handler(handler)", "intent": "Set `handler` as the new event loop exception handler .", "question_id": 307}
{"snippet": "loop.get_exception_handler()", "intent": "Return the current exception handler , or None if no custom exception handler was set .", "question_id": 308}
{"snippet": "loop.default_exception_handler(context)", "intent": "Default exception handler . `context` parameter has the same meaning as in call_exception_handler ( ) .", "question_id": 309}
{"snippet": "loop.call_exception_handler(context)", "intent": "Call the current event loop exception handler . `context` is a dict object containing the following keys ( new keys may be introduced in future Python versions ) :", "question_id": 310}
{"snippet": "loop.get_debug()", "intent": "Get the debug mode ( bool ) of the event loop .", "question_id": 311}
{"snippet": "loop.set_debug(enabled: bool)", "intent": "Set the debug mode of the event loop . With arguments `enabled: bool`.", "question_id": 312}
{"snippet": "loop.subprocess_exec(protocol_factory, *args, **kwargs)", "intent": "Create a subprocess from one or more string arguments specified by args . The `protocol_factory` must be a callable returning a subclass of the asyncio.SubprocessProtocol class . With arguments `*args`, `**kwargs`.", "question_id": 313}
{"snippet": "loop.subprocess_exec(protocol_factory, *args, **kwargs, stdin=subprocess.PIPE)", "intent": "Create a subprocess from one or more string arguments specified by args . The `protocol_factory` must be a callable returning a subclass of the asyncio.SubprocessProtocol class . With arguments `*args`, `**kwargs`, `stdin`.", "question_id": 314}
{"snippet": "loop.subprocess_exec(protocol_factory, *args, **kwargs, stdout=subprocess.PIPE)", "intent": "Create a subprocess from one or more string arguments specified by args . The `protocol_factory` must be a callable returning a subclass of the asyncio.SubprocessProtocol class . With arguments `*args`, `**kwargs`, `stdout`.", "question_id": 315}
{"snippet": "loop.subprocess_exec(protocol_factory, *args, **kwargs, stderr=subprocess.PIPE)", "intent": "Create a subprocess from one or more string arguments specified by args . The `protocol_factory` must be a callable returning a subclass of the asyncio.SubprocessProtocol class . With arguments `*args`, `**kwargs`, `stderr`.", "question_id": 316}
{"snippet": "loop.subprocess_exec(protocol_factory, *args, **kwargs, stdin=subprocess.PIPE, stdout=subprocess.PIPE)", "intent": "Create a subprocess from one or more string arguments specified by args . The `protocol_factory` must be a callable returning a subclass of the asyncio.SubprocessProtocol class . With arguments `*args`, `**kwargs`, `stdin`, `stdout`.", "question_id": 317}
{"snippet": "loop.subprocess_exec(protocol_factory, *args, **kwargs, stdin=subprocess.PIPE, stderr=subprocess.PIPE)", "intent": "Create a subprocess from one or more string arguments specified by args . The `protocol_factory` must be a callable returning a subclass of the asyncio.SubprocessProtocol class . With arguments `*args`, `**kwargs`, `stdin`, `stderr`.", "question_id": 318}
{"snippet": "loop.subprocess_exec(protocol_factory, *args, **kwargs, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "intent": "Create a subprocess from one or more string arguments specified by args . The `protocol_factory` must be a callable returning a subclass of the asyncio.SubprocessProtocol class . With arguments `*args`, `**kwargs`, `stdout`, `stderr`.", "question_id": 319}
{"snippet": "loop.subprocess_exec(protocol_factory, *args, **kwargs, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "intent": "Create a subprocess from one or more string arguments specified by args . The `protocol_factory` must be a callable returning a subclass of the asyncio.SubprocessProtocol class . With arguments `*args`, `**kwargs`, `stdin`, `stdout`, `stderr`.", "question_id": 320}
{"snippet": "loop.subprocess_shell(protocol_factory, cmd, **kwargs)", "intent": "Create a subprocess from `cmd` , which can be a str or a bytes string encoded to the filesystem encoding , using the platform \u2019 s \u201c shell \u201d syntax . The `protocol_factory` must be a callable returning a subclass of the SubprocessProtocol class . With arguments `**kwargs`.", "question_id": 321}
{"snippet": "loop.subprocess_shell(protocol_factory, cmd, **kwargs, stdin=subprocess.PIPE)", "intent": "Create a subprocess from `cmd` , which can be a str or a bytes string encoded to the filesystem encoding , using the platform \u2019 s \u201c shell \u201d syntax . The `protocol_factory` must be a callable returning a subclass of the SubprocessProtocol class . With arguments `**kwargs`, `stdin`.", "question_id": 322}
{"snippet": "loop.subprocess_shell(protocol_factory, cmd, **kwargs, stdout=subprocess.PIPE)", "intent": "Create a subprocess from `cmd` , which can be a str or a bytes string encoded to the filesystem encoding , using the platform \u2019 s \u201c shell \u201d syntax . The `protocol_factory` must be a callable returning a subclass of the SubprocessProtocol class . With arguments `**kwargs`, `stdout`.", "question_id": 323}
{"snippet": "loop.subprocess_shell(protocol_factory, cmd, **kwargs, stderr=subprocess.PIPE)", "intent": "Create a subprocess from `cmd` , which can be a str or a bytes string encoded to the filesystem encoding , using the platform \u2019 s \u201c shell \u201d syntax . The `protocol_factory` must be a callable returning a subclass of the SubprocessProtocol class . With arguments `**kwargs`, `stderr`.", "question_id": 324}
{"snippet": "loop.subprocess_shell(protocol_factory, cmd, **kwargs, stdin=subprocess.PIPE, stdout=subprocess.PIPE)", "intent": "Create a subprocess from `cmd` , which can be a str or a bytes string encoded to the filesystem encoding , using the platform \u2019 s \u201c shell \u201d syntax . The `protocol_factory` must be a callable returning a subclass of the SubprocessProtocol class . With arguments `**kwargs`, `stdin`, `stdout`.", "question_id": 325}
{"snippet": "loop.subprocess_shell(protocol_factory, cmd, **kwargs, stdin=subprocess.PIPE, stderr=subprocess.PIPE)", "intent": "Create a subprocess from `cmd` , which can be a str or a bytes string encoded to the filesystem encoding , using the platform \u2019 s \u201c shell \u201d syntax . The `protocol_factory` must be a callable returning a subclass of the SubprocessProtocol class . With arguments `**kwargs`, `stdin`, `stderr`.", "question_id": 326}
{"snippet": "loop.subprocess_shell(protocol_factory, cmd, **kwargs, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "intent": "Create a subprocess from `cmd` , which can be a str or a bytes string encoded to the filesystem encoding , using the platform \u2019 s \u201c shell \u201d syntax . The `protocol_factory` must be a callable returning a subclass of the SubprocessProtocol class . With arguments `**kwargs`, `stdout`, `stderr`.", "question_id": 327}
{"snippet": "loop.subprocess_shell(protocol_factory, cmd, **kwargs, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)", "intent": "Create a subprocess from `cmd` , which can be a str or a bytes string encoded to the filesystem encoding , using the platform \u2019 s \u201c shell \u201d syntax . The `protocol_factory` must be a callable returning a subclass of the SubprocessProtocol class . With arguments `**kwargs`, `stdin`, `stdout`, `stderr`.", "question_id": 328}
{"snippet": "asyncio.Handle", "intent": "A callback wrapper object returned by loop.call_soon(), loop.call_soon_threadsafe().", "question_id": 329}
{"snippet": "handle.cancel()", "intent": "Cancel the callback .", "question_id": 330}
{"snippet": "handle.cancelled()", "intent": "Return True if the callback was cancelled .", "question_id": 331}
{"snippet": "asyncio.TimerHandle", "intent": "A callback wrapper object returned by loop.call_later(), and loop.call_at().", "question_id": 332}
{"snippet": "timer_handle.when()", "intent": "Return a scheduled callback time as float seconds .", "question_id": 333}
{"snippet": "asyncio.Server", "intent": "Server objects are asynchronous context managers.", "question_id": 334}
{"snippet": "server.close()", "intent": "Stop serving : close listening sockets and set the sockets attribute to None .", "question_id": 335}
{"snippet": "server.get_loop()", "intent": "Return the event loop associated with the server object .", "question_id": 336}
{"snippet": "server.start_serving()", "intent": "Start accepting connections .", "question_id": 337}
{"snippet": "server.serve_forever()", "intent": "Start accepting connections until the coroutine is cancelled .", "question_id": 338}
{"snippet": "server.is_serving()", "intent": "Return True if the server is accepting new connections .", "question_id": 339}
{"snippet": "server.wait_closed()", "intent": "Wait until the close ( ) method completes .", "question_id": 340}
{"snippet": "server.sockets", "intent": "List of socket.socket objects the server is listening on, or None if the server is closed.", "question_id": 341}
{"snippet": "asyncio.SelectorEventLoop", "intent": "An event loop based on the selectors module.", "question_id": 342}
{"snippet": "asyncio.ProactorEventLoop", "intent": "An event loop for Windows that uses \u201cI/O Completion Ports\u201d (IOCP).", "question_id": 343}
{"snippet": "asyncio.AbstractEventLoop", "intent": "Abstract base class for asyncio-compliant event loops.", "question_id": 344}
{"snippet": "asyncio.TimeoutError", "intent": "The operation has exceeded the given deadline.", "question_id": 345}
{"snippet": "asyncio.CancelledError", "intent": "The operation has been cancelled.", "question_id": 346}
{"snippet": "asyncio.InvalidStateError", "intent": "Invalid internal state of Task or Future.", "question_id": 347}
{"snippet": "asyncio.SendfileNotAvailableError", "intent": "The \u201csendfile\u201d syscall is not available for the given socket or file type.", "question_id": 348}
{"snippet": "asyncio.IncompleteReadError", "intent": "The requested read operation did not complete fully.", "question_id": 349}
{"snippet": "abstract_event_loop.expected", "intent": "The total number (int) of expected bytes.", "question_id": 350}
{"snippet": "abstract_event_loop.partial", "intent": "A string of bytes read before the end of stream was reached.", "question_id": 351}
{"snippet": "asyncio.LimitOverrunError", "intent": "Reached the buffer size limit while looking for a separator.", "question_id": 352}
{"snippet": "abstract_event_loop.consumed", "intent": "The total number of to be consumed bytes.", "question_id": 353}
{"snippet": "asyncio.isfuture(obj)", "intent": "Return True if `obj` is either of :", "question_id": 354}
{"snippet": "asyncio.ensure_future(obj)", "intent": "Return : If `obj` is neither of the above a TypeError is raised .", "question_id": 355}
{"snippet": "asyncio.ensure_future(obj, loop=None)", "intent": "Return : If `obj` is neither of the above a TypeError is raised . With arguments `loop`.", "question_id": 356}
{"snippet": "asyncio.wrap_future(future)", "intent": "Wrap a concurrent.futures.Future object in a asyncio.Future object . With arguments `future`.", "question_id": 357}
{"snippet": "asyncio.wrap_future(future, loop=None)", "intent": "Wrap a concurrent.futures.Future object in a asyncio.Future object . With arguments `future`, `loop`.", "question_id": 358}
{"snippet": "asyncio.Future()", "intent": "A Future represents an eventual result of an asynchronous operation .", "question_id": 359}
{"snippet": "asyncio.Future(loop=None)", "intent": "A Future represents an eventual result of an asynchronous operation . This way alternative event `loop` implementations can inject their own optimized implementations of a Future object .", "question_id": 360}
{"snippet": "future.result()", "intent": "Return the result of the Future .", "question_id": 361}
{"snippet": "future.set_result(result)", "intent": "Mark the Future as done and set its `result` .", "question_id": 362}
{"snippet": "future.set_exception(exception)", "intent": "Mark the Future as done and set an `exception` .", "question_id": 363}
{"snippet": "future.done()", "intent": "Return True if the Future is done .", "question_id": 364}
{"snippet": "future.cancelled()", "intent": "Return True if the Future was cancelled .", "question_id": 365}
{"snippet": "future.add_done_callback(callback)", "intent": "Add a `callback` to be run when the Future is done .", "question_id": 366}
{"snippet": "future.add_done_callback(callback, context=None)", "intent": "Add a `callback` to be run when the Future is done . An optional keyword-only `context` argument allows specifying a custom contextvars.Context for the callback to run in .", "question_id": 367}
{"snippet": "future.remove_done_callback(callback)", "intent": "Remove `callback` from the callbacks list .", "question_id": 368}
{"snippet": "future.cancel()", "intent": "Cancel the Future and schedule callbacks .", "question_id": 369}
{"snippet": "future.exception()", "intent": "Return the exception that was set on this Future .", "question_id": 370}
{"snippet": "future.get_loop()", "intent": "Return the event loop the Future object is bound to .", "question_id": 371}
{"snippet": "asyncio.get_event_loop_policy()", "intent": "Return the current process-wide policy .", "question_id": 372}
{"snippet": "asyncio.set_event_loop_policy(policy)", "intent": "Set the current process-wide `policy` to policy .", "question_id": 373}
{"snippet": "asyncio.AbstractEventLoopPolicy", "intent": "An abstract base class for asyncio policies.", "question_id": 374}
{"snippet": "abstract_event_loop_policy.get_event_loop()", "intent": "Get the event loop for the current context .", "question_id": 375}
{"snippet": "abstract_event_loop_policy.set_event_loop(loop)", "intent": "Set the event `loop` for the current context to loop .", "question_id": 376}
{"snippet": "abstract_event_loop_policy.new_event_loop()", "intent": "Create and return a new event loop object .", "question_id": 377}
{"snippet": "abstract_event_loop_policy.get_child_watcher()", "intent": "Get a child process watcher object .", "question_id": 378}
{"snippet": "abstract_event_loop_policy.set_child_watcher(watcher)", "intent": "Set the current child process `watcher` to watcher .", "question_id": 379}
{"snippet": "asyncio.DefaultEventLoopPolicy", "intent": "The default asyncio policy.", "question_id": 380}
{"snippet": "asyncio.WindowsProactorEventLoopPolicy", "intent": "An alternative event loop policy that uses the ProactorEventLoop event loop implementation.", "question_id": 381}
{"snippet": "asyncio.get_child_watcher()", "intent": "Return the current child watcher for the current policy .", "question_id": 382}
{"snippet": "asyncio.set_child_watcher(watcher)", "intent": "Set the current child `watcher` to watcher for the current policy .", "question_id": 383}
{"snippet": "windows_proactor_event_loop_policy.add_child_handler(pid, callback, *args)", "intent": "Register a new child handler . Arrange for `callback` ( `pid` , returncode , `*args` ) to be called when a process with PID equal to pid terminates .", "question_id": 384}
{"snippet": "windows_proactor_event_loop_policy.remove_child_handler(pid)", "intent": "Removes the handler for process with PID equal to `pid` .", "question_id": 385}
{"snippet": "windows_proactor_event_loop_policy.attach_loop(loop)", "intent": "Attach the watcher to an event `loop` .", "question_id": 386}
{"snippet": "windows_proactor_event_loop_policy.close()", "intent": "Close the watcher .", "question_id": 387}
{"snippet": "asyncio.SafeChildWatcher", "intent": "This implementation avoids disrupting other code spawning processes by polling every process explicitly on a SIGCHLD signal.", "question_id": 388}
{"snippet": "asyncio.FastChildWatcher", "intent": "This implementation reaps every terminated processes by calling os.waitpid(-1) directly, possibly breaking other code spawning processes and waiting for their termination.", "question_id": 389}
{"snippet": "asyncio.BaseTransport", "intent": "Base class for all transports.", "question_id": 390}
{"snippet": "asyncio.WriteTransport(BaseTransport)", "intent": "A base transport for write-only connections . With arguments `BaseTransport`.", "question_id": 391}
{"snippet": "asyncio.ReadTransport(BaseTransport)", "intent": "A base transport for read-only connections . With arguments `BaseTransport`.", "question_id": 392}
{"snippet": "asyncio.Transport(WriteTransport, ReadTransport)", "intent": "Interface representing a bidirectional transport , such as a TCP connection . With arguments `WriteTransport`, `ReadTransport`.", "question_id": 393}
{"snippet": "asyncio.DatagramTransport(BaseTransport)", "intent": "A transport for datagram ( UDP ) connections . With arguments `BaseTransport`.", "question_id": 394}
{"snippet": "asyncio.SubprocessTransport(BaseTransport)", "intent": "An abstraction to represent a connection between a parent and its child OS process . With arguments `BaseTransport`.", "question_id": 395}
{"snippet": "BaseTransport.close()", "intent": "Close the transport .", "question_id": 396}
{"snippet": "BaseTransport.is_closing()", "intent": "Return True if the transport is closing or is closed .", "question_id": 397}
{"snippet": "BaseTransport.get_extra_info(name)", "intent": "Return information about the transport or underlying resources it uses . `name` is a string representing the piece of transport-specific information to get .", "question_id": 398}
{"snippet": "BaseTransport.get_extra_info(name, default=None)", "intent": "Return information about the transport or underlying resources it uses . `name` is a string representing the piece of transport-specific information to get . `default` is the value to return if the information is not available , or if the transport does not support querying it with the given third-party event loop implementation or on the current platform .", "question_id": 399}
{"snippet": "BaseTransport.set_protocol(protocol)", "intent": "Set a new `protocol` .", "question_id": 400}
{"snippet": "BaseTransport.get_protocol()", "intent": "Return the current protocol .", "question_id": 401}
{"snippet": "ReadTransport.is_reading()", "intent": "Return True if the transport is receiving new data .", "question_id": 402}
{"snippet": "ReadTransport.pause_reading()", "intent": "Pause the receiving end of the transport .", "question_id": 403}
{"snippet": "ReadTransport.resume_reading()", "intent": "Resume the receiving end .", "question_id": 404}
{"snippet": "WriteTransport.abort()", "intent": "Close the transport immediately , without waiting for pending operations to complete .", "question_id": 405}
{"snippet": "WriteTransport.can_write_eof()", "intent": "Return True if the transport supports write_eof ( ) , False if not .", "question_id": 406}
{"snippet": "WriteTransport.get_write_buffer_size()", "intent": "Return the current size of the output buffer used by the transport .", "question_id": 407}
{"snippet": "WriteTransport.get_write_buffer_limits()", "intent": "Get the high and low watermarks for write flow control .", "question_id": 408}
{"snippet": "WriteTransport.set_write_buffer_limits()", "intent": "Set the `high` and `low` watermarks for write flow control .", "question_id": 409}
{"snippet": "WriteTransport.set_write_buffer_limits(high=None)", "intent": "Set the `high` and `low` watermarks for write flow control .", "question_id": 410}
{"snippet": "WriteTransport.set_write_buffer_limits(low=None)", "intent": "Set the `high` and `low` watermarks for write flow control .", "question_id": 411}
{"snippet": "WriteTransport.set_write_buffer_limits(high=None, low=None)", "intent": "Set the `high` and `low` watermarks for write flow control .", "question_id": 412}
{"snippet": "WriteTransport.write(data)", "intent": "Write some `data` bytes to the transport .", "question_id": 413}
{"snippet": "WriteTransport.writelines(list_of_data)", "intent": "Write a list ( or any iterable ) of data bytes to the transport . With arguments `list_of_data`.", "question_id": 414}
{"snippet": "WriteTransport.write_eof()", "intent": "Close the write end of the transport after flushing all buffered data .", "question_id": 415}
{"snippet": "DatagramTransport.sendto(data)", "intent": "Send the `data` bytes to the remote peer given by `addr` ( a transport-dependent target address ) .", "question_id": 416}
{"snippet": "DatagramTransport.sendto(data, addr=None)", "intent": "Send the `data` bytes to the remote peer given by `addr` ( a transport-dependent target address ) .", "question_id": 417}
{"snippet": "DatagramTransport.abort()", "intent": "Close the transport immediately , without waiting for pending operations to complete .", "question_id": 418}
{"snippet": "SubprocessTransport.get_pid()", "intent": "Return the subprocess process id as an integer .", "question_id": 419}
{"snippet": "SubprocessTransport.get_pipe_transport(fd)", "intent": "Return the transport for the communication pipe corresponding to the integer file descriptor `fd` :", "question_id": 420}
{"snippet": "SubprocessTransport.get_returncode()", "intent": "Return the subprocess return code as an integer or None if it hasn \u2019 t returned , which is similar to the subprocess.Popen.returncode attribute .", "question_id": 421}
{"snippet": "SubprocessTransport.kill()", "intent": "Kill the subprocess .", "question_id": 422}
{"snippet": "SubprocessTransport.send_signal(signal)", "intent": "Send the `signal` number to the subprocess , as in subprocess.Popen.send_signal ( ) .", "question_id": 423}
{"snippet": "SubprocessTransport.terminate()", "intent": "Stop the subprocess .", "question_id": 424}
{"snippet": "SubprocessTransport.close()", "intent": "Kill the subprocess by calling the kill ( ) method .", "question_id": 425}
{"snippet": "asyncio.BaseProtocol", "intent": "Base protocol with methods that all protocols share.", "question_id": 426}
{"snippet": "asyncio.Protocol(BaseProtocol)", "intent": "The base class for implementing streaming protocols ( TCP , Unix sockets , etc ) . With arguments `BaseProtocol`.", "question_id": 427}
{"snippet": "asyncio.BufferedProtocol(BaseProtocol)", "intent": "A base class for implementing streaming protocols with manual control of the receive buffer . With arguments `BaseProtocol`.", "question_id": 428}
{"snippet": "asyncio.DatagramProtocol(BaseProtocol)", "intent": "The base class for implementing datagram ( UDP ) protocols . With arguments `BaseProtocol`.", "question_id": 429}
{"snippet": "asyncio.SubprocessProtocol(BaseProtocol)", "intent": "The base class for implementing protocols communicating with child processes ( unidirectional pipes ) . With arguments `BaseProtocol`.", "question_id": 430}
{"snippet": "BaseProtocol.connection_made(transport)", "intent": "Called when a connection is made . The `transport` argument is the transport representing the connection .", "question_id": 431}
{"snippet": "BaseProtocol.connection_lost(exc)", "intent": "Called when the connection is lost or closed . With arguments `exc`.", "question_id": 432}
{"snippet": "BaseProtocol.pause_writing()", "intent": "Called when the transport \u2019 s buffer goes over the high watermark .", "question_id": 433}
{"snippet": "BaseProtocol.resume_writing()", "intent": "Called when the transport \u2019 s buffer drains below the low watermark .", "question_id": 434}
{"snippet": "Protocol.data_received(data)", "intent": "Called when some `data` is received .", "question_id": 435}
{"snippet": "Protocol.eof_received()", "intent": "Called when the other end signals it won \u2019 t send any more data ( for example by calling transport.write_eof ( ) , if the other end also uses asyncio ) .", "question_id": 436}
{"snippet": "BufferedProtocol.get_buffer(sizehint)", "intent": "Called to allocate a new receive buffer . `sizehint` is the recommended minimum size for the returned buffer .", "question_id": 437}
{"snippet": "BufferedProtocol.buffer_updated(nbytes)", "intent": "Called when the buffer was updated with the received data . `nbytes` is the total number of bytes that were written to the buffer .", "question_id": 438}
{"snippet": "BufferedProtocol.eof_received()", "intent": "See the documentation of the protocol.eof_received ( ) method .", "question_id": 439}
{"snippet": "DatagramProtocol.datagram_received(data, addr)", "intent": "Called when a datagram is received . `data` is a bytes object containing the incoming data . `addr` is the address of the peer sending the data ; the exact format depends on the transport .", "question_id": 440}
{"snippet": "DatagramProtocol.error_received(exc)", "intent": "Called when a previous send or receive operation raises an OSError . `exc` is the OSError instance .", "question_id": 441}
{"snippet": "SubprocessProtocol.pipe_data_received(fd, data)", "intent": "Called when the child process writes `data` into its stdout or stderr pipe . `fd` is the integer file descriptor of the pipe .", "question_id": 442}
{"snippet": "SubprocessProtocol.pipe_connection_lost(fd, exc)", "intent": "Called when one of the pipes communicating with the child process is closed . `fd` is the integer file descriptor that was closed . With arguments `exc`.", "question_id": 443}
{"snippet": "SubprocessProtocol.process_exited()", "intent": "Called when the child process has exited .", "question_id": 444}
{"snippet": "asyncio.Queue()", "intent": "A first in , first out ( FIFO ) queue .", "question_id": 445}
{"snippet": "asyncio.Queue(maxsize=0)", "intent": "A first in , first out ( FIFO ) queue . If `maxsize` is less than or equal to zero , the queue size is infinite .", "question_id": 446}
{"snippet": "asyncio.Queue(loop=None)", "intent": "A first in , first out ( FIFO ) queue . With arguments `loop`.", "question_id": 447}
{"snippet": "asyncio.Queue(maxsize=0, loop=None)", "intent": "A first in , first out ( FIFO ) queue . If `maxsize` is less than or equal to zero , the queue size is infinite . With arguments `loop`.", "question_id": 448}
{"snippet": "queue.maxsize", "intent": "Number of items allowed in the queue.", "question_id": 449}
{"snippet": "queue.empty()", "intent": "Return True if the queue is empty , False otherwise .", "question_id": 450}
{"snippet": "queue.full()", "intent": "Return True if there are maxsize items in the queue .", "question_id": 451}
{"snippet": "queue.get()", "intent": "Remove and return an item from the queue .", "question_id": 452}
{"snippet": "queue.get_nowait()", "intent": "Return an item if one is immediately available , else raise QueueEmpty .", "question_id": 453}
{"snippet": "queue.join()", "intent": "Block until all items in the queue have been received and processed .", "question_id": 454}
{"snippet": "queue.put(item)", "intent": "Put an `item` into the queue .", "question_id": 455}
{"snippet": "queue.put_nowait(item)", "intent": "Put an `item` into the queue without blocking .", "question_id": 456}
{"snippet": "queue.qsize()", "intent": "Return the number of items in the queue .", "question_id": 457}
{"snippet": "queue.task_done()", "intent": "Indicate that a formerly enqueued task is complete .", "question_id": 458}
{"snippet": "asyncio.PriorityQueue", "intent": "A variant of Queue; retrieves entries in priority order (lowest first).", "question_id": 459}
{"snippet": "asyncio.LifoQueue", "intent": "A variant of Queue that retrieves most recently added entries first (last in, first out).", "question_id": 460}
{"snippet": "asyncio.QueueEmpty", "intent": "This exception is raised when the get_nowait() method is called on an empty queue.", "question_id": 461}
{"snippet": "asyncio.QueueFull", "intent": "Exception raised when the put_nowait() method is called on a queue that has reached its maxsize.", "question_id": 462}
{"snippet": "asyncio.open_connection()", "intent": "Establish a network connection and return a pair of ( reader , writer ) objects .", "question_id": 463}
{"snippet": "asyncio.open_connection(host=None)", "intent": "Establish a network connection and return a pair of ( reader , writer ) objects . With arguments `host`.", "question_id": 464}
{"snippet": "asyncio.open_connection(port=None)", "intent": "Establish a network connection and return a pair of ( reader , writer ) objects . With arguments `port`.", "question_id": 465}
{"snippet": "asyncio.open_connection(loop=None)", "intent": "Establish a network connection and return a pair of ( reader , writer ) objects . The `loop` argument is optional and can always be determined automatically when this function is awaited from a coroutine .", "question_id": 466}
{"snippet": "asyncio.open_connection(limit=None)", "intent": "Establish a network connection and return a pair of ( reader , writer ) objects . `limit` determines the buffer size limit used by the returned StreamReader instance .", "question_id": 467}
{"snippet": "asyncio.open_connection(ssl=None)", "intent": "Establish a network connection and return a pair of ( reader , writer ) objects . With arguments `ssl`.", "question_id": 468}
{"snippet": "asyncio.open_connection(family=0)", "intent": "Establish a network connection and return a pair of ( reader , writer ) objects . With arguments `family`.", "question_id": 469}
{"snippet": "asyncio.open_connection(proto=0)", "intent": "Establish a network connection and return a pair of ( reader , writer ) objects . With arguments `proto`.", "question_id": 470}
{"snippet": "asyncio.open_connection(flags=0)", "intent": "Establish a network connection and return a pair of ( reader , writer ) objects . With arguments `flags`.", "question_id": 471}
{"snippet": "asyncio.open_connection(sock=None)", "intent": "Establish a network connection and return a pair of ( reader , writer ) objects . With arguments `sock`.", "question_id": 472}
{"snippet": "asyncio.start_server(client_connected_cb)", "intent": "Start a socket server . The `client_connected_cb` callback is called whenever a new client connection is established .", "question_id": 473}
{"snippet": "asyncio.start_server(client_connected_cb, host=None)", "intent": "Start a socket server . The `client_connected_cb` callback is called whenever a new client connection is established . With arguments `host`.", "question_id": 474}
{"snippet": "asyncio.start_server(client_connected_cb, port=None)", "intent": "Start a socket server . The `client_connected_cb` callback is called whenever a new client connection is established . With arguments `port`.", "question_id": 475}
{"snippet": "asyncio.start_server(client_connected_cb, loop=None)", "intent": "Start a socket server . The `client_connected_cb` callback is called whenever a new client connection is established . The `loop` argument is optional and can always be determined automatically when this method is awaited from a coroutine .", "question_id": 476}
{"snippet": "asyncio.start_server(client_connected_cb, limit=None)", "intent": "Start a socket server . The `client_connected_cb` callback is called whenever a new client connection is established . `limit` determines the buffer size limit used by the returned StreamReader instance .", "question_id": 477}
{"snippet": "asyncio.start_server(client_connected_cb, family=socket.AF_UNSPEC)", "intent": "Start a socket server . The `client_connected_cb` callback is called whenever a new client connection is established . With arguments `family`.", "question_id": 478}
{"snippet": "asyncio.start_server(client_connected_cb, flags=socket.AI_PASSIVE)", "intent": "Start a socket server . The `client_connected_cb` callback is called whenever a new client connection is established . With arguments `flags`.", "question_id": 479}
{"snippet": "asyncio.start_server(client_connected_cb, sock=None)", "intent": "Start a socket server . The `client_connected_cb` callback is called whenever a new client connection is established . With arguments `sock`.", "question_id": 480}
{"snippet": "asyncio.start_server(client_connected_cb, backlog=100)", "intent": "Start a socket server . The `client_connected_cb` callback is called whenever a new client connection is established . With arguments `backlog`.", "question_id": 481}
{"snippet": "asyncio.start_server(client_connected_cb, ssl=None)", "intent": "Start a socket server . The `client_connected_cb` callback is called whenever a new client connection is established . With arguments `ssl`.", "question_id": 482}
{"snippet": "asyncio.open_unix_connection()", "intent": "Establish a Unix socket connection and return a pair of ( reader , writer ) .", "question_id": 483}
{"snippet": "asyncio.open_unix_connection(path=None)", "intent": "Establish a Unix socket connection and return a pair of ( reader , writer ) . With arguments `path`.", "question_id": 484}
{"snippet": "asyncio.open_unix_connection(loop=None)", "intent": "Establish a Unix socket connection and return a pair of ( reader , writer ) . With arguments `loop`.", "question_id": 485}
{"snippet": "asyncio.open_unix_connection(limit=None)", "intent": "Establish a Unix socket connection and return a pair of ( reader , writer ) . With arguments `limit`.", "question_id": 486}
{"snippet": "asyncio.open_unix_connection(ssl=None)", "intent": "Establish a Unix socket connection and return a pair of ( reader , writer ) . With arguments `ssl`.", "question_id": 487}
{"snippet": "asyncio.open_unix_connection(sock=None)", "intent": "Establish a Unix socket connection and return a pair of ( reader , writer ) . With arguments `sock`.", "question_id": 488}
{"snippet": "asyncio.open_unix_connection(server_hostname=None)", "intent": "Establish a Unix socket connection and return a pair of ( reader , writer ) . With arguments `server_hostname`.", "question_id": 489}
{"snippet": "asyncio.open_unix_connection(ssl_handshake_timeout=None)", "intent": "Establish a Unix socket connection and return a pair of ( reader , writer ) . With arguments `ssl_handshake_timeout`.", "question_id": 490}
{"snippet": "asyncio.open_unix_connection(path=None, loop=None)", "intent": "Establish a Unix socket connection and return a pair of ( reader , writer ) . With arguments `path`, `loop`.", "question_id": 491}
{"snippet": "asyncio.open_unix_connection(path=None, limit=None)", "intent": "Establish a Unix socket connection and return a pair of ( reader , writer ) . With arguments `path`, `limit`.", "question_id": 492}
{"snippet": "asyncio.start_unix_server(client_connected_cb)", "intent": "Start a Unix socket server . With arguments `client_connected_cb`.", "question_id": 493}
{"snippet": "asyncio.start_unix_server(client_connected_cb, path=None)", "intent": "Start a Unix socket server . With arguments `client_connected_cb`, `path`.", "question_id": 494}
{"snippet": "asyncio.start_unix_server(client_connected_cb, loop=None)", "intent": "Start a Unix socket server . With arguments `client_connected_cb`, `loop`.", "question_id": 495}
{"snippet": "asyncio.start_unix_server(client_connected_cb, limit=None)", "intent": "Start a Unix socket server . With arguments `client_connected_cb`, `limit`.", "question_id": 496}
{"snippet": "asyncio.start_unix_server(client_connected_cb, sock=None)", "intent": "Start a Unix socket server . With arguments `client_connected_cb`, `sock`.", "question_id": 497}
{"snippet": "asyncio.start_unix_server(client_connected_cb, backlog=100)", "intent": "Start a Unix socket server . With arguments `client_connected_cb`, `backlog`.", "question_id": 498}
{"snippet": "asyncio.start_unix_server(client_connected_cb, ssl=None)", "intent": "Start a Unix socket server . With arguments `client_connected_cb`, `ssl`.", "question_id": 499}
{"snippet": "asyncio.start_unix_server(client_connected_cb, ssl_handshake_timeout=None)", "intent": "Start a Unix socket server . With arguments `client_connected_cb`, `ssl_handshake_timeout`.", "question_id": 500}
{"snippet": "asyncio.start_unix_server(client_connected_cb, start_serving=True)", "intent": "Start a Unix socket server . With arguments `client_connected_cb`, `start_serving`.", "question_id": 501}
{"snippet": "asyncio.start_unix_server(client_connected_cb, path=None, loop=None)", "intent": "Start a Unix socket server . With arguments `client_connected_cb`, `path`, `loop`.", "question_id": 502}
{"snippet": "asyncio.StreamReader", "intent": "Represents a reader object that provides APIs to read data from the IO stream.", "question_id": 503}
{"snippet": "stream_reader.read()", "intent": "Read up to `n` bytes .", "question_id": 504}
{"snippet": "stream_reader.read(n=-1)", "intent": "Read up to `n` bytes .", "question_id": 505}
{"snippet": "stream_reader.readline()", "intent": "Read one line , where \u201c line \u201d is a sequence of bytes ending with \\n .", "question_id": 506}
{"snippet": "stream_reader.readexactly(n)", "intent": "Read exactly `n` bytes .", "question_id": 507}
{"snippet": "stream_reader.readuntil()", "intent": "Read data from the stream until `separator` is found .", "question_id": 508}
{"snippet": "stream_reader.readuntil(separator=b'\\n')", "intent": "Read data from the stream until `separator` is found .", "question_id": 509}
{"snippet": "stream_reader.at_eof()", "intent": "Return True if the buffer is empty and feed_eof ( ) was called .", "question_id": 510}
{"snippet": "asyncio.StreamWriter", "intent": "Represents a writer object that provides APIs to write data to the IO stream.", "question_id": 511}
{"snippet": "stream_writer.can_write_eof()", "intent": "Return True if the underlying transport supports the write_eof ( ) method , False otherwise .", "question_id": 512}
{"snippet": "stream_writer.write_eof()", "intent": "Close the write end of the stream after the buffered write data is flushed .", "question_id": 513}
{"snippet": "stream_writer.transport", "intent": "Return the underlying asyncio transport.", "question_id": 514}
{"snippet": "stream_writer.get_extra_info(name)", "intent": "Access optional transport information ; see BaseTransport.get_extra_info ( ) for details . With arguments `name`.", "question_id": 515}
{"snippet": "stream_writer.get_extra_info(name, default=None)", "intent": "Access optional transport information ; see BaseTransport.get_extra_info ( ) for details . With arguments `name`, `default`.", "question_id": 516}
{"snippet": "stream_writer.write(data)", "intent": "Write `data` to the stream .", "question_id": 517}
{"snippet": "stream_writer.writelines(data)", "intent": "Write a list ( or any iterable ) of bytes to the stream . With arguments `data`.", "question_id": 518}
{"snippet": "stream_writer.drain()", "intent": "Wait until it is appropriate to resume writing to the stream .", "question_id": 519}
{"snippet": "stream_writer.close()", "intent": "Close the stream .", "question_id": 520}
{"snippet": "stream_writer.is_closing()", "intent": "Return True if the stream is closed or in the process of being closed .", "question_id": 521}
{"snippet": "stream_writer.wait_closed()", "intent": "Wait until the stream is closed .", "question_id": 522}
{"snippet": "asyncio.create_subprocess_exec(program, *args, **kwds)", "intent": "Create a subprocess . With arguments `program`, `*args`, `**kwds`.", "question_id": 523}
{"snippet": "asyncio.create_subprocess_exec(program, *args, **kwds, stdin=None)", "intent": "Create a subprocess . With arguments `program`, `*args`, `**kwds`, `stdin`.", "question_id": 524}
{"snippet": "asyncio.create_subprocess_exec(program, *args, **kwds, stdout=None)", "intent": "Create a subprocess . The `limit` argument sets the buffer limit for StreamReader wrappers for Process.stdout and Process.stderr ( if subprocess.PIPE is passed to `stdout` and `stderr` arguments ) . With arguments `program`, `*args`, `**kwds`.", "question_id": 525}
{"snippet": "asyncio.create_subprocess_exec(program, *args, **kwds, stderr=None)", "intent": "Create a subprocess . The `limit` argument sets the buffer limit for StreamReader wrappers for Process.stdout and Process.stderr ( if subprocess.PIPE is passed to `stdout` and `stderr` arguments ) . With arguments `program`, `*args`, `**kwds`.", "question_id": 526}
{"snippet": "asyncio.create_subprocess_exec(program, *args, **kwds, loop=None)", "intent": "Create a subprocess . With arguments `program`, `*args`, `**kwds`, `loop`.", "question_id": 527}
{"snippet": "asyncio.create_subprocess_exec(program, *args, **kwds, limit=None)", "intent": "Create a subprocess . The `limit` argument sets the buffer limit for StreamReader wrappers for Process.stdout and Process.stderr ( if subprocess.PIPE is passed to `stdout` and `stderr` arguments ) . With arguments `program`, `*args`, `**kwds`.", "question_id": 528}
{"snippet": "asyncio.create_subprocess_exec(program, *args, **kwds, stdin=None, stdout=None)", "intent": "Create a subprocess . The `limit` argument sets the buffer limit for StreamReader wrappers for Process.stdout and Process.stderr ( if subprocess.PIPE is passed to `stdout` and `stderr` arguments ) . With arguments `program`, `*args`, `**kwds`, `stdin`.", "question_id": 529}
{"snippet": "asyncio.create_subprocess_exec(program, *args, **kwds, stdin=None, stderr=None)", "intent": "Create a subprocess . The `limit` argument sets the buffer limit for StreamReader wrappers for Process.stdout and Process.stderr ( if subprocess.PIPE is passed to `stdout` and `stderr` arguments ) . With arguments `program`, `*args`, `**kwds`, `stdin`.", "question_id": 530}
{"snippet": "asyncio.create_subprocess_exec(program, *args, **kwds, stdin=None, loop=None)", "intent": "Create a subprocess . With arguments `program`, `*args`, `**kwds`, `stdin`, `loop`.", "question_id": 531}
{"snippet": "asyncio.create_subprocess_exec(program, *args, **kwds, stdin=None, limit=None)", "intent": "Create a subprocess . The `limit` argument sets the buffer limit for StreamReader wrappers for Process.stdout and Process.stderr ( if subprocess.PIPE is passed to `stdout` and `stderr` arguments ) . With arguments `program`, `*args`, `**kwds`, `stdin`.", "question_id": 532}
{"snippet": "asyncio.create_subprocess_shell(cmd, **kwds)", "intent": "Run the `cmd` shell command . With arguments `**kwds`.", "question_id": 533}
{"snippet": "asyncio.create_subprocess_shell(cmd, **kwds, stdin=None)", "intent": "Run the `cmd` shell command . With arguments `**kwds`, `stdin`.", "question_id": 534}
{"snippet": "asyncio.create_subprocess_shell(cmd, **kwds, stdout=None)", "intent": "Run the `cmd` shell command . The `limit` argument sets the buffer limit for StreamReader wrappers for Process.stdout and Process.stderr ( if subprocess.PIPE is passed to `stdout` and `stderr` arguments ) . With arguments `**kwds`.", "question_id": 535}
{"snippet": "asyncio.create_subprocess_shell(cmd, **kwds, stderr=None)", "intent": "Run the `cmd` shell command . The `limit` argument sets the buffer limit for StreamReader wrappers for Process.stdout and Process.stderr ( if subprocess.PIPE is passed to `stdout` and `stderr` arguments ) . With arguments `**kwds`.", "question_id": 536}
{"snippet": "asyncio.create_subprocess_shell(cmd, **kwds, loop=None)", "intent": "Run the `cmd` shell command . With arguments `**kwds`, `loop`.", "question_id": 537}
{"snippet": "asyncio.create_subprocess_shell(cmd, **kwds, limit=None)", "intent": "Run the `cmd` shell command . The `limit` argument sets the buffer limit for StreamReader wrappers for Process.stdout and Process.stderr ( if subprocess.PIPE is passed to `stdout` and `stderr` arguments ) . With arguments `**kwds`.", "question_id": 538}
{"snippet": "asyncio.create_subprocess_shell(cmd, **kwds, stdin=None, stdout=None)", "intent": "Run the `cmd` shell command . The `limit` argument sets the buffer limit for StreamReader wrappers for Process.stdout and Process.stderr ( if subprocess.PIPE is passed to `stdout` and `stderr` arguments ) . With arguments `**kwds`, `stdin`.", "question_id": 539}
{"snippet": "asyncio.create_subprocess_shell(cmd, **kwds, stdin=None, stderr=None)", "intent": "Run the `cmd` shell command . The `limit` argument sets the buffer limit for StreamReader wrappers for Process.stdout and Process.stderr ( if subprocess.PIPE is passed to `stdout` and `stderr` arguments ) . With arguments `**kwds`, `stdin`.", "question_id": 540}
{"snippet": "asyncio.create_subprocess_shell(cmd, **kwds, stdin=None, loop=None)", "intent": "Run the `cmd` shell command . With arguments `**kwds`, `stdin`, `loop`.", "question_id": 541}
{"snippet": "asyncio.create_subprocess_shell(cmd, **kwds, stdin=None, limit=None)", "intent": "Run the `cmd` shell command . The `limit` argument sets the buffer limit for StreamReader wrappers for Process.stdout and Process.stderr ( if subprocess.PIPE is passed to `stdout` and `stderr` arguments ) . With arguments `**kwds`, `stdin`.", "question_id": 542}
{"snippet": "asyncio.subprocess.PIPE", "intent": "Can be passed to the stdin, stdout or stderr parameters.", "question_id": 543}
{"snippet": "asyncio.subprocess.STDOUT", "intent": "Special value that can be used as the stderr argument and indicates that standard error should be redirected into standard output.", "question_id": 544}
{"snippet": "asyncio.subprocess.DEVNULL", "intent": "Special value that can be used as the stdin, stdout or stderr argument to process creation functions.", "question_id": 545}
{"snippet": "asyncio.subprocess.Process", "intent": "An object that wraps OS processes created by the create_subprocess_exec() and create_subprocess_shell() functions.", "question_id": 546}
{"snippet": "process.wait()", "intent": "Wait for the child process to terminate .", "question_id": 547}
{"snippet": "process.communicate()", "intent": "Interact with process :", "question_id": 548}
{"snippet": "process.communicate(input=None)", "intent": "Interact with process : The optional `input` argument is the data ( bytes object ) that will be sent to the child process .", "question_id": 549}
{"snippet": "process.send_signal(signal)", "intent": "Sends the `signal` signal to the child process .", "question_id": 550}
{"snippet": "process.terminate()", "intent": "Stop the child process .", "question_id": 551}
{"snippet": "process.kill()", "intent": "Kill the child .", "question_id": 552}
{"snippet": "process.stdin", "intent": "Standard input stream (StreamWriter) or None if the process was created with stdin=None.", "question_id": 553}
{"snippet": "process.stdout", "intent": "Standard output stream (StreamReader) or None if the process was created with stdout=None.", "question_id": 554}
{"snippet": "process.stderr", "intent": "Standard error stream (StreamReader) or None if the process was created with stderr=None.", "question_id": 555}
{"snippet": "process.pid", "intent": "Process identification number (PID).", "question_id": 556}
{"snippet": "process.returncode", "intent": "Return code of the process when it exits.", "question_id": 557}
{"snippet": "asyncio.Lock()", "intent": "Implements a mutex lock for asyncio tasks .", "question_id": 558}
{"snippet": "asyncio.Lock(loop=None)", "intent": "Implements a mutex lock for asyncio tasks . With arguments `loop`.", "question_id": 559}
{"snippet": "lock.acquire()", "intent": "Acquire the lock .", "question_id": 560}
{"snippet": "lock.release()", "intent": "Release the lock .", "question_id": 561}
{"snippet": "lock.locked()", "intent": "Return True if the lock is locked .", "question_id": 562}
{"snippet": "asyncio.Event()", "intent": "An event object .", "question_id": 563}
{"snippet": "asyncio.Event(loop=None)", "intent": "An event object . With arguments `loop`.", "question_id": 564}
{"snippet": "event.wait()", "intent": "Wait until the event is set .", "question_id": 565}
{"snippet": "event.set()", "intent": "Set the event .", "question_id": 566}
{"snippet": "event.clear()", "intent": "Clear ( unset ) the event .", "question_id": 567}
{"snippet": "event.is_set()", "intent": "Return True if the event is set .", "question_id": 568}
{"snippet": "asyncio.Condition()", "intent": "A Condition object .", "question_id": 569}
{"snippet": "asyncio.Condition(lock=None)", "intent": "A Condition object . The optional `lock` argument must be a Lock object or None .", "question_id": 570}
{"snippet": "asyncio.Condition(loop=None)", "intent": "A Condition object . With arguments `loop`.", "question_id": 571}
{"snippet": "asyncio.Condition(lock=None, loop=None)", "intent": "A Condition object . The optional `lock` argument must be a Lock object or None . With arguments `loop`.", "question_id": 572}
{"snippet": "condition.acquire()", "intent": "Acquire the underlying lock .", "question_id": 573}
{"snippet": "condition.notify()", "intent": "Wake up at most `n` tasks ( 1 by default ) waiting on this condition .", "question_id": 574}
{"snippet": "condition.notify(n=1)", "intent": "Wake up at most `n` tasks ( 1 by default ) waiting on this condition .", "question_id": 575}
{"snippet": "condition.locked()", "intent": "Return True if the underlying lock is acquired .", "question_id": 576}
{"snippet": "condition.notify_all()", "intent": "Wake up all tasks waiting on this condition .", "question_id": 577}
{"snippet": "condition.release()", "intent": "Release the underlying lock .", "question_id": 578}
{"snippet": "condition.wait()", "intent": "Wait until notified .", "question_id": 579}
{"snippet": "condition.wait_for(predicate)", "intent": "Wait until a `predicate` becomes true .", "question_id": 580}
{"snippet": "asyncio.Semaphore()", "intent": "A Semaphore object .", "question_id": 581}
{"snippet": "asyncio.Semaphore(value=1)", "intent": "A Semaphore object . The optional `value` argument gives the initial value for the internal counter ( 1 by default ) .", "question_id": 582}
{"snippet": "asyncio.Semaphore(loop=None)", "intent": "A Semaphore object . With arguments `loop`.", "question_id": 583}
{"snippet": "asyncio.Semaphore(value=1, loop=None)", "intent": "A Semaphore object . The optional `value` argument gives the initial value for the internal counter ( 1 by default ) . With arguments `loop`.", "question_id": 584}
{"snippet": "semaphore.acquire()", "intent": "Acquire a semaphore .", "question_id": 585}
{"snippet": "semaphore.locked()", "intent": "Returns True if semaphore can not be acquired immediately .", "question_id": 586}
{"snippet": "semaphore.release()", "intent": "Release a semaphore , incrementing the internal counter by one .", "question_id": 587}
{"snippet": "asyncio.BoundedSemaphore()", "intent": "A bounded semaphore object .", "question_id": 588}
{"snippet": "asyncio.BoundedSemaphore(value=1)", "intent": "A bounded semaphore object . Bounded Semaphore is a version of Semaphore that raises a ValueError in release ( ) if it increases the internal counter above the initial `value` .", "question_id": 589}
{"snippet": "asyncio.BoundedSemaphore(loop=None)", "intent": "A bounded semaphore object . With arguments `loop`.", "question_id": 590}
{"snippet": "asyncio.BoundedSemaphore(value=1, loop=None)", "intent": "A bounded semaphore object . Bounded Semaphore is a version of Semaphore that raises a ValueError in release ( ) if it increases the internal counter above the initial `value` . With arguments `loop`.", "question_id": 591}
{"snippet": "asyncio.run(coro)", "intent": "Execute the coroutine `coro` and return the result .", "question_id": 592}
{"snippet": "asyncio.run(coro, debug=False)", "intent": "Execute the coroutine `coro` and return the result . If `debug` is True , the event loop will be run in debug mode .", "question_id": 593}
{"snippet": "asyncio.create_task(coro)", "intent": "Wrap the `coro` coroutine into a Task and schedule its execution .", "question_id": 594}
{"snippet": "asyncio.sleep(delay)", "intent": "Block for `delay` seconds .", "question_id": 595}
{"snippet": "asyncio.sleep(delay, result=None)", "intent": "Block for `delay` seconds . If `result` is provided , it is returned to the caller when the coroutine completes .", "question_id": 596}
{"snippet": "asyncio.sleep(delay, loop=None)", "intent": "Block for `delay` seconds . The `loop` argument is deprecated and scheduled for removal in Python 3.10 .", "question_id": 597}
{"snippet": "asyncio.sleep(delay, result=None, loop=None)", "intent": "Block for `delay` seconds . If `result` is provided , it is returned to the caller when the coroutine completes . The `loop` argument is deprecated and scheduled for removal in Python 3.10 .", "question_id": 598}
{"snippet": "asyncio.gather(*aws)", "intent": "Run awaitable objects in the aws sequence concurrently . With arguments `*aws`.", "question_id": 599}
{"snippet": "asyncio.gather(*aws, loop=None)", "intent": "Run awaitable objects in the aws sequence concurrently . With arguments `*aws`, `loop`.", "question_id": 600}
{"snippet": "asyncio.gather(*aws, return_exceptions=False)", "intent": "Run awaitable objects in the aws sequence concurrently . If `return_exceptions` is False ( default ) , the first raised exception is immediately propagated to the task that awaits on gather ( ) . With arguments `*aws`.", "question_id": 601}
{"snippet": "asyncio.gather(*aws, loop=None, return_exceptions=False)", "intent": "Run awaitable objects in the aws sequence concurrently . If `return_exceptions` is False ( default ) , the first raised exception is immediately propagated to the task that awaits on gather ( ) . With arguments `*aws`, `loop`.", "question_id": 602}
{"snippet": "asyncio.shield(aw)", "intent": "Protect an awaitable object from being cancelled . If `aw` is a coroutine it is automatically scheduled as a Task .", "question_id": 603}
{"snippet": "asyncio.shield(aw, loop=None)", "intent": "Protect an awaitable object from being cancelled . If `aw` is a coroutine it is automatically scheduled as a Task . With arguments `loop`.", "question_id": 604}
{"snippet": "asyncio.wait_for(aw, timeout)", "intent": "Wait for the `aw` awaitable to complete with a `timeout` .", "question_id": 605}
{"snippet": "asyncio.wait_for(aw, timeout, loop=None)", "intent": "Wait for the `aw` awaitable to complete with a `timeout` . The `loop` argument is deprecated and scheduled for removal in Python 3.10 .", "question_id": 606}
{"snippet": "asyncio.wait(aws)", "intent": "Run awaitable objects in the `aws` set concurrently and block until the condition specified by `return_when` .", "question_id": 607}
{"snippet": "asyncio.wait(aws, loop=None)", "intent": "Run awaitable objects in the `aws` set concurrently and block until the condition specified by `return_when` . The `loop` argument is deprecated and scheduled for removal in Python 3.10 .", "question_id": 608}
{"snippet": "asyncio.wait(aws, timeout=None)", "intent": "Run awaitable objects in the `aws` set concurrently and block until the condition specified by `return_when` . `timeout` ( a float or int ) , if specified , can be used to control the maximum number of seconds to wait before returning .", "question_id": 609}
{"snippet": "asyncio.wait(aws, return_when=ALL_COMPLETED)", "intent": "Run awaitable objects in the `aws` set concurrently and block until the condition specified by `return_when` .", "question_id": 610}
{"snippet": "asyncio.wait(aws, loop=None, timeout=None)", "intent": "Run awaitable objects in the `aws` set concurrently and block until the condition specified by `return_when` . The `loop` argument is deprecated and scheduled for removal in Python 3.10 . `timeout` ( a float or int ) , if specified , can be used to control the maximum number of seconds to wait before returning .", "question_id": 611}
{"snippet": "asyncio.wait(aws, loop=None, return_when=ALL_COMPLETED)", "intent": "Run awaitable objects in the `aws` set concurrently and block until the condition specified by `return_when` . The `loop` argument is deprecated and scheduled for removal in Python 3.10 .", "question_id": 612}
{"snippet": "asyncio.wait(aws, timeout=None, return_when=ALL_COMPLETED)", "intent": "Run awaitable objects in the `aws` set concurrently and block until the condition specified by `return_when` . `timeout` ( a float or int ) , if specified , can be used to control the maximum number of seconds to wait before returning .", "question_id": 613}
{"snippet": "asyncio.wait(aws, loop=None, timeout=None, return_when=ALL_COMPLETED)", "intent": "Run awaitable objects in the `aws` set concurrently and block until the condition specified by `return_when` . The `loop` argument is deprecated and scheduled for removal in Python 3.10 . `timeout` ( a float or int ) , if specified , can be used to control the maximum number of seconds to wait before returning .", "question_id": 614}
{"snippet": "asyncio.as_completed(aws)", "intent": "Run awaitable objects in the `aws` set concurrently .", "question_id": 615}
{"snippet": "asyncio.as_completed(aws, loop=None)", "intent": "Run awaitable objects in the `aws` set concurrently . With arguments `loop`.", "question_id": 616}
{"snippet": "asyncio.as_completed(aws, timeout=None)", "intent": "Run awaitable objects in the `aws` set concurrently . Raises asyncio.TimeoutError if the `timeout` occurs before all Futures are done .", "question_id": 617}
{"snippet": "asyncio.as_completed(aws, loop=None, timeout=None)", "intent": "Run awaitable objects in the `aws` set concurrently . Raises asyncio.TimeoutError if the `timeout` occurs before all Futures are done . With arguments `loop`.", "question_id": 618}
{"snippet": "asyncio.run_coroutine_threadsafe(coro, loop)", "intent": "Submit a coroutine to the given event `loop` . With arguments `coro`.", "question_id": 619}
{"snippet": "asyncio.current_task()", "intent": "Return the currently running Task instance , or None if no task is running .", "question_id": 620}
{"snippet": "asyncio.current_task(loop=None)", "intent": "Return the currently running Task instance , or None if no task is running . If `loop` is None get_running_loop ( ) is used to get the current loop .", "question_id": 621}
{"snippet": "asyncio.all_tasks()", "intent": "Return a set of not yet finished Task objects run by the `loop` .", "question_id": 622}
{"snippet": "asyncio.all_tasks(loop=None)", "intent": "Return a set of not yet finished Task objects run by the `loop` .", "question_id": 623}
{"snippet": "asyncio.Task(coro)", "intent": "A Future-like object that runs a Python coroutine . With arguments `coro`.", "question_id": 624}
{"snippet": "asyncio.Task(coro, loop=None)", "intent": "A Future-like object that runs a Python coroutine . Event loops use cooperative scheduling : an event `loop` runs one Task at a time . With arguments `coro`.", "question_id": 625}
{"snippet": "task.cancel()", "intent": "Request the Task to be cancelled .", "question_id": 626}
{"snippet": "task.cancelled()", "intent": "Return True if the Task is cancelled .", "question_id": 627}
{"snippet": "task.done()", "intent": "Return True if the Task is done .", "question_id": 628}
{"snippet": "task.result()", "intent": "Return the result of the Task .", "question_id": 629}
{"snippet": "task.exception()", "intent": "Return the exception of the Task .", "question_id": 630}
{"snippet": "task.add_done_callback(callback)", "intent": "Add a `callback` to be run when the Task is done .", "question_id": 631}
{"snippet": "task.add_done_callback(callback, context=None)", "intent": "Add a `callback` to be run when the Task is done . With arguments `context`.", "question_id": 632}
{"snippet": "task.remove_done_callback(callback)", "intent": "Remove `callback` from the callbacks list .", "question_id": 633}
{"snippet": "task.get_stack()", "intent": "Return the list of stack frames for this Task .", "question_id": 634}
{"snippet": "task.get_stack(limit=None)", "intent": "Return the list of stack frames for this Task . The optional `limit` argument sets the maximum number of frames to return ; by default all available frames are returned .", "question_id": 635}
{"snippet": "task.print_stack()", "intent": "Print the stack or traceback for this Task .", "question_id": 636}
{"snippet": "task.print_stack(limit=None)", "intent": "Print the stack or traceback for this Task . The `limit` argument is passed to get_stack ( ) directly .", "question_id": 637}
{"snippet": "task.print_stack(file=None)", "intent": "Print the stack or traceback for this Task . The `file` argument is an I/O stream to which the output is written ; by default output is written to sys.stderr .", "question_id": 638}
{"snippet": "task.print_stack(limit=None, file=None)", "intent": "Print the stack or traceback for this Task . The `limit` argument is passed to get_stack ( ) directly . The `file` argument is an I/O stream to which the output is written ; by default output is written to sys.stderr .", "question_id": 639}
{"snippet": "task.all_tasks()", "intent": "Return a set of all tasks for an event `loop` .", "question_id": 640}
{"snippet": "task.all_tasks(loop=None)", "intent": "Return a set of all tasks for an event `loop` .", "question_id": 641}
{"snippet": "task.current_task()", "intent": "Return the currently running task or None .", "question_id": 642}
{"snippet": "task.current_task(loop=None)", "intent": "Return the currently running task or None . If `loop` is None , the get_event_loop ( ) function is used to get the current loop .", "question_id": 643}
{"snippet": "@asyncio.coroutine", "intent": "Decorator to mark generator-based coroutines.", "question_id": 644}
{"snippet": "asyncio.iscoroutine(obj)", "intent": "Return True if `obj` is a coroutine object .", "question_id": 645}
{"snippet": "asyncio.iscoroutinefunction(func)", "intent": "Return True if `func` is a coroutine function .", "question_id": 646}
{"snippet": "asyncore.loop(timeout, use_poll, map, count)", "intent": "Enter a polling loop that terminates after `count` passes or all open channels have been closed . The `timeout` argument sets the timeout parameter for the appropriate select ( ) or poll ( ) call , measured in seconds ; the default is 30 seconds . The `use_poll` parameter , if true , indicates that poll ( ) should be used in preference to select ( ) ( the default is False ) . The `map` parameter is a dictionary whose items are the channels to watch .", "question_id": 647}
{"snippet": "asyncore.loop(timeout, use_poll, map)", "intent": "Enter a polling loop that terminates after `count` passes or all open channels have been closed . The `timeout` argument sets the timeout parameter for the appropriate select ( ) or poll ( ) call , measured in seconds ; the default is 30 seconds . The `use_poll` parameter , if true , indicates that poll ( ) should be used in preference to select ( ) ( the default is False ) . The `map` parameter is a dictionary whose items are the channels to watch .", "question_id": 648}
{"snippet": "asyncore.loop(timeout, use_poll)", "intent": "Enter a polling loop that terminates after `count` passes or all open channels have been closed . The `timeout` argument sets the timeout parameter for the appropriate select ( ) or poll ( ) call , measured in seconds ; the default is 30 seconds . The `use_poll` parameter , if true , indicates that poll ( ) should be used in preference to select ( ) ( the default is False ) .", "question_id": 649}
{"snippet": "asyncore.loop(timeout)", "intent": "Enter a polling loop that terminates after `count` passes or all open channels have been closed . The `timeout` argument sets the timeout parameter for the appropriate select ( ) or poll ( ) call , measured in seconds ; the default is 30 seconds .", "question_id": 650}
{"snippet": "asyncore.loop()", "intent": "Enter a polling loop that terminates after `count` passes or all open channels have been closed .", "question_id": 651}
{"snippet": "asyncore.dispatcher", "intent": "The dispatcher class is a thin wrapper around a low-level socket object.", "question_id": 652}
{"snippet": "dispatcher.handle_read()", "intent": "Called when the asynchronous loop detects that a read ( ) call on the channel \u2019 s socket will succeed .", "question_id": 653}
{"snippet": "dispatcher.handle_write()", "intent": "Called when the asynchronous loop detects that a writable socket can be written .", "question_id": 654}
{"snippet": "dispatcher.handle_expt()", "intent": "Called when there is out of band ( OOB ) data for a socket connection .", "question_id": 655}
{"snippet": "dispatcher.handle_connect()", "intent": "Called when the active opener \u2019 s socket actually makes a connection .", "question_id": 656}
{"snippet": "dispatcher.handle_close()", "intent": "Called when the socket is closed .", "question_id": 657}
{"snippet": "dispatcher.handle_error()", "intent": "Called when an exception is raised and not otherwise handled .", "question_id": 658}
{"snippet": "dispatcher.handle_accept()", "intent": "Called on listening channels ( passive openers ) when a connection can be established with a new remote endpoint that has issued a connect ( ) call for the local endpoint .", "question_id": 659}
{"snippet": "dispatcher.handle_accepted(sock, addr)", "intent": "Called on listening channels ( passive openers ) when a connection has been established with a new remote endpoint that has issued a connect ( ) call for the local endpoint . `sock` is a new socket object usable to send and receive data on the connection , and `addr` is the address bound to the socket on the other end of the connection .", "question_id": 660}
{"snippet": "dispatcher.readable()", "intent": "Called each time around the asynchronous loop to determine whether a channel \u2019 s socket should be added to the list on which read events can occur .", "question_id": 661}
{"snippet": "dispatcher.writable()", "intent": "Called each time around the asynchronous loop to determine whether a channel \u2019 s socket should be added to the list on which write events can occur .", "question_id": 662}
{"snippet": "dispatcher.create_socket()", "intent": "This is identical to the creation of a normal socket , and will use the same options for creation .", "question_id": 663}
{"snippet": "dispatcher.create_socket(family=socket.AF_INET)", "intent": "This is identical to the creation of a normal socket , and will use the same options for creation . With arguments `family`.", "question_id": 664}
{"snippet": "dispatcher.create_socket(type=socket.SOCK_STREAM)", "intent": "This is identical to the creation of a normal socket , and will use the same options for creation . With arguments `type`.", "question_id": 665}
{"snippet": "dispatcher.create_socket(family=socket.AF_INET, type=socket.SOCK_STREAM)", "intent": "This is identical to the creation of a normal socket , and will use the same options for creation . With arguments `family`, `type`.", "question_id": 666}
{"snippet": "dispatcher.connect(address)", "intent": "As with the normal socket object , `address` is a tuple with the first element the host to connect to , and the second the port number .", "question_id": 667}
{"snippet": "dispatcher.send(data)", "intent": "Send `data` to the remote end-point of the socket .", "question_id": 668}
{"snippet": "dispatcher.recv(buffer_size)", "intent": "Read at most `buffer_size` bytes from the socket \u2019 s remote end-point .", "question_id": 669}
{"snippet": "dispatcher.listen(backlog)", "intent": "Listen for connections made to the socket . The `backlog` argument specifies the maximum number of queued connections and should be at least 1 ; the maximum value is system-dependent ( usually 5 ) .", "question_id": 670}
{"snippet": "dispatcher.bind(address)", "intent": "Bind the socket to `address` .", "question_id": 671}
{"snippet": "dispatcher.accept()", "intent": "Accept a connection .", "question_id": 672}
{"snippet": "dispatcher.close()", "intent": "Close the socket .", "question_id": 673}
{"snippet": "asyncore.dispatcher_with_send", "intent": "A dispatcher subclass which adds simple buffered output capability, useful for simple clients.", "question_id": 674}
{"snippet": "asyncore.file_dispatcher", "intent": "A file_dispatcher takes a file descriptor or file object along with an optional map argument and wraps it for use with the poll() or loop() functions.", "question_id": 675}
{"snippet": "asyncore.file_wrapper", "intent": "A file_wrapper takes an integer file descriptor and calls os.dup() to duplicate the handle so that the original handle may be closed independently of the file_wrapper.", "question_id": 676}
{"snippet": "atexit.register(func, *args, **kwargs)", "intent": "Register `func` as a function to be executed at termination . With arguments `*args`, `**kwargs`.", "question_id": 677}
{"snippet": "atexit.unregister(func)", "intent": "Remove `func` from the list of functions to be run at interpreter shutdown .", "question_id": 678}
{"snippet": "audioop.error", "intent": "This exception is raised on all errors, such as unknown number of bytes per sample, etc.", "question_id": 679}
{"snippet": "audioop.add(fragment1, fragment2, width)", "intent": "Return a fragment which is the addition of the two samples passed as parameters . `width` is the sample width in bytes , either 1 , 2 , 3 or 4 . With arguments `fragment1`, `fragment2`.", "question_id": 680}
{"snippet": "audioop.adpcm2lin(adpcmfragment, width, state)", "intent": "Decode an Intel/DVI ADPCM coded fragment to a linear fragment . Return a tuple ( sample , newstate ) where the sample has the `width` specified in width . With arguments `adpcmfragment`, `state`.", "question_id": 681}
{"snippet": "audioop.alaw2lin(fragment, width)", "intent": "Convert sound fragments in a-LAW encoding to linearly encoded sound fragments . a-LAW encoding always uses 8 bits samples , so `width` refers only to the sample width of the output `fragment` here .", "question_id": 682}
{"snippet": "audioop.avg(fragment, width)", "intent": "Return the average over all samples in the `fragment` . With arguments `width`.", "question_id": 683}
{"snippet": "audioop.avgpp(fragment, width)", "intent": "Return the average peak-peak value over all samples in the `fragment` . With arguments `width`.", "question_id": 684}
{"snippet": "audioop.bias(fragment, width, bias)", "intent": "Return a `fragment` that is the original fragment with a `bias` added to each sample . With arguments `width`.", "question_id": 685}
{"snippet": "audioop.byteswap(fragment, width)", "intent": "\u201c Byteswap \u201d all samples in a `fragment` and returns the modified fragment . With arguments `width`.", "question_id": 686}
{"snippet": "audioop.cross(fragment, width)", "intent": "Return the number of zero crossings in the `fragment` passed as an argument . With arguments `width`.", "question_id": 687}
{"snippet": "audioop.findfactor(fragment, reference)", "intent": "Return a factor F such that rms ( add ( `fragment` , mul ( `reference` , -F ) ) ) is minimal , i.e. , return the factor with which you should multiply reference to make it match as well as possible to fragment .", "question_id": 688}
{"snippet": "audioop.findfit(fragment, reference)", "intent": "Try to match `reference` as well as possible to a portion of `fragment` ( which should be the longer fragment ) .", "question_id": 689}
{"snippet": "audioop.findmax(fragment, length)", "intent": "Search `fragment` for a slice of `length` length samples ( not bytes ! )", "question_id": 690}
{"snippet": "audioop.getsample(fragment, width, index)", "intent": "Return the value of sample `index` from the `fragment` . With arguments `width`.", "question_id": 691}
{"snippet": "audioop.lin2adpcm(fragment, width, state)", "intent": "Convert samples to 4 bit Intel/DVI ADPCM encoding . adpcmfrag is the ADPCM coded `fragment` packed 2 4-bit values per byte . `state` is a tuple containing the state of the coder . With arguments `width`.", "question_id": 692}
{"snippet": "audioop.lin2alaw(fragment, width)", "intent": "Convert samples in the audio `fragment` to a-LAW encoding and return this as a bytes object . With arguments `width`.", "question_id": 693}
{"snippet": "audioop.lin2lin(fragment, width, newwidth)", "intent": "Convert samples between 1- , 2- , 3- and 4-byte formats . With arguments `fragment`, `width`, `newwidth`.", "question_id": 694}
{"snippet": "audioop.lin2ulaw(fragment, width)", "intent": "Convert samples in the audio `fragment` to u-LAW encoding and return this as a bytes object . With arguments `width`.", "question_id": 695}
{"snippet": "audioop.max(fragment, width)", "intent": "Return the maximum of the absolute value of all samples in a `fragment` . With arguments `width`.", "question_id": 696}
{"snippet": "audioop.maxpp(fragment, width)", "intent": "Return the maximum peak-peak value in the sound `fragment` . With arguments `width`.", "question_id": 697}
{"snippet": "audioop.minmax(fragment, width)", "intent": "Return a tuple consisting of the minimum and maximum values of all samples in the sound `fragment` . With arguments `width`.", "question_id": 698}
{"snippet": "audioop.mul(fragment, width, factor)", "intent": "Return a `fragment` that has all samples in the original fragment multiplied by the floating-point value `factor` . With arguments `width`.", "question_id": 699}
{"snippet": "audioop.ratecv(fragment, width, nchannels, inrate, outrate, state, weightA, weightB)", "intent": "Convert the frame rate of the input `fragment` . `state` is a tuple containing the state of the converter . The `weightA` and `weightB` arguments are parameters for a simple digital filter and default to 1 and 0 respectively . With arguments `width`, `nchannels`, `inrate`, `outrate`.", "question_id": 700}
{"snippet": "audioop.ratecv(fragment, width, nchannels, inrate, outrate, state, weightA)", "intent": "Convert the frame rate of the input `fragment` . `state` is a tuple containing the state of the converter . The `weightA` and `weightB` arguments are parameters for a simple digital filter and default to 1 and 0 respectively . With arguments `width`, `nchannels`, `inrate`, `outrate`.", "question_id": 701}
{"snippet": "audioop.ratecv(fragment, width, nchannels, inrate, outrate, state)", "intent": "Convert the frame rate of the input `fragment` . `state` is a tuple containing the state of the converter . With arguments `width`, `nchannels`, `inrate`, `outrate`.", "question_id": 702}
{"snippet": "audioop.reverse(fragment, width)", "intent": "Reverse the samples in a `fragment` and returns the modified fragment . With arguments `width`.", "question_id": 703}
{"snippet": "audioop.rms(fragment, width)", "intent": "Return the root-mean-square of the `fragment` , i.e . With arguments `width`.", "question_id": 704}
{"snippet": "audioop.tomono(fragment, width, lfactor, rfactor)", "intent": "Convert a stereo `fragment` to a mono fragment . The left channel is multiplied by `lfactor` and the right channel by `rfactor` before adding the two channels to give a mono signal . With arguments `width`.", "question_id": 705}
{"snippet": "audioop.tostereo(fragment, width, lfactor, rfactor)", "intent": "Generate a stereo `fragment` from a mono fragment . Each pair of samples in the stereo fragment are computed from the mono sample , whereby left channel samples are multiplied by `lfactor` and right channel samples by `rfactor` . With arguments `width`.", "question_id": 706}
{"snippet": "audioop.ulaw2lin(fragment, width)", "intent": "Convert sound fragments in u-LAW encoding to linearly encoded sound fragments . u-LAW encoding always uses 8 bits samples , so `width` refers only to the sample width of the output `fragment` here .", "question_id": 707}
{"snippet": "base64.b64encode(s)", "intent": "Encode the bytes-like object `s` using Base64 and return the encoded bytes .", "question_id": 708}
{"snippet": "base64.b64encode(s, altchars=None)", "intent": "Encode the bytes-like object `s` using Base64 and return the encoded bytes . Optional `altchars` must be a bytes-like object of at least length 2 ( additional characters are ignored ) which specifies an alternative alphabet for the + and / characters .", "question_id": 709}
{"snippet": "base64.b64decode(s)", "intent": "Decode the Base64 encoded bytes-like object or ASCII string `s` and return the decoded bytes .", "question_id": 710}
{"snippet": "base64.b64decode(s, altchars=None)", "intent": "Decode the Base64 encoded bytes-like object or ASCII string `s` and return the decoded bytes . Optional `altchars` must be a bytes-like object or ASCII string of at least length 2 ( additional characters are ignored ) which specifies the alternative alphabet used instead of the + and / characters .", "question_id": 711}
{"snippet": "base64.b64decode(s, validate=False)", "intent": "Decode the Base64 encoded bytes-like object or ASCII string `s` and return the decoded bytes . If `validate` is False ( the default ) , characters that are neither in the normal base-64 alphabet nor the alternative alphabet are discarded prior to the padding check .", "question_id": 712}
{"snippet": "base64.b64decode(s, altchars=None, validate=False)", "intent": "Decode the Base64 encoded bytes-like object or ASCII string `s` and return the decoded bytes . Optional `altchars` must be a bytes-like object or ASCII string of at least length 2 ( additional characters are ignored ) which specifies the alternative alphabet used instead of the + and / characters . If `validate` is False ( the default ) , characters that are neither in the normal base-64 alphabet nor the alternative alphabet are discarded prior to the padding check .", "question_id": 713}
{"snippet": "base64.standard_b64encode(s)", "intent": "Encode bytes-like object `s` using the standard Base64 alphabet and return the encoded bytes .", "question_id": 714}
{"snippet": "base64.standard_b64decode(s)", "intent": "Decode bytes-like object or ASCII string `s` using the standard Base64 alphabet and return the decoded bytes .", "question_id": 715}
{"snippet": "base64.urlsafe_b64encode(s)", "intent": "Encode bytes-like object `s` using the URL- and filesystem-safe alphabet , which substitutes - instead of + and _ instead of / in the standard Base64 alphabet , and return the encoded bytes .", "question_id": 716}
{"snippet": "base64.urlsafe_b64decode(s)", "intent": "Decode bytes-like object or ASCII string `s` using the URL- and filesystem-safe alphabet , which substitutes - instead of + and _ instead of / in the standard Base64 alphabet , and return the decoded bytes .", "question_id": 717}
{"snippet": "base64.b32encode(s)", "intent": "Encode the bytes-like object `s` using Base32 and return the encoded bytes .", "question_id": 718}
{"snippet": "base64.b32decode(s)", "intent": "Decode the Base32 encoded bytes-like object or ASCII string `s` and return the decoded bytes .", "question_id": 719}
{"snippet": "base64.b32decode(s, casefold=False)", "intent": "Decode the Base32 encoded bytes-like object or ASCII string `s` and return the decoded bytes . Optional `casefold` is a flag specifying whether a lowercase alphabet is acceptable as input .", "question_id": 720}
{"snippet": "base64.b32decode(s, map01=None)", "intent": "Decode the Base32 encoded bytes-like object or ASCII string `s` and return the decoded bytes . The optional argument `map01` when not None , specifies which letter the digit 1 should be mapped to ( when map01 is not None , the digit 0 is always mapped to the letter O ) .", "question_id": 721}
{"snippet": "base64.b32decode(s, casefold=False, map01=None)", "intent": "Decode the Base32 encoded bytes-like object or ASCII string `s` and return the decoded bytes . Optional `casefold` is a flag specifying whether a lowercase alphabet is acceptable as input . The optional argument `map01` when not None , specifies which letter the digit 1 should be mapped to ( when map01 is not None , the digit 0 is always mapped to the letter O ) .", "question_id": 722}
{"snippet": "base64.b16encode(s)", "intent": "Encode the bytes-like object `s` using Base16 and return the encoded bytes .", "question_id": 723}
{"snippet": "base64.b16decode(s)", "intent": "Decode the Base16 encoded bytes-like object or ASCII string `s` and return the decoded bytes .", "question_id": 724}
{"snippet": "base64.b16decode(s, casefold=False)", "intent": "Decode the Base16 encoded bytes-like object or ASCII string `s` and return the decoded bytes . Optional `casefold` is a flag specifying whether a lowercase alphabet is acceptable as input .", "question_id": 725}
{"snippet": "base64.a85encode(b)", "intent": "Encode the bytes-like object `b` using Ascii85 and return the encoded bytes .", "question_id": 726}
{"snippet": "base64.a85encode(b, foldspaces=False)", "intent": "Encode the bytes-like object `b` using Ascii85 and return the encoded bytes . `foldspaces` is an optional flag that uses the special short sequence \u2018 y \u2019 instead of 4 consecutive spaces ( ASCII 0x20 ) as supported by \u2018 btoa \u2019 .", "question_id": 727}
{"snippet": "base64.a85encode(b, wrapcol=0)", "intent": "Encode the bytes-like object `b` using Ascii85 and return the encoded bytes . `wrapcol` controls whether the output should have newline ( b'\\n ' ) characters added to it .", "question_id": 728}
{"snippet": "base64.a85encode(b, pad=False)", "intent": "Encode the bytes-like object `b` using Ascii85 and return the encoded bytes . `pad` controls whether the input is padded to a multiple of 4 before encoding .", "question_id": 729}
{"snippet": "base64.a85encode(b, adobe=False)", "intent": "Encode the bytes-like object `b` using Ascii85 and return the encoded bytes . `adobe` controls whether the encoded byte sequence is framed with < ~ and ~ > , which is used by the Adobe implementation .", "question_id": 730}
{"snippet": "base64.a85encode(b, foldspaces=False, wrapcol=0)", "intent": "Encode the bytes-like object `b` using Ascii85 and return the encoded bytes . `foldspaces` is an optional flag that uses the special short sequence \u2018 y \u2019 instead of 4 consecutive spaces ( ASCII 0x20 ) as supported by \u2018 btoa \u2019 . `wrapcol` controls whether the output should have newline ( b'\\n ' ) characters added to it .", "question_id": 731}
{"snippet": "base64.a85encode(b, foldspaces=False, pad=False)", "intent": "Encode the bytes-like object `b` using Ascii85 and return the encoded bytes . `foldspaces` is an optional flag that uses the special short sequence \u2018 y \u2019 instead of 4 consecutive spaces ( ASCII 0x20 ) as supported by \u2018 btoa \u2019 . `pad` controls whether the input is padded to a multiple of 4 before encoding .", "question_id": 732}
{"snippet": "base64.a85encode(b, foldspaces=False, adobe=False)", "intent": "Encode the bytes-like object `b` using Ascii85 and return the encoded bytes . `foldspaces` is an optional flag that uses the special short sequence \u2018 y \u2019 instead of 4 consecutive spaces ( ASCII 0x20 ) as supported by \u2018 btoa \u2019 . `adobe` controls whether the encoded byte sequence is framed with < ~ and ~ > , which is used by the Adobe implementation .", "question_id": 733}
{"snippet": "base64.a85encode(b, wrapcol=0, pad=False)", "intent": "Encode the bytes-like object `b` using Ascii85 and return the encoded bytes . `wrapcol` controls whether the output should have newline ( b'\\n ' ) characters added to it . `pad` controls whether the input is padded to a multiple of 4 before encoding .", "question_id": 734}
{"snippet": "base64.a85encode(b, wrapcol=0, adobe=False)", "intent": "Encode the bytes-like object `b` using Ascii85 and return the encoded bytes . `wrapcol` controls whether the output should have newline ( b'\\n ' ) characters added to it . `adobe` controls whether the encoded byte sequence is framed with < ~ and ~ > , which is used by the Adobe implementation .", "question_id": 735}
{"snippet": "base64.a85decode(b)", "intent": "Decode the Ascii85 encoded bytes-like object or ASCII string `b` and return the decoded bytes .", "question_id": 736}
{"snippet": "base64.a85decode(b, foldspaces=False)", "intent": "Decode the Ascii85 encoded bytes-like object or ASCII string `b` and return the decoded bytes . `foldspaces` is a flag that specifies whether the \u2018 y \u2019 short sequence should be accepted as shorthand for 4 consecutive spaces ( ASCII 0x20 ) .", "question_id": 737}
{"snippet": "base64.a85decode(b, adobe=False)", "intent": "Decode the Ascii85 encoded bytes-like object or ASCII string `b` and return the decoded bytes . `adobe` controls whether the input sequence is in Adobe Ascii85 format ( i.e .", "question_id": 738}
{"snippet": "base64.a85decode(b, ignorechars=b' \\t\\n\\r\\v')", "intent": "Decode the Ascii85 encoded bytes-like object or ASCII string `b` and return the decoded bytes . `ignorechars` should be a bytes-like object or ASCII string containing characters to ignore from the input .", "question_id": 739}
{"snippet": "base64.a85decode(b, foldspaces=False, adobe=False)", "intent": "Decode the Ascii85 encoded bytes-like object or ASCII string `b` and return the decoded bytes . `foldspaces` is a flag that specifies whether the \u2018 y \u2019 short sequence should be accepted as shorthand for 4 consecutive spaces ( ASCII 0x20 ) . `adobe` controls whether the input sequence is in Adobe Ascii85 format ( i.e .", "question_id": 740}
{"snippet": "base64.a85decode(b, foldspaces=False, ignorechars=b' \\t\\n\\r\\v')", "intent": "Decode the Ascii85 encoded bytes-like object or ASCII string `b` and return the decoded bytes . `foldspaces` is a flag that specifies whether the \u2018 y \u2019 short sequence should be accepted as shorthand for 4 consecutive spaces ( ASCII 0x20 ) . `ignorechars` should be a bytes-like object or ASCII string containing characters to ignore from the input .", "question_id": 741}
{"snippet": "base64.a85decode(b, adobe=False, ignorechars=b' \\t\\n\\r\\v')", "intent": "Decode the Ascii85 encoded bytes-like object or ASCII string `b` and return the decoded bytes . `adobe` controls whether the input sequence is in Adobe Ascii85 format ( i.e . `ignorechars` should be a bytes-like object or ASCII string containing characters to ignore from the input .", "question_id": 742}
{"snippet": "base64.a85decode(b, foldspaces=False, adobe=False, ignorechars=b' \\t\\n\\r\\v')", "intent": "Decode the Ascii85 encoded bytes-like object or ASCII string `b` and return the decoded bytes . `foldspaces` is a flag that specifies whether the \u2018 y \u2019 short sequence should be accepted as shorthand for 4 consecutive spaces ( ASCII 0x20 ) . `adobe` controls whether the input sequence is in Adobe Ascii85 format ( i.e . `ignorechars` should be a bytes-like object or ASCII string containing characters to ignore from the input .", "question_id": 743}
{"snippet": "base64.b85encode(b)", "intent": "Encode the bytes-like object `b` using base85 ( as used in e.g .", "question_id": 744}
{"snippet": "base64.b85encode(b, pad=False)", "intent": "Encode the bytes-like object `b` using base85 ( as used in e.g . If `pad` is true , the input is padded with b'\\0 ' so its length is a multiple of 4 bytes before encoding .", "question_id": 745}
{"snippet": "base64.b85decode(b)", "intent": "Decode the base85-encoded bytes-like object or ASCII string `b` and return the decoded bytes .", "question_id": 746}
{"snippet": "base64.decode(input, output)", "intent": "Decode the contents of the binary `input` file and write the resulting binary data to the `output` file .", "question_id": 747}
{"snippet": "base64.decodebytes(s)", "intent": "Decode the bytes-like object `s` , which must contain one or more lines of base64 encoded data , and return the decoded bytes .", "question_id": 748}
{"snippet": "base64.decodestring(s)", "intent": "Deprecated alias of decodebytes ( ) . With arguments `s`.", "question_id": 749}
{"snippet": "base64.encode(input, output)", "intent": "Encode the contents of the binary `input` file and write the resulting base64 encoded data to the `output` file .", "question_id": 750}
{"snippet": "base64.encodebytes(s)", "intent": "Encode the bytes-like object `s` , which can contain arbitrary binary data , and return bytes containing the base64-encoded data , with newlines ( b'\\n ' ) inserted after every 76 bytes of output , and ensuring that there is a trailing newline , as per RFC 2045 ( MIME ) .", "question_id": 751}
{"snippet": "base64.encodestring(s)", "intent": "Deprecated alias of encodebytes ( ) . With arguments `s`.", "question_id": 752}
{"snippet": "bdb.BdbQuit", "intent": "Exception raised by the Bdb class for quitting the debugger.", "question_id": 753}
{"snippet": "bdb.Breakpoint(self, file, line)", "intent": "This class implements `temporary` breakpoints , ignore counts , disabling and ( re- ) enabling , and conditionals . Breakpoints are indexed by number through a list called bpbynumber and by ( `file` , `line` ) pairs through bplist . With arguments `self`.", "question_id": 754}
{"snippet": "bdb.Breakpoint(self, file, line, temporary=0)", "intent": "This class implements `temporary` breakpoints , ignore counts , disabling and ( re- ) enabling , and conditionals . Breakpoints are indexed by number through a list called bpbynumber and by ( `file` , `line` ) pairs through bplist . With arguments `self`.", "question_id": 755}
{"snippet": "bdb.Breakpoint(self, file, line, cond=None)", "intent": "This class implements `temporary` breakpoints , ignore counts , disabling and ( re- ) enabling , and conditionals . Breakpoints are indexed by number through a list called bpbynumber and by ( `file` , `line` ) pairs through bplist . With arguments `self`, `cond`.", "question_id": 756}
{"snippet": "bdb.Breakpoint(self, file, line, funcname=None)", "intent": "This class implements `temporary` breakpoints , ignore counts , disabling and ( re- ) enabling , and conditionals . Breakpoints are indexed by number through a list called bpbynumber and by ( `file` , `line` ) pairs through bplist . If a `funcname` is defined , a breakpoint hit will be counted when the first line of that function is executed . With arguments `self`.", "question_id": 757}
{"snippet": "bdb.Breakpoint(self, file, line, temporary=0, cond=None)", "intent": "This class implements `temporary` breakpoints , ignore counts , disabling and ( re- ) enabling , and conditionals . Breakpoints are indexed by number through a list called bpbynumber and by ( `file` , `line` ) pairs through bplist . With arguments `self`, `cond`.", "question_id": 758}
{"snippet": "bdb.Breakpoint(self, file, line, temporary=0, funcname=None)", "intent": "This class implements `temporary` breakpoints , ignore counts , disabling and ( re- ) enabling , and conditionals . Breakpoints are indexed by number through a list called bpbynumber and by ( `file` , `line` ) pairs through bplist . If a `funcname` is defined , a breakpoint hit will be counted when the first line of that function is executed . With arguments `self`.", "question_id": 759}
{"snippet": "bdb.Breakpoint(self, file, line, cond=None, funcname=None)", "intent": "This class implements `temporary` breakpoints , ignore counts , disabling and ( re- ) enabling , and conditionals . Breakpoints are indexed by number through a list called bpbynumber and by ( `file` , `line` ) pairs through bplist . If a `funcname` is defined , a breakpoint hit will be counted when the first line of that function is executed . With arguments `self`, `cond`.", "question_id": 760}
{"snippet": "bdb.Breakpoint(self, file, line, temporary=0, cond=None, funcname=None)", "intent": "This class implements `temporary` breakpoints , ignore counts , disabling and ( re- ) enabling , and conditionals . Breakpoints are indexed by number through a list called bpbynumber and by ( `file` , `line` ) pairs through bplist . If a `funcname` is defined , a breakpoint hit will be counted when the first line of that function is executed . With arguments `self`, `cond`.", "question_id": 761}
{"snippet": "breakpoint.deleteMe()", "intent": "Delete the breakpoint from the list associated to a file/line .", "question_id": 762}
{"snippet": "breakpoint.enable()", "intent": "Mark the breakpoint as enabled .", "question_id": 763}
{"snippet": "breakpoint.disable()", "intent": "Mark the breakpoint as disabled .", "question_id": 764}
{"snippet": "breakpoint.bpformat()", "intent": "Return a string with all the information about the breakpoint , nicely formatted :", "question_id": 765}
{"snippet": "breakpoint.bpprint()", "intent": "Print the output of bpformat ( ) to the file `out` , or if it is None , to standard output .", "question_id": 766}
{"snippet": "breakpoint.bpprint(out=None)", "intent": "Print the output of bpformat ( ) to the file `out` , or if it is None , to standard output .", "question_id": 767}
{"snippet": "bdb.Bdb()", "intent": "The Bdb class acts as a generic Python debugger base class .", "question_id": 768}
{"snippet": "bdb.Bdb(skip=None)", "intent": "The Bdb class acts as a generic Python debugger base class . The `skip` argument , if given , must be an iterable of glob-style module name patterns .", "question_id": 769}
{"snippet": "bdb.canonic(filename)", "intent": "Auxiliary method for getting a `filename` in a canonical form , that is , as a case-normalized ( on case-insensitive filesystems ) absolute path , stripped of surrounding angle brackets .", "question_id": 770}
{"snippet": "bdb.reset()", "intent": "Set the botframe , stopframe , returnframe and quitting attributes with values ready to start debugging .", "question_id": 771}
{"snippet": "bdb.trace_dispatch(frame, event, arg)", "intent": "This function is installed as the trace function of debugged frames . The default implementation decides how to dispatch a `frame` , depending on the type of `event` ( passed as a string ) that is about to be executed . The `arg` parameter depends on the previous event .", "question_id": 772}
{"snippet": "bdb.dispatch_line(frame)", "intent": "If the debugger should stop on the current line , invoke the user_line ( ) method ( which should be overridden in subclasses ) . With arguments `frame`.", "question_id": 773}
{"snippet": "bdb.dispatch_call(frame, arg)", "intent": "If the debugger should stop on this function call , invoke the user_call ( ) method ( which should be overridden in subclasses ) . With arguments `frame`, `arg`.", "question_id": 774}
{"snippet": "bdb.dispatch_return(frame, arg)", "intent": "If the debugger should stop on this function return , invoke the user_return ( ) method ( which should be overridden in subclasses ) . With arguments `frame`, `arg`.", "question_id": 775}
{"snippet": "bdb.dispatch_exception(frame, arg)", "intent": "If the debugger should stop at this exception , invokes the user_exception ( ) method ( which should be overridden in subclasses ) . With arguments `frame`, `arg`.", "question_id": 776}
{"snippet": "bdb.stop_here(frame)", "intent": "This method checks if the `frame` is somewhere below botframe in the call stack .", "question_id": 777}
{"snippet": "bdb.break_here(frame)", "intent": "This method checks if there is a breakpoint in the filename and line belonging to `frame` or , at least , in the current function .", "question_id": 778}
{"snippet": "bdb.break_anywhere(frame)", "intent": "This method checks if there is a breakpoint in the filename of the current `frame` .", "question_id": 779}
{"snippet": "bdb.user_call(frame, argument_list)", "intent": "This method is called from dispatch_call ( ) when there is the possibility that a break might be necessary anywhere inside the called function . With arguments `frame`, `argument_list`.", "question_id": 780}
{"snippet": "bdb.user_line(frame)", "intent": "This method is called from dispatch_line ( ) when either stop_here ( ) or break_here ( ) yields True . With arguments `frame`.", "question_id": 781}
{"snippet": "bdb.user_return(frame, return_value)", "intent": "This method is called from dispatch_return ( ) when stop_here ( ) yields True . With arguments `frame`, `return_value`.", "question_id": 782}
{"snippet": "bdb.user_exception(frame, exc_info)", "intent": "This method is called from dispatch_exception ( ) when stop_here ( ) yields True . With arguments `frame`, `exc_info`.", "question_id": 783}
{"snippet": "bdb.do_clear(arg)", "intent": "Handle how a breakpoint must be removed when it is a temporary one . With arguments `arg`.", "question_id": 784}
{"snippet": "bdb.set_step()", "intent": "Stop after one line of code .", "question_id": 785}
{"snippet": "bdb.set_next(frame)", "intent": "Stop on the next line in or below the given `frame` .", "question_id": 786}
{"snippet": "bdb.set_return(frame)", "intent": "Stop when returning from the given `frame` .", "question_id": 787}
{"snippet": "bdb.set_until(frame)", "intent": "Stop when the line with the line no greater than the current one is reached or when returning from current `frame` .", "question_id": 788}
{"snippet": "bdb.set_trace(frame)", "intent": "Start debugging from `frame` .", "question_id": 789}
{"snippet": "bdb.set_trace()", "intent": "Start debugging from `frame` .", "question_id": 790}
{"snippet": "bdb.set_continue()", "intent": "Stop only at breakpoints or when finished .", "question_id": 791}
{"snippet": "bdb.set_quit()", "intent": "Set the quitting attribute to True .", "question_id": 792}
{"snippet": "bdb.set_break(filename, lineno, cond, funcname)", "intent": "Set a new breakpoint . If the `lineno` line doesn \u2019 t exist for the `filename` passed as argument , return an error message . With arguments `cond`, `funcname`.", "question_id": 793}
{"snippet": "bdb.set_break(filename, lineno, cond, funcname, temporary=0)", "intent": "Set a new breakpoint . If the `lineno` line doesn \u2019 t exist for the `filename` passed as argument , return an error message . With arguments `cond`, `funcname`, `temporary`.", "question_id": 794}
{"snippet": "bdb.clear_break(filename, lineno)", "intent": "Delete the breakpoints in `filename` and `lineno` .", "question_id": 795}
{"snippet": "bdb.clear_bpbynumber(arg)", "intent": "Delete the breakpoint which has the index `arg` in the Breakpoint.bpbynumber .", "question_id": 796}
{"snippet": "bdb.clear_all_file_breaks(filename)", "intent": "Delete all breakpoints in `filename` .", "question_id": 797}
{"snippet": "bdb.clear_all_breaks()", "intent": "Delete all existing breakpoints .", "question_id": 798}
{"snippet": "bdb.get_bpbynumber(arg)", "intent": "Return a breakpoint specified by the given number . If `arg` is a string , it will be converted to a number .", "question_id": 799}
{"snippet": "bdb.get_break(filename, lineno)", "intent": "Check if there is a breakpoint for `lineno` of `filename` .", "question_id": 800}
{"snippet": "bdb.get_breaks(filename, lineno)", "intent": "Return all breakpoints for `lineno` in `filename` , or an empty list if none are set .", "question_id": 801}
{"snippet": "bdb.get_file_breaks(filename)", "intent": "Return all breakpoints in `filename` , or an empty list if none are set .", "question_id": 802}
{"snippet": "bdb.get_all_breaks()", "intent": "Return all breakpoints that are set .", "question_id": 803}
{"snippet": "bdb.get_stack(f, t)", "intent": "Get a list of records for a frame and all higher ( calling ) and lower frames , and the size of the higher part . With arguments `f`, `t`.", "question_id": 804}
{"snippet": "bdb.format_stack_entry(frame_lineno)", "intent": "Return a string with information about a stack entry , identified by a ( frame , lineno ) tuple : With arguments `frame_lineno`.", "question_id": 805}
{"snippet": "bdb.format_stack_entry(frame_lineno, lprefix=': ')", "intent": "Return a string with information about a stack entry , identified by a ( frame , lineno ) tuple : With arguments `frame_lineno`, `lprefix`.", "question_id": 806}
{"snippet": "bdb.run(cmd)", "intent": "Debug a statement executed via the exec ( ) function . With arguments `cmd`.", "question_id": 807}
{"snippet": "bdb.run(cmd, globals=None)", "intent": "Debug a statement executed via the exec ( ) function . `globals` defaults to __main__.__dict__ , `locals` defaults to globals . With arguments `cmd`.", "question_id": 808}
{"snippet": "bdb.run(cmd, locals=None)", "intent": "Debug a statement executed via the exec ( ) function . `globals` defaults to __main__.__dict__ , `locals` defaults to globals . With arguments `cmd`.", "question_id": 809}
{"snippet": "bdb.run(cmd, globals=None, locals=None)", "intent": "Debug a statement executed via the exec ( ) function . `globals` defaults to __main__.__dict__ , `locals` defaults to globals . With arguments `cmd`.", "question_id": 810}
{"snippet": "bdb.runeval(expr)", "intent": "Debug an expression executed via the eval ( ) function . With arguments `expr`.", "question_id": 811}
{"snippet": "bdb.runeval(expr, globals=None)", "intent": "Debug an expression executed via the eval ( ) function . `globals` and `locals` have the same meaning as in run ( ) . With arguments `expr`.", "question_id": 812}
{"snippet": "bdb.runeval(expr, locals=None)", "intent": "Debug an expression executed via the eval ( ) function . `globals` and `locals` have the same meaning as in run ( ) . With arguments `expr`.", "question_id": 813}
{"snippet": "bdb.runeval(expr, globals=None, locals=None)", "intent": "Debug an expression executed via the eval ( ) function . `globals` and `locals` have the same meaning as in run ( ) . With arguments `expr`.", "question_id": 814}
{"snippet": "bdb.runctx(cmd, globals, locals)", "intent": "For backwards compatibility . With arguments `cmd`, `globals`, `locals`.", "question_id": 815}
{"snippet": "bdb.runcall(func, *args, **kwds)", "intent": "Debug a single function call , and return its result . With arguments `func`, `*args`, `**kwds`.", "question_id": 816}
{"snippet": "bdb.checkfuncname(b, frame)", "intent": "Check whether we should break here , depending on the way the breakpoint `b` was set . If it was set via line number , it checks if b.line is the same as the one in the `frame` also passed as argument .", "question_id": 817}
{"snippet": "bdb.effective(file, line, frame)", "intent": "Determine if there is an effective ( active ) breakpoint at this `line` of code . With arguments `file`, `frame`.", "question_id": 818}
{"snippet": "bdb.set_trace()", "intent": "Start debugging with a Bdb instance from caller \u2019 s frame .", "question_id": 819}
{"snippet": "binascii.a2b_uu(string)", "intent": "Convert a single line of uuencoded data back to binary and return the binary data . With arguments `string`.", "question_id": 820}
{"snippet": "binascii.b2a_uu(data)", "intent": "Convert binary `data` to a line of ASCII characters , the return value is the converted line , including a newline char .", "question_id": 821}
{"snippet": "binascii.b2a_uu(data, backtick=False)", "intent": "Convert binary `data` to a line of ASCII characters , the return value is the converted line , including a newline char . If `backtick` is true , zeros are represented by ' ` ' instead of spaces .", "question_id": 822}
{"snippet": "binascii.a2b_base64(string)", "intent": "Convert a block of base64 data back to binary and return the binary data . With arguments `string`.", "question_id": 823}
{"snippet": "binascii.b2a_base64(data)", "intent": "Convert binary `data` to a line of ASCII characters in base64 coding .", "question_id": 824}
{"snippet": "binascii.b2a_base64(data, newline=True)", "intent": "Convert binary `data` to a line of ASCII characters in base64 coding . The return value is the converted line , including a `newline` char if newline is true .", "question_id": 825}
{"snippet": "binascii.a2b_qp(data)", "intent": "Convert a block of quoted-printable `data` back to binary and return the binary data .", "question_id": 826}
{"snippet": "binascii.a2b_qp(data, header=False)", "intent": "Convert a block of quoted-printable `data` back to binary and return the binary data . If the optional argument `header` is present and true , underscores will be decoded as spaces .", "question_id": 827}
{"snippet": "binascii.b2a_qp(data)", "intent": "Convert binary `data` to a line ( s ) of ASCII characters in quoted-printable encoding .", "question_id": 828}
{"snippet": "binascii.b2a_qp(data, quotetabs=False)", "intent": "Convert binary `data` to a line ( s ) of ASCII characters in quoted-printable encoding . If the optional argument `quotetabs` is present and true , all tabs and spaces will be encoded .", "question_id": 829}
{"snippet": "binascii.b2a_qp(data, istext=True)", "intent": "Convert binary `data` to a line ( s ) of ASCII characters in quoted-printable encoding . If the optional argument `istext` is present and true , newlines are not encoded but trailing whitespace will be encoded .", "question_id": 830}
{"snippet": "binascii.b2a_qp(data, header=False)", "intent": "Convert binary `data` to a line ( s ) of ASCII characters in quoted-printable encoding . If the optional argument `header` is present and true , spaces will be encoded as underscores per RFC 1522 .", "question_id": 831}
{"snippet": "binascii.b2a_qp(data, quotetabs=False, istext=True)", "intent": "Convert binary `data` to a line ( s ) of ASCII characters in quoted-printable encoding . If the optional argument `quotetabs` is present and true , all tabs and spaces will be encoded . If the optional argument `istext` is present and true , newlines are not encoded but trailing whitespace will be encoded .", "question_id": 832}
{"snippet": "binascii.b2a_qp(data, quotetabs=False, header=False)", "intent": "Convert binary `data` to a line ( s ) of ASCII characters in quoted-printable encoding . If the optional argument `quotetabs` is present and true , all tabs and spaces will be encoded . If the optional argument `header` is present and true , spaces will be encoded as underscores per RFC 1522 .", "question_id": 833}
{"snippet": "binascii.b2a_qp(data, istext=True, header=False)", "intent": "Convert binary `data` to a line ( s ) of ASCII characters in quoted-printable encoding . If the optional argument `istext` is present and true , newlines are not encoded but trailing whitespace will be encoded . If the optional argument `header` is present and true , spaces will be encoded as underscores per RFC 1522 .", "question_id": 834}
{"snippet": "binascii.b2a_qp(data, quotetabs=False, istext=True, header=False)", "intent": "Convert binary `data` to a line ( s ) of ASCII characters in quoted-printable encoding . If the optional argument `quotetabs` is present and true , all tabs and spaces will be encoded . If the optional argument `istext` is present and true , newlines are not encoded but trailing whitespace will be encoded . If the optional argument `header` is present and true , spaces will be encoded as underscores per RFC 1522 .", "question_id": 835}
{"snippet": "binascii.a2b_hqx(string)", "intent": "Convert binhex4 formatted ASCII data to binary , without doing RLE-decompression . The `string` should contain a complete number of binary bytes , or ( in case of the last portion of the binhex4 data ) have the remaining bits zero .", "question_id": 836}
{"snippet": "binascii.rledecode_hqx(data)", "intent": "Perform RLE-decompression on the `data` , as per the binhex4 standard .", "question_id": 837}
{"snippet": "binascii.rlecode_hqx(data)", "intent": "Perform binhex4 style RLE-compression on `data` and return the result .", "question_id": 838}
{"snippet": "binascii.b2a_hqx(data)", "intent": "Perform hexbin4 binary-to-ASCII translation and return the resulting string . With arguments `data`.", "question_id": 839}
{"snippet": "binascii.crc_hqx(data, value)", "intent": "Compute a 16-bit CRC `value` of `data` , starting with value as the initial CRC , and return the result .", "question_id": 840}
{"snippet": "binascii.crc32(data, value)", "intent": "Compute CRC-32 , the 32-bit checksum of `data` , starting with an initial CRC of `value` .", "question_id": 841}
{"snippet": "binascii.crc32(data)", "intent": "Compute CRC-32 , the 32-bit checksum of `data` , starting with an initial CRC of `value` .", "question_id": 842}
{"snippet": "binascii.b2a_hex(data)", "intent": "Return the hexadecimal representation of the binary `data` .", "question_id": 843}
{"snippet": "binascii.hexlify(data)", "intent": "Return the hexadecimal representation of the binary `data` .", "question_id": 844}
{"snippet": "binascii.a2b_hex(hexstr)", "intent": "Return the binary data represented by the hexadecimal string `hexstr` .", "question_id": 845}
{"snippet": "binascii.unhexlify(hexstr)", "intent": "Return the binary data represented by the hexadecimal string `hexstr` .", "question_id": 846}
{"snippet": "binascii.Error", "intent": "Exception raised on errors.", "question_id": 847}
{"snippet": "binascii.Incomplete", "intent": "Exception raised on incomplete data.", "question_id": 848}
{"snippet": "binhex.binhex(input, output)", "intent": "Convert a binary file with filename `input` to binhex file `output` .", "question_id": 849}
{"snippet": "binhex.hexbin(input, output)", "intent": "Decode a binhex file `input` . The resulting file is written to a file named `output` , unless the argument is None in which case the output filename is read from the binhex file .", "question_id": 850}
{"snippet": "binhex.Error", "intent": "Exception raised when something can\u2019t be encoded using the binhex format (for example, a filename is too long to fit in the filename field), or when input is not properly encoded binhex data.", "question_id": 851}
{"snippet": "bisect.bisect_left(a, x)", "intent": "Locate the insertion point for `x` in `a` to maintain sorted order .", "question_id": 852}
{"snippet": "bisect.bisect_left(a, x, lo=0)", "intent": "Locate the insertion point for `x` in `a` to maintain sorted order . The parameters `lo` and `hi` may be used to specify a subset of the list which should be considered ; by default the entire list is used .", "question_id": 853}
{"snippet": "bisect.bisect_left(a, x, hi=len(a))", "intent": "Locate the insertion point for `x` in `a` to maintain sorted order . The parameters `lo` and `hi` may be used to specify a subset of the list which should be considered ; by default the entire list is used .", "question_id": 854}
{"snippet": "bisect.bisect_left(a, x, lo=0, hi=len(a))", "intent": "Locate the insertion point for `x` in `a` to maintain sorted order . The parameters `lo` and `hi` may be used to specify a subset of the list which should be considered ; by default the entire list is used .", "question_id": 855}
{"snippet": "bisect.bisect_right(a, x)", "intent": "Similar to bisect_left ( ) , but returns an insertion point which comes after ( to the right of ) any existing entries of `x` in `a` .", "question_id": 856}
{"snippet": "bisect.bisect_right(a, x, lo=0)", "intent": "Similar to bisect_left ( ) , but returns an insertion point which comes after ( to the right of ) any existing entries of `x` in `a` . The returned insertion point i partitions the array a into two halves so that all ( val < = x for val in a [ `lo` : i ] ) for the left side and all ( val > x for val in a [ i : `hi` ] ) for the right side .", "question_id": 857}
{"snippet": "bisect.bisect_right(a, x, hi=len(a))", "intent": "Similar to bisect_left ( ) , but returns an insertion point which comes after ( to the right of ) any existing entries of `x` in `a` . The returned insertion point i partitions the array a into two halves so that all ( val < = x for val in a [ `lo` : i ] ) for the left side and all ( val > x for val in a [ i : `hi` ] ) for the right side .", "question_id": 858}
{"snippet": "bisect.bisect_right(a, x, lo=0, hi=len(a))", "intent": "Similar to bisect_left ( ) , but returns an insertion point which comes after ( to the right of ) any existing entries of `x` in `a` . The returned insertion point i partitions the array a into two halves so that all ( val < = x for val in a [ `lo` : i ] ) for the left side and all ( val > x for val in a [ i : `hi` ] ) for the right side .", "question_id": 859}
{"snippet": "bisect.bisect(a, x)", "intent": "Similar to bisect_left ( ) , but returns an insertion point which comes after ( to the right of ) any existing entries of `x` in `a` .", "question_id": 860}
{"snippet": "bisect.bisect(a, x, lo=0)", "intent": "Similar to bisect_left ( ) , but returns an insertion point which comes after ( to the right of ) any existing entries of `x` in `a` . The returned insertion point i partitions the array a into two halves so that all ( val < = x for val in a [ `lo` : i ] ) for the left side and all ( val > x for val in a [ i : `hi` ] ) for the right side .", "question_id": 861}
{"snippet": "bisect.bisect(a, x, hi=len(a))", "intent": "Similar to bisect_left ( ) , but returns an insertion point which comes after ( to the right of ) any existing entries of `x` in `a` . The returned insertion point i partitions the array a into two halves so that all ( val < = x for val in a [ `lo` : i ] ) for the left side and all ( val > x for val in a [ i : `hi` ] ) for the right side .", "question_id": 862}
{"snippet": "bisect.bisect(a, x, lo=0, hi=len(a))", "intent": "Similar to bisect_left ( ) , but returns an insertion point which comes after ( to the right of ) any existing entries of `x` in `a` . The returned insertion point i partitions the array a into two halves so that all ( val < = x for val in a [ `lo` : i ] ) for the left side and all ( val > x for val in a [ i : `hi` ] ) for the right side .", "question_id": 863}
{"snippet": "bisect.insort_left(a, x)", "intent": "Insert `x` in `a` in sorted order .", "question_id": 864}
{"snippet": "bisect.insort_left(a, x, lo=0)", "intent": "Insert `x` in `a` in sorted order . This is equivalent to a.insert ( bisect.bisect_left ( a , x , `lo` , `hi` ) , x ) assuming that a is already sorted .", "question_id": 865}
{"snippet": "bisect.insort_left(a, x, hi=len(a))", "intent": "Insert `x` in `a` in sorted order . This is equivalent to a.insert ( bisect.bisect_left ( a , x , `lo` , `hi` ) , x ) assuming that a is already sorted .", "question_id": 866}
{"snippet": "bisect.insort_left(a, x, lo=0, hi=len(a))", "intent": "Insert `x` in `a` in sorted order . This is equivalent to a.insert ( bisect.bisect_left ( a , x , `lo` , `hi` ) , x ) assuming that a is already sorted .", "question_id": 867}
{"snippet": "bisect.insort_right(a, x)", "intent": "Similar to insort_left ( ) , but inserting `x` in `a` after any existing entries of x .", "question_id": 868}
{"snippet": "bisect.insort_right(a, x, lo=0)", "intent": "Similar to insort_left ( ) , but inserting `x` in `a` after any existing entries of x . With arguments `lo`.", "question_id": 869}
{"snippet": "bisect.insort_right(a, x, hi=len(a))", "intent": "Similar to insort_left ( ) , but inserting `x` in `a` after any existing entries of x . With arguments `hi`.", "question_id": 870}
{"snippet": "bisect.insort_right(a, x, lo=0, hi=len(a))", "intent": "Similar to insort_left ( ) , but inserting `x` in `a` after any existing entries of x . With arguments `lo`, `hi`.", "question_id": 871}
{"snippet": "bisect.insort(a, x)", "intent": "Similar to insort_left ( ) , but inserting `x` in `a` after any existing entries of x .", "question_id": 872}
{"snippet": "bisect.insort(a, x, lo=0)", "intent": "Similar to insort_left ( ) , but inserting `x` in `a` after any existing entries of x . With arguments `lo`.", "question_id": 873}
{"snippet": "bisect.insort(a, x, hi=len(a))", "intent": "Similar to insort_left ( ) , but inserting `x` in `a` after any existing entries of x . With arguments `hi`.", "question_id": 874}
{"snippet": "bisect.insort(a, x, lo=0, hi=len(a))", "intent": "Similar to insort_left ( ) , but inserting `x` in `a` after any existing entries of x . With arguments `lo`, `hi`.", "question_id": 875}
{"snippet": "bz2.open(filename)", "intent": "Open a bzip2-compressed file in binary or text `mode` , returning a file object . As with the constructor for BZ2File , the `filename` argument can be an actual filename ( a str or bytes object ) , or an existing file object to read from or write to .", "question_id": 876}
{"snippet": "bz2.open(filename, mode='r')", "intent": "Open a bzip2-compressed file in binary or text `mode` , returning a file object . As with the constructor for BZ2File , the `filename` argument can be an actual filename ( a str or bytes object ) , or an existing file object to read from or write to .", "question_id": 877}
{"snippet": "bz2.open(filename, compresslevel=9)", "intent": "Open a bzip2-compressed file in binary or text `mode` , returning a file object . As with the constructor for BZ2File , the `filename` argument can be an actual filename ( a str or bytes object ) , or an existing file object to read from or write to . The `compresslevel` argument is an integer from 1 to 9 , as for the BZ2File constructor .", "question_id": 878}
{"snippet": "bz2.open(filename, encoding=None)", "intent": "Open a bzip2-compressed file in binary or text `mode` , returning a file object . As with the constructor for BZ2File , the `filename` argument can be an actual filename ( a str or bytes object ) , or an existing file object to read from or write to . In this case , the `encoding` , `errors` and `newline` arguments must not be provided .", "question_id": 879}
{"snippet": "bz2.open(filename, errors=None)", "intent": "Open a bzip2-compressed file in binary or text `mode` , returning a file object . As with the constructor for BZ2File , the `filename` argument can be an actual filename ( a str or bytes object ) , or an existing file object to read from or write to . In this case , the `encoding` , `errors` and `newline` arguments must not be provided .", "question_id": 880}
{"snippet": "bz2.open(filename, newline=None)", "intent": "Open a bzip2-compressed file in binary or text `mode` , returning a file object . As with the constructor for BZ2File , the `filename` argument can be an actual filename ( a str or bytes object ) , or an existing file object to read from or write to . In this case , the `encoding` , `errors` and `newline` arguments must not be provided .", "question_id": 881}
{"snippet": "bz2.open(filename, mode='r', compresslevel=9)", "intent": "Open a bzip2-compressed file in binary or text `mode` , returning a file object . As with the constructor for BZ2File , the `filename` argument can be an actual filename ( a str or bytes object ) , or an existing file object to read from or write to . The `compresslevel` argument is an integer from 1 to 9 , as for the BZ2File constructor .", "question_id": 882}
{"snippet": "bz2.open(filename, mode='r', encoding=None)", "intent": "Open a bzip2-compressed file in binary or text `mode` , returning a file object . As with the constructor for BZ2File , the `filename` argument can be an actual filename ( a str or bytes object ) , or an existing file object to read from or write to . In this case , the `encoding` , `errors` and `newline` arguments must not be provided .", "question_id": 883}
{"snippet": "bz2.open(filename, mode='r', errors=None)", "intent": "Open a bzip2-compressed file in binary or text `mode` , returning a file object . As with the constructor for BZ2File , the `filename` argument can be an actual filename ( a str or bytes object ) , or an existing file object to read from or write to . In this case , the `encoding` , `errors` and `newline` arguments must not be provided .", "question_id": 884}
{"snippet": "bz2.open(filename, mode='r', newline=None)", "intent": "Open a bzip2-compressed file in binary or text `mode` , returning a file object . As with the constructor for BZ2File , the `filename` argument can be an actual filename ( a str or bytes object ) , or an existing file object to read from or write to . In this case , the `encoding` , `errors` and `newline` arguments must not be provided .", "question_id": 885}
{"snippet": "bz2.BZ2File(filename)", "intent": "Open a bzip2-compressed file in binary `mode` . If `filename` is a str or bytes object , open the named file directly .", "question_id": 886}
{"snippet": "bz2.BZ2File(filename, mode='r')", "intent": "Open a bzip2-compressed file in binary `mode` . If `filename` is a str or bytes object , open the named file directly .", "question_id": 887}
{"snippet": "bz2.BZ2File(filename, buffering=None)", "intent": "Open a bzip2-compressed file in binary `mode` . If `filename` is a str or bytes object , open the named file directly . The `buffering` argument is ignored .", "question_id": 888}
{"snippet": "bz2.BZ2File(filename, compresslevel=9)", "intent": "Open a bzip2-compressed file in binary `mode` . If `filename` is a str or bytes object , open the named file directly . If mode is ' w ' or ' a ' , `compresslevel` can be an integer between 1 and 9 specifying the level of compression : 1 produces the least compression , and 9 ( default ) produces the most compression .", "question_id": 889}
{"snippet": "bz2.BZ2File(filename, mode='r', buffering=None)", "intent": "Open a bzip2-compressed file in binary `mode` . If `filename` is a str or bytes object , open the named file directly . The `buffering` argument is ignored .", "question_id": 890}
{"snippet": "bz2.BZ2File(filename, mode='r', compresslevel=9)", "intent": "Open a bzip2-compressed file in binary `mode` . If `filename` is a str or bytes object , open the named file directly . If mode is ' w ' or ' a ' , `compresslevel` can be an integer between 1 and 9 specifying the level of compression : 1 produces the least compression , and 9 ( default ) produces the most compression .", "question_id": 891}
{"snippet": "bz2.BZ2File(filename, buffering=None, compresslevel=9)", "intent": "Open a bzip2-compressed file in binary `mode` . If `filename` is a str or bytes object , open the named file directly . The `buffering` argument is ignored . If mode is ' w ' or ' a ' , `compresslevel` can be an integer between 1 and 9 specifying the level of compression : 1 produces the least compression , and 9 ( default ) produces the most compression .", "question_id": 892}
{"snippet": "bz2.BZ2File(filename, mode='r', buffering=None, compresslevel=9)", "intent": "Open a bzip2-compressed file in binary `mode` . If `filename` is a str or bytes object , open the named file directly . The `buffering` argument is ignored . If mode is ' w ' or ' a ' , `compresslevel` can be an integer between 1 and 9 specifying the level of compression : 1 produces the least compression , and 9 ( default ) produces the most compression .", "question_id": 893}
{"snippet": "bz2_file.peek(n)", "intent": "Return buffered data without advancing the file position . With arguments `n`.", "question_id": 894}
{"snippet": "bz2_file.peek()", "intent": "Return buffered data without advancing the file position .", "question_id": 895}
{"snippet": "bz2.BZ2Compressor()", "intent": "Create a new compressor object .", "question_id": 896}
{"snippet": "bz2.BZ2Compressor(compresslevel=9)", "intent": "Create a new compressor object . `compresslevel` , if given , must be an integer between 1 and 9 .", "question_id": 897}
{"snippet": "bz2_compressor.compress(data)", "intent": "Provide `data` to the compressor object .", "question_id": 898}
{"snippet": "bz2_compressor.flush()", "intent": "Finish the compression process .", "question_id": 899}
{"snippet": "bz2.BZ2Decompressor", "intent": "Create a new decompressor object.", "question_id": 900}
{"snippet": "bz2_decompressor.decompress(data)", "intent": "Decompress `data` ( a bytes-like object ) , returning uncompressed data as bytes .", "question_id": 901}
{"snippet": "bz2_decompressor.decompress(data, max_length=-1)", "intent": "Decompress `data` ( a bytes-like object ) , returning uncompressed data as bytes . If `max_length` is nonnegative , returns at most max_length bytes of decompressed data .", "question_id": 902}
{"snippet": "bz2_decompressor.eof", "intent": "True if the end-of-stream marker has been reached.", "question_id": 903}
{"snippet": "bz2_decompressor.unused_data", "intent": "Data found after the end of the compressed stream.", "question_id": 904}
{"snippet": "bz2_decompressor.needs_input", "intent": "False if the decompress() method can provide more decompressed data before requiring new uncompressed input.", "question_id": 905}
{"snippet": "bz2.compress(data)", "intent": "Compress `data` , a bytes-like object .", "question_id": 906}
{"snippet": "bz2.compress(data, compresslevel=9)", "intent": "Compress `data` , a bytes-like object . `compresslevel` , if given , must be an integer between 1 and 9 .", "question_id": 907}
{"snippet": "bz2.decompress(data)", "intent": "Decompress `data` , a bytes-like object .", "question_id": 908}
{"snippet": "calendar.Calendar()", "intent": "Creates a Calendar object .", "question_id": 909}
{"snippet": "calendar.Calendar(firstweekday=0)", "intent": "Creates a Calendar object . `firstweekday` is an integer specifying the first day of the week .", "question_id": 910}
{"snippet": "calendar.iterweekdays()", "intent": "Return an iterator for the week day numbers that will be used for one week .", "question_id": 911}
{"snippet": "calendar.itermonthdates(year, month)", "intent": "Return an iterator for the `month` month ( 1\u201312 ) in the `year` year .", "question_id": 912}
{"snippet": "calendar.itermonthdays(year, month)", "intent": "Return an iterator for the `month` month in the `year` year similar to itermonthdates ( ) , but not restricted by the datetime.date range .", "question_id": 913}
{"snippet": "calendar.itermonthdays2(year, month)", "intent": "Return an iterator for the `month` month in the `year` year similar to itermonthdates ( ) , but not restricted by the datetime.date range .", "question_id": 914}
{"snippet": "calendar.itermonthdays3(year, month)", "intent": "Return an iterator for the `month` month in the `year` year similar to itermonthdates ( ) , but not restricted by the datetime.date range .", "question_id": 915}
{"snippet": "calendar.itermonthdays4(year, month)", "intent": "Return an iterator for the `month` month in the `year` year similar to itermonthdates ( ) , but not restricted by the datetime.date range .", "question_id": 916}
{"snippet": "calendar.monthdatescalendar(year, month)", "intent": "Return a list of the weeks in the `month` month of the `year` as full weeks .", "question_id": 917}
{"snippet": "calendar.monthdays2calendar(year, month)", "intent": "Return a list of the weeks in the `month` month of the `year` as full weeks .", "question_id": 918}
{"snippet": "calendar.monthdayscalendar(year, month)", "intent": "Return a list of the weeks in the `month` month of the `year` as full weeks .", "question_id": 919}
{"snippet": "calendar.yeardatescalendar(year)", "intent": "Return the data for the specified `year` ready for formatting .", "question_id": 920}
{"snippet": "calendar.yeardatescalendar(year, width=3)", "intent": "Return the data for the specified `year` ready for formatting . Each month row contains up to `width` months ( defaulting to 3 ) .", "question_id": 921}
{"snippet": "calendar.yeardays2calendar(year)", "intent": "Return the data for the specified `year` ready for formatting ( similar to yeardatescalendar ( ) ) .", "question_id": 922}
{"snippet": "calendar.yeardays2calendar(year, width=3)", "intent": "Return the data for the specified `year` ready for formatting ( similar to yeardatescalendar ( ) ) . With arguments `width`.", "question_id": 923}
{"snippet": "calendar.yeardayscalendar(year)", "intent": "Return the data for the specified `year` ready for formatting ( similar to yeardatescalendar ( ) ) .", "question_id": 924}
{"snippet": "calendar.yeardayscalendar(year, width=3)", "intent": "Return the data for the specified `year` ready for formatting ( similar to yeardatescalendar ( ) ) . With arguments `width`.", "question_id": 925}
{"snippet": "calendar.TextCalendar()", "intent": "This class can be used to generate plain text calendars .", "question_id": 926}
{"snippet": "calendar.TextCalendar(firstweekday=0)", "intent": "This class can be used to generate plain text calendars . With arguments `firstweekday`.", "question_id": 927}
{"snippet": "text_calendar.formatmonth(theyear, themonth)", "intent": "Return a month \u2019 s calendar in a multi-line string . With arguments `theyear`, `themonth`.", "question_id": 928}
{"snippet": "text_calendar.formatmonth(theyear, themonth, w=0)", "intent": "Return a month \u2019 s calendar in a multi-line string . If `w` is provided , it specifies the width of the date columns , which are centered . With arguments `theyear`, `themonth`.", "question_id": 929}
{"snippet": "text_calendar.formatmonth(theyear, themonth, l=0)", "intent": "Return a month \u2019 s calendar in a multi-line string . If `l` is given , it specifies the number of lines that each week will use . With arguments `theyear`, `themonth`.", "question_id": 930}
{"snippet": "text_calendar.formatmonth(theyear, themonth, w=0, l=0)", "intent": "Return a month \u2019 s calendar in a multi-line string . If `w` is provided , it specifies the width of the date columns , which are centered . If `l` is given , it specifies the number of lines that each week will use . With arguments `theyear`, `themonth`.", "question_id": 931}
{"snippet": "text_calendar.prmonth(theyear, themonth)", "intent": "Print a month \u2019 s calendar as returned by formatmonth ( ) . With arguments `theyear`, `themonth`.", "question_id": 932}
{"snippet": "text_calendar.prmonth(theyear, themonth, w=0)", "intent": "Print a month \u2019 s calendar as returned by formatmonth ( ) . With arguments `theyear`, `themonth`, `w`.", "question_id": 933}
{"snippet": "text_calendar.prmonth(theyear, themonth, l=0)", "intent": "Print a month \u2019 s calendar as returned by formatmonth ( ) . With arguments `theyear`, `themonth`, `l`.", "question_id": 934}
{"snippet": "text_calendar.prmonth(theyear, themonth, w=0, l=0)", "intent": "Print a month \u2019 s calendar as returned by formatmonth ( ) . With arguments `theyear`, `themonth`, `w`, `l`.", "question_id": 935}
{"snippet": "text_calendar.formatyear(theyear)", "intent": "Return a m-column calendar for an entire year as a multi-line string . With arguments `theyear`.", "question_id": 936}
{"snippet": "text_calendar.formatyear(theyear, w=2)", "intent": "Return a m-column calendar for an entire year as a multi-line string . Optional parameters `w` , `l` , and `c` are for date column width , lines per week , and number of spaces between month columns , respectively . With arguments `theyear`.", "question_id": 937}
{"snippet": "text_calendar.formatyear(theyear, l=1)", "intent": "Return a m-column calendar for an entire year as a multi-line string . Optional parameters `w` , `l` , and `c` are for date column width , lines per week , and number of spaces between month columns , respectively . With arguments `theyear`.", "question_id": 938}
{"snippet": "text_calendar.formatyear(theyear, c=6)", "intent": "Return a m-column calendar for an entire year as a multi-line string . Optional parameters `w` , `l` , and `c` are for date column width , lines per week , and number of spaces between month columns , respectively . With arguments `theyear`.", "question_id": 939}
{"snippet": "text_calendar.formatyear(theyear, m=3)", "intent": "Return a m-column calendar for an entire year as a multi-line string . With arguments `theyear`, `m`.", "question_id": 940}
{"snippet": "text_calendar.formatyear(theyear, w=2, l=1)", "intent": "Return a m-column calendar for an entire year as a multi-line string . Optional parameters `w` , `l` , and `c` are for date column width , lines per week , and number of spaces between month columns , respectively . With arguments `theyear`.", "question_id": 941}
{"snippet": "text_calendar.formatyear(theyear, w=2, c=6)", "intent": "Return a m-column calendar for an entire year as a multi-line string . Optional parameters `w` , `l` , and `c` are for date column width , lines per week , and number of spaces between month columns , respectively . With arguments `theyear`.", "question_id": 942}
{"snippet": "text_calendar.formatyear(theyear, w=2, m=3)", "intent": "Return a m-column calendar for an entire year as a multi-line string . Optional parameters `w` , `l` , and `c` are for date column width , lines per week , and number of spaces between month columns , respectively . With arguments `theyear`, `m`.", "question_id": 943}
{"snippet": "text_calendar.formatyear(theyear, l=1, c=6)", "intent": "Return a m-column calendar for an entire year as a multi-line string . Optional parameters `w` , `l` , and `c` are for date column width , lines per week , and number of spaces between month columns , respectively . With arguments `theyear`.", "question_id": 944}
{"snippet": "text_calendar.formatyear(theyear, l=1, m=3)", "intent": "Return a m-column calendar for an entire year as a multi-line string . Optional parameters `w` , `l` , and `c` are for date column width , lines per week , and number of spaces between month columns , respectively . With arguments `theyear`, `m`.", "question_id": 945}
{"snippet": "text_calendar.pryear(theyear)", "intent": "Print the calendar for an entire year as returned by formatyear ( ) . With arguments `theyear`.", "question_id": 946}
{"snippet": "text_calendar.pryear(theyear, w=2)", "intent": "Print the calendar for an entire year as returned by formatyear ( ) . With arguments `theyear`, `w`.", "question_id": 947}
{"snippet": "text_calendar.pryear(theyear, l=1)", "intent": "Print the calendar for an entire year as returned by formatyear ( ) . With arguments `theyear`, `l`.", "question_id": 948}
{"snippet": "text_calendar.pryear(theyear, c=6)", "intent": "Print the calendar for an entire year as returned by formatyear ( ) . With arguments `theyear`, `c`.", "question_id": 949}
{"snippet": "text_calendar.pryear(theyear, m=3)", "intent": "Print the calendar for an entire year as returned by formatyear ( ) . With arguments `theyear`, `m`.", "question_id": 950}
{"snippet": "text_calendar.pryear(theyear, w=2, l=1)", "intent": "Print the calendar for an entire year as returned by formatyear ( ) . With arguments `theyear`, `w`, `l`.", "question_id": 951}
{"snippet": "text_calendar.pryear(theyear, w=2, c=6)", "intent": "Print the calendar for an entire year as returned by formatyear ( ) . With arguments `theyear`, `w`, `c`.", "question_id": 952}
{"snippet": "text_calendar.pryear(theyear, w=2, m=3)", "intent": "Print the calendar for an entire year as returned by formatyear ( ) . With arguments `theyear`, `w`, `m`.", "question_id": 953}
{"snippet": "text_calendar.pryear(theyear, l=1, c=6)", "intent": "Print the calendar for an entire year as returned by formatyear ( ) . With arguments `theyear`, `l`, `c`.", "question_id": 954}
{"snippet": "text_calendar.pryear(theyear, l=1, m=3)", "intent": "Print the calendar for an entire year as returned by formatyear ( ) . With arguments `theyear`, `l`, `m`.", "question_id": 955}
{"snippet": "calendar.HTMLCalendar()", "intent": "This class can be used to generate HTML calendars .", "question_id": 956}
{"snippet": "calendar.HTMLCalendar(firstweekday=0)", "intent": "This class can be used to generate HTML calendars . With arguments `firstweekday`.", "question_id": 957}
{"snippet": "html_calendar.formatmonth(theyear, themonth)", "intent": "Return a month \u2019 s calendar as an HTML table . With arguments `theyear`, `themonth`.", "question_id": 958}
{"snippet": "html_calendar.formatmonth(theyear, themonth, withyear=True)", "intent": "Return a month \u2019 s calendar as an HTML table . If `withyear` is true the year will be included in the header , otherwise just the month name will be used . With arguments `theyear`, `themonth`.", "question_id": 959}
{"snippet": "html_calendar.formatyear(theyear)", "intent": "Return a year \u2019 s calendar as an HTML table . With arguments `theyear`.", "question_id": 960}
{"snippet": "html_calendar.formatyear(theyear, width=3)", "intent": "Return a year \u2019 s calendar as an HTML table . `width` ( defaulting to 3 ) specifies the number of months per row . With arguments `theyear`.", "question_id": 961}
{"snippet": "html_calendar.formatyearpage(theyear)", "intent": "Return a year \u2019 s calendar as a complete HTML page . With arguments `theyear`.", "question_id": 962}
{"snippet": "html_calendar.formatyearpage(theyear, width=3)", "intent": "Return a year \u2019 s calendar as a complete HTML page . `width` ( defaulting to 3 ) specifies the number of months per row . With arguments `theyear`.", "question_id": 963}
{"snippet": "html_calendar.formatyearpage(theyear, css='calendar.css')", "intent": "Return a year \u2019 s calendar as a complete HTML page . `css` is the name for the cascading style sheet to be used . With arguments `theyear`.", "question_id": 964}
{"snippet": "html_calendar.formatyearpage(theyear, encoding=None)", "intent": "Return a year \u2019 s calendar as a complete HTML page . `encoding` specifies the encoding to be used for the output ( defaulting to the system default encoding ) . With arguments `theyear`.", "question_id": 965}
{"snippet": "html_calendar.formatyearpage(theyear, width=3, css='calendar.css')", "intent": "Return a year \u2019 s calendar as a complete HTML page . `width` ( defaulting to 3 ) specifies the number of months per row . `css` is the name for the cascading style sheet to be used . With arguments `theyear`.", "question_id": 966}
{"snippet": "html_calendar.formatyearpage(theyear, width=3, encoding=None)", "intent": "Return a year \u2019 s calendar as a complete HTML page . `width` ( defaulting to 3 ) specifies the number of months per row . `encoding` specifies the encoding to be used for the output ( defaulting to the system default encoding ) . With arguments `theyear`.", "question_id": 967}
{"snippet": "html_calendar.formatyearpage(theyear, css='calendar.css', encoding=None)", "intent": "Return a year \u2019 s calendar as a complete HTML page . `css` is the name for the cascading style sheet to be used . `encoding` specifies the encoding to be used for the output ( defaulting to the system default encoding ) . With arguments `theyear`.", "question_id": 968}
{"snippet": "html_calendar.formatyearpage(theyear, width=3, css='calendar.css', encoding=None)", "intent": "Return a year \u2019 s calendar as a complete HTML page . `width` ( defaulting to 3 ) specifies the number of months per row . `css` is the name for the cascading style sheet to be used . `encoding` specifies the encoding to be used for the output ( defaulting to the system default encoding ) . With arguments `theyear`.", "question_id": 969}
{"snippet": "html_calendar.cssclasses", "intent": "A list of CSS classes used for each weekday.", "question_id": 970}
{"snippet": "html_calendar.cssclass_noday", "intent": "The CSS class for a weekday occurring in the previous or coming month.", "question_id": 971}
{"snippet": "html_calendar.cssclasses_weekday_head", "intent": "A list of CSS classes used for weekday names in the header row.", "question_id": 972}
{"snippet": "html_calendar.cssclass_month_head", "intent": "The month\u2019s head CSS class (used by formatmonthname()).", "question_id": 973}
{"snippet": "html_calendar.cssclass_month", "intent": "The CSS class for the whole month\u2019s table (used by formatmonth()).", "question_id": 974}
{"snippet": "html_calendar.cssclass_year", "intent": "The CSS class for the whole year\u2019s table of tables (used by formatyear()).", "question_id": 975}
{"snippet": "html_calendar.cssclass_year_head", "intent": "The CSS class for the table head for the whole year (used by formatyear()).", "question_id": 976}
{"snippet": "calendar.LocaleTextCalendar()", "intent": "This subclass of TextCalendar can be passed a `locale` name in the constructor and will return month and weekday names in the specified locale .", "question_id": 977}
{"snippet": "calendar.LocaleTextCalendar(firstweekday=0)", "intent": "This subclass of TextCalendar can be passed a `locale` name in the constructor and will return month and weekday names in the specified locale . With arguments `firstweekday`.", "question_id": 978}
{"snippet": "calendar.LocaleTextCalendar(locale=None)", "intent": "This subclass of TextCalendar can be passed a `locale` name in the constructor and will return month and weekday names in the specified locale .", "question_id": 979}
{"snippet": "calendar.LocaleTextCalendar(firstweekday=0, locale=None)", "intent": "This subclass of TextCalendar can be passed a `locale` name in the constructor and will return month and weekday names in the specified locale . With arguments `firstweekday`.", "question_id": 980}
{"snippet": "calendar.LocaleHTMLCalendar()", "intent": "This subclass of HTMLCalendar can be passed a `locale` name in the constructor and will return month and weekday names in the specified locale .", "question_id": 981}
{"snippet": "calendar.LocaleHTMLCalendar(firstweekday=0)", "intent": "This subclass of HTMLCalendar can be passed a `locale` name in the constructor and will return month and weekday names in the specified locale . With arguments `firstweekday`.", "question_id": 982}
{"snippet": "calendar.LocaleHTMLCalendar(locale=None)", "intent": "This subclass of HTMLCalendar can be passed a `locale` name in the constructor and will return month and weekday names in the specified locale .", "question_id": 983}
{"snippet": "calendar.LocaleHTMLCalendar(firstweekday=0, locale=None)", "intent": "This subclass of HTMLCalendar can be passed a `locale` name in the constructor and will return month and weekday names in the specified locale . With arguments `firstweekday`.", "question_id": 984}
{"snippet": "calendar.setfirstweekday(weekday)", "intent": "Sets the `weekday` ( 0 is Monday , 6 is Sunday ) to start each week .", "question_id": 985}
{"snippet": "calendar.firstweekday()", "intent": "Returns the current setting for the weekday to start each week .", "question_id": 986}
{"snippet": "calendar.isleap(year)", "intent": "Returns True if `year` is a leap year , otherwise False .", "question_id": 987}
{"snippet": "calendar.leapdays(y1, y2)", "intent": "Returns the number of leap years in the range from `y1` to `y2` ( exclusive ) , where y1 and y2 are years .", "question_id": 988}
{"snippet": "calendar.weekday(year, month, day)", "intent": "Returns the `day` of the week ( 0 is Monday ) for `year` ( 1970\u2013\u2026 ) , `month` ( 1\u201312 ) , day ( 1\u201331 ) .", "question_id": 989}
{"snippet": "calendar.weekheader(n)", "intent": "Return a header containing abbreviated weekday names . `n` specifies the width in characters for one weekday .", "question_id": 990}
{"snippet": "calendar.monthrange(year, month)", "intent": "Returns weekday of first day of the `month` and number of days in month , for the specified `year` and month .", "question_id": 991}
{"snippet": "calendar.monthcalendar(year, month)", "intent": "Returns a matrix representing a `month` \u2019 s calendar . With arguments `year`.", "question_id": 992}
{"snippet": "calendar.prmonth(theyear, themonth)", "intent": "Prints a month \u2019 s calendar as returned by month ( ) . With arguments `theyear`, `themonth`.", "question_id": 993}
{"snippet": "calendar.prmonth(theyear, themonth, w=0)", "intent": "Prints a month \u2019 s calendar as returned by month ( ) . With arguments `theyear`, `themonth`, `w`.", "question_id": 994}
{"snippet": "calendar.prmonth(theyear, themonth, l=0)", "intent": "Prints a month \u2019 s calendar as returned by month ( ) . With arguments `theyear`, `themonth`, `l`.", "question_id": 995}
{"snippet": "calendar.prmonth(theyear, themonth, w=0, l=0)", "intent": "Prints a month \u2019 s calendar as returned by month ( ) . With arguments `theyear`, `themonth`, `w`, `l`.", "question_id": 996}
{"snippet": "calendar.month(theyear, themonth)", "intent": "Returns a month \u2019 s calendar in a multi-line string using the formatmonth ( ) of the TextCalendar class . With arguments `theyear`, `themonth`.", "question_id": 997}
{"snippet": "calendar.month(theyear, themonth, w=0)", "intent": "Returns a month \u2019 s calendar in a multi-line string using the formatmonth ( ) of the TextCalendar class . With arguments `theyear`, `themonth`, `w`.", "question_id": 998}
{"snippet": "calendar.month(theyear, themonth, l=0)", "intent": "Returns a month \u2019 s calendar in a multi-line string using the formatmonth ( ) of the TextCalendar class . With arguments `theyear`, `themonth`, `l`.", "question_id": 999}
{"snippet": "calendar.month(theyear, themonth, w=0, l=0)", "intent": "Returns a month \u2019 s calendar in a multi-line string using the formatmonth ( ) of the TextCalendar class . With arguments `theyear`, `themonth`, `w`, `l`.", "question_id": 1000}
{"snippet": "calendar.prcal(year)", "intent": "Prints the calendar for an entire `year` as returned by calendar ( ) .", "question_id": 1001}
{"snippet": "calendar.prcal(year, w=0)", "intent": "Prints the calendar for an entire `year` as returned by calendar ( ) . With arguments `w`.", "question_id": 1002}
{"snippet": "calendar.prcal(year, l=0)", "intent": "Prints the calendar for an entire `year` as returned by calendar ( ) . With arguments `l`.", "question_id": 1003}
{"snippet": "calendar.prcal(year, c=6)", "intent": "Prints the calendar for an entire `year` as returned by calendar ( ) . With arguments `c`.", "question_id": 1004}
{"snippet": "calendar.prcal(year, m=3)", "intent": "Prints the calendar for an entire `year` as returned by calendar ( ) . With arguments `m`.", "question_id": 1005}
{"snippet": "calendar.prcal(year, w=0, l=0)", "intent": "Prints the calendar for an entire `year` as returned by calendar ( ) . With arguments `w`, `l`.", "question_id": 1006}
{"snippet": "calendar.prcal(year, w=0, c=6)", "intent": "Prints the calendar for an entire `year` as returned by calendar ( ) . With arguments `w`, `c`.", "question_id": 1007}
{"snippet": "calendar.prcal(year, w=0, m=3)", "intent": "Prints the calendar for an entire `year` as returned by calendar ( ) . With arguments `w`, `m`.", "question_id": 1008}
{"snippet": "calendar.prcal(year, l=0, c=6)", "intent": "Prints the calendar for an entire `year` as returned by calendar ( ) . With arguments `l`, `c`.", "question_id": 1009}
{"snippet": "calendar.prcal(year, l=0, m=3)", "intent": "Prints the calendar for an entire `year` as returned by calendar ( ) . With arguments `l`, `m`.", "question_id": 1010}
{"snippet": "calendar.calendar(year)", "intent": "Returns a 3-column calendar for an entire `year` as a multi-line string using the formatyear ( ) of the TextCalendar class .", "question_id": 1011}
{"snippet": "calendar.calendar(year, w=2)", "intent": "Returns a 3-column calendar for an entire `year` as a multi-line string using the formatyear ( ) of the TextCalendar class . With arguments `w`.", "question_id": 1012}
{"snippet": "calendar.calendar(year, l=1)", "intent": "Returns a 3-column calendar for an entire `year` as a multi-line string using the formatyear ( ) of the TextCalendar class . With arguments `l`.", "question_id": 1013}
{"snippet": "calendar.calendar(year, c=6)", "intent": "Returns a 3-column calendar for an entire `year` as a multi-line string using the formatyear ( ) of the TextCalendar class . With arguments `c`.", "question_id": 1014}
{"snippet": "calendar.calendar(year, m=3)", "intent": "Returns a 3-column calendar for an entire `year` as a multi-line string using the formatyear ( ) of the TextCalendar class . With arguments `m`.", "question_id": 1015}
{"snippet": "calendar.calendar(year, w=2, l=1)", "intent": "Returns a 3-column calendar for an entire `year` as a multi-line string using the formatyear ( ) of the TextCalendar class . With arguments `w`, `l`.", "question_id": 1016}
{"snippet": "calendar.calendar(year, w=2, c=6)", "intent": "Returns a 3-column calendar for an entire `year` as a multi-line string using the formatyear ( ) of the TextCalendar class . With arguments `w`, `c`.", "question_id": 1017}
{"snippet": "calendar.calendar(year, w=2, m=3)", "intent": "Returns a 3-column calendar for an entire `year` as a multi-line string using the formatyear ( ) of the TextCalendar class . With arguments `w`, `m`.", "question_id": 1018}
{"snippet": "calendar.calendar(year, l=1, c=6)", "intent": "Returns a 3-column calendar for an entire `year` as a multi-line string using the formatyear ( ) of the TextCalendar class . With arguments `l`, `c`.", "question_id": 1019}
{"snippet": "calendar.calendar(year, l=1, m=3)", "intent": "Returns a 3-column calendar for an entire `year` as a multi-line string using the formatyear ( ) of the TextCalendar class . With arguments `l`, `m`.", "question_id": 1020}
{"snippet": "calendar.timegm(tuple)", "intent": "An unrelated but handy function that takes a time `tuple` such as returned by the gmtime ( ) function in the time module , and returns the corresponding Unix timestamp value , assuming an epoch of 1970 , and the POSIX encoding .", "question_id": 1021}
{"snippet": "calendar.day_name", "intent": "An array that represents the days of the week in the current locale.", "question_id": 1022}
{"snippet": "calendar.day_abbr", "intent": "An array that represents the abbreviated days of the week in the current locale.", "question_id": 1023}
{"snippet": "calendar.month_name", "intent": "An array that represents the months of the year in the current locale.", "question_id": 1024}
{"snippet": "calendar.month_abbr", "intent": "An array that represents the abbreviated months of the year in the current locale.", "question_id": 1025}
{"snippet": "FieldStorage.getfirst(name)", "intent": "This method always returns only one value associated with form field `name` .", "question_id": 1026}
{"snippet": "FieldStorage.getfirst(name, default=None)", "intent": "This method always returns only one value associated with form field `name` . 1 If no such form field or value exists then the method returns the value specified by the optional parameter `default` .", "question_id": 1027}
{"snippet": "FieldStorage.getlist(name)", "intent": "This method always returns a list of values associated with form field `name` .", "question_id": 1028}
{"snippet": "cgi.parse()", "intent": "Parse a query in the environment or from a file ( the file defaults to sys.stdin ) .", "question_id": 1029}
{"snippet": "cgi.parse(fp=None)", "intent": "Parse a query in the environment or from a file ( the file defaults to sys.stdin ) . With arguments `fp`.", "question_id": 1030}
{"snippet": "cgi.parse(environ=os.environ)", "intent": "Parse a query in the environment or from a file ( the file defaults to sys.stdin ) . With arguments `environ`.", "question_id": 1031}
{"snippet": "cgi.parse(keep_blank_values=False)", "intent": "Parse a query in the environment or from a file ( the file defaults to sys.stdin ) . The `keep_blank_values` and `strict_parsing` parameters are passed to urllib.parse.parse_qs ( ) unchanged .", "question_id": 1032}
{"snippet": "cgi.parse(strict_parsing=False)", "intent": "Parse a query in the environment or from a file ( the file defaults to sys.stdin ) . The `keep_blank_values` and `strict_parsing` parameters are passed to urllib.parse.parse_qs ( ) unchanged .", "question_id": 1033}
{"snippet": "cgi.parse(fp=None, environ=os.environ)", "intent": "Parse a query in the environment or from a file ( the file defaults to sys.stdin ) . With arguments `fp`, `environ`.", "question_id": 1034}
{"snippet": "cgi.parse(fp=None, keep_blank_values=False)", "intent": "Parse a query in the environment or from a file ( the file defaults to sys.stdin ) . The `keep_blank_values` and `strict_parsing` parameters are passed to urllib.parse.parse_qs ( ) unchanged . With arguments `fp`.", "question_id": 1035}
{"snippet": "cgi.parse(fp=None, strict_parsing=False)", "intent": "Parse a query in the environment or from a file ( the file defaults to sys.stdin ) . The `keep_blank_values` and `strict_parsing` parameters are passed to urllib.parse.parse_qs ( ) unchanged . With arguments `fp`.", "question_id": 1036}
{"snippet": "cgi.parse(environ=os.environ, keep_blank_values=False)", "intent": "Parse a query in the environment or from a file ( the file defaults to sys.stdin ) . The `keep_blank_values` and `strict_parsing` parameters are passed to urllib.parse.parse_qs ( ) unchanged . With arguments `environ`.", "question_id": 1037}
{"snippet": "cgi.parse(environ=os.environ, strict_parsing=False)", "intent": "Parse a query in the environment or from a file ( the file defaults to sys.stdin ) . The `keep_blank_values` and `strict_parsing` parameters are passed to urllib.parse.parse_qs ( ) unchanged . With arguments `environ`.", "question_id": 1038}
{"snippet": "cgi.parse_qs(qs)", "intent": "This function is deprecated in this module . With arguments `qs`.", "question_id": 1039}
{"snippet": "cgi.parse_qs(qs, keep_blank_values=False)", "intent": "This function is deprecated in this module . With arguments `qs`, `keep_blank_values`.", "question_id": 1040}
{"snippet": "cgi.parse_qs(qs, strict_parsing=False)", "intent": "This function is deprecated in this module . With arguments `qs`, `strict_parsing`.", "question_id": 1041}
{"snippet": "cgi.parse_qs(qs, keep_blank_values=False, strict_parsing=False)", "intent": "This function is deprecated in this module . With arguments `qs`, `keep_blank_values`, `strict_parsing`.", "question_id": 1042}
{"snippet": "cgi.parse_qsl(qs)", "intent": "This function is deprecated in this module . With arguments `qs`.", "question_id": 1043}
{"snippet": "cgi.parse_qsl(qs, keep_blank_values=False)", "intent": "This function is deprecated in this module . With arguments `qs`, `keep_blank_values`.", "question_id": 1044}
{"snippet": "cgi.parse_qsl(qs, strict_parsing=False)", "intent": "This function is deprecated in this module . With arguments `qs`, `strict_parsing`.", "question_id": 1045}
{"snippet": "cgi.parse_qsl(qs, keep_blank_values=False, strict_parsing=False)", "intent": "This function is deprecated in this module . With arguments `qs`, `keep_blank_values`, `strict_parsing`.", "question_id": 1046}
{"snippet": "cgi.parse_multipart(fp, pdict)", "intent": "Parse input of type multipart/form-data ( for file uploads ) . Arguments are `fp` for the input file , `pdict` for a dictionary containing other parameters in the Content-Type header , and `encoding` , the request encoding .", "question_id": 1047}
{"snippet": "cgi.parse_multipart(fp, pdict, encoding=\"utf-8\")", "intent": "Parse input of type multipart/form-data ( for file uploads ) . Arguments are `fp` for the input file , `pdict` for a dictionary containing other parameters in the Content-Type header , and `encoding` , the request encoding .", "question_id": 1048}
{"snippet": "cgi.parse_multipart(fp, pdict, errors=\"replace\")", "intent": "Parse input of type multipart/form-data ( for file uploads ) . Arguments are `fp` for the input file , `pdict` for a dictionary containing other parameters in the Content-Type header , and `encoding` , the request encoding . With arguments `errors`.", "question_id": 1049}
{"snippet": "cgi.parse_multipart(fp, pdict, encoding=\"utf-8\", errors=\"replace\")", "intent": "Parse input of type multipart/form-data ( for file uploads ) . Arguments are `fp` for the input file , `pdict` for a dictionary containing other parameters in the Content-Type header , and `encoding` , the request encoding . With arguments `errors`.", "question_id": 1050}
{"snippet": "cgi.parse_header(string)", "intent": "Parse a MIME header ( such as Content-Type ) into a main value and a dictionary of parameters . With arguments `string`.", "question_id": 1051}
{"snippet": "cgi.test()", "intent": "Robust test CGI script , usable as main program .", "question_id": 1052}
{"snippet": "cgi.print_environ()", "intent": "Format the shell environment in HTML .", "question_id": 1053}
{"snippet": "cgi.print_form(form)", "intent": "Format a `form` in HTML .", "question_id": 1054}
{"snippet": "cgi.print_directory()", "intent": "Format the current directory in HTML .", "question_id": 1055}
{"snippet": "cgi.print_environ_usage()", "intent": "Print a list of useful ( used by CGI ) environment variables in HTML .", "question_id": 1056}
{"snippet": "cgi.escape(s)", "intent": "Convert the characters ' & ' , ' < ' and ' > ' in string `s` to HTML-safe sequences .", "question_id": 1057}
{"snippet": "cgi.escape(s, quote=False)", "intent": "Convert the characters ' & ' , ' < ' and ' > ' in string `s` to HTML-safe sequences . If the optional flag `quote` is true , the quotation mark character ( `` ) is also translated ; this helps for inclusion in an HTML attribute value delimited by double quotes , as in < a href= '' ... '' > .", "question_id": 1058}
{"snippet": "cgitb.enable()", "intent": "This function causes the cgitb module to take over the interpreter \u2019 s default handling for exceptions by setting the value of sys.excepthook .", "question_id": 1059}
{"snippet": "cgitb.enable(display=1)", "intent": "This function causes the cgitb module to take over the interpreter \u2019 s default handling for exceptions by setting the value of sys.excepthook . The optional argument `display` defaults to 1 and can be set to 0 to suppress sending the traceback to the browser .", "question_id": 1060}
{"snippet": "cgitb.enable(logdir=None)", "intent": "This function causes the cgitb module to take over the interpreter \u2019 s default handling for exceptions by setting the value of sys.excepthook . If the argument `logdir` is present , the traceback reports are written to files .", "question_id": 1061}
{"snippet": "cgitb.enable(context=5)", "intent": "This function causes the cgitb module to take over the interpreter \u2019 s default handling for exceptions by setting the value of sys.excepthook . The optional argument `context` is the number of lines of context to display around the current line of source code in the traceback ; this defaults to 5 .", "question_id": 1062}
{"snippet": "cgitb.enable(format=\"html\")", "intent": "This function causes the cgitb module to take over the interpreter \u2019 s default handling for exceptions by setting the value of sys.excepthook . If the optional argument `format` is `` html '' , the output is formatted as HTML .", "question_id": 1063}
{"snippet": "cgitb.enable(display=1, logdir=None)", "intent": "This function causes the cgitb module to take over the interpreter \u2019 s default handling for exceptions by setting the value of sys.excepthook . The optional argument `display` defaults to 1 and can be set to 0 to suppress sending the traceback to the browser . If the argument `logdir` is present , the traceback reports are written to files .", "question_id": 1064}
{"snippet": "cgitb.enable(display=1, context=5)", "intent": "This function causes the cgitb module to take over the interpreter \u2019 s default handling for exceptions by setting the value of sys.excepthook . The optional argument `display` defaults to 1 and can be set to 0 to suppress sending the traceback to the browser . The optional argument `context` is the number of lines of context to display around the current line of source code in the traceback ; this defaults to 5 .", "question_id": 1065}
{"snippet": "cgitb.enable(display=1, format=\"html\")", "intent": "This function causes the cgitb module to take over the interpreter \u2019 s default handling for exceptions by setting the value of sys.excepthook . The optional argument `display` defaults to 1 and can be set to 0 to suppress sending the traceback to the browser . If the optional argument `format` is `` html '' , the output is formatted as HTML .", "question_id": 1066}
{"snippet": "cgitb.enable(logdir=None, context=5)", "intent": "This function causes the cgitb module to take over the interpreter \u2019 s default handling for exceptions by setting the value of sys.excepthook . If the argument `logdir` is present , the traceback reports are written to files . The optional argument `context` is the number of lines of context to display around the current line of source code in the traceback ; this defaults to 5 .", "question_id": 1067}
{"snippet": "cgitb.enable(logdir=None, format=\"html\")", "intent": "This function causes the cgitb module to take over the interpreter \u2019 s default handling for exceptions by setting the value of sys.excepthook . If the argument `logdir` is present , the traceback reports are written to files . If the optional argument `format` is `` html '' , the output is formatted as HTML .", "question_id": 1068}
{"snippet": "cgitb.text(info)", "intent": "This function handles the exception described by `info` ( a 3-tuple containing the result of sys.exc_info ( ) ) , formatting its traceback as text and returning the result as a string .", "question_id": 1069}
{"snippet": "cgitb.text(info, context=5)", "intent": "This function handles the exception described by `info` ( a 3-tuple containing the result of sys.exc_info ( ) ) , formatting its traceback as text and returning the result as a string . The optional argument `context` is the number of lines of context to display around the current line of source code in the traceback ; this defaults to 5 .", "question_id": 1070}
{"snippet": "cgitb.html(info)", "intent": "This function handles the exception described by `info` ( a 3-tuple containing the result of sys.exc_info ( ) ) , formatting its traceback as HTML and returning the result as a string .", "question_id": 1071}
{"snippet": "cgitb.html(info, context=5)", "intent": "This function handles the exception described by `info` ( a 3-tuple containing the result of sys.exc_info ( ) ) , formatting its traceback as HTML and returning the result as a string . The optional argument `context` is the number of lines of context to display around the current line of source code in the traceback ; this defaults to 5 .", "question_id": 1072}
{"snippet": "cgitb.handler()", "intent": "This function handles an exception using the default settings ( that is , show a report in the browser , but don \u2019 t log to a file ) .", "question_id": 1073}
{"snippet": "cgitb.handler(info=None)", "intent": "This function handles an exception using the default settings ( that is , show a report in the browser , but don \u2019 t log to a file ) . The optional `info` argument should be a 3-tuple containing an exception type , exception value , and traceback object , exactly like the tuple returned by sys.exc_info ( ) .", "question_id": 1074}
{"snippet": "chunk.Chunk(file)", "intent": "Class which represents a chunk . The `file` argument is expected to be a file-like object .", "question_id": 1075}
{"snippet": "chunk.Chunk(file, align=True)", "intent": "Class which represents a chunk . The `file` argument is expected to be a file-like object . If the optional argument `align` is true , chunks are assumed to be aligned on 2-byte boundaries .", "question_id": 1076}
{"snippet": "chunk.Chunk(file, bigendian=True)", "intent": "Class which represents a chunk . The `file` argument is expected to be a file-like object . If the optional argument `bigendian` is false , the chunk size is assumed to be in little-endian order .", "question_id": 1077}
{"snippet": "chunk.Chunk(file, inclheader=False)", "intent": "Class which represents a chunk . The `file` argument is expected to be a file-like object . If the optional argument `inclheader` is true , the size given in the chunk header includes the size of the header .", "question_id": 1078}
{"snippet": "chunk.Chunk(file, align=True, bigendian=True)", "intent": "Class which represents a chunk . The `file` argument is expected to be a file-like object . If the optional argument `align` is true , chunks are assumed to be aligned on 2-byte boundaries . If the optional argument `bigendian` is false , the chunk size is assumed to be in little-endian order .", "question_id": 1079}
{"snippet": "chunk.Chunk(file, align=True, inclheader=False)", "intent": "Class which represents a chunk . The `file` argument is expected to be a file-like object . If the optional argument `align` is true , chunks are assumed to be aligned on 2-byte boundaries . If the optional argument `inclheader` is true , the size given in the chunk header includes the size of the header .", "question_id": 1080}
{"snippet": "chunk.Chunk(file, bigendian=True, inclheader=False)", "intent": "Class which represents a chunk . The `file` argument is expected to be a file-like object . If the optional argument `bigendian` is false , the chunk size is assumed to be in little-endian order . If the optional argument `inclheader` is true , the size given in the chunk header includes the size of the header .", "question_id": 1081}
{"snippet": "chunk.Chunk(file, align=True, bigendian=True, inclheader=False)", "intent": "Class which represents a chunk . The `file` argument is expected to be a file-like object . If the optional argument `align` is true , chunks are assumed to be aligned on 2-byte boundaries . If the optional argument `bigendian` is false , the chunk size is assumed to be in little-endian order . If the optional argument `inclheader` is true , the size given in the chunk header includes the size of the header .", "question_id": 1082}
{"snippet": "chunk.getname()", "intent": "Returns the name ( ID ) of the chunk .", "question_id": 1083}
{"snippet": "chunk.getsize()", "intent": "Returns the size of the chunk .", "question_id": 1084}
{"snippet": "chunk.close()", "intent": "Close and skip to the end of the chunk .", "question_id": 1085}
{"snippet": "chunk.isatty()", "intent": "Returns False .", "question_id": 1086}
{"snippet": "chunk.seek(pos)", "intent": "Set the chunk \u2019 s current position . With arguments `pos`.", "question_id": 1087}
{"snippet": "chunk.seek(pos, whence=0)", "intent": "Set the chunk \u2019 s current position . The `whence` argument is optional and defaults to 0 ( absolute file positioning ) ; other values are 1 ( seek relative to the current position ) and 2 ( seek relative to the file \u2019 s end ) . With arguments `pos`.", "question_id": 1088}
{"snippet": "chunk.tell()", "intent": "Return the current position into the chunk .", "question_id": 1089}
{"snippet": "chunk.read()", "intent": "Read at most `size` bytes from the chunk ( less if the read hits the end of the chunk before obtaining size bytes ) .", "question_id": 1090}
{"snippet": "chunk.read(size=-1)", "intent": "Read at most `size` bytes from the chunk ( less if the read hits the end of the chunk before obtaining size bytes ) .", "question_id": 1091}
{"snippet": "chunk.skip()", "intent": "Skip to the end of the chunk .", "question_id": 1092}
{"snippet": "cmath.phase(x)", "intent": "Return the phase of `x` ( also known as the argument of x ) , as a float .", "question_id": 1093}
{"snippet": "cmath.polar(x)", "intent": "Return the representation of `x` in polar coordinates .", "question_id": 1094}
{"snippet": "cmath.rect(r, phi)", "intent": "Return the complex number x with polar coordinates `r` and `phi` .", "question_id": 1095}
{"snippet": "cmath.exp(x)", "intent": "Return e raised to the power `x` , where e is the base of natural logarithms .", "question_id": 1096}
{"snippet": "cmath.log(x, base)", "intent": "Returns the logarithm of `x` to the given `base` .", "question_id": 1097}
{"snippet": "cmath.log(x)", "intent": "Returns the logarithm of `x` to the given `base` .", "question_id": 1098}
{"snippet": "cmath.log10(x)", "intent": "Return the base-10 logarithm of `x` .", "question_id": 1099}
{"snippet": "cmath.sqrt(x)", "intent": "Return the square root of `x` .", "question_id": 1100}
{"snippet": "cmath.acos(x)", "intent": "Return the arc cosine of `x` .", "question_id": 1101}
{"snippet": "cmath.asin(x)", "intent": "Return the arc sine of `x` .", "question_id": 1102}
{"snippet": "cmath.atan(x)", "intent": "Return the arc tangent of `x` .", "question_id": 1103}
{"snippet": "cmath.cos(x)", "intent": "Return the cosine of `x` .", "question_id": 1104}
{"snippet": "cmath.sin(x)", "intent": "Return the sine of `x` .", "question_id": 1105}
{"snippet": "cmath.tan(x)", "intent": "Return the tangent of `x` .", "question_id": 1106}
{"snippet": "cmath.acosh(x)", "intent": "Return the inverse hyperbolic cosine of `x` .", "question_id": 1107}
{"snippet": "cmath.asinh(x)", "intent": "Return the inverse hyperbolic sine of `x` .", "question_id": 1108}
{"snippet": "cmath.atanh(x)", "intent": "Return the inverse hyperbolic tangent of `x` .", "question_id": 1109}
{"snippet": "cmath.cosh(x)", "intent": "Return the hyperbolic cosine of `x` .", "question_id": 1110}
{"snippet": "cmath.sinh(x)", "intent": "Return the hyperbolic sine of `x` .", "question_id": 1111}
{"snippet": "cmath.tanh(x)", "intent": "Return the hyperbolic tangent of `x` .", "question_id": 1112}
{"snippet": "cmath.isfinite(x)", "intent": "Return True if both the real and imaginary parts of `x` are finite , and False otherwise .", "question_id": 1113}
{"snippet": "cmath.isinf(x)", "intent": "Return True if either the real or the imaginary part of `x` is an infinity , and False otherwise .", "question_id": 1114}
{"snippet": "cmath.isnan(x)", "intent": "Return True if either the real or the imaginary part of `x` is a NaN , and False otherwise .", "question_id": 1115}
{"snippet": "cmath.isclose(a, b)", "intent": "Return True if the values `a` and `b` are close to each other and False otherwise .", "question_id": 1116}
{"snippet": "cmath.isclose(a, b, rel_tol=1e-09)", "intent": "Return True if the values `a` and `b` are close to each other and False otherwise . `rel_tol` is the relative tolerance \u2013 it is the maximum allowed difference between a and b , relative to the larger absolute value of a or b .", "question_id": 1117}
{"snippet": "cmath.isclose(a, b, abs_tol=0.0)", "intent": "Return True if the values `a` and `b` are close to each other and False otherwise . `abs_tol` is the minimum absolute tolerance \u2013 useful for comparisons near zero .", "question_id": 1118}
{"snippet": "cmath.isclose(a, b, rel_tol=1e-09, abs_tol=0.0)", "intent": "Return True if the values `a` and `b` are close to each other and False otherwise . `rel_tol` is the relative tolerance \u2013 it is the maximum allowed difference between a and b , relative to the larger absolute value of a or b . `abs_tol` is the minimum absolute tolerance \u2013 useful for comparisons near zero .", "question_id": 1119}
{"snippet": "cmath.pi", "intent": "The mathematical constant \u03c0, as a float.", "question_id": 1120}
{"snippet": "cmath.e", "intent": "The mathematical constant e, as a float.", "question_id": 1121}
{"snippet": "cmath.tau", "intent": "The mathematical constant \u03c4, as a float.", "question_id": 1122}
{"snippet": "cmath.inf", "intent": "Floating-point positive infinity.", "question_id": 1123}
{"snippet": "cmath.infj", "intent": "Complex number with zero real part and positive infinity imaginary part.", "question_id": 1124}
{"snippet": "cmath.nan", "intent": "A floating-point \u201cnot a number\u201d (NaN) value.", "question_id": 1125}
{"snippet": "cmath.nanj", "intent": "Complex number with zero real part and NaN imaginary part.", "question_id": 1126}
{"snippet": "cmd.Cmd()", "intent": "A Cmd instance or subclass instance is a line-oriented interpreter framework .", "question_id": 1127}
{"snippet": "cmd.Cmd(completekey='tab')", "intent": "A Cmd instance or subclass instance is a line-oriented interpreter framework . The optional argument `completekey` is the readline name of a completion key ; it defaults to Tab .", "question_id": 1128}
{"snippet": "cmd.Cmd(stdin=None)", "intent": "A Cmd instance or subclass instance is a line-oriented interpreter framework . The optional arguments `stdin` and `stdout` specify the input and output file objects that the Cmd instance or subclass instance will use for input and output .", "question_id": 1129}
{"snippet": "cmd.Cmd(stdout=None)", "intent": "A Cmd instance or subclass instance is a line-oriented interpreter framework . The optional arguments `stdin` and `stdout` specify the input and output file objects that the Cmd instance or subclass instance will use for input and output .", "question_id": 1130}
{"snippet": "cmd.Cmd(completekey='tab', stdin=None)", "intent": "A Cmd instance or subclass instance is a line-oriented interpreter framework . The optional argument `completekey` is the readline name of a completion key ; it defaults to Tab . The optional arguments `stdin` and `stdout` specify the input and output file objects that the Cmd instance or subclass instance will use for input and output .", "question_id": 1131}
{"snippet": "cmd.Cmd(completekey='tab', stdout=None)", "intent": "A Cmd instance or subclass instance is a line-oriented interpreter framework . The optional argument `completekey` is the readline name of a completion key ; it defaults to Tab . The optional arguments `stdin` and `stdout` specify the input and output file objects that the Cmd instance or subclass instance will use for input and output .", "question_id": 1132}
{"snippet": "cmd.Cmd(stdin=None, stdout=None)", "intent": "A Cmd instance or subclass instance is a line-oriented interpreter framework . The optional arguments `stdin` and `stdout` specify the input and output file objects that the Cmd instance or subclass instance will use for input and output .", "question_id": 1133}
{"snippet": "cmd.Cmd(completekey='tab', stdin=None, stdout=None)", "intent": "A Cmd instance or subclass instance is a line-oriented interpreter framework . The optional argument `completekey` is the readline name of a completion key ; it defaults to Tab . The optional arguments `stdin` and `stdout` specify the input and output file objects that the Cmd instance or subclass instance will use for input and output .", "question_id": 1134}
{"snippet": "Cmd.cmdloop()", "intent": "Repeatedly issue a prompt , accept input , parse an initial prefix off the received input , and dispatch to action methods , passing them the remainder of the line as argument .", "question_id": 1135}
{"snippet": "Cmd.cmdloop(intro=None)", "intent": "Repeatedly issue a prompt , accept input , parse an initial prefix off the received input , and dispatch to action methods , passing them the remainder of the line as argument . The optional argument is a banner or `intro` string to be issued before the first prompt ( this overrides the intro class attribute ) .", "question_id": 1136}
{"snippet": "Cmd.onecmd(str)", "intent": "Interpret the argument as though it had been typed in response to the prompt . If there is a do_* ( ) method for the command `str` , the return value of that method is returned , otherwise the return value from the default ( ) method is returned .", "question_id": 1137}
{"snippet": "Cmd.emptyline()", "intent": "Method called when an empty line is entered in response to the prompt .", "question_id": 1138}
{"snippet": "Cmd.default(line)", "intent": "Method called on an input `line` when the command prefix is not recognized .", "question_id": 1139}
{"snippet": "Cmd.completedefault(text, line, begidx, endidx)", "intent": "Method called to complete an input `line` when no command-specific complete_* ( ) method is available . With arguments `text`, `begidx`, `endidx`.", "question_id": 1140}
{"snippet": "Cmd.precmd(line)", "intent": "Hook method executed just before the command `line` line is interpreted , but after the input prompt is generated and issued .", "question_id": 1141}
{"snippet": "Cmd.postcmd(stop, line)", "intent": "Hook method executed just after a command dispatch is finished . `line` is the command line which was executed , and `stop` is a flag which indicates whether execution will be terminated after the call to postcmd ( ) ; this will be the return value of the onecmd ( ) method .", "question_id": 1142}
{"snippet": "Cmd.preloop()", "intent": "Hook method executed once when cmdloop ( ) is called .", "question_id": 1143}
{"snippet": "Cmd.postloop()", "intent": "Hook method executed once when cmdloop ( ) is about to return .", "question_id": 1144}
{"snippet": "Cmd.prompt", "intent": "The prompt issued to solicit input.", "question_id": 1145}
{"snippet": "Cmd.identchars", "intent": "The string of characters accepted for the command prefix.", "question_id": 1146}
{"snippet": "Cmd.lastcmd", "intent": "The last nonempty command prefix seen.", "question_id": 1147}
{"snippet": "Cmd.cmdqueue", "intent": "A list of queued input lines.", "question_id": 1148}
{"snippet": "Cmd.intro", "intent": "A string to issue as an intro or banner.", "question_id": 1149}
{"snippet": "Cmd.doc_header", "intent": "The header to issue if the help output has a section for documented commands.", "question_id": 1150}
{"snippet": "Cmd.misc_header", "intent": "The header to issue if the help output has a section for miscellaneous  help topics (that is, there are help_*() methods without corresponding do_*() methods).", "question_id": 1151}
{"snippet": "Cmd.undoc_header", "intent": "The header to issue if the help output has a section for undocumented  commands (that is, there are do_*() methods without corresponding help_*() methods).", "question_id": 1152}
{"snippet": "Cmd.ruler", "intent": "The character used to draw separator lines under the help-message headers.", "question_id": 1153}
{"snippet": "Cmd.use_rawinput", "intent": "A flag, defaulting to true.", "question_id": 1154}
{"snippet": "code.InteractiveInterpreter()", "intent": "This class deals with parsing and interpreter state ( the user \u2019 s namespace ) ; it does not deal with input buffering or prompting or input file naming ( the filename is always passed in explicitly ) .", "question_id": 1155}
{"snippet": "code.InteractiveInterpreter(locals=None)", "intent": "This class deals with parsing and interpreter state ( the user \u2019 s namespace ) ; it does not deal with input buffering or prompting or input file naming ( the filename is always passed in explicitly ) . The optional `locals` argument specifies the dictionary in which code will be executed ; it defaults to a newly created dictionary with key '__name__ ' set to '__console__ ' and key '__doc__ ' set to None .", "question_id": 1156}
{"snippet": "code.InteractiveConsole()", "intent": "Closely emulate the behavior of the interactive Python interpreter .", "question_id": 1157}
{"snippet": "code.InteractiveConsole(locals=None)", "intent": "Closely emulate the behavior of the interactive Python interpreter . With arguments `locals`.", "question_id": 1158}
{"snippet": "code.InteractiveConsole(filename=\"<console>\")", "intent": "Closely emulate the behavior of the interactive Python interpreter . With arguments `filename`.", "question_id": 1159}
{"snippet": "code.InteractiveConsole(locals=None, filename=\"<console>\")", "intent": "Closely emulate the behavior of the interactive Python interpreter . With arguments `locals`, `filename`.", "question_id": 1160}
{"snippet": "code.interact()", "intent": "Convenience function to run a read-eval-print loop .", "question_id": 1161}
{"snippet": "code.interact(banner=None)", "intent": "Convenience function to run a read-eval-print loop . The interact ( ) method of the instance is then run with `banner` and `exitmsg` passed as the banner and exit message to use , if provided .", "question_id": 1162}
{"snippet": "code.interact(readfunc=None)", "intent": "Convenience function to run a read-eval-print loop . This creates a new instance of InteractiveConsole and sets `readfunc` to be used as the InteractiveConsole.raw_input ( ) method , if provided .", "question_id": 1163}
{"snippet": "code.interact(local=None)", "intent": "Convenience function to run a read-eval-print loop . If `local` is provided , it is passed to the InteractiveConsole constructor for use as the default namespace for the interpreter loop .", "question_id": 1164}
{"snippet": "code.interact(exitmsg=None)", "intent": "Convenience function to run a read-eval-print loop . The interact ( ) method of the instance is then run with `banner` and `exitmsg` passed as the banner and exit message to use , if provided .", "question_id": 1165}
{"snippet": "code.interact(banner=None, readfunc=None)", "intent": "Convenience function to run a read-eval-print loop . The interact ( ) method of the instance is then run with `banner` and `exitmsg` passed as the banner and exit message to use , if provided . This creates a new instance of InteractiveConsole and sets `readfunc` to be used as the InteractiveConsole.raw_input ( ) method , if provided .", "question_id": 1166}
{"snippet": "code.interact(banner=None, local=None)", "intent": "Convenience function to run a read-eval-print loop . The interact ( ) method of the instance is then run with `banner` and `exitmsg` passed as the banner and exit message to use , if provided . If `local` is provided , it is passed to the InteractiveConsole constructor for use as the default namespace for the interpreter loop .", "question_id": 1167}
{"snippet": "code.interact(banner=None, exitmsg=None)", "intent": "Convenience function to run a read-eval-print loop . The interact ( ) method of the instance is then run with `banner` and `exitmsg` passed as the banner and exit message to use , if provided .", "question_id": 1168}
{"snippet": "code.interact(readfunc=None, local=None)", "intent": "Convenience function to run a read-eval-print loop . This creates a new instance of InteractiveConsole and sets `readfunc` to be used as the InteractiveConsole.raw_input ( ) method , if provided . If `local` is provided , it is passed to the InteractiveConsole constructor for use as the default namespace for the interpreter loop .", "question_id": 1169}
{"snippet": "code.interact(readfunc=None, exitmsg=None)", "intent": "Convenience function to run a read-eval-print loop . This creates a new instance of InteractiveConsole and sets `readfunc` to be used as the InteractiveConsole.raw_input ( ) method , if provided . The interact ( ) method of the instance is then run with `banner` and `exitmsg` passed as the banner and exit message to use , if provided .", "question_id": 1170}
{"snippet": "code.compile_command(source)", "intent": "This function is useful for programs that want to emulate Python \u2019 s interpreter main loop ( a.k.a . `source` is the source string ; `filename` is the optional filename from which source was read , defaulting to ' < input > ' ; and `symbol` is the optional grammar start symbol , which should be either 'single ' ( the default ) or 'eval ' .", "question_id": 1171}
{"snippet": "code.compile_command(source, filename=\"<input>\")", "intent": "This function is useful for programs that want to emulate Python \u2019 s interpreter main loop ( a.k.a . `source` is the source string ; `filename` is the optional filename from which source was read , defaulting to ' < input > ' ; and `symbol` is the optional grammar start symbol , which should be either 'single ' ( the default ) or 'eval ' .", "question_id": 1172}
{"snippet": "code.compile_command(source, symbol=\"single\")", "intent": "This function is useful for programs that want to emulate Python \u2019 s interpreter main loop ( a.k.a . `source` is the source string ; `filename` is the optional filename from which source was read , defaulting to ' < input > ' ; and `symbol` is the optional grammar start symbol , which should be either 'single ' ( the default ) or 'eval ' .", "question_id": 1173}
{"snippet": "code.compile_command(source, filename=\"<input>\", symbol=\"single\")", "intent": "This function is useful for programs that want to emulate Python \u2019 s interpreter main loop ( a.k.a . `source` is the source string ; `filename` is the optional filename from which source was read , defaulting to ' < input > ' ; and `symbol` is the optional grammar start symbol , which should be either 'single ' ( the default ) or 'eval ' .", "question_id": 1174}
{"snippet": "InteractiveInterpreter.runsource(source)", "intent": "Compile and run some `source` in the interpreter .", "question_id": 1175}
{"snippet": "InteractiveInterpreter.runsource(source, filename=\"<input>\")", "intent": "Compile and run some `source` in the interpreter . Arguments are the same as for compile_command ( ) ; the default for `filename` is ' < input > ' , and for `symbol` is 'single ' .", "question_id": 1176}
{"snippet": "InteractiveInterpreter.runsource(source, symbol=\"single\")", "intent": "Compile and run some `source` in the interpreter . Arguments are the same as for compile_command ( ) ; the default for `filename` is ' < input > ' , and for `symbol` is 'single ' .", "question_id": 1177}
{"snippet": "InteractiveInterpreter.runsource(source, filename=\"<input>\", symbol=\"single\")", "intent": "Compile and run some `source` in the interpreter . Arguments are the same as for compile_command ( ) ; the default for `filename` is ' < input > ' , and for `symbol` is 'single ' .", "question_id": 1178}
{"snippet": "InteractiveInterpreter.runcode(code)", "intent": "Execute a `code` object .", "question_id": 1179}
{"snippet": "InteractiveInterpreter.showsyntaxerror()", "intent": "Display the syntax error that just occurred .", "question_id": 1180}
{"snippet": "InteractiveInterpreter.showsyntaxerror(filename=None)", "intent": "Display the syntax error that just occurred . If `filename` is given , it is stuffed into the exception instead of the default filename provided by Python \u2019 s parser , because it always uses ' < string > ' when reading from a string .", "question_id": 1181}
{"snippet": "InteractiveInterpreter.showtraceback()", "intent": "Display the exception that just occurred .", "question_id": 1182}
{"snippet": "InteractiveInterpreter.write(data)", "intent": "Write a string to the standard error stream ( sys.stderr ) . With arguments `data`.", "question_id": 1183}
{"snippet": "InteractiveConsole.interact()", "intent": "Closely emulate the interactive Python console .", "question_id": 1184}
{"snippet": "InteractiveConsole.interact(banner=None)", "intent": "Closely emulate the interactive Python console . The optional `banner` argument specify the banner to print before the first interaction ; by default it prints a banner similar to the one printed by the standard Python interpreter , followed by the class name of the console object in parentheses ( so as not to confuse this with the real interpreter \u2013 since it \u2019 s so close !", "question_id": 1185}
{"snippet": "InteractiveConsole.interact(exitmsg=None)", "intent": "Closely emulate the interactive Python console . The optional `exitmsg` argument specifies an exit message printed when exiting .", "question_id": 1186}
{"snippet": "InteractiveConsole.interact(banner=None, exitmsg=None)", "intent": "Closely emulate the interactive Python console . The optional `banner` argument specify the banner to print before the first interaction ; by default it prints a banner similar to the one printed by the standard Python interpreter , followed by the class name of the console object in parentheses ( so as not to confuse this with the real interpreter \u2013 since it \u2019 s so close ! The optional `exitmsg` argument specifies an exit message printed when exiting .", "question_id": 1187}
{"snippet": "InteractiveConsole.push(line)", "intent": "Push a `line` of source text to the interpreter .", "question_id": 1188}
{"snippet": "InteractiveConsole.resetbuffer()", "intent": "Remove any unhandled source text from the input buffer .", "question_id": 1189}
{"snippet": "InteractiveConsole.raw_input()", "intent": "Write a `prompt` and read a line .", "question_id": 1190}
{"snippet": "InteractiveConsole.raw_input(prompt=\"\")", "intent": "Write a `prompt` and read a line .", "question_id": 1191}
{"snippet": "codecs.encode(obj)", "intent": "Encodes `obj` using the codec registered for `encoding` .", "question_id": 1192}
{"snippet": "codecs.encode(obj, encoding='utf-8')", "intent": "Encodes `obj` using the codec registered for `encoding` .", "question_id": 1193}
{"snippet": "codecs.encode(obj, errors='strict')", "intent": "Encodes `obj` using the codec registered for `encoding` . The default error handler is 'strict ' meaning that encoding `errors` raise ValueError ( or a more codec specific subclass , such as UnicodeEncodeError ) .", "question_id": 1194}
{"snippet": "codecs.encode(obj, encoding='utf-8', errors='strict')", "intent": "Encodes `obj` using the codec registered for `encoding` . The default error handler is 'strict ' meaning that encoding `errors` raise ValueError ( or a more codec specific subclass , such as UnicodeEncodeError ) .", "question_id": 1195}
{"snippet": "codecs.decode(obj)", "intent": "Decodes `obj` using the codec registered for `encoding` .", "question_id": 1196}
{"snippet": "codecs.decode(obj, encoding='utf-8')", "intent": "Decodes `obj` using the codec registered for `encoding` .", "question_id": 1197}
{"snippet": "codecs.decode(obj, errors='strict')", "intent": "Decodes `obj` using the codec registered for `encoding` . The default error handler is 'strict ' meaning that decoding `errors` raise ValueError ( or a more codec specific subclass , such as UnicodeDecodeError ) .", "question_id": 1198}
{"snippet": "codecs.decode(obj, encoding='utf-8', errors='strict')", "intent": "Decodes `obj` using the codec registered for `encoding` . The default error handler is 'strict ' meaning that decoding `errors` raise ValueError ( or a more codec specific subclass , such as UnicodeDecodeError ) .", "question_id": 1199}
{"snippet": "codecs.lookup(encoding)", "intent": "Looks up the codec info in the Python codec registry and returns a CodecInfo object as defined below . With arguments `encoding`.", "question_id": 1200}
{"snippet": "codecs.CodecInfo(encode, decode)", "intent": "Codec details when looking up the codec registry . With arguments `encode`, `decode`.", "question_id": 1201}
{"snippet": "codecs.CodecInfo(encode, decode, streamreader=None)", "intent": "Codec details when looking up the codec registry . With arguments `encode`, `decode`, `streamreader`.", "question_id": 1202}
{"snippet": "codecs.CodecInfo(encode, decode, streamwriter=None)", "intent": "Codec details when looking up the codec registry . With arguments `encode`, `decode`, `streamwriter`.", "question_id": 1203}
{"snippet": "codecs.CodecInfo(encode, decode, incrementalencoder=None)", "intent": "Codec details when looking up the codec registry . With arguments `encode`, `decode`, `incrementalencoder`.", "question_id": 1204}
{"snippet": "codecs.CodecInfo(encode, decode, incrementaldecoder=None)", "intent": "Codec details when looking up the codec registry . With arguments `encode`, `decode`, `incrementaldecoder`.", "question_id": 1205}
{"snippet": "codecs.CodecInfo(encode, decode, name=None)", "intent": "Codec details when looking up the codec registry . The constructor arguments are stored in attributes of the same `name` : With arguments `encode`, `decode`.", "question_id": 1206}
{"snippet": "codecs.CodecInfo(encode, decode, streamreader=None, streamwriter=None)", "intent": "Codec details when looking up the codec registry . With arguments `encode`, `decode`, `streamreader`, `streamwriter`.", "question_id": 1207}
{"snippet": "codecs.CodecInfo(encode, decode, streamreader=None, incrementalencoder=None)", "intent": "Codec details when looking up the codec registry . With arguments `encode`, `decode`, `streamreader`, `incrementalencoder`.", "question_id": 1208}
{"snippet": "codecs.CodecInfo(encode, decode, streamreader=None, incrementaldecoder=None)", "intent": "Codec details when looking up the codec registry . With arguments `encode`, `decode`, `streamreader`, `incrementaldecoder`.", "question_id": 1209}
{"snippet": "codecs.CodecInfo(encode, decode, streamreader=None, name=None)", "intent": "Codec details when looking up the codec registry . The constructor arguments are stored in attributes of the same `name` : With arguments `encode`, `decode`, `streamreader`.", "question_id": 1210}
{"snippet": "codec_info.name", "intent": "The name of the encoding.", "question_id": 1211}
{"snippet": "codec_info.encode", "intent": "The stateless encoding and decoding functions.", "question_id": 1212}
{"snippet": "codec_info.decode", "intent": "The stateless encoding and decoding functions.", "question_id": 1213}
{"snippet": "codec_info.incrementalencoder", "intent": "Incremental encoder and decoder classes or factory functions.", "question_id": 1214}
{"snippet": "codec_info.incrementaldecoder", "intent": "Incremental encoder and decoder classes or factory functions.", "question_id": 1215}
{"snippet": "codec_info.streamwriter", "intent": "Stream writer and reader classes or factory functions.", "question_id": 1216}
{"snippet": "codec_info.streamreader", "intent": "Stream writer and reader classes or factory functions.", "question_id": 1217}
{"snippet": "codecs.getencoder(encoding)", "intent": "Look up the codec for the given `encoding` and return its encoder function .", "question_id": 1218}
{"snippet": "codecs.getdecoder(encoding)", "intent": "Look up the codec for the given `encoding` and return its decoder function .", "question_id": 1219}
{"snippet": "codecs.getincrementalencoder(encoding)", "intent": "Look up the codec for the given `encoding` and return its incremental encoder class or factory function .", "question_id": 1220}
{"snippet": "codecs.getincrementaldecoder(encoding)", "intent": "Look up the codec for the given `encoding` and return its incremental decoder class or factory function .", "question_id": 1221}
{"snippet": "codecs.getreader(encoding)", "intent": "Look up the codec for the given `encoding` and return its StreamReader class or factory function .", "question_id": 1222}
{"snippet": "codecs.getwriter(encoding)", "intent": "Look up the codec for the given `encoding` and return its StreamWriter class or factory function .", "question_id": 1223}
{"snippet": "codecs.register(search_function)", "intent": "Register a codec search function . With arguments `search_function`.", "question_id": 1224}
{"snippet": "codecs.open(filename)", "intent": "Open an encoded file using the given `mode` and return an instance of StreamReaderWriter , providing transparent encoding/decoding . With arguments `filename`.", "question_id": 1225}
{"snippet": "codecs.open(filename, mode='r')", "intent": "Open an encoded file using the given `mode` and return an instance of StreamReaderWriter , providing transparent encoding/decoding . With arguments `filename`.", "question_id": 1226}
{"snippet": "codecs.open(filename, encoding=None)", "intent": "Open an encoded file using the given `mode` and return an instance of StreamReaderWriter , providing transparent encoding/decoding . `encoding` specifies the encoding which is to be used for the file . With arguments `filename`.", "question_id": 1227}
{"snippet": "codecs.open(filename, errors='strict')", "intent": "Open an encoded file using the given `mode` and return an instance of StreamReaderWriter , providing transparent encoding/decoding . `errors` may be given to define the error handling . With arguments `filename`.", "question_id": 1228}
{"snippet": "codecs.open(filename, buffering=1)", "intent": "Open an encoded file using the given `mode` and return an instance of StreamReaderWriter , providing transparent encoding/decoding . `buffering` has the same meaning as for the built-in open ( ) function . With arguments `filename`.", "question_id": 1229}
{"snippet": "codecs.open(filename, mode='r', encoding=None)", "intent": "Open an encoded file using the given `mode` and return an instance of StreamReaderWriter , providing transparent encoding/decoding . `encoding` specifies the encoding which is to be used for the file . With arguments `filename`.", "question_id": 1230}
{"snippet": "codecs.open(filename, mode='r', errors='strict')", "intent": "Open an encoded file using the given `mode` and return an instance of StreamReaderWriter , providing transparent encoding/decoding . `errors` may be given to define the error handling . With arguments `filename`.", "question_id": 1231}
{"snippet": "codecs.open(filename, mode='r', buffering=1)", "intent": "Open an encoded file using the given `mode` and return an instance of StreamReaderWriter , providing transparent encoding/decoding . `buffering` has the same meaning as for the built-in open ( ) function . With arguments `filename`.", "question_id": 1232}
{"snippet": "codecs.open(filename, encoding=None, errors='strict')", "intent": "Open an encoded file using the given `mode` and return an instance of StreamReaderWriter , providing transparent encoding/decoding . `encoding` specifies the encoding which is to be used for the file . `errors` may be given to define the error handling . With arguments `filename`.", "question_id": 1233}
{"snippet": "codecs.open(filename, encoding=None, buffering=1)", "intent": "Open an encoded file using the given `mode` and return an instance of StreamReaderWriter , providing transparent encoding/decoding . `encoding` specifies the encoding which is to be used for the file . `buffering` has the same meaning as for the built-in open ( ) function . With arguments `filename`.", "question_id": 1234}
{"snippet": "codecs.EncodedFile(file, data_encoding)", "intent": "Return a StreamRecoder instance , a wrapped version of `file` which provides transparent transcoding . Data written to the wrapped file is decoded according to the given `data_encoding` and then written to the original file as bytes using `file_encoding` .", "question_id": 1235}
{"snippet": "codecs.EncodedFile(file, data_encoding, file_encoding=None)", "intent": "Return a StreamRecoder instance , a wrapped version of `file` which provides transparent transcoding . Data written to the wrapped file is decoded according to the given `data_encoding` and then written to the original file as bytes using `file_encoding` .", "question_id": 1236}
{"snippet": "codecs.EncodedFile(file, data_encoding, errors='strict')", "intent": "Return a StreamRecoder instance , a wrapped version of `file` which provides transparent transcoding . Data written to the wrapped file is decoded according to the given `data_encoding` and then written to the original file as bytes using `file_encoding` . `errors` may be given to define the error handling .", "question_id": 1237}
{"snippet": "codecs.EncodedFile(file, data_encoding, file_encoding=None, errors='strict')", "intent": "Return a StreamRecoder instance , a wrapped version of `file` which provides transparent transcoding . Data written to the wrapped file is decoded according to the given `data_encoding` and then written to the original file as bytes using `file_encoding` . `errors` may be given to define the error handling .", "question_id": 1238}
{"snippet": "codecs.iterencode(iterator, encoding, **kwargs)", "intent": "Uses an incremental encoder to iteratively encode the input provided by `iterator` . With arguments `encoding`, `**kwargs`.", "question_id": 1239}
{"snippet": "codecs.iterencode(iterator, encoding, **kwargs, errors='strict')", "intent": "Uses an incremental encoder to iteratively encode the input provided by `iterator` . The `errors` argument ( as well as any other keyword argument ) is passed through to the incremental encoder . With arguments `encoding`, `**kwargs`.", "question_id": 1240}
{"snippet": "codecs.iterdecode(iterator, encoding, **kwargs)", "intent": "Uses an incremental decoder to iteratively decode the input provided by `iterator` . With arguments `encoding`, `**kwargs`.", "question_id": 1241}
{"snippet": "codecs.iterdecode(iterator, encoding, **kwargs, errors='strict')", "intent": "Uses an incremental decoder to iteratively decode the input provided by `iterator` . The `errors` argument ( as well as any other keyword argument ) is passed through to the incremental decoder . With arguments `encoding`, `**kwargs`.", "question_id": 1242}
{"snippet": "codecs.BOM", "intent": "These constants define various byte sequences, being Unicode byte order marks (BOMs) for several encodings.", "question_id": 1243}
{"snippet": "codecs.BOM_BE", "intent": "These constants define various byte sequences, being Unicode byte order marks (BOMs) for several encodings.", "question_id": 1244}
{"snippet": "codecs.BOM_LE", "intent": "These constants define various byte sequences, being Unicode byte order marks (BOMs) for several encodings.", "question_id": 1245}
{"snippet": "codecs.BOM_UTF8", "intent": "These constants define various byte sequences, being Unicode byte order marks (BOMs) for several encodings.", "question_id": 1246}
{"snippet": "codecs.BOM_UTF16", "intent": "These constants define various byte sequences, being Unicode byte order marks (BOMs) for several encodings.", "question_id": 1247}
{"snippet": "codecs.BOM_UTF16_BE", "intent": "These constants define various byte sequences, being Unicode byte order marks (BOMs) for several encodings.", "question_id": 1248}
{"snippet": "codecs.BOM_UTF16_LE", "intent": "These constants define various byte sequences, being Unicode byte order marks (BOMs) for several encodings.", "question_id": 1249}
{"snippet": "codecs.BOM_UTF32", "intent": "These constants define various byte sequences, being Unicode byte order marks (BOMs) for several encodings.", "question_id": 1250}
{"snippet": "codecs.BOM_UTF32_BE", "intent": "These constants define various byte sequences, being Unicode byte order marks (BOMs) for several encodings.", "question_id": 1251}
{"snippet": "codecs.BOM_UTF32_LE", "intent": "These constants define various byte sequences, being Unicode byte order marks (BOMs) for several encodings.", "question_id": 1252}
{"snippet": "codecs.register_error(name, error_handler)", "intent": "Register the error handling function `error_handler` under the `name` name .", "question_id": 1253}
{"snippet": "codecs.lookup_error(name)", "intent": "Return the error handler previously registered under the `name` name .", "question_id": 1254}
{"snippet": "codecs.strict_errors(exception)", "intent": "Implements the 'strict ' error handling : each encoding or decoding error raises a UnicodeError . With arguments `exception`.", "question_id": 1255}
{"snippet": "codecs.replace_errors(exception)", "intent": "Implements the 'replace ' error handling ( for text encodings only ) : substitutes ' ? ' With arguments `exception`.", "question_id": 1256}
{"snippet": "codecs.ignore_errors(exception)", "intent": "Implements the 'ignore ' error handling : malformed data is ignored and encoding or decoding is continued without further notice . With arguments `exception`.", "question_id": 1257}
{"snippet": "codecs.xmlcharrefreplace_errors(exception)", "intent": "Implements the 'xmlcharrefreplace ' error handling ( for encoding with text encodings only ) : the unencodable character is replaced by an appropriate XML character reference . With arguments `exception`.", "question_id": 1258}
{"snippet": "codecs.backslashreplace_errors(exception)", "intent": "Implements the 'backslashreplace ' error handling ( for text encodings only ) : malformed data is replaced by a backslashed escape sequence . With arguments `exception`.", "question_id": 1259}
{"snippet": "codecs.namereplace_errors(exception)", "intent": "Implements the 'namereplace ' error handling ( for encoding with text encodings only ) : the unencodable character is replaced by a \\N { ... } escape sequence . With arguments `exception`.", "question_id": 1260}
{"snippet": "Codec.encode(input, errors)", "intent": "Encodes the object `input` and returns a tuple ( output object , length consumed ) . The `errors` argument defines the error handling to apply .", "question_id": 1261}
{"snippet": "Codec.encode(input)", "intent": "Encodes the object `input` and returns a tuple ( output object , length consumed ) .", "question_id": 1262}
{"snippet": "Codec.decode(input, errors)", "intent": "Decodes the object `input` and returns a tuple ( output object , length consumed ) . The `errors` argument defines the error handling to apply .", "question_id": 1263}
{"snippet": "Codec.decode(input)", "intent": "Decodes the object `input` and returns a tuple ( output object , length consumed ) .", "question_id": 1264}
{"snippet": "codecs.IncrementalEncoder()", "intent": "Constructor for an IncrementalEncoder instance .", "question_id": 1265}
{"snippet": "codecs.IncrementalEncoder(errors='strict')", "intent": "Constructor for an IncrementalEncoder instance . The IncrementalEncoder may implement different error handling schemes by providing the `errors` keyword argument .", "question_id": 1266}
{"snippet": "incremental_encoder.encode(object, final)", "intent": "Encodes `object` ( taking the current state of the encoder into account ) and returns the resulting encoded object . If this is the last call to encode ( ) `final` must be true ( the default is false ) .", "question_id": 1267}
{"snippet": "incremental_encoder.encode(object)", "intent": "Encodes `object` ( taking the current state of the encoder into account ) and returns the resulting encoded object .", "question_id": 1268}
{"snippet": "incremental_encoder.reset()", "intent": "Reset the encoder to the initial state .", "question_id": 1269}
{"snippet": "incremental_encoder.getstate()", "intent": "Return the current state of the encoder which must be an integer .", "question_id": 1270}
{"snippet": "incremental_encoder.setstate(state)", "intent": "Set the `state` of the encoder to state .", "question_id": 1271}
{"snippet": "codecs.IncrementalDecoder()", "intent": "Constructor for an IncrementalDecoder instance .", "question_id": 1272}
{"snippet": "codecs.IncrementalDecoder(errors='strict')", "intent": "Constructor for an IncrementalDecoder instance . The IncrementalDecoder may implement different error handling schemes by providing the `errors` keyword argument .", "question_id": 1273}
{"snippet": "incremental_decoder.decode(object, final)", "intent": "Decodes `object` ( taking the current state of the decoder into account ) and returns the resulting decoded object . If this is the last call to decode ( ) `final` must be true ( the default is false ) .", "question_id": 1274}
{"snippet": "incremental_decoder.decode(object)", "intent": "Decodes `object` ( taking the current state of the decoder into account ) and returns the resulting decoded object .", "question_id": 1275}
{"snippet": "incremental_decoder.reset()", "intent": "Reset the decoder to the initial state .", "question_id": 1276}
{"snippet": "incremental_decoder.getstate()", "intent": "Return the current state of the decoder .", "question_id": 1277}
{"snippet": "incremental_decoder.setstate(state)", "intent": "Set the `state` of the decoder to state .", "question_id": 1278}
{"snippet": "codecs.StreamWriter(stream)", "intent": "Constructor for a StreamWriter instance . All `stream` writers must provide this constructor interface .", "question_id": 1279}
{"snippet": "codecs.StreamWriter(stream, errors='strict')", "intent": "Constructor for a StreamWriter instance . All `stream` writers must provide this constructor interface . The StreamWriter may implement different error handling schemes by providing the `errors` keyword argument .", "question_id": 1280}
{"snippet": "stream_writer.write(object)", "intent": "Writes the `object` \u2019 s contents encoded to the stream .", "question_id": 1281}
{"snippet": "stream_writer.writelines(list)", "intent": "Writes the concatenated `list` of strings to the stream ( possibly by reusing the write ( ) method ) .", "question_id": 1282}
{"snippet": "stream_writer.reset()", "intent": "Flushes and resets the codec buffers used for keeping state .", "question_id": 1283}
{"snippet": "codecs.StreamReader(stream)", "intent": "Constructor for a StreamReader instance . All `stream` readers must provide this constructor interface .", "question_id": 1284}
{"snippet": "codecs.StreamReader(stream, errors='strict')", "intent": "Constructor for a StreamReader instance . All `stream` readers must provide this constructor interface . The StreamReader may implement different error handling schemes by providing the `errors` keyword argument .", "question_id": 1285}
{"snippet": "stream_reader.read(size, chars, firstline)", "intent": "Decodes data from the stream and returns the resulting object . The `size` argument indicates the approximate maximum number of encoded bytes or code points to read for decoding . The `chars` argument indicates the number of decoded code points or bytes to return . The `firstline` flag indicates that it would be sufficient to only return the first line , if there are decoding errors on later lines .", "question_id": 1286}
{"snippet": "stream_reader.read(size, chars)", "intent": "Decodes data from the stream and returns the resulting object . The `size` argument indicates the approximate maximum number of encoded bytes or code points to read for decoding . The `chars` argument indicates the number of decoded code points or bytes to return .", "question_id": 1287}
{"snippet": "stream_reader.read(size)", "intent": "Decodes data from the stream and returns the resulting object . The `size` argument indicates the approximate maximum number of encoded bytes or code points to read for decoding .", "question_id": 1288}
{"snippet": "stream_reader.read()", "intent": "Decodes data from the stream and returns the resulting object .", "question_id": 1289}
{"snippet": "stream_reader.readline(size, keepends)", "intent": "Read one line from the input stream and return the decoded data . `size` , if given , is passed as size argument to the stream \u2019 s read ( ) method . If `keepends` is false line-endings will be stripped from the lines returned .", "question_id": 1290}
{"snippet": "stream_reader.readline(size)", "intent": "Read one line from the input stream and return the decoded data . `size` , if given , is passed as size argument to the stream \u2019 s read ( ) method .", "question_id": 1291}
{"snippet": "stream_reader.readline()", "intent": "Read one line from the input stream and return the decoded data .", "question_id": 1292}
{"snippet": "stream_reader.readlines(sizehint, keepends)", "intent": "Read all lines available on the input stream and return them as a list of lines . `sizehint` , if given , is passed as the size argument to the stream \u2019 s read ( ) method . Line-endings are implemented using the codec \u2019 s decode ( ) method and are included in the list entries if `keepends` is true .", "question_id": 1293}
{"snippet": "stream_reader.readlines(sizehint)", "intent": "Read all lines available on the input stream and return them as a list of lines . `sizehint` , if given , is passed as the size argument to the stream \u2019 s read ( ) method .", "question_id": 1294}
{"snippet": "stream_reader.readlines()", "intent": "Read all lines available on the input stream and return them as a list of lines .", "question_id": 1295}
{"snippet": "stream_reader.reset()", "intent": "Resets the codec buffers used for keeping state .", "question_id": 1296}
{"snippet": "codecs.StreamReaderWriter(stream, Reader, Writer)", "intent": "Creates a StreamReaderWriter instance . `stream` must be a file-like object . `Reader` and `Writer` must be factory functions or classes providing the StreamReader and StreamWriter interface resp .", "question_id": 1297}
{"snippet": "codecs.StreamReaderWriter(stream, Reader, Writer, errors='strict')", "intent": "Creates a StreamReaderWriter instance . `stream` must be a file-like object . `Reader` and `Writer` must be factory functions or classes providing the StreamReader and StreamWriter interface resp . With arguments `errors`.", "question_id": 1298}
{"snippet": "codecs.StreamRecoder(stream, encode, decode, Reader, Writer)", "intent": "Creates a StreamRecoder instance which implements a two-way conversion : `encode` and `decode` work on the frontend \u2014 the data visible to code calling read ( ) and write ( ) , while `Reader` and `Writer` work on the backend \u2014 the data in `stream` .", "question_id": 1299}
{"snippet": "codecs.StreamRecoder(stream, encode, decode, Reader, Writer, errors='strict')", "intent": "Creates a StreamRecoder instance which implements a two-way conversion : `encode` and `decode` work on the frontend \u2014 the data visible to code calling read ( ) and write ( ) , while `Reader` and `Writer` work on the backend \u2014 the data in `stream` . With arguments `errors`.", "question_id": 1300}
{"snippet": "encodings.idna.nameprep(label)", "intent": "Return the nameprepped version of `label` .", "question_id": 1301}
{"snippet": "encodings.idna.ToASCII(label)", "intent": "Convert a `label` to ASCII , as specified in RFC 3490 .", "question_id": 1302}
{"snippet": "encodings.idna.ToUnicode(label)", "intent": "Convert a `label` to Unicode , as specified in RFC 3490 .", "question_id": 1303}
{"snippet": "codeop.compile_command(source)", "intent": "Tries to compile `source` , which should be a string of Python code and return a code object if source is valid Python code .", "question_id": 1304}
{"snippet": "codeop.compile_command(source, filename=\"<input>\")", "intent": "Tries to compile `source` , which should be a string of Python code and return a code object if source is valid Python code . In that case , the `filename` attribute of the code object will be filename , which defaults to ' < input > ' .", "question_id": 1305}
{"snippet": "codeop.compile_command(source, symbol=\"single\")", "intent": "Tries to compile `source` , which should be a string of Python code and return a code object if source is valid Python code . The `symbol` argument determines whether source is compiled as a statement ( 'single ' , the default ) or as an expression ( 'eval ' ) .", "question_id": 1306}
{"snippet": "codeop.compile_command(source, filename=\"<input>\", symbol=\"single\")", "intent": "Tries to compile `source` , which should be a string of Python code and return a code object if source is valid Python code . In that case , the `filename` attribute of the code object will be filename , which defaults to ' < input > ' . The `symbol` argument determines whether source is compiled as a statement ( 'single ' , the default ) or as an expression ( 'eval ' ) .", "question_id": 1307}
{"snippet": "codeop.Compile", "intent": "Instances of this class have __call__() methods identical in signature to the built-in function compile(), but with the difference that if the instance compiles program text containing a __future__ statement, the instance \u2018remembers\u2019 and compiles all subsequent program texts with the statement in force.", "question_id": 1308}
{"snippet": "codeop.CommandCompiler", "intent": "Instances of this class have __call__() methods identical in signature to compile_command(); the difference is that if the instance compiles program text containing a __future__ statement, the instance \u2018remembers\u2019 and compiles all subsequent program texts with the statement in force.", "question_id": 1309}
{"snippet": "collections.abc.Container", "intent": "ABCs for classes that provide respectively the methods __contains__(), __hash__(), __len__(), and __call__().", "question_id": 1310}
{"snippet": "collections.abc.Hashable", "intent": "ABCs for classes that provide respectively the methods __contains__(), __hash__(), __len__(), and __call__().", "question_id": 1311}
{"snippet": "collections.abc.Sized", "intent": "ABCs for classes that provide respectively the methods __contains__(), __hash__(), __len__(), and __call__().", "question_id": 1312}
{"snippet": "collections.abc.Callable", "intent": "ABCs for classes that provide respectively the methods __contains__(), __hash__(), __len__(), and __call__().", "question_id": 1313}
{"snippet": "collections.abc.Iterable", "intent": "ABC for classes that provide the __iter__() method.", "question_id": 1314}
{"snippet": "collections.abc.Collection", "intent": "ABC for sized iterable container classes.", "question_id": 1315}
{"snippet": "collections.abc.Iterator", "intent": "ABC for classes that provide the __iter__() and __next__() methods.", "question_id": 1316}
{"snippet": "collections.abc.Reversible", "intent": "ABC for iterable classes that also provide the __reversed__() method.", "question_id": 1317}
{"snippet": "collections.abc.Generator", "intent": "ABC for generator classes that implement the protocol defined in PEP 342 that extends iterators with the send(), throw() and close() methods.", "question_id": 1318}
{"snippet": "collections.abc.Sequence", "intent": "ABCs for read-only and mutable sequences.", "question_id": 1319}
{"snippet": "collections.abc.MutableSequence", "intent": "ABCs for read-only and mutable sequences.", "question_id": 1320}
{"snippet": "collections.abc.ByteString", "intent": "ABCs for read-only and mutable sequences.", "question_id": 1321}
{"snippet": "collections.abc.Set", "intent": "ABCs for read-only and mutable sets.", "question_id": 1322}
{"snippet": "collections.abc.MutableSet", "intent": "ABCs for read-only and mutable sets.", "question_id": 1323}
{"snippet": "collections.abc.Mapping", "intent": "ABCs for read-only and mutable mappings.", "question_id": 1324}
{"snippet": "collections.abc.MutableMapping", "intent": "ABCs for read-only and mutable mappings.", "question_id": 1325}
{"snippet": "collections.abc.MappingView", "intent": "ABCs for mapping, items, keys, and values views.", "question_id": 1326}
{"snippet": "collections.abc.ItemsView", "intent": "ABCs for mapping, items, keys, and values views.", "question_id": 1327}
{"snippet": "collections.abc.KeysView", "intent": "ABCs for mapping, items, keys, and values views.", "question_id": 1328}
{"snippet": "collections.abc.ValuesView", "intent": "ABCs for mapping, items, keys, and values views.", "question_id": 1329}
{"snippet": "collections.abc.Awaitable", "intent": "ABC for awaitable objects, which can be used in await expressions.", "question_id": 1330}
{"snippet": "collections.abc.Coroutine", "intent": "ABC for coroutine compatible classes.", "question_id": 1331}
{"snippet": "collections.abc.AsyncIterable", "intent": "ABC for classes that provide __aiter__ method.", "question_id": 1332}
{"snippet": "collections.abc.AsyncIterator", "intent": "ABC for classes that provide __aiter__ and __anext__ methods.", "question_id": 1333}
{"snippet": "collections.abc.AsyncGenerator", "intent": "ABC for asynchronous generator classes that implement the protocol defined in PEP 525 and PEP 492.", "question_id": 1334}
{"snippet": "collections.ChainMap(*maps)", "intent": "A ChainMap groups multiple dicts or other mappings together to create a single , updateable view . With arguments `*maps`.", "question_id": 1335}
{"snippet": "chain_map.maps", "intent": "A user updateable list of mappings.", "question_id": 1336}
{"snippet": "chain_map.new_child()", "intent": "Returns a new ChainMap containing a new map followed by all of the maps in the current instance .", "question_id": 1337}
{"snippet": "chain_map.new_child(m=None)", "intent": "Returns a new ChainMap containing a new map followed by all of the maps in the current instance . If `m` is specified , it becomes the new map at the front of the list of mappings ; if not specified , an empty dict is used , so that a call to d.new_child ( ) is equivalent to : ChainMap ( { } , *d.maps ) .", "question_id": 1338}
{"snippet": "chain_map.parents", "intent": "Property returning a new ChainMap containing all of the maps in the current instance except the first one.", "question_id": 1339}
{"snippet": "collections.Counter(iterable-or-mapping)", "intent": "A Counter is a dict subclass for counting hashable objects . With arguments `iterable-or-mapping`.", "question_id": 1340}
{"snippet": "collections.Counter()", "intent": "A Counter is a dict subclass for counting hashable objects .", "question_id": 1341}
{"snippet": "counter.elements()", "intent": "Return an iterator over elements repeating each as many times as its count .", "question_id": 1342}
{"snippet": "counter.most_common(n)", "intent": "Return a list of the `n` most common elements and their counts from the most common to the least .", "question_id": 1343}
{"snippet": "counter.most_common()", "intent": "Return a list of the `n` most common elements and their counts from the most common to the least .", "question_id": 1344}
{"snippet": "counter.subtract(iterable-or-mapping)", "intent": "Elements are subtracted from an iterable or from another mapping ( or counter ) . With arguments `iterable-or-mapping`.", "question_id": 1345}
{"snippet": "counter.subtract()", "intent": "Elements are subtracted from an iterable or from another mapping ( or counter ) .", "question_id": 1346}
{"snippet": "counter.fromkeys(iterable)", "intent": "This class method is not implemented for Counter objects . With arguments `iterable`.", "question_id": 1347}
{"snippet": "counter.update(iterable-or-mapping)", "intent": "Elements are counted from an iterable or added-in from another mapping ( or counter ) . With arguments `iterable-or-mapping`.", "question_id": 1348}
{"snippet": "counter.update()", "intent": "Elements are counted from an iterable or added-in from another mapping ( or counter ) .", "question_id": 1349}
{"snippet": "collections.deque(iterable, maxlen)", "intent": "Returns a new deque object initialized left-to-right ( using append ( ) ) with data from `iterable` . If `maxlen` is not specified or is None , deques may grow to an arbitrary length .", "question_id": 1350}
{"snippet": "collections.deque(iterable)", "intent": "Returns a new deque object initialized left-to-right ( using append ( ) ) with data from `iterable` .", "question_id": 1351}
{"snippet": "collections.deque()", "intent": "Returns a new deque object initialized left-to-right ( using append ( ) ) with data from `iterable` .", "question_id": 1352}
{"snippet": "deque.append(x)", "intent": "Add `x` to the right side of the deque .", "question_id": 1353}
{"snippet": "deque.appendleft(x)", "intent": "Add `x` to the left side of the deque .", "question_id": 1354}
{"snippet": "deque.clear()", "intent": "Remove all elements from the deque leaving it with length 0 .", "question_id": 1355}
{"snippet": "deque.copy()", "intent": "Create a shallow copy of the deque .", "question_id": 1356}
{"snippet": "deque.count(x)", "intent": "Count the number of deque elements equal to `x` .", "question_id": 1357}
{"snippet": "deque.extend(iterable)", "intent": "Extend the right side of the deque by appending elements from the `iterable` argument .", "question_id": 1358}
{"snippet": "deque.extendleft(iterable)", "intent": "Extend the left side of the deque by appending elements from `iterable` .", "question_id": 1359}
{"snippet": "deque.index(x, start, stop)", "intent": "Return the position of `x` in the deque ( at or after index `start` and before index `stop` ) .", "question_id": 1360}
{"snippet": "deque.index(x, start)", "intent": "Return the position of `x` in the deque ( at or after index `start` and before index `stop` ) .", "question_id": 1361}
{"snippet": "deque.index(x)", "intent": "Return the position of `x` in the deque ( at or after index `start` and before index `stop` ) .", "question_id": 1362}
{"snippet": "deque.insert(i, x)", "intent": "Insert `x` into the deque at position `i` .", "question_id": 1363}
{"snippet": "deque.pop()", "intent": "Remove and return an element from the right side of the deque .", "question_id": 1364}
{"snippet": "deque.popleft()", "intent": "Remove and return an element from the left side of the deque .", "question_id": 1365}
{"snippet": "deque.remove(value)", "intent": "Remove the first occurrence of `value` .", "question_id": 1366}
{"snippet": "deque.reverse()", "intent": "Reverse the elements of the deque in-place and then return None .", "question_id": 1367}
{"snippet": "deque.rotate()", "intent": "Rotate the deque `n` steps to the right .", "question_id": 1368}
{"snippet": "deque.rotate(n=1)", "intent": "Rotate the deque `n` steps to the right .", "question_id": 1369}
{"snippet": "deque.maxlen", "intent": "Maximum size of a deque or None if unbounded.", "question_id": 1370}
{"snippet": "collections.defaultdict(default_factory)", "intent": "Returns a new dictionary-like object . The first argument provides the initial value for the `default_factory` attribute ; it defaults to None .", "question_id": 1371}
{"snippet": "collections.defaultdict()", "intent": "Returns a new dictionary-like object .", "question_id": 1372}
{"snippet": "collections.defaultdict()", "intent": "Returns a new dictionary-like object .", "question_id": 1373}
{"snippet": "defaultdict.__missing__(key)", "intent": "If the default_factory attribute is None , this raises a KeyError exception with the `key` as argument .", "question_id": 1374}
{"snippet": "defaultdict.default_factory", "intent": "This attribute is used by the __missing__() method; it is initialized from the first argument to the constructor, if present, or to None, if absent.", "question_id": 1375}
{"snippet": "collections.namedtuple(typename, field_names)", "intent": "Returns a new tuple subclass named `typename` . Instances of the subclass also have a helpful docstring ( with typename and `field_names` ) and a helpful __repr__ ( ) method which lists the tuple contents in a name=value format .", "question_id": 1376}
{"snippet": "collections.namedtuple(typename, field_names, rename=False)", "intent": "Returns a new tuple subclass named `typename` . Instances of the subclass also have a helpful docstring ( with typename and `field_names` ) and a helpful __repr__ ( ) method which lists the tuple contents in a name=value format . If `rename` is true , invalid fieldnames are automatically replaced with positional names .", "question_id": 1377}
{"snippet": "collections.namedtuple(typename, field_names, defaults=None)", "intent": "Returns a new tuple subclass named `typename` . Instances of the subclass also have a helpful docstring ( with typename and `field_names` ) and a helpful __repr__ ( ) method which lists the tuple contents in a name=value format . `defaults` can be None or an iterable of default values .", "question_id": 1378}
{"snippet": "collections.namedtuple(typename, field_names, module=None)", "intent": "Returns a new tuple subclass named `typename` . Instances of the subclass also have a helpful docstring ( with typename and `field_names` ) and a helpful __repr__ ( ) method which lists the tuple contents in a name=value format . If `module` is defined , the __module__ attribute of the named tuple is set to that value .", "question_id": 1379}
{"snippet": "collections.namedtuple(typename, field_names, rename=False, defaults=None)", "intent": "Returns a new tuple subclass named `typename` . Instances of the subclass also have a helpful docstring ( with typename and `field_names` ) and a helpful __repr__ ( ) method which lists the tuple contents in a name=value format . If `rename` is true , invalid fieldnames are automatically replaced with positional names . `defaults` can be None or an iterable of default values .", "question_id": 1380}
{"snippet": "collections.namedtuple(typename, field_names, rename=False, module=None)", "intent": "Returns a new tuple subclass named `typename` . Instances of the subclass also have a helpful docstring ( with typename and `field_names` ) and a helpful __repr__ ( ) method which lists the tuple contents in a name=value format . If `rename` is true , invalid fieldnames are automatically replaced with positional names . If `module` is defined , the __module__ attribute of the named tuple is set to that value .", "question_id": 1381}
{"snippet": "collections.namedtuple(typename, field_names, defaults=None, module=None)", "intent": "Returns a new tuple subclass named `typename` . Instances of the subclass also have a helpful docstring ( with typename and `field_names` ) and a helpful __repr__ ( ) method which lists the tuple contents in a name=value format . `defaults` can be None or an iterable of default values . If `module` is defined , the __module__ attribute of the named tuple is set to that value .", "question_id": 1382}
{"snippet": "collections.namedtuple(typename, field_names, rename=False, defaults=None, module=None)", "intent": "Returns a new tuple subclass named `typename` . Instances of the subclass also have a helpful docstring ( with typename and `field_names` ) and a helpful __repr__ ( ) method which lists the tuple contents in a name=value format . If `rename` is true , invalid fieldnames are automatically replaced with positional names . `defaults` can be None or an iterable of default values . If `module` is defined , the __module__ attribute of the named tuple is set to that value .", "question_id": 1383}
{"snippet": "somenamedtuple._make(iterable)", "intent": "Class method that makes a new instance from an existing sequence or `iterable` .", "question_id": 1384}
{"snippet": "somenamedtuple._asdict()", "intent": "Return a new dict which maps field names to their corresponding values :", "question_id": 1385}
{"snippet": "somenamedtuple._replace(**kwargs)", "intent": "Return a new instance of the named tuple replacing specified fields with new values : With arguments `**kwargs`.", "question_id": 1386}
{"snippet": "somenamedtuple._fields", "intent": "Tuple of strings listing the field names.", "question_id": 1387}
{"snippet": "somenamedtuple._field_defaults", "intent": "Dictionary mapping field names to default values.", "question_id": 1388}
{"snippet": "collections.OrderedDict(items)", "intent": "Return an instance of a dict subclass that has methods specialized for rearranging dictionary order . With arguments `items`.", "question_id": 1389}
{"snippet": "collections.OrderedDict()", "intent": "Return an instance of a dict subclass that has methods specialized for rearranging dictionary order .", "question_id": 1390}
{"snippet": "ordered_dict.popitem()", "intent": "The popitem ( ) method for ordered dictionaries returns and removes a ( key , value ) pair .", "question_id": 1391}
{"snippet": "ordered_dict.popitem(last=True)", "intent": "The popitem ( ) method for ordered dictionaries returns and removes a ( key , value ) pair . The pairs are returned in LIFO order if `last` is true or FIFO order if false .", "question_id": 1392}
{"snippet": "ordered_dict.move_to_end(key)", "intent": "Move an existing `key` to either end of an ordered dictionary .", "question_id": 1393}
{"snippet": "ordered_dict.move_to_end(key, last=True)", "intent": "Move an existing `key` to either end of an ordered dictionary . The item is moved to the right end if `last` is true ( the default ) or to the beginning if last is false .", "question_id": 1394}
{"snippet": "collections.UserDict(initialdata)", "intent": "Class that simulates a dictionary . If `initialdata` is provided , data is initialized with its contents ; note that a reference to initialdata will not be kept , allowing it be used for other purposes .", "question_id": 1395}
{"snippet": "collections.UserDict()", "intent": "Class that simulates a dictionary .", "question_id": 1396}
{"snippet": "user_dict.data", "intent": "A real dictionary used to store the contents of the UserDict class.", "question_id": 1397}
{"snippet": "collections.UserList(list)", "intent": "Class that simulates a `list` .", "question_id": 1398}
{"snippet": "collections.UserList()", "intent": "Class that simulates a `list` .", "question_id": 1399}
{"snippet": "user_list.data", "intent": "A real list object used to store the contents of the UserList class.", "question_id": 1400}
{"snippet": "collections.UserString(seq)", "intent": "Class that simulates a string object . The instance \u2019 s contents are initially set to a copy of `seq` .", "question_id": 1401}
{"snippet": "user_string.data", "intent": "A real str object used to store the contents of the UserString class.", "question_id": 1402}
{"snippet": "colorsys.rgb_to_yiq(r, g, b)", "intent": "Convert the color from RGB coordinates to YIQ coordinates . With arguments `r`, `g`, `b`.", "question_id": 1403}
{"snippet": "colorsys.yiq_to_rgb(y, i, q)", "intent": "Convert the color from YIQ coordinates to RGB coordinates . With arguments `y`, `i`, `q`.", "question_id": 1404}
{"snippet": "colorsys.rgb_to_hls(r, g, b)", "intent": "Convert the color from RGB coordinates to HLS coordinates . With arguments `r`, `g`, `b`.", "question_id": 1405}
{"snippet": "colorsys.hls_to_rgb(h, l, s)", "intent": "Convert the color from HLS coordinates to RGB coordinates . With arguments `h`, `l`, `s`.", "question_id": 1406}
{"snippet": "colorsys.rgb_to_hsv(r, g, b)", "intent": "Convert the color from RGB coordinates to HSV coordinates . With arguments `r`, `g`, `b`.", "question_id": 1407}
{"snippet": "colorsys.hsv_to_rgb(h, s, v)", "intent": "Convert the color from HSV coordinates to RGB coordinates . With arguments `h`, `s`, `v`.", "question_id": 1408}
{"snippet": "compileall.compile_dir(dir)", "intent": "Recursively descend the directory tree named by `dir` , compiling all .py files along the way .", "question_id": 1409}
{"snippet": "compileall.compile_dir(dir, maxlevels=10)", "intent": "Recursively descend the directory tree named by `dir` , compiling all .py files along the way . The `maxlevels` parameter is used to limit the depth of the recursion ; it defaults to 10 .", "question_id": 1410}
{"snippet": "compileall.compile_dir(dir, ddir=None)", "intent": "Recursively descend the directory tree named by `dir` , compiling all .py files along the way . If `ddir` is given , it is prepended to the path to each file being compiled for use in compilation time tracebacks , and is also compiled in to the byte-code file , where it will be used in tracebacks and other messages in cases where the source file does not exist at the time the byte-code file is executed .", "question_id": 1411}
{"snippet": "compileall.compile_dir(dir, force=False)", "intent": "Recursively descend the directory tree named by `dir` , compiling all .py files along the way . If `force` is true , modules are re-compiled even if the timestamps are up to date .", "question_id": 1412}
{"snippet": "compileall.compile_dir(dir, rx=None)", "intent": "Recursively descend the directory tree named by `dir` , compiling all .py files along the way . If `rx` is given , its search method is called on the complete path to each file considered for compilation , and if it returns a true value , the file is skipped .", "question_id": 1413}
{"snippet": "compileall.compile_dir(dir, quiet=0)", "intent": "Recursively descend the directory tree named by `dir` , compiling all .py files along the way . If `quiet` is False or 0 ( the default ) , the filenames and other information are printed to standard out .", "question_id": 1414}
{"snippet": "compileall.compile_dir(dir, legacy=False)", "intent": "Recursively descend the directory tree named by `dir` , compiling all .py files along the way . If `legacy` is true , byte-code files are written to their legacy locations and names , which may overwrite byte-code files created by another version of Python .", "question_id": 1415}
{"snippet": "compileall.compile_dir(dir, optimize=-1)", "intent": "Recursively descend the directory tree named by `dir` , compiling all .py files along the way . `optimize` specifies the optimization level for the compiler .", "question_id": 1416}
{"snippet": "compileall.compile_dir(dir, workers=1)", "intent": "Recursively descend the directory tree named by `dir` , compiling all .py files along the way . The argument `workers` specifies how many workers are used to compile files in parallel .", "question_id": 1417}
{"snippet": "compileall.compile_dir(dir, invalidation_mode=py_compile.PycInvalidationMode.TIMESTAMP)", "intent": "Recursively descend the directory tree named by `dir` , compiling all .py files along the way . `invalidation_mode` should be a member of the py_compile.PycInvalidationMode enum and controls how the generated pycs are invalidated at runtime .", "question_id": 1418}
{"snippet": "compileall.compile_file(fullname)", "intent": "Compile the file with path `fullname` .", "question_id": 1419}
{"snippet": "compileall.compile_file(fullname, ddir=None)", "intent": "Compile the file with path `fullname` . If `ddir` is given , it is prepended to the path to the file being compiled for use in compilation time tracebacks , and is also compiled in to the byte-code file , where it will be used in tracebacks and other messages in cases where the source file does not exist at the time the byte-code file is executed .", "question_id": 1420}
{"snippet": "compileall.compile_file(fullname, force=False)", "intent": "Compile the file with path `fullname` . With arguments `force`.", "question_id": 1421}
{"snippet": "compileall.compile_file(fullname, rx=None)", "intent": "Compile the file with path `fullname` . If `rx` is given , its search method is passed the full path name to the file being compiled , and if it returns a true value , the file is not compiled and True is returned .", "question_id": 1422}
{"snippet": "compileall.compile_file(fullname, quiet=0)", "intent": "Compile the file with path `fullname` . If `quiet` is False or 0 ( the default ) , the filenames and other information are printed to standard out .", "question_id": 1423}
{"snippet": "compileall.compile_file(fullname, legacy=False)", "intent": "Compile the file with path `fullname` . If `legacy` is true , byte-code files are written to their legacy locations and names , which may overwrite byte-code files created by another version of Python .", "question_id": 1424}
{"snippet": "compileall.compile_file(fullname, optimize=-1)", "intent": "Compile the file with path `fullname` . `optimize` specifies the optimization level for the compiler .", "question_id": 1425}
{"snippet": "compileall.compile_file(fullname, invalidation_mode=py_compile.PycInvalidationMode.TIMESTAMP)", "intent": "Compile the file with path `fullname` . `invalidation_mode` should be a member of the py_compile.PycInvalidationMode enum and controls how the generated pycs are invalidated at runtime .", "question_id": 1426}
{"snippet": "compileall.compile_file(fullname, ddir=None, force=False)", "intent": "Compile the file with path `fullname` . If `ddir` is given , it is prepended to the path to the file being compiled for use in compilation time tracebacks , and is also compiled in to the byte-code file , where it will be used in tracebacks and other messages in cases where the source file does not exist at the time the byte-code file is executed . With arguments `force`.", "question_id": 1427}
{"snippet": "compileall.compile_file(fullname, ddir=None, rx=None)", "intent": "Compile the file with path `fullname` . If `ddir` is given , it is prepended to the path to the file being compiled for use in compilation time tracebacks , and is also compiled in to the byte-code file , where it will be used in tracebacks and other messages in cases where the source file does not exist at the time the byte-code file is executed . If `rx` is given , its search method is passed the full path name to the file being compiled , and if it returns a true value , the file is not compiled and True is returned .", "question_id": 1428}
{"snippet": "compileall.compile_path()", "intent": "Byte-compile all the .py files found along sys.path .", "question_id": 1429}
{"snippet": "compileall.compile_path(skip_curdir=True)", "intent": "Byte-compile all the .py files found along sys.path . If `skip_curdir` is true ( the default ) , the current directory is not included in the search .", "question_id": 1430}
{"snippet": "compileall.compile_path(maxlevels=0)", "intent": "Byte-compile all the .py files found along sys.path . Note that unlike the other compile functions , `maxlevels` defaults to 0 .", "question_id": 1431}
{"snippet": "compileall.compile_path(force=False)", "intent": "Byte-compile all the .py files found along sys.path . With arguments `force`.", "question_id": 1432}
{"snippet": "compileall.compile_path(quiet=0)", "intent": "Byte-compile all the .py files found along sys.path . With arguments `quiet`.", "question_id": 1433}
{"snippet": "compileall.compile_path(legacy=False)", "intent": "Byte-compile all the .py files found along sys.path . With arguments `legacy`.", "question_id": 1434}
{"snippet": "compileall.compile_path(optimize=-1)", "intent": "Byte-compile all the .py files found along sys.path . With arguments `optimize`.", "question_id": 1435}
{"snippet": "compileall.compile_path(invalidation_mode=py_compile.PycInvalidationMode.TIMESTAMP)", "intent": "Byte-compile all the .py files found along sys.path . With arguments `invalidation_mode`.", "question_id": 1436}
{"snippet": "compileall.compile_path(skip_curdir=True, maxlevels=0)", "intent": "Byte-compile all the .py files found along sys.path . If `skip_curdir` is true ( the default ) , the current directory is not included in the search . Note that unlike the other compile functions , `maxlevels` defaults to 0 .", "question_id": 1437}
{"snippet": "compileall.compile_path(skip_curdir=True, force=False)", "intent": "Byte-compile all the .py files found along sys.path . If `skip_curdir` is true ( the default ) , the current directory is not included in the search . With arguments `force`.", "question_id": 1438}
{"snippet": "concurrent.futures.Executor", "intent": "An abstract class that provides methods to execute calls asynchronously.", "question_id": 1439}
{"snippet": "executor.submit(fn, *args, **kwargs)", "intent": "Schedules the callable , `fn` , to be executed as fn ( `*args` `**kwargs` ) and returns a Future object representing the execution of the callable .", "question_id": 1440}
{"snippet": "executor.map(func, *iterables)", "intent": "Similar to map ( `func` , `*iterables` ) except :", "question_id": 1441}
{"snippet": "executor.map(func, *iterables, timeout=None)", "intent": "Similar to map ( `func` , `*iterables` ) except : The returned iterator raises a concurrent.futures.TimeoutError if __next__ ( ) is called and the result isn \u2019 t available after `timeout` seconds from the original call to Executor.map ( ) .", "question_id": 1442}
{"snippet": "executor.map(func, *iterables, chunksize=1)", "intent": "Similar to map ( `func` , `*iterables` ) except : The ( approximate ) size of these chunks can be specified by setting `chunksize` to a positive integer .", "question_id": 1443}
{"snippet": "executor.map(func, *iterables, timeout=None, chunksize=1)", "intent": "Similar to map ( `func` , `*iterables` ) except : The returned iterator raises a concurrent.futures.TimeoutError if __next__ ( ) is called and the result isn \u2019 t available after `timeout` seconds from the original call to Executor.map ( ) . The ( approximate ) size of these chunks can be specified by setting `chunksize` to a positive integer .", "question_id": 1444}
{"snippet": "executor.shutdown()", "intent": "Signal the executor that it should free any resources that it is using when the currently pending futures are done executing .", "question_id": 1445}
{"snippet": "executor.shutdown(wait=True)", "intent": "Signal the executor that it should free any resources that it is using when the currently pending futures are done executing . If `wait` is True then this method will not return until all the pending futures are done executing and the resources associated with the executor have been freed .", "question_id": 1446}
{"snippet": "concurrent.futures.ThreadPoolExecutor()", "intent": "An Executor subclass that uses a pool of at most `max_workers` threads to execute calls asynchronously .", "question_id": 1447}
{"snippet": "concurrent.futures.ThreadPoolExecutor(max_workers=None)", "intent": "An Executor subclass that uses a pool of at most `max_workers` threads to execute calls asynchronously .", "question_id": 1448}
{"snippet": "concurrent.futures.ThreadPoolExecutor(thread_name_prefix='')", "intent": "An Executor subclass that uses a pool of at most `max_workers` threads to execute calls asynchronously . With arguments `thread_name_prefix`.", "question_id": 1449}
{"snippet": "concurrent.futures.ThreadPoolExecutor(initializer=None)", "intent": "An Executor subclass that uses a pool of at most `max_workers` threads to execute calls asynchronously . `initializer` is an optional callable that is called at the start of each worker thread ; `initargs` is a tuple of arguments passed to the initializer .", "question_id": 1450}
{"snippet": "concurrent.futures.ThreadPoolExecutor(initargs=())", "intent": "An Executor subclass that uses a pool of at most `max_workers` threads to execute calls asynchronously . `initializer` is an optional callable that is called at the start of each worker thread ; `initargs` is a tuple of arguments passed to the initializer .", "question_id": 1451}
{"snippet": "concurrent.futures.ThreadPoolExecutor(max_workers=None, thread_name_prefix='')", "intent": "An Executor subclass that uses a pool of at most `max_workers` threads to execute calls asynchronously . With arguments `thread_name_prefix`.", "question_id": 1452}
{"snippet": "concurrent.futures.ThreadPoolExecutor(max_workers=None, initializer=None)", "intent": "An Executor subclass that uses a pool of at most `max_workers` threads to execute calls asynchronously . `initializer` is an optional callable that is called at the start of each worker thread ; `initargs` is a tuple of arguments passed to the initializer .", "question_id": 1453}
{"snippet": "concurrent.futures.ThreadPoolExecutor(max_workers=None, initargs=())", "intent": "An Executor subclass that uses a pool of at most `max_workers` threads to execute calls asynchronously . `initializer` is an optional callable that is called at the start of each worker thread ; `initargs` is a tuple of arguments passed to the initializer .", "question_id": 1454}
{"snippet": "concurrent.futures.ThreadPoolExecutor(thread_name_prefix='', initializer=None)", "intent": "An Executor subclass that uses a pool of at most `max_workers` threads to execute calls asynchronously . `initializer` is an optional callable that is called at the start of each worker thread ; `initargs` is a tuple of arguments passed to the initializer . With arguments `thread_name_prefix`.", "question_id": 1455}
{"snippet": "concurrent.futures.ThreadPoolExecutor(thread_name_prefix='', initargs=())", "intent": "An Executor subclass that uses a pool of at most `max_workers` threads to execute calls asynchronously . `initializer` is an optional callable that is called at the start of each worker thread ; `initargs` is a tuple of arguments passed to the initializer . With arguments `thread_name_prefix`.", "question_id": 1456}
{"snippet": "concurrent.futures.ProcessPoolExecutor()", "intent": "An Executor subclass that executes calls asynchronously using a pool of at most `max_workers` processes .", "question_id": 1457}
{"snippet": "concurrent.futures.ProcessPoolExecutor(max_workers=None)", "intent": "An Executor subclass that executes calls asynchronously using a pool of at most `max_workers` processes .", "question_id": 1458}
{"snippet": "concurrent.futures.ProcessPoolExecutor(mp_context=None)", "intent": "An Executor subclass that executes calls asynchronously using a pool of at most `max_workers` processes . `mp_context` can be a multiprocessing context or None .", "question_id": 1459}
{"snippet": "concurrent.futures.ProcessPoolExecutor(initializer=None)", "intent": "An Executor subclass that executes calls asynchronously using a pool of at most `max_workers` processes . `initializer` is an optional callable that is called at the start of each worker process ; `initargs` is a tuple of arguments passed to the initializer .", "question_id": 1460}
{"snippet": "concurrent.futures.ProcessPoolExecutor(initargs=())", "intent": "An Executor subclass that executes calls asynchronously using a pool of at most `max_workers` processes . `initializer` is an optional callable that is called at the start of each worker process ; `initargs` is a tuple of arguments passed to the initializer .", "question_id": 1461}
{"snippet": "concurrent.futures.ProcessPoolExecutor(max_workers=None, mp_context=None)", "intent": "An Executor subclass that executes calls asynchronously using a pool of at most `max_workers` processes . `mp_context` can be a multiprocessing context or None .", "question_id": 1462}
{"snippet": "concurrent.futures.ProcessPoolExecutor(max_workers=None, initializer=None)", "intent": "An Executor subclass that executes calls asynchronously using a pool of at most `max_workers` processes . `initializer` is an optional callable that is called at the start of each worker process ; `initargs` is a tuple of arguments passed to the initializer .", "question_id": 1463}
{"snippet": "concurrent.futures.ProcessPoolExecutor(max_workers=None, initargs=())", "intent": "An Executor subclass that executes calls asynchronously using a pool of at most `max_workers` processes . `initializer` is an optional callable that is called at the start of each worker process ; `initargs` is a tuple of arguments passed to the initializer .", "question_id": 1464}
{"snippet": "concurrent.futures.ProcessPoolExecutor(mp_context=None, initializer=None)", "intent": "An Executor subclass that executes calls asynchronously using a pool of at most `max_workers` processes . `mp_context` can be a multiprocessing context or None . `initializer` is an optional callable that is called at the start of each worker process ; `initargs` is a tuple of arguments passed to the initializer .", "question_id": 1465}
{"snippet": "concurrent.futures.ProcessPoolExecutor(mp_context=None, initargs=())", "intent": "An Executor subclass that executes calls asynchronously using a pool of at most `max_workers` processes . `mp_context` can be a multiprocessing context or None . `initializer` is an optional callable that is called at the start of each worker process ; `initargs` is a tuple of arguments passed to the initializer .", "question_id": 1466}
{"snippet": "concurrent.futures.Future", "intent": "Encapsulates the asynchronous execution of a callable.", "question_id": 1467}
{"snippet": "future.cancel()", "intent": "Attempt to cancel the call .", "question_id": 1468}
{"snippet": "future.cancelled()", "intent": "Return True if the call was successfully cancelled .", "question_id": 1469}
{"snippet": "future.running()", "intent": "Return True if the call is currently being executed and can not be cancelled .", "question_id": 1470}
{"snippet": "future.done()", "intent": "Return True if the call was successfully cancelled or finished running .", "question_id": 1471}
{"snippet": "future.result()", "intent": "Return the value returned by the call .", "question_id": 1472}
{"snippet": "future.result(timeout=None)", "intent": "Return the value returned by the call . If the call hasn \u2019 t yet completed then this method will wait up to `timeout` seconds .", "question_id": 1473}
{"snippet": "future.exception()", "intent": "Return the exception raised by the call .", "question_id": 1474}
{"snippet": "future.exception(timeout=None)", "intent": "Return the exception raised by the call . If the call hasn \u2019 t yet completed then this method will wait up to `timeout` seconds .", "question_id": 1475}
{"snippet": "future.add_done_callback(fn)", "intent": "Attaches the callable `fn` to the future .", "question_id": 1476}
{"snippet": "future.set_running_or_notify_cancel()", "intent": "This method should only be called by Executor implementations before executing the work associated with the Future and by unit tests .", "question_id": 1477}
{"snippet": "future.set_result(result)", "intent": "Sets the `result` of the work associated with the Future to result .", "question_id": 1478}
{"snippet": "future.set_exception(exception)", "intent": "Sets the result of the work associated with the Future to the Exception `exception` .", "question_id": 1479}
{"snippet": "concurrent.futures.wait(fs)", "intent": "Wait for the Future instances ( possibly created by different Executor instances ) given by `fs` to complete .", "question_id": 1480}
{"snippet": "concurrent.futures.wait(fs, timeout=None)", "intent": "Wait for the Future instances ( possibly created by different Executor instances ) given by `fs` to complete . `timeout` can be used to control the maximum number of seconds to wait before returning .", "question_id": 1481}
{"snippet": "concurrent.futures.wait(fs, return_when=ALL_COMPLETED)", "intent": "Wait for the Future instances ( possibly created by different Executor instances ) given by `fs` to complete . `return_when` indicates when this function should return .", "question_id": 1482}
{"snippet": "concurrent.futures.wait(fs, timeout=None, return_when=ALL_COMPLETED)", "intent": "Wait for the Future instances ( possibly created by different Executor instances ) given by `fs` to complete . `timeout` can be used to control the maximum number of seconds to wait before returning . `return_when` indicates when this function should return .", "question_id": 1483}
{"snippet": "concurrent.futures.as_completed(fs)", "intent": "Returns an iterator over the Future instances ( possibly created by different Executor instances ) given by `fs` that yields futures as they complete ( finished or cancelled futures ) .", "question_id": 1484}
{"snippet": "concurrent.futures.as_completed(fs, timeout=None)", "intent": "Returns an iterator over the Future instances ( possibly created by different Executor instances ) given by `fs` that yields futures as they complete ( finished or cancelled futures ) . The returned iterator raises a concurrent.futures.TimeoutError if __next__ ( ) is called and the result isn \u2019 t available after `timeout` seconds from the original call to as_completed ( ) .", "question_id": 1485}
{"snippet": "concurrent.futures.CancelledError", "intent": "Raised when a future is cancelled.", "question_id": 1486}
{"snippet": "concurrent.futures.TimeoutError", "intent": "Raised when a future operation exceeds the given timeout.", "question_id": 1487}
{"snippet": "concurrent.futures.BrokenExecutor", "intent": "Derived from RuntimeError, this exception class is raised when an executor is broken for some reason, and cannot be used to submit or execute new tasks.", "question_id": 1488}
{"snippet": "concurrent.futures.thread.BrokenThreadPool", "intent": "Derived from BrokenExecutor, this exception class is raised when one of the workers of a ThreadPoolExecutor has failed initializing.", "question_id": 1489}
{"snippet": "concurrent.futures.process.BrokenProcessPool", "intent": "Derived from BrokenExecutor (formerly RuntimeError), this exception class is raised when one of the workers of a ProcessPoolExecutor has terminated in a non-clean fashion (for example, if it was killed from the outside).", "question_id": 1490}
{"snippet": "configparser.BasicInterpolation", "intent": "The default implementation used by ConfigParser.", "question_id": 1491}
{"snippet": "configparser.ExtendedInterpolation", "intent": "An alternative handler for interpolation which implements a more advanced syntax, used for instance in zc.buildout.", "question_id": 1492}
{"snippet": "ConfigParser.BOOLEAN_STATES", "intent": "By default when using getboolean(), config parsers consider the following values True: '1', 'yes', 'true', 'on' and the following values False: '0', 'no', 'false', 'off'.", "question_id": 1493}
{"snippet": "ConfigParser.optionxform(option)", "intent": "This method transforms `option` names on every read , get , or set operation .", "question_id": 1494}
{"snippet": "ConfigParser.SECTCRE", "intent": "A compiled regular expression used to parse section headers.", "question_id": 1495}
{"snippet": "configparser.ConfigParser(':'), ';'))", "intent": "The main configuration parser . With arguments `':')`, `';')`.", "question_id": 1496}
{"snippet": "configparser.ConfigParser(':'), ';'), defaults=None)", "intent": "The main configuration parser . When `defaults` is given , it is initialized into the dictionary of intrinsic defaults . With arguments `':')`, `';')`.", "question_id": 1497}
{"snippet": "configparser.ConfigParser(':'), ';'), dict_type=collections.OrderedDict)", "intent": "The main configuration parser . When `dict_type` is given , it will be used to create the dictionary objects for the list of sections , for the options within a section , and for the default values . With arguments `':')`, `';')`.", "question_id": 1498}
{"snippet": "configparser.ConfigParser(':'), ';'), allow_no_value=False)", "intent": "The main configuration parser . When `allow_no_value` is True ( default : False ) , options without values are accepted ; the value held for these is None and they are serialized without the trailing delimiter . With arguments `':')`, `';')`.", "question_id": 1499}
{"snippet": "configparser.ConfigParser(':'), ';'), delimiters=('=')", "intent": "The main configuration parser . When `delimiters` is given , it is used as the set of substrings that divide keys from values . With arguments `':')`, `';')`.", "question_id": 1500}
{"snippet": "configparser.ConfigParser(':'), ';'), comment_prefixes=('#')", "intent": "The main configuration parser . When `comment_prefixes` is given , it will be used as the set of substrings that prefix comments in otherwise empty lines . With arguments `':')`, `';')`.", "question_id": 1501}
{"snippet": "configparser.ConfigParser(':'), ';'), inline_comment_prefixes=None)", "intent": "The main configuration parser . When `inline_comment_prefixes` is given , it will be used as the set of substrings that prefix comments in non-empty lines . With arguments `':')`, `';')`.", "question_id": 1502}
{"snippet": "configparser.ConfigParser(':'), ';'), strict=True)", "intent": "The main configuration parser . When `strict` is True ( the default ) , the parser won \u2019 t allow for any section or option duplicates while reading from a single source ( file , string or dictionary ) , raising DuplicateSectionError or DuplicateOptionError . With arguments `':')`, `';')`.", "question_id": 1503}
{"snippet": "configparser.ConfigParser(':'), ';'), empty_lines_in_values=True)", "intent": "The main configuration parser . When `empty_lines_in_values` is False ( default : True ) , each empty line marks the end of an option . With arguments `':')`, `';')`.", "question_id": 1504}
{"snippet": "configparser.ConfigParser(':'), ';'), default_section=configparser.DEFAULTSECT)", "intent": "The main configuration parser . When `default_section` is given , it specifies the name for the special section holding default values for other sections and `interpolation` purposes ( normally named `` DEFAULT '' ) . With arguments `':')`, `';')`.", "question_id": 1505}
{"snippet": "config_parser.defaults()", "intent": "Return a dictionary containing the instance-wide defaults .", "question_id": 1506}
{"snippet": "config_parser.sections()", "intent": "Return a list of the sections available ; the default section is not included in the list .", "question_id": 1507}
{"snippet": "config_parser.add_section(section)", "intent": "Add a `section` named section to the instance .", "question_id": 1508}
{"snippet": "config_parser.has_section(section)", "intent": "Indicates whether the named `section` is present in the configuration .", "question_id": 1509}
{"snippet": "config_parser.options(section)", "intent": "Return a list of options available in the specified `section` .", "question_id": 1510}
{"snippet": "config_parser.has_option(section, option)", "intent": "If the given `section` exists , and contains the given `option` , return True ; otherwise return False .", "question_id": 1511}
{"snippet": "config_parser.read(filenames)", "intent": "Attempt to read and parse an iterable of `filenames` , returning a list of filenames which were successfully parsed .", "question_id": 1512}
{"snippet": "config_parser.read(filenames, encoding=None)", "intent": "Attempt to read and parse an iterable of `filenames` , returning a list of filenames which were successfully parsed . With arguments `encoding`.", "question_id": 1513}
{"snippet": "config_parser.read_file(f)", "intent": "Read and parse configuration data from `f` which must be an iterable yielding Unicode strings ( for example files opened in text mode ) .", "question_id": 1514}
{"snippet": "config_parser.read_file(f, source=None)", "intent": "Read and parse configuration data from `f` which must be an iterable yielding Unicode strings ( for example files opened in text mode ) . Optional argument `source` specifies the name of the file being read .", "question_id": 1515}
{"snippet": "config_parser.read_string(string)", "intent": "Parse configuration data from a `string` .", "question_id": 1516}
{"snippet": "config_parser.read_string(string, source='<string>')", "intent": "Parse configuration data from a `string` . Optional argument `source` specifies a context-specific name of the string passed .", "question_id": 1517}
{"snippet": "config_parser.read_dict(dictionary)", "intent": "Load configuration from any object that provides a dict-like items ( ) method . If the used `dictionary` type preserves order , sections and their keys will be added in order .", "question_id": 1518}
{"snippet": "config_parser.read_dict(dictionary, source='<dict>')", "intent": "Load configuration from any object that provides a dict-like items ( ) method . If the used `dictionary` type preserves order , sections and their keys will be added in order . Optional argument `source` specifies a context-specific name of the dictionary passed .", "question_id": 1519}
{"snippet": "config_parser.get(section, option, fallback)", "intent": "Get an `option` value for the named `section` . If the key is not found and `fallback` is provided , it is used as a fallback value .", "question_id": 1520}
{"snippet": "config_parser.get(section, option, fallback, raw=False)", "intent": "Get an `option` value for the named `section` . If the key is not found and `fallback` is provided , it is used as a fallback value . All the ' % ' interpolations are expanded in the return values , unless the `raw` argument is true .", "question_id": 1521}
{"snippet": "config_parser.get(section, option, fallback, vars=None)", "intent": "Get an `option` value for the named `section` . If the key is not found and `fallback` is provided , it is used as a fallback value . If `vars` is provided , it must be a dictionary .", "question_id": 1522}
{"snippet": "config_parser.get(section, option, fallback, raw=False, vars=None)", "intent": "Get an `option` value for the named `section` . If the key is not found and `fallback` is provided , it is used as a fallback value . All the ' % ' interpolations are expanded in the return values , unless the `raw` argument is true . If `vars` is provided , it must be a dictionary .", "question_id": 1523}
{"snippet": "config_parser.get(section, option)", "intent": "Get an `option` value for the named `section` .", "question_id": 1524}
{"snippet": "config_parser.get(section, option, raw=False)", "intent": "Get an `option` value for the named `section` . All the ' % ' interpolations are expanded in the return values , unless the `raw` argument is true .", "question_id": 1525}
{"snippet": "config_parser.get(section, option, vars=None)", "intent": "Get an `option` value for the named `section` . If `vars` is provided , it must be a dictionary .", "question_id": 1526}
{"snippet": "config_parser.get(section, option, raw=False, vars=None)", "intent": "Get an `option` value for the named `section` . All the ' % ' interpolations are expanded in the return values , unless the `raw` argument is true . If `vars` is provided , it must be a dictionary .", "question_id": 1527}
{"snippet": "config_parser.getint(section, option, fallback)", "intent": "A convenience method which coerces the `option` in the specified `section` to an integer . See get ( ) for explanation of `raw` , `vars` and `fallback` .", "question_id": 1528}
{"snippet": "config_parser.getint(section, option, fallback, raw=False)", "intent": "A convenience method which coerces the `option` in the specified `section` to an integer . See get ( ) for explanation of `raw` , `vars` and `fallback` .", "question_id": 1529}
{"snippet": "config_parser.getint(section, option, fallback, vars=None)", "intent": "A convenience method which coerces the `option` in the specified `section` to an integer . See get ( ) for explanation of `raw` , `vars` and `fallback` .", "question_id": 1530}
{"snippet": "config_parser.getint(section, option, fallback, raw=False, vars=None)", "intent": "A convenience method which coerces the `option` in the specified `section` to an integer . See get ( ) for explanation of `raw` , `vars` and `fallback` .", "question_id": 1531}
{"snippet": "config_parser.getint(section, option)", "intent": "A convenience method which coerces the `option` in the specified `section` to an integer .", "question_id": 1532}
{"snippet": "config_parser.getint(section, option, raw=False)", "intent": "A convenience method which coerces the `option` in the specified `section` to an integer . See get ( ) for explanation of `raw` , `vars` and `fallback` .", "question_id": 1533}
{"snippet": "config_parser.getint(section, option, vars=None)", "intent": "A convenience method which coerces the `option` in the specified `section` to an integer . See get ( ) for explanation of `raw` , `vars` and `fallback` .", "question_id": 1534}
{"snippet": "config_parser.getint(section, option, raw=False, vars=None)", "intent": "A convenience method which coerces the `option` in the specified `section` to an integer . See get ( ) for explanation of `raw` , `vars` and `fallback` .", "question_id": 1535}
{"snippet": "config_parser.getfloat(section, option, fallback)", "intent": "A convenience method which coerces the `option` in the specified `section` to a floating point number . See get ( ) for explanation of `raw` , `vars` and `fallback` .", "question_id": 1536}
{"snippet": "config_parser.getfloat(section, option, fallback, raw=False)", "intent": "A convenience method which coerces the `option` in the specified `section` to a floating point number . See get ( ) for explanation of `raw` , `vars` and `fallback` .", "question_id": 1537}
{"snippet": "config_parser.getfloat(section, option, fallback, vars=None)", "intent": "A convenience method which coerces the `option` in the specified `section` to a floating point number . See get ( ) for explanation of `raw` , `vars` and `fallback` .", "question_id": 1538}
{"snippet": "config_parser.getfloat(section, option, fallback, raw=False, vars=None)", "intent": "A convenience method which coerces the `option` in the specified `section` to a floating point number . See get ( ) for explanation of `raw` , `vars` and `fallback` .", "question_id": 1539}
{"snippet": "config_parser.getfloat(section, option)", "intent": "A convenience method which coerces the `option` in the specified `section` to a floating point number .", "question_id": 1540}
{"snippet": "config_parser.getfloat(section, option, raw=False)", "intent": "A convenience method which coerces the `option` in the specified `section` to a floating point number . See get ( ) for explanation of `raw` , `vars` and `fallback` .", "question_id": 1541}
{"snippet": "config_parser.getfloat(section, option, vars=None)", "intent": "A convenience method which coerces the `option` in the specified `section` to a floating point number . See get ( ) for explanation of `raw` , `vars` and `fallback` .", "question_id": 1542}
{"snippet": "config_parser.getfloat(section, option, raw=False, vars=None)", "intent": "A convenience method which coerces the `option` in the specified `section` to a floating point number . See get ( ) for explanation of `raw` , `vars` and `fallback` .", "question_id": 1543}
{"snippet": "config_parser.getboolean(section, option, fallback)", "intent": "A convenience method which coerces the `option` in the specified `section` to a Boolean value . See get ( ) for explanation of `raw` , `vars` and `fallback` .", "question_id": 1544}
{"snippet": "config_parser.getboolean(section, option, fallback, raw=False)", "intent": "A convenience method which coerces the `option` in the specified `section` to a Boolean value . See get ( ) for explanation of `raw` , `vars` and `fallback` .", "question_id": 1545}
{"snippet": "config_parser.getboolean(section, option, fallback, vars=None)", "intent": "A convenience method which coerces the `option` in the specified `section` to a Boolean value . See get ( ) for explanation of `raw` , `vars` and `fallback` .", "question_id": 1546}
{"snippet": "config_parser.getboolean(section, option, fallback, raw=False, vars=None)", "intent": "A convenience method which coerces the `option` in the specified `section` to a Boolean value . See get ( ) for explanation of `raw` , `vars` and `fallback` .", "question_id": 1547}
{"snippet": "config_parser.getboolean(section, option)", "intent": "A convenience method which coerces the `option` in the specified `section` to a Boolean value .", "question_id": 1548}
{"snippet": "config_parser.getboolean(section, option, raw=False)", "intent": "A convenience method which coerces the `option` in the specified `section` to a Boolean value . See get ( ) for explanation of `raw` , `vars` and `fallback` .", "question_id": 1549}
{"snippet": "config_parser.getboolean(section, option, vars=None)", "intent": "A convenience method which coerces the `option` in the specified `section` to a Boolean value . See get ( ) for explanation of `raw` , `vars` and `fallback` .", "question_id": 1550}
{"snippet": "config_parser.getboolean(section, option, raw=False, vars=None)", "intent": "A convenience method which coerces the `option` in the specified `section` to a Boolean value . See get ( ) for explanation of `raw` , `vars` and `fallback` .", "question_id": 1551}
{"snippet": "config_parser.items()", "intent": "When section is not given , return a list of section_name , section_proxy pairs , including DEFAULTSECT .", "question_id": 1552}
{"snippet": "config_parser.items(raw=False)", "intent": "When section is not given , return a list of section_name , section_proxy pairs , including DEFAULTSECT . With arguments `raw`.", "question_id": 1553}
{"snippet": "config_parser.items(vars=None)", "intent": "When section is not given , return a list of section_name , section_proxy pairs , including DEFAULTSECT . With arguments `vars`.", "question_id": 1554}
{"snippet": "config_parser.items(raw=False, vars=None)", "intent": "When section is not given , return a list of section_name , section_proxy pairs , including DEFAULTSECT . With arguments `raw`, `vars`.", "question_id": 1555}
{"snippet": "config_parser.items(section)", "intent": "When `section` is not given , return a list of section_name , section_proxy pairs , including DEFAULTSECT .", "question_id": 1556}
{"snippet": "config_parser.items(section, raw=False)", "intent": "When `section` is not given , return a list of section_name , section_proxy pairs , including DEFAULTSECT . With arguments `raw`.", "question_id": 1557}
{"snippet": "config_parser.items(section, vars=None)", "intent": "When `section` is not given , return a list of section_name , section_proxy pairs , including DEFAULTSECT . With arguments `vars`.", "question_id": 1558}
{"snippet": "config_parser.items(section, raw=False, vars=None)", "intent": "When `section` is not given , return a list of section_name , section_proxy pairs , including DEFAULTSECT . With arguments `raw`, `vars`.", "question_id": 1559}
{"snippet": "config_parser.set(section, option, value)", "intent": "If the given `section` exists , set the given `option` to the specified `value` ; otherwise raise NoSectionError .", "question_id": 1560}
{"snippet": "config_parser.write(fileobject)", "intent": "Write a representation of the configuration to the specified file object , which must be opened in text mode ( accepting strings ) . With arguments `fileobject`.", "question_id": 1561}
{"snippet": "config_parser.write(fileobject, space_around_delimiters=True)", "intent": "Write a representation of the configuration to the specified file object , which must be opened in text mode ( accepting strings ) . If `space_around_delimiters` is true , delimiters between keys and values are surrounded by spaces . With arguments `fileobject`.", "question_id": 1562}
{"snippet": "config_parser.remove_option(section, option)", "intent": "Remove the specified `option` from the specified `section` .", "question_id": 1563}
{"snippet": "config_parser.remove_section(section)", "intent": "Remove the specified `section` from the configuration .", "question_id": 1564}
{"snippet": "config_parser.optionxform(option)", "intent": "Transforms the `option` name option as found in an input file or as passed in by client code to the form that should be used in the internal structures .", "question_id": 1565}
{"snippet": "config_parser.readfp(fp)", "intent": "For existing code calling readfp ( ) with arguments which don \u2019 t support iteration , the following generator may be used as a wrapper around the file-like object : Instead of parser.readfp ( `fp` ) use parser.read_file ( readline_generator ( fp ) ) .", "question_id": 1566}
{"snippet": "config_parser.readfp(fp, filename=None)", "intent": "For existing code calling readfp ( ) with arguments which don \u2019 t support iteration , the following generator may be used as a wrapper around the file-like object : Instead of parser.readfp ( `fp` ) use parser.read_file ( readline_generator ( fp ) ) . With arguments `filename`.", "question_id": 1567}
{"snippet": "configparser.MAX_INTERPOLATION_DEPTH", "intent": "The maximum depth for recursive interpolation for get() when the raw parameter is false.", "question_id": 1568}
{"snippet": "configparser.RawConfigParser(':'), ';'), interpolation)", "intent": "Legacy variant of the ConfigParser . It has `interpolation` disabled by default and allows for non-string section names , option names , and values via its unsafe add_section and set methods , as well as the legacy defaults= keyword argument handling . With arguments `':')`, `';')`.", "question_id": 1569}
{"snippet": "configparser.RawConfigParser(':'), ';'), interpolation, defaults=None)", "intent": "Legacy variant of the ConfigParser . It has `interpolation` disabled by default and allows for non-string section names , option names , and values via its unsafe add_section and set methods , as well as the legacy defaults= keyword argument handling . With arguments `':')`, `';')`, `defaults`.", "question_id": 1570}
{"snippet": "configparser.RawConfigParser(':'), ';'), interpolation, dict_type=collections.OrderedDict)", "intent": "Legacy variant of the ConfigParser . It has `interpolation` disabled by default and allows for non-string section names , option names , and values via its unsafe add_section and set methods , as well as the legacy defaults= keyword argument handling . With arguments `':')`, `';')`, `dict_type`.", "question_id": 1571}
{"snippet": "configparser.RawConfigParser(':'), ';'), interpolation, allow_no_value=False)", "intent": "Legacy variant of the ConfigParser . It has `interpolation` disabled by default and allows for non-string section names , option names , and values via its unsafe add_section and set methods , as well as the legacy defaults= keyword argument handling . With arguments `':')`, `';')`, `allow_no_value`.", "question_id": 1572}
{"snippet": "configparser.RawConfigParser(':'), ';'), interpolation, delimiters=('=')", "intent": "Legacy variant of the ConfigParser . It has `interpolation` disabled by default and allows for non-string section names , option names , and values via its unsafe add_section and set methods , as well as the legacy defaults= keyword argument handling . With arguments `':')`, `';')`, `delimiters`.", "question_id": 1573}
{"snippet": "configparser.RawConfigParser(':'), ';'), interpolation, comment_prefixes=('#')", "intent": "Legacy variant of the ConfigParser . It has `interpolation` disabled by default and allows for non-string section names , option names , and values via its unsafe add_section and set methods , as well as the legacy defaults= keyword argument handling . With arguments `':')`, `';')`, `comment_prefixes`.", "question_id": 1574}
{"snippet": "configparser.RawConfigParser(':'), ';'), interpolation, inline_comment_prefixes=None)", "intent": "Legacy variant of the ConfigParser . It has `interpolation` disabled by default and allows for non-string section names , option names , and values via its unsafe add_section and set methods , as well as the legacy defaults= keyword argument handling . With arguments `':')`, `';')`, `inline_comment_prefixes`.", "question_id": 1575}
{"snippet": "configparser.RawConfigParser(':'), ';'), interpolation, strict=True)", "intent": "Legacy variant of the ConfigParser . It has `interpolation` disabled by default and allows for non-string section names , option names , and values via its unsafe add_section and set methods , as well as the legacy defaults= keyword argument handling . With arguments `':')`, `';')`, `strict`.", "question_id": 1576}
{"snippet": "configparser.RawConfigParser(':'), ';'), interpolation, empty_lines_in_values=True)", "intent": "Legacy variant of the ConfigParser . It has `interpolation` disabled by default and allows for non-string section names , option names , and values via its unsafe add_section and set methods , as well as the legacy defaults= keyword argument handling . With arguments `':')`, `';')`, `empty_lines_in_values`.", "question_id": 1577}
{"snippet": "configparser.RawConfigParser(':'), ';'), interpolation, default_section=configparser.DEFAULTSECT)", "intent": "Legacy variant of the ConfigParser . It has `interpolation` disabled by default and allows for non-string section names , option names , and values via its unsafe add_section and set methods , as well as the legacy defaults= keyword argument handling . With arguments `':')`, `';')`, `default_section`.", "question_id": 1578}
{"snippet": "configparser.RawConfigParser(':'), ';'))", "intent": "Legacy variant of the ConfigParser . With arguments `':')`, `';')`.", "question_id": 1579}
{"snippet": "configparser.RawConfigParser(':'), ';'), defaults=None)", "intent": "Legacy variant of the ConfigParser . With arguments `':')`, `';')`, `defaults`.", "question_id": 1580}
{"snippet": "configparser.RawConfigParser(':'), ';'), dict_type=collections.OrderedDict)", "intent": "Legacy variant of the ConfigParser . With arguments `':')`, `';')`, `dict_type`.", "question_id": 1581}
{"snippet": "configparser.RawConfigParser(':'), ';'), allow_no_value=False)", "intent": "Legacy variant of the ConfigParser . With arguments `':')`, `';')`, `allow_no_value`.", "question_id": 1582}
{"snippet": "configparser.RawConfigParser(':'), ';'), delimiters=('=')", "intent": "Legacy variant of the ConfigParser . With arguments `':')`, `';')`, `delimiters`.", "question_id": 1583}
{"snippet": "configparser.RawConfigParser(':'), ';'), comment_prefixes=('#')", "intent": "Legacy variant of the ConfigParser . With arguments `':')`, `';')`, `comment_prefixes`.", "question_id": 1584}
{"snippet": "configparser.RawConfigParser(':'), ';'), inline_comment_prefixes=None)", "intent": "Legacy variant of the ConfigParser . With arguments `':')`, `';')`, `inline_comment_prefixes`.", "question_id": 1585}
{"snippet": "configparser.RawConfigParser(':'), ';'), strict=True)", "intent": "Legacy variant of the ConfigParser . With arguments `':')`, `';')`, `strict`.", "question_id": 1586}
{"snippet": "configparser.RawConfigParser(':'), ';'), empty_lines_in_values=True)", "intent": "Legacy variant of the ConfigParser . With arguments `':')`, `';')`, `empty_lines_in_values`.", "question_id": 1587}
{"snippet": "configparser.RawConfigParser(':'), ';'), default_section=configparser.DEFAULTSECT)", "intent": "Legacy variant of the ConfigParser . With arguments `':')`, `';')`, `default_section`.", "question_id": 1588}
{"snippet": "raw_config_parser.add_section(section)", "intent": "Add a `section` named section to the instance .", "question_id": 1589}
{"snippet": "raw_config_parser.set(section, option, value)", "intent": "If the given `section` exists , set the given `option` to the specified `value` ; otherwise raise NoSectionError .", "question_id": 1590}
{"snippet": "configparser.Error", "intent": "Base class for all other configparser exceptions.", "question_id": 1591}
{"snippet": "configparser.NoSectionError", "intent": "Exception raised when a specified section is not found.", "question_id": 1592}
{"snippet": "configparser.DuplicateSectionError", "intent": "Exception raised if add_section() is called with the name of a section that is already present or in strict parsers when a section if found more than once in a single input file, string or dictionary.", "question_id": 1593}
{"snippet": "configparser.DuplicateOptionError", "intent": "Exception raised by strict parsers if a single option appears twice during reading from a single file, string or dictionary.", "question_id": 1594}
{"snippet": "configparser.NoOptionError", "intent": "Exception raised when a specified option is not found in the specified section.", "question_id": 1595}
{"snippet": "configparser.InterpolationError", "intent": "Base class for exceptions raised when problems occur performing string interpolation.", "question_id": 1596}
{"snippet": "configparser.InterpolationDepthError", "intent": "Exception raised when string interpolation cannot be completed because the number of iterations exceeds MAX_INTERPOLATION_DEPTH.", "question_id": 1597}
{"snippet": "configparser.InterpolationMissingOptionError", "intent": "Exception raised when an option referenced from a value does not exist.", "question_id": 1598}
{"snippet": "configparser.InterpolationSyntaxError", "intent": "Exception raised when the source text into which substitutions are made does not conform to the required syntax.", "question_id": 1599}
{"snippet": "configparser.MissingSectionHeaderError", "intent": "Exception raised when attempting to parse a file which has no section headers.", "question_id": 1600}
{"snippet": "configparser.ParsingError", "intent": "Exception raised when errors occur attempting to parse a file.", "question_id": 1601}
{"snippet": "False", "intent": "The false value of the bool type.", "question_id": 1602}
{"snippet": "True", "intent": "The true value of the bool type.", "question_id": 1603}
{"snippet": "None", "intent": "The sole value of the type NoneType.", "question_id": 1604}
{"snippet": "NotImplemented", "intent": "Special value which should be returned by the binary special methods (e.g.", "question_id": 1605}
{"snippet": "Ellipsis", "intent": "The same as the ellipsis literal \u201c...\u201d.", "question_id": 1606}
{"snippet": "__debug__", "intent": "This constant is true if Python was not started with an -O option.", "question_id": 1607}
{"snippet": "quit()", "intent": "Objects that when printed , print a message like \u201c Use quit ( ) or Ctrl-D ( i.e .", "question_id": 1608}
{"snippet": "quit(code=None)", "intent": "Objects that when printed , print a message like \u201c Use quit ( ) or Ctrl-D ( i.e . EOF ) to exit \u201d , and when called , raise SystemExit with the specified exit `code` .", "question_id": 1609}
{"snippet": "exit()", "intent": "Objects that when printed , print a message like \u201c Use quit ( ) or Ctrl-D ( i.e .", "question_id": 1610}
{"snippet": "exit(code=None)", "intent": "Objects that when printed , print a message like \u201c Use quit ( ) or Ctrl-D ( i.e . EOF ) to exit \u201d , and when called , raise SystemExit with the specified exit `code` .", "question_id": 1611}
{"snippet": "copyright", "intent": "Objects that when printed or called, print the text of copyright or credits, respectively.", "question_id": 1612}
{"snippet": "credits", "intent": "Objects that when printed or called, print the text of copyright or credits, respectively.", "question_id": 1613}
{"snippet": "license", "intent": "Object that when printed, prints the message \u201cType license() to see the full license text\u201d, and when called, displays the full license text in a pager-like fashion (one screen at a time).", "question_id": 1614}
{"snippet": "contextlib.AbstractContextManager", "intent": "An abstract base class for classes that implement object.__enter__() and object.__exit__().", "question_id": 1615}
{"snippet": "contextlib.AbstractAsyncContextManager", "intent": "An abstract base class for classes that implement object.__aenter__() and object.__aexit__().", "question_id": 1616}
{"snippet": "@contextlib.contextmanager", "intent": "This function is a decorator that can be used to define a factory function for with statement context managers, without needing to create a class or separate __enter__() and __exit__() methods.", "question_id": 1617}
{"snippet": "@contextlib.asynccontextmanager", "intent": "Similar to contextmanager(), but creates an asynchronous context manager.", "question_id": 1618}
{"snippet": "contextlib.closing(thing)", "intent": "Return a context manager that closes `thing` upon completion of the block .", "question_id": 1619}
{"snippet": "contextlib.nullcontext()", "intent": "Return a context manager that returns `enter_result` from __enter__ , but otherwise does nothing .", "question_id": 1620}
{"snippet": "contextlib.nullcontext(enter_result=None)", "intent": "Return a context manager that returns `enter_result` from __enter__ , but otherwise does nothing .", "question_id": 1621}
{"snippet": "contextlib.suppress(*exceptions)", "intent": "Return a context manager that suppresses any of the specified exceptions if they occur in the body of a with statement and then resumes execution with the first statement following the end of the with statement . With arguments `*exceptions`.", "question_id": 1622}
{"snippet": "contextlib.redirect_stdout(new_target)", "intent": "Context manager for temporarily redirecting sys.stdout to another file or file-like object . With arguments `new_target`.", "question_id": 1623}
{"snippet": "contextlib.redirect_stderr(new_target)", "intent": "Similar to redirect_stdout ( ) but redirecting sys.stderr to another file or file-like object . With arguments `new_target`.", "question_id": 1624}
{"snippet": "contextlib.ContextDecorator", "intent": "A base class that enables a context manager to also be used as a decorator.", "question_id": 1625}
{"snippet": "contextlib.ExitStack", "intent": "A context manager that is designed to make it easy to programmatically combine other context managers and cleanup functions, especially those that are optional or otherwise driven by input data.", "question_id": 1626}
{"snippet": "exit_stack.enter_context(cm)", "intent": "Enters a new context manager and adds its __exit__ ( ) method to the callback stack . With arguments `cm`.", "question_id": 1627}
{"snippet": "exit_stack.push(exit)", "intent": "Adds a context manager \u2019 s __exit__ ( ) method to the callback stack . With arguments `exit`.", "question_id": 1628}
{"snippet": "exit_stack.callback(callback, *args, **kwds)", "intent": "Accepts an arbitrary `callback` function and arguments and adds it to the callback stack . With arguments `*args`, `**kwds`.", "question_id": 1629}
{"snippet": "exit_stack.pop_all()", "intent": "Transfers the callback stack to a fresh ExitStack instance and returns it .", "question_id": 1630}
{"snippet": "exit_stack.close()", "intent": "Immediately unwinds the callback stack , invoking callbacks in the reverse order of registration .", "question_id": 1631}
{"snippet": "contextlib.AsyncExitStack", "intent": "An asynchronous context manager, similar to ExitStack, that supports combining both synchronous and asynchronous context managers, as well as having coroutines for cleanup logic.", "question_id": 1632}
{"snippet": "async_exit_stack.enter_async_context(cm)", "intent": "Similar to enter_context ( ) but expects an asynchronous context manager . With arguments `cm`.", "question_id": 1633}
{"snippet": "async_exit_stack.push_async_exit(exit)", "intent": "Similar to push ( ) but expects either an asynchronous context manager or a coroutine function . With arguments `exit`.", "question_id": 1634}
{"snippet": "async_exit_stack.push_async_callback(callback, *args, **kwds)", "intent": "Similar to `callback` ( ) but expects a coroutine function . With arguments `*args`, `**kwds`.", "question_id": 1635}
{"snippet": "async_exit_stack.aclose()", "intent": "Similar to close ( ) but properly handles awaitables .", "question_id": 1636}
{"snippet": "contextvars.ContextVar(name, default)", "intent": "This class is used to declare a new Context Variable , e.g . The required `name` parameter is used for introspection and debug purposes . The optional keyword-only `default` parameter is returned by ContextVar.get ( ) when no value for the variable is found in the current context .", "question_id": 1637}
{"snippet": "contextvars.ContextVar(name)", "intent": "This class is used to declare a new Context Variable , e.g . The required `name` parameter is used for introspection and debug purposes .", "question_id": 1638}
{"snippet": "context_var.name", "intent": "The name of the variable.", "question_id": 1639}
{"snippet": "context_var.get(default)", "intent": "Return a value for the context variable for the current context . With arguments `default`.", "question_id": 1640}
{"snippet": "context_var.get()", "intent": "Return a value for the context variable for the current context .", "question_id": 1641}
{"snippet": "context_var.set(value)", "intent": "Call to set a new `value` for the context variable in the current context .", "question_id": 1642}
{"snippet": "context_var.reset(token)", "intent": "Reset the context variable to the value it had before the ContextVar.set ( ) that created the `token` was used .", "question_id": 1643}
{"snippet": "contextvars.Token", "intent": "Token objects are returned by the ContextVar.set() method.", "question_id": 1644}
{"snippet": "Token.var", "intent": "A read-only property.", "question_id": 1645}
{"snippet": "Token.old_value", "intent": "A read-only property.", "question_id": 1646}
{"snippet": "Token.MISSING", "intent": "A marker object used by Token.old_value.", "question_id": 1647}
{"snippet": "contextvars.copy_context()", "intent": "Returns a copy of the current Context object .", "question_id": 1648}
{"snippet": "contextvars.Context", "intent": "A mapping of ContextVars to their values.", "question_id": 1649}
{"snippet": "context.run(callable, *args, **kwargs)", "intent": "Execute `callable` ( `*args` , `**kwargs` ) code in the context object the run method is called on .", "question_id": 1650}
{"snippet": "context.copy()", "intent": "Return a shallow copy of the context object .", "question_id": 1651}
{"snippet": "var in context", "intent": "Return True if the context has a value for var set; return False otherwise.", "question_id": 1652}
{"snippet": "context[var]", "intent": "Return the value of the var ContextVar variable.", "question_id": 1653}
{"snippet": "context.get(var, default)", "intent": "Return the value for `var` if var has the value in the context object . Return `default` otherwise .", "question_id": 1654}
{"snippet": "context.get(var)", "intent": "Return the value for `var` if var has the value in the context object .", "question_id": 1655}
{"snippet": "iter(context)", "intent": "Return an iterator over the variables stored in the `context` object .", "question_id": 1656}
{"snippet": "len(proxy)", "intent": "Return the number of variables set in the context object . With arguments `proxy`.", "question_id": 1657}
{"snippet": "context.keys()", "intent": "Return a list of all variables in the context object .", "question_id": 1658}
{"snippet": "context.values()", "intent": "Return a list of all variables \u2019 values in the context object .", "question_id": 1659}
{"snippet": "context.items()", "intent": "Return a list of 2-tuples containing all variables and their values in the context object .", "question_id": 1660}
{"snippet": "copy.copy(x)", "intent": "Return a shallow copy of `x` .", "question_id": 1661}
{"snippet": "copy.deepcopy(x, memo)", "intent": "Return a deep copy of `x` . With arguments `memo`.", "question_id": 1662}
{"snippet": "copy.deepcopy(x)", "intent": "Return a deep copy of `x` .", "question_id": 1663}
{"snippet": "copy.error", "intent": "Raised for module specific errors.", "question_id": 1664}
{"snippet": "copyreg.constructor(object)", "intent": "Declares `object` to be a valid constructor .", "question_id": 1665}
{"snippet": "copyreg.pickle(type, function)", "intent": "Declares that `function` should be used as a \u201c reduction \u201d function for objects of `type` type .", "question_id": 1666}
{"snippet": "copyreg.pickle(type, function, constructor=None)", "intent": "Declares that `function` should be used as a \u201c reduction \u201d function for objects of `type` type . The optional `constructor` parameter , if provided , is a callable object which can be used to reconstruct the object when called with the tuple of arguments returned by function at pickling time .", "question_id": 1667}
{"snippet": "crypt.METHOD_SHA512", "intent": "A Modular Crypt Format method with 16 character salt and 86 character hash based on the SHA-512 hash function.", "question_id": 1668}
{"snippet": "crypt.METHOD_SHA256", "intent": "Another Modular Crypt Format method with 16 character salt and 43 character hash based on the SHA-256 hash function.", "question_id": 1669}
{"snippet": "crypt.METHOD_BLOWFISH", "intent": "Another Modular Crypt Format method with 22 character salt and 31 character hash based on the Blowfish cipher.", "question_id": 1670}
{"snippet": "crypt.METHOD_MD5", "intent": "Another Modular Crypt Format method with 8 character salt and 22 character hash based on the MD5 hash function.", "question_id": 1671}
{"snippet": "crypt.METHOD_CRYPT", "intent": "The traditional method with a 2 character salt and 13 characters of hash.", "question_id": 1672}
{"snippet": "crypt.methods", "intent": "A list of available password hashing algorithms, as crypt.METHOD_* objects.", "question_id": 1673}
{"snippet": "crypt.crypt(word)", "intent": "`word` will usually be a user \u2019 s password as typed at a prompt or in a graphical interface .", "question_id": 1674}
{"snippet": "crypt.crypt(word, salt=None)", "intent": "`word` will usually be a user \u2019 s password as typed at a prompt or in a graphical interface . The optional `salt` is either a string as returned from mksalt ( ) , one of the crypt.METHOD_* values ( though not all may be available on all platforms ) , or a full encrypted password including salt , as returned by this function .", "question_id": 1675}
{"snippet": "crypt.mksalt()", "intent": "Return a randomly generated salt of the specified `method` .", "question_id": 1676}
{"snippet": "crypt.mksalt(method=None)", "intent": "Return a randomly generated salt of the specified `method` .", "question_id": 1677}
{"snippet": "crypt.mksalt(rounds=None)", "intent": "Return a randomly generated salt of the specified `method` . `rounds` specifies the number of rounds for METHOD_SHA256 , METHOD_SHA512 and METHOD_BLOWFISH .", "question_id": 1678}
{"snippet": "crypt.mksalt(method=None, rounds=None)", "intent": "Return a randomly generated salt of the specified `method` . `rounds` specifies the number of rounds for METHOD_SHA256 , METHOD_SHA512 and METHOD_BLOWFISH .", "question_id": 1679}
{"snippet": "csv.reader(csvfile, **fmtparams)", "intent": "Return a reader object which will iterate over lines in the given `csvfile` . With arguments `**fmtparams`.", "question_id": 1680}
{"snippet": "csv.reader(csvfile, **fmtparams, dialect='excel')", "intent": "Return a reader object which will iterate over lines in the given `csvfile` . 1 An optional `dialect` parameter can be given which is used to define a set of parameters specific to a particular CSV dialect . With arguments `**fmtparams`.", "question_id": 1681}
{"snippet": "csv.writer(csvfile, **fmtparams)", "intent": "Return a writer object responsible for converting the user \u2019 s data into delimited strings on the given file-like object . `csvfile` can be any object with a write ( ) method . With arguments `**fmtparams`.", "question_id": 1682}
{"snippet": "csv.writer(csvfile, **fmtparams, dialect='excel')", "intent": "Return a writer object responsible for converting the user \u2019 s data into delimited strings on the given file-like object . `csvfile` can be any object with a write ( ) method . An optional `dialect` parameter can be given which is used to define a set of parameters specific to a particular CSV dialect . With arguments `**fmtparams`.", "question_id": 1683}
{"snippet": "csv.register_dialect(name, dialect, **fmtparams)", "intent": "Associate `dialect` with `name` . With arguments `**fmtparams`.", "question_id": 1684}
{"snippet": "csv.register_dialect(name, dialect)", "intent": "Associate `dialect` with `name` .", "question_id": 1685}
{"snippet": "csv.register_dialect(name)", "intent": "Associate `dialect` with `name` .", "question_id": 1686}
{"snippet": "csv.unregister_dialect(name)", "intent": "Delete the dialect associated with `name` from the dialect registry .", "question_id": 1687}
{"snippet": "csv.get_dialect(name)", "intent": "Return the dialect associated with `name` .", "question_id": 1688}
{"snippet": "csv.list_dialects()", "intent": "Return the names of all registered dialects .", "question_id": 1689}
{"snippet": "csv.field_size_limit(new_limit)", "intent": "Returns the current maximum field size allowed by the parser . If `new_limit` is given , this becomes the new limit .", "question_id": 1690}
{"snippet": "csv.field_size_limit()", "intent": "Returns the current maximum field size allowed by the parser .", "question_id": 1691}
{"snippet": "csv.DictReader(f, *args, **kwds)", "intent": "Create an object that operates like a regular reader but maps the information in each row to an OrderedDict whose keys are given by the optional `fieldnames` parameter . If fieldnames is omitted , the values in the first row of file `f` will be used as the fieldnames . With arguments `*args`, `**kwds`.", "question_id": 1692}
{"snippet": "csv.DictReader(f, *args, **kwds, fieldnames=None)", "intent": "Create an object that operates like a regular reader but maps the information in each row to an OrderedDict whose keys are given by the optional `fieldnames` parameter . If fieldnames is omitted , the values in the first row of file `f` will be used as the fieldnames . With arguments `*args`, `**kwds`.", "question_id": 1693}
{"snippet": "csv.DictReader(f, *args, **kwds, restkey=None)", "intent": "Create an object that operates like a regular reader but maps the information in each row to an OrderedDict whose keys are given by the optional `fieldnames` parameter . If fieldnames is omitted , the values in the first row of file `f` will be used as the fieldnames . If a row has more fields than fieldnames , the remaining data is put in a list and stored with the fieldname specified by `restkey` ( which defaults to None ) . With arguments `*args`, `**kwds`.", "question_id": 1694}
{"snippet": "csv.DictReader(f, *args, **kwds, restval=None)", "intent": "Create an object that operates like a regular reader but maps the information in each row to an OrderedDict whose keys are given by the optional `fieldnames` parameter . If fieldnames is omitted , the values in the first row of file `f` will be used as the fieldnames . With arguments `*args`, `**kwds`, `restval`.", "question_id": 1695}
{"snippet": "csv.DictReader(f, *args, **kwds, dialect='excel')", "intent": "Create an object that operates like a regular reader but maps the information in each row to an OrderedDict whose keys are given by the optional `fieldnames` parameter . If fieldnames is omitted , the values in the first row of file `f` will be used as the fieldnames . With arguments `*args`, `**kwds`, `dialect`.", "question_id": 1696}
{"snippet": "csv.DictReader(f, *args, **kwds, fieldnames=None, restkey=None)", "intent": "Create an object that operates like a regular reader but maps the information in each row to an OrderedDict whose keys are given by the optional `fieldnames` parameter . If fieldnames is omitted , the values in the first row of file `f` will be used as the fieldnames . If a row has more fields than fieldnames , the remaining data is put in a list and stored with the fieldname specified by `restkey` ( which defaults to None ) . With arguments `*args`, `**kwds`.", "question_id": 1697}
{"snippet": "csv.DictReader(f, *args, **kwds, fieldnames=None, restval=None)", "intent": "Create an object that operates like a regular reader but maps the information in each row to an OrderedDict whose keys are given by the optional `fieldnames` parameter . If fieldnames is omitted , the values in the first row of file `f` will be used as the fieldnames . With arguments `*args`, `**kwds`, `restval`.", "question_id": 1698}
{"snippet": "csv.DictReader(f, *args, **kwds, fieldnames=None, dialect='excel')", "intent": "Create an object that operates like a regular reader but maps the information in each row to an OrderedDict whose keys are given by the optional `fieldnames` parameter . If fieldnames is omitted , the values in the first row of file `f` will be used as the fieldnames . With arguments `*args`, `**kwds`, `dialect`.", "question_id": 1699}
{"snippet": "csv.DictReader(f, *args, **kwds, restkey=None, restval=None)", "intent": "Create an object that operates like a regular reader but maps the information in each row to an OrderedDict whose keys are given by the optional `fieldnames` parameter . If fieldnames is omitted , the values in the first row of file `f` will be used as the fieldnames . If a row has more fields than fieldnames , the remaining data is put in a list and stored with the fieldname specified by `restkey` ( which defaults to None ) . With arguments `*args`, `**kwds`, `restval`.", "question_id": 1700}
{"snippet": "csv.DictReader(f, *args, **kwds, restkey=None, dialect='excel')", "intent": "Create an object that operates like a regular reader but maps the information in each row to an OrderedDict whose keys are given by the optional `fieldnames` parameter . If fieldnames is omitted , the values in the first row of file `f` will be used as the fieldnames . If a row has more fields than fieldnames , the remaining data is put in a list and stored with the fieldname specified by `restkey` ( which defaults to None ) . With arguments `*args`, `**kwds`, `dialect`.", "question_id": 1701}
{"snippet": "csv.DictWriter(f, fieldnames, *args, **kwds)", "intent": "Create an object which operates like a regular writer but maps dictionaries onto output rows . The `fieldnames` parameter is a sequence of keys that identify the order in which values in the dictionary passed to the writerow ( ) method are written to file f. The optional `restval` parameter specifies the value to be written if the dictionary is missing a key in fieldnames . With arguments `f`, `*args`, `**kwds`.", "question_id": 1702}
{"snippet": "csv.DictWriter(f, fieldnames, *args, **kwds, restval='')", "intent": "Create an object which operates like a regular writer but maps dictionaries onto output rows . The `fieldnames` parameter is a sequence of keys that identify the order in which values in the dictionary passed to the writerow ( ) method are written to file f. The optional `restval` parameter specifies the value to be written if the dictionary is missing a key in fieldnames . With arguments `f`, `*args`, `**kwds`.", "question_id": 1703}
{"snippet": "csv.DictWriter(f, fieldnames, *args, **kwds, extrasaction='raise')", "intent": "Create an object which operates like a regular writer but maps dictionaries onto output rows . The `fieldnames` parameter is a sequence of keys that identify the order in which values in the dictionary passed to the writerow ( ) method are written to file f. The optional `restval` parameter specifies the value to be written if the dictionary is missing a key in fieldnames . If the dictionary passed to the writerow ( ) method contains a key not found in fieldnames , the optional `extrasaction` parameter indicates what action to take . With arguments `f`, `*args`, `**kwds`.", "question_id": 1704}
{"snippet": "csv.DictWriter(f, fieldnames, *args, **kwds, dialect='excel')", "intent": "Create an object which operates like a regular writer but maps dictionaries onto output rows . The `fieldnames` parameter is a sequence of keys that identify the order in which values in the dictionary passed to the writerow ( ) method are written to file f. The optional `restval` parameter specifies the value to be written if the dictionary is missing a key in fieldnames . With arguments `f`, `*args`, `**kwds`, `dialect`.", "question_id": 1705}
{"snippet": "csv.DictWriter(f, fieldnames, *args, **kwds, restval='', extrasaction='raise')", "intent": "Create an object which operates like a regular writer but maps dictionaries onto output rows . The `fieldnames` parameter is a sequence of keys that identify the order in which values in the dictionary passed to the writerow ( ) method are written to file f. The optional `restval` parameter specifies the value to be written if the dictionary is missing a key in fieldnames . If the dictionary passed to the writerow ( ) method contains a key not found in fieldnames , the optional `extrasaction` parameter indicates what action to take . With arguments `f`, `*args`, `**kwds`.", "question_id": 1706}
{"snippet": "csv.DictWriter(f, fieldnames, *args, **kwds, restval='', dialect='excel')", "intent": "Create an object which operates like a regular writer but maps dictionaries onto output rows . The `fieldnames` parameter is a sequence of keys that identify the order in which values in the dictionary passed to the writerow ( ) method are written to file f. The optional `restval` parameter specifies the value to be written if the dictionary is missing a key in fieldnames . With arguments `f`, `*args`, `**kwds`, `dialect`.", "question_id": 1707}
{"snippet": "csv.DictWriter(f, fieldnames, *args, **kwds, extrasaction='raise', dialect='excel')", "intent": "Create an object which operates like a regular writer but maps dictionaries onto output rows . The `fieldnames` parameter is a sequence of keys that identify the order in which values in the dictionary passed to the writerow ( ) method are written to file f. The optional `restval` parameter specifies the value to be written if the dictionary is missing a key in fieldnames . If the dictionary passed to the writerow ( ) method contains a key not found in fieldnames , the optional `extrasaction` parameter indicates what action to take . With arguments `f`, `*args`, `**kwds`, `dialect`.", "question_id": 1708}
{"snippet": "csv.DictWriter(f, fieldnames, *args, **kwds, restval='', extrasaction='raise', dialect='excel')", "intent": "Create an object which operates like a regular writer but maps dictionaries onto output rows . The `fieldnames` parameter is a sequence of keys that identify the order in which values in the dictionary passed to the writerow ( ) method are written to file f. The optional `restval` parameter specifies the value to be written if the dictionary is missing a key in fieldnames . If the dictionary passed to the writerow ( ) method contains a key not found in fieldnames , the optional `extrasaction` parameter indicates what action to take . With arguments `f`, `*args`, `**kwds`, `dialect`.", "question_id": 1709}
{"snippet": "csv.Dialect", "intent": "The Dialect class is a container class relied on primarily for its attributes, which are used to define the parameters for a specific reader or writer instance.", "question_id": 1710}
{"snippet": "csv.excel", "intent": "The excel class defines the usual properties of an Excel-generated CSV file.", "question_id": 1711}
{"snippet": "csv.excel_tab", "intent": "The excel_tab class defines the usual properties of an Excel-generated TAB-delimited file.", "question_id": 1712}
{"snippet": "csv.unix_dialect", "intent": "The unix_dialect class defines the usual properties of a CSV file generated on UNIX systems, i.e.", "question_id": 1713}
{"snippet": "csv.Sniffer", "intent": "The Sniffer class is used to deduce the format of a CSV file.", "question_id": 1714}
{"snippet": "sniffer.sniff(sample)", "intent": "Analyze the given `sample` and return a Dialect subclass reflecting the parameters found .", "question_id": 1715}
{"snippet": "sniffer.sniff(sample, delimiters=None)", "intent": "Analyze the given `sample` and return a Dialect subclass reflecting the parameters found . If the optional `delimiters` parameter is given , it is interpreted as a string containing possible valid delimiter characters .", "question_id": 1716}
{"snippet": "sniffer.has_header(sample)", "intent": "Analyze the `sample` text ( presumed to be in CSV format ) and return True if the first row appears to be a series of column headers .", "question_id": 1717}
{"snippet": "csv.QUOTE_ALL", "intent": "Instructs writer objects to quote all fields.", "question_id": 1718}
{"snippet": "csv.QUOTE_MINIMAL", "intent": "Instructs writer objects to only quote those fields which contain special characters such as delimiter, quotechar or any of the characters in lineterminator.", "question_id": 1719}
{"snippet": "csv.QUOTE_NONNUMERIC", "intent": "Instructs writer objects to quote all non-numeric fields.", "question_id": 1720}
{"snippet": "csv.QUOTE_NONE", "intent": "Instructs writer objects to never quote fields.", "question_id": 1721}
{"snippet": "csv.Error", "intent": "Raised by any of the functions when an error is detected.", "question_id": 1722}
{"snippet": "Dialect.delimiter", "intent": "A one-character string used to separate fields.", "question_id": 1723}
{"snippet": "Dialect.doublequote", "intent": "Controls how instances of quotechar appearing inside a field should themselves be quoted.", "question_id": 1724}
{"snippet": "Dialect.escapechar", "intent": "A one-character string used by the writer to escape the delimiter if quoting is set to QUOTE_NONE and the quotechar if doublequote is False.", "question_id": 1725}
{"snippet": "Dialect.lineterminator", "intent": "The string used to terminate lines produced by the writer.", "question_id": 1726}
{"snippet": "Dialect.quotechar", "intent": "A one-character string used to quote fields containing special characters, such as the delimiter or quotechar, or which contain new-line characters.", "question_id": 1727}
{"snippet": "Dialect.quoting", "intent": "Controls when quotes should be generated by the writer and recognised by the reader.", "question_id": 1728}
{"snippet": "Dialect.skipinitialspace", "intent": "When True, whitespace immediately following the delimiter is ignored.", "question_id": 1729}
{"snippet": "Dialect.strict", "intent": "When True, raise exception Error on bad CSV input.", "question_id": 1730}
{"snippet": "csvreader.__next__()", "intent": "Return the next row of the reader \u2019 s iterable object as a list ( if the object was returned from reader ( ) ) or a dict ( if it is a DictReader instance ) , parsed according to the current dialect .", "question_id": 1731}
{"snippet": "csvreader.dialect", "intent": "A read-only description of the dialect in use by the parser.", "question_id": 1732}
{"snippet": "csvreader.line_num", "intent": "The number of lines read from the source iterator.", "question_id": 1733}
{"snippet": "csvreader.fieldnames", "intent": "If not passed as a parameter when creating the object, this attribute is initialized upon first access or when the first record is read from the file.", "question_id": 1734}
{"snippet": "csvwriter.writerow(row)", "intent": "Write the `row` parameter to the writer \u2019 s file object , formatted according to the current dialect .", "question_id": 1735}
{"snippet": "csvwriter.writerows(rows)", "intent": "Write all elements in `rows` ( an iterable of row objects as described above ) to the writer \u2019 s file object , formatted according to the current dialect .", "question_id": 1736}
{"snippet": "csvwriter.dialect", "intent": "A read-only description of the dialect in use by the writer.", "question_id": 1737}
{"snippet": "DictWriter.writeheader()", "intent": "Write a row with the field names ( as specified in the constructor ) .", "question_id": 1738}
{"snippet": "ctypes.util.find_library(name)", "intent": "Try to find a library and return a pathname . `name` is the library name without any prefix like lib , suffix like .so , .dylib or version number ( this is the form used for the posix linker option -l ) .", "question_id": 1739}
{"snippet": "ctypes.CDLL(name)", "intent": "Instances of this class represent loaded shared libraries . With arguments `name`.", "question_id": 1740}
{"snippet": "ctypes.CDLL(name, mode=DEFAULT_MODE)", "intent": "Instances of this class represent loaded shared libraries . With arguments `name`, `mode`.", "question_id": 1741}
{"snippet": "ctypes.CDLL(name, handle=None)", "intent": "Instances of this class represent loaded shared libraries . With arguments `name`, `handle`.", "question_id": 1742}
{"snippet": "ctypes.CDLL(name, use_errno=False)", "intent": "Instances of this class represent loaded shared libraries . With arguments `name`, `use_errno`.", "question_id": 1743}
{"snippet": "ctypes.CDLL(name, use_last_error=False)", "intent": "Instances of this class represent loaded shared libraries . With arguments `name`, `use_last_error`.", "question_id": 1744}
{"snippet": "ctypes.CDLL(name, mode=DEFAULT_MODE, handle=None)", "intent": "Instances of this class represent loaded shared libraries . With arguments `name`, `mode`, `handle`.", "question_id": 1745}
{"snippet": "ctypes.CDLL(name, mode=DEFAULT_MODE, use_errno=False)", "intent": "Instances of this class represent loaded shared libraries . With arguments `name`, `mode`, `use_errno`.", "question_id": 1746}
{"snippet": "ctypes.CDLL(name, mode=DEFAULT_MODE, use_last_error=False)", "intent": "Instances of this class represent loaded shared libraries . With arguments `name`, `mode`, `use_last_error`.", "question_id": 1747}
{"snippet": "ctypes.CDLL(name, handle=None, use_errno=False)", "intent": "Instances of this class represent loaded shared libraries . With arguments `name`, `handle`, `use_errno`.", "question_id": 1748}
{"snippet": "ctypes.CDLL(name, handle=None, use_last_error=False)", "intent": "Instances of this class represent loaded shared libraries . With arguments `name`, `handle`, `use_last_error`.", "question_id": 1749}
{"snippet": "ctypes.OleDLL(name)", "intent": "Windows only : Instances of this class represent loaded shared libraries , functions in these libraries use the stdcall calling convention , and are assumed to return the windows specific HRESULT code . With arguments `name`.", "question_id": 1750}
{"snippet": "ctypes.OleDLL(name, mode=DEFAULT_MODE)", "intent": "Windows only : Instances of this class represent loaded shared libraries , functions in these libraries use the stdcall calling convention , and are assumed to return the windows specific HRESULT code . With arguments `name`, `mode`.", "question_id": 1751}
{"snippet": "ctypes.OleDLL(name, handle=None)", "intent": "Windows only : Instances of this class represent loaded shared libraries , functions in these libraries use the stdcall calling convention , and are assumed to return the windows specific HRESULT code . With arguments `name`, `handle`.", "question_id": 1752}
{"snippet": "ctypes.OleDLL(name, use_errno=False)", "intent": "Windows only : Instances of this class represent loaded shared libraries , functions in these libraries use the stdcall calling convention , and are assumed to return the windows specific HRESULT code . With arguments `name`, `use_errno`.", "question_id": 1753}
{"snippet": "ctypes.OleDLL(name, use_last_error=False)", "intent": "Windows only : Instances of this class represent loaded shared libraries , functions in these libraries use the stdcall calling convention , and are assumed to return the windows specific HRESULT code . With arguments `name`, `use_last_error`.", "question_id": 1754}
{"snippet": "ctypes.OleDLL(name, mode=DEFAULT_MODE, handle=None)", "intent": "Windows only : Instances of this class represent loaded shared libraries , functions in these libraries use the stdcall calling convention , and are assumed to return the windows specific HRESULT code . With arguments `name`, `mode`, `handle`.", "question_id": 1755}
{"snippet": "ctypes.OleDLL(name, mode=DEFAULT_MODE, use_errno=False)", "intent": "Windows only : Instances of this class represent loaded shared libraries , functions in these libraries use the stdcall calling convention , and are assumed to return the windows specific HRESULT code . With arguments `name`, `mode`, `use_errno`.", "question_id": 1756}
{"snippet": "ctypes.OleDLL(name, mode=DEFAULT_MODE, use_last_error=False)", "intent": "Windows only : Instances of this class represent loaded shared libraries , functions in these libraries use the stdcall calling convention , and are assumed to return the windows specific HRESULT code . With arguments `name`, `mode`, `use_last_error`.", "question_id": 1757}
{"snippet": "ctypes.OleDLL(name, handle=None, use_errno=False)", "intent": "Windows only : Instances of this class represent loaded shared libraries , functions in these libraries use the stdcall calling convention , and are assumed to return the windows specific HRESULT code . With arguments `name`, `handle`, `use_errno`.", "question_id": 1758}
{"snippet": "ctypes.OleDLL(name, handle=None, use_last_error=False)", "intent": "Windows only : Instances of this class represent loaded shared libraries , functions in these libraries use the stdcall calling convention , and are assumed to return the windows specific HRESULT code . With arguments `name`, `handle`, `use_last_error`.", "question_id": 1759}
{"snippet": "ctypes.WinDLL(name)", "intent": "Windows only : Instances of this class represent loaded shared libraries , functions in these libraries use the stdcall calling convention , and are assumed to return int by default . With arguments `name`.", "question_id": 1760}
{"snippet": "ctypes.WinDLL(name, mode=DEFAULT_MODE)", "intent": "Windows only : Instances of this class represent loaded shared libraries , functions in these libraries use the stdcall calling convention , and are assumed to return int by default . With arguments `name`, `mode`.", "question_id": 1761}
{"snippet": "ctypes.WinDLL(name, handle=None)", "intent": "Windows only : Instances of this class represent loaded shared libraries , functions in these libraries use the stdcall calling convention , and are assumed to return int by default . With arguments `name`, `handle`.", "question_id": 1762}
{"snippet": "ctypes.WinDLL(name, use_errno=False)", "intent": "Windows only : Instances of this class represent loaded shared libraries , functions in these libraries use the stdcall calling convention , and are assumed to return int by default . With arguments `name`, `use_errno`.", "question_id": 1763}
{"snippet": "ctypes.WinDLL(name, use_last_error=False)", "intent": "Windows only : Instances of this class represent loaded shared libraries , functions in these libraries use the stdcall calling convention , and are assumed to return int by default . With arguments `name`, `use_last_error`.", "question_id": 1764}
{"snippet": "ctypes.WinDLL(name, mode=DEFAULT_MODE, handle=None)", "intent": "Windows only : Instances of this class represent loaded shared libraries , functions in these libraries use the stdcall calling convention , and are assumed to return int by default . With arguments `name`, `mode`, `handle`.", "question_id": 1765}
{"snippet": "ctypes.WinDLL(name, mode=DEFAULT_MODE, use_errno=False)", "intent": "Windows only : Instances of this class represent loaded shared libraries , functions in these libraries use the stdcall calling convention , and are assumed to return int by default . With arguments `name`, `mode`, `use_errno`.", "question_id": 1766}
{"snippet": "ctypes.WinDLL(name, mode=DEFAULT_MODE, use_last_error=False)", "intent": "Windows only : Instances of this class represent loaded shared libraries , functions in these libraries use the stdcall calling convention , and are assumed to return int by default . With arguments `name`, `mode`, `use_last_error`.", "question_id": 1767}
{"snippet": "ctypes.WinDLL(name, handle=None, use_errno=False)", "intent": "Windows only : Instances of this class represent loaded shared libraries , functions in these libraries use the stdcall calling convention , and are assumed to return int by default . With arguments `name`, `handle`, `use_errno`.", "question_id": 1768}
{"snippet": "ctypes.WinDLL(name, handle=None, use_last_error=False)", "intent": "Windows only : Instances of this class represent loaded shared libraries , functions in these libraries use the stdcall calling convention , and are assumed to return int by default . With arguments `name`, `handle`, `use_last_error`.", "question_id": 1769}
{"snippet": "ctypes.PyDLL(name)", "intent": "Instances of this class behave like CDLL instances , except that the Python GIL is not released during the function call , and after the function execution the Python error flag is checked . With arguments `name`.", "question_id": 1770}
{"snippet": "ctypes.PyDLL(name, mode=DEFAULT_MODE)", "intent": "Instances of this class behave like CDLL instances , except that the Python GIL is not released during the function call , and after the function execution the Python error flag is checked . With arguments `name`, `mode`.", "question_id": 1771}
{"snippet": "ctypes.PyDLL(name, handle=None)", "intent": "Instances of this class behave like CDLL instances , except that the Python GIL is not released during the function call , and after the function execution the Python error flag is checked . With arguments `name`, `handle`.", "question_id": 1772}
{"snippet": "ctypes.PyDLL(name, mode=DEFAULT_MODE, handle=None)", "intent": "Instances of this class behave like CDLL instances , except that the Python GIL is not released during the function call , and after the function execution the Python error flag is checked . With arguments `name`, `mode`, `handle`.", "question_id": 1773}
{"snippet": "ctypes.RTLD_GLOBAL", "intent": "Flag to use as mode parameter.", "question_id": 1774}
{"snippet": "ctypes.RTLD_LOCAL", "intent": "Flag to use as mode parameter.", "question_id": 1775}
{"snippet": "ctypes.DEFAULT_MODE", "intent": "The default mode which is used to load shared libraries.", "question_id": 1776}
{"snippet": "PyDLL._handle", "intent": "The system handle used to access the library.", "question_id": 1777}
{"snippet": "PyDLL._name", "intent": "The name of the library passed in the constructor.", "question_id": 1778}
{"snippet": "ctypes.LibraryLoader(dlltype)", "intent": "Class which loads shared libraries . `dlltype` should be one of the CDLL , PyDLL , WinDLL , or OleDLL types .", "question_id": 1779}
{"snippet": "library_loader.LoadLibrary(name)", "intent": "Load a shared library into the process and return it . With arguments `name`.", "question_id": 1780}
{"snippet": "ctypes.cdll", "intent": "Creates CDLL instances.", "question_id": 1781}
{"snippet": "ctypes.windll", "intent": "Windows only: Creates WinDLL instances.", "question_id": 1782}
{"snippet": "ctypes.oledll", "intent": "Windows only: Creates OleDLL instances.", "question_id": 1783}
{"snippet": "ctypes.pydll", "intent": "Creates PyDLL instances.", "question_id": 1784}
{"snippet": "ctypes.pythonapi", "intent": "An instance of PyDLL that exposes Python C API functions as attributes.", "question_id": 1785}
{"snippet": "ctypes._FuncPtr", "intent": "Base class for C callable foreign functions.", "question_id": 1786}
{"snippet": "_func_ptr.restype", "intent": "Assign a ctypes type to specify the result type of the foreign function.", "question_id": 1787}
{"snippet": "_func_ptr.argtypes", "intent": "Assign a tuple of ctypes types to specify the argument types that the function accepts.", "question_id": 1788}
{"snippet": "_func_ptr.errcheck", "intent": "Assign a Python function or another callable to this attribute.", "question_id": 1789}
{"snippet": "callable(result, func, arguments)", "intent": "`result` is what the foreign function returns , as specified by the restype attribute . `func` is the foreign function object itself , this allows reusing the same callable object to check or post process the results of several functions . `arguments` is a tuple containing the parameters originally passed to the function call , this allows specializing the behavior on the arguments used .", "question_id": 1790}
{"snippet": "ctypes.ArgumentError", "intent": "This exception is raised when a foreign function call cannot convert one of the passed arguments.", "question_id": 1791}
{"snippet": "ctypes.CFUNCTYPE(restype, *argtypes)", "intent": "The returned function prototype creates functions that use the standard C calling convention . With arguments `restype`, `*argtypes`.", "question_id": 1792}
{"snippet": "ctypes.CFUNCTYPE(restype, *argtypes, use_errno=False)", "intent": "The returned function prototype creates functions that use the standard C calling convention . If `use_errno` is set to true , the ctypes private copy of the system errno variable is exchanged with the real errno value before and after the call ; `use_last_error` does the same for the Windows error code . With arguments `restype`, `*argtypes`.", "question_id": 1793}
{"snippet": "ctypes.CFUNCTYPE(restype, *argtypes, use_last_error=False)", "intent": "The returned function prototype creates functions that use the standard C calling convention . If `use_errno` is set to true , the ctypes private copy of the system errno variable is exchanged with the real errno value before and after the call ; `use_last_error` does the same for the Windows error code . With arguments `restype`, `*argtypes`.", "question_id": 1794}
{"snippet": "ctypes.CFUNCTYPE(restype, *argtypes, use_errno=False, use_last_error=False)", "intent": "The returned function prototype creates functions that use the standard C calling convention . If `use_errno` is set to true , the ctypes private copy of the system errno variable is exchanged with the real errno value before and after the call ; `use_last_error` does the same for the Windows error code . With arguments `restype`, `*argtypes`.", "question_id": 1795}
{"snippet": "ctypes.WINFUNCTYPE(restype, *argtypes)", "intent": "Windows only : The returned function prototype creates functions that use the stdcall calling convention , except on Windows CE where WINFUNCTYPE ( ) is the same as CFUNCTYPE ( ) . With arguments `restype`, `*argtypes`.", "question_id": 1796}
{"snippet": "ctypes.WINFUNCTYPE(restype, *argtypes, use_errno=False)", "intent": "Windows only : The returned function prototype creates functions that use the stdcall calling convention , except on Windows CE where WINFUNCTYPE ( ) is the same as CFUNCTYPE ( ) . `use_errno` and `use_last_error` have the same meaning as above . With arguments `restype`, `*argtypes`.", "question_id": 1797}
{"snippet": "ctypes.WINFUNCTYPE(restype, *argtypes, use_last_error=False)", "intent": "Windows only : The returned function prototype creates functions that use the stdcall calling convention , except on Windows CE where WINFUNCTYPE ( ) is the same as CFUNCTYPE ( ) . `use_errno` and `use_last_error` have the same meaning as above . With arguments `restype`, `*argtypes`.", "question_id": 1798}
{"snippet": "ctypes.WINFUNCTYPE(restype, *argtypes, use_errno=False, use_last_error=False)", "intent": "Windows only : The returned function prototype creates functions that use the stdcall calling convention , except on Windows CE where WINFUNCTYPE ( ) is the same as CFUNCTYPE ( ) . `use_errno` and `use_last_error` have the same meaning as above . With arguments `restype`, `*argtypes`.", "question_id": 1799}
{"snippet": "ctypes.PYFUNCTYPE(restype, *argtypes)", "intent": "The returned function prototype creates functions that use the Python calling convention . With arguments `restype`, `*argtypes`.", "question_id": 1800}
{"snippet": "prototype(address)", "intent": "Returns a foreign function at the specified `address` which must be an integer .", "question_id": 1801}
{"snippet": "prototype(callable)", "intent": "Create a C `callable` function ( a callback function ) from a Python callable .", "question_id": 1802}
{"snippet": "prototype(func_spec, paramflags)", "intent": "Returns a foreign function exported by a shared library . `func_spec` must be a 2-tuple ( name_or_ordinal , library ) . With arguments `paramflags`.", "question_id": 1803}
{"snippet": "prototype(func_spec)", "intent": "Returns a foreign function exported by a shared library . `func_spec` must be a 2-tuple ( name_or_ordinal , library ) .", "question_id": 1804}
{"snippet": "prototype(vtbl_index, name, paramflags, iid)", "intent": "Returns a foreign function that will call a COM method . `vtbl_index` is the index into the virtual function table , a small non-negative integer . `name` is name of the COM method . `iid` is an optional pointer to the interface identifier which is used in extended error reporting . With arguments `paramflags`.", "question_id": 1805}
{"snippet": "prototype(vtbl_index, name, paramflags)", "intent": "Returns a foreign function that will call a COM method . `vtbl_index` is the index into the virtual function table , a small non-negative integer . `name` is name of the COM method . With arguments `paramflags`.", "question_id": 1806}
{"snippet": "prototype(vtbl_index, name)", "intent": "Returns a foreign function that will call a COM method . `vtbl_index` is the index into the virtual function table , a small non-negative integer . `name` is name of the COM method .", "question_id": 1807}
{"snippet": "ctypes.addressof(obj)", "intent": "Returns the address of the memory buffer as integer . `obj` must be an instance of a ctypes type .", "question_id": 1808}
{"snippet": "ctypes.alignment(obj_or_type)", "intent": "Returns the alignment requirements of a ctypes type . `obj_or_type` must be a ctypes type or instance .", "question_id": 1809}
{"snippet": "ctypes.byref(obj, offset)", "intent": "Returns a light-weight pointer to `obj` , which must be an instance of a ctypes type . `offset` defaults to zero , and must be an integer that will be added to the internal pointer value .", "question_id": 1810}
{"snippet": "ctypes.byref(obj)", "intent": "Returns a light-weight pointer to `obj` , which must be an instance of a ctypes type .", "question_id": 1811}
{"snippet": "ctypes.cast(obj, type)", "intent": "This function is similar to the cast operator in C. It returns a new instance of `type` which points to the same memory block as `obj` .", "question_id": 1812}
{"snippet": "ctypes.create_string_buffer(init_or_size)", "intent": "This function creates a mutable character buffer . `init_or_size` must be an integer which specifies the `size` of the array , or a bytes object which will be used to initialize the array items .", "question_id": 1813}
{"snippet": "ctypes.create_string_buffer(init_or_size, size=None)", "intent": "This function creates a mutable character buffer . `init_or_size` must be an integer which specifies the `size` of the array , or a bytes object which will be used to initialize the array items .", "question_id": 1814}
{"snippet": "ctypes.create_unicode_buffer(init_or_size)", "intent": "This function creates a mutable unicode character buffer . `init_or_size` must be an integer which specifies the `size` of the array , or a string which will be used to initialize the array items .", "question_id": 1815}
{"snippet": "ctypes.create_unicode_buffer(init_or_size, size=None)", "intent": "This function creates a mutable unicode character buffer . `init_or_size` must be an integer which specifies the `size` of the array , or a string which will be used to initialize the array items .", "question_id": 1816}
{"snippet": "ctypes.DllCanUnloadNow()", "intent": "Windows only : This function is a hook which allows implementing in-process COM servers with ctypes .", "question_id": 1817}
{"snippet": "ctypes.DllGetClassObject()", "intent": "Windows only : This function is a hook which allows implementing in-process COM servers with ctypes .", "question_id": 1818}
{"snippet": "ctypes.util.find_library(name)", "intent": "Try to find a library and return a pathname . `name` is the library name without any prefix like lib , suffix like .so , .dylib or version number ( this is the form used for the posix linker option -l ) .", "question_id": 1819}
{"snippet": "ctypes.util.find_msvcrt()", "intent": "Windows only : return the filename of the VC runtime library used by Python , and by the extension modules .", "question_id": 1820}
{"snippet": "ctypes.FormatError(code)", "intent": "Windows only : Returns a textual description of the error `code` code .", "question_id": 1821}
{"snippet": "ctypes.FormatError()", "intent": "Windows only : Returns a textual description of the error `code` code .", "question_id": 1822}
{"snippet": "ctypes.GetLastError()", "intent": "Windows only : Returns the last error code set by Windows in the calling thread .", "question_id": 1823}
{"snippet": "ctypes.get_errno()", "intent": "Returns the current value of the ctypes-private copy of the system errno variable in the calling thread .", "question_id": 1824}
{"snippet": "ctypes.get_last_error()", "intent": "Windows only : returns the current value of the ctypes-private copy of the system LastError variable in the calling thread .", "question_id": 1825}
{"snippet": "ctypes.memmove(dst, src, count)", "intent": "Same as the standard C memmove library function : copies `count` bytes from `src` to `dst` .", "question_id": 1826}
{"snippet": "ctypes.memset(dst, c, count)", "intent": "Same as the standard C memset library function : fills the memory block at address `dst` with `count` bytes of value c. dst must be an integer specifying an address , or a ctypes instance . With arguments `c`.", "question_id": 1827}
{"snippet": "ctypes.POINTER(type)", "intent": "This factory function creates and returns a new ctypes pointer `type` .", "question_id": 1828}
{"snippet": "ctypes.pointer(obj)", "intent": "This function creates a new pointer instance , pointing to `obj` .", "question_id": 1829}
{"snippet": "ctypes.resize(obj, size)", "intent": "This function resizes the internal memory buffer of `obj` , which must be an instance of a ctypes type . It is not possible to make the buffer smaller than the native `size` of the objects type , as given by sizeof ( type ( obj ) ) , but it is possible to enlarge the buffer .", "question_id": 1830}
{"snippet": "ctypes.set_errno(value)", "intent": "Set the current `value` of the ctypes-private copy of the system errno variable in the calling thread to value and return the previous value .", "question_id": 1831}
{"snippet": "ctypes.set_last_error(value)", "intent": "Windows only : set the current `value` of the ctypes-private copy of the system LastError variable in the calling thread to value and return the previous value .", "question_id": 1832}
{"snippet": "ctypes.sizeof(obj_or_type)", "intent": "Returns the size in bytes of a ctypes type or instance memory buffer . With arguments `obj_or_type`.", "question_id": 1833}
{"snippet": "ctypes.string_at(address)", "intent": "This function returns the C string starting at memory `address` address as a bytes object .", "question_id": 1834}
{"snippet": "ctypes.string_at(address, size=-1)", "intent": "This function returns the C string starting at memory `address` address as a bytes object . If `size` is specified , it is used as size , otherwise the string is assumed to be zero-terminated .", "question_id": 1835}
{"snippet": "ctypes.WinError()", "intent": "Windows only : this function is probably the worst-named thing in ctypes .", "question_id": 1836}
{"snippet": "ctypes.WinError(code=None)", "intent": "Windows only : this function is probably the worst-named thing in ctypes . If `code` is not specified , GetLastError is called to determine the error code .", "question_id": 1837}
{"snippet": "ctypes.WinError(descr=None)", "intent": "Windows only : this function is probably the worst-named thing in ctypes . If `descr` is not specified , FormatError ( ) is called to get a textual description of the error .", "question_id": 1838}
{"snippet": "ctypes.WinError(code=None, descr=None)", "intent": "Windows only : this function is probably the worst-named thing in ctypes . If `code` is not specified , GetLastError is called to determine the error code . If `descr` is not specified , FormatError ( ) is called to get a textual description of the error .", "question_id": 1839}
{"snippet": "ctypes.wstring_at(address)", "intent": "This function returns the wide character string starting at memory `address` address as a string .", "question_id": 1840}
{"snippet": "ctypes.wstring_at(address, size=-1)", "intent": "This function returns the wide character string starting at memory `address` address as a string . If `size` is specified , it is used as the number of characters of the string , otherwise the string is assumed to be zero-terminated .", "question_id": 1841}
{"snippet": "ctypes._CData", "intent": "This non-public class is the common base class of all ctypes data types.", "question_id": 1842}
{"snippet": "_c_data.from_buffer(source, offset)", "intent": "This method returns a ctypes instance that shares the buffer of the `source` object . The optional `offset` parameter specifies an offset into the source buffer in bytes ; the default is zero .", "question_id": 1843}
{"snippet": "_c_data.from_buffer(source)", "intent": "This method returns a ctypes instance that shares the buffer of the `source` object .", "question_id": 1844}
{"snippet": "_c_data.from_buffer_copy(source, offset)", "intent": "This method creates a ctypes instance , copying the buffer from the `source` object buffer which must be readable . The optional `offset` parameter specifies an offset into the source buffer in bytes ; the default is zero .", "question_id": 1845}
{"snippet": "_c_data.from_buffer_copy(source)", "intent": "This method creates a ctypes instance , copying the buffer from the `source` object buffer which must be readable .", "question_id": 1846}
{"snippet": "_c_data.from_address(address)", "intent": "This method returns a ctypes type instance using the memory specified by `address` which must be an integer .", "question_id": 1847}
{"snippet": "_c_data.from_param(obj)", "intent": "This method adapts `obj` to a ctypes type .", "question_id": 1848}
{"snippet": "_c_data.in_dll(library, name)", "intent": "This method returns a ctypes type instance exported by a shared `library` . `name` is the name of the symbol that exports the data , library is the loaded shared library .", "question_id": 1849}
{"snippet": "_c_data._b_base_", "intent": "Sometimes ctypes data instances do not own the memory block they contain, instead they share part of the memory block of a base object.", "question_id": 1850}
{"snippet": "_c_data._b_needsfree_", "intent": "This read-only variable is true when the ctypes data instance has allocated the memory block itself, false otherwise.", "question_id": 1851}
{"snippet": "_c_data._objects", "intent": "This member is either None or a dictionary containing Python objects that need to be kept alive so that the memory block contents is kept valid.", "question_id": 1852}
{"snippet": "ctypes._SimpleCData", "intent": "This non-public class is the base class of all fundamental ctypes data types.", "question_id": 1853}
{"snippet": "_simple_c_data.value", "intent": "This attribute contains the actual value of the instance.", "question_id": 1854}
{"snippet": "ctypes.c_byte", "intent": "Represents the C signed char datatype, and interprets the value as small integer.", "question_id": 1855}
{"snippet": "ctypes.c_char", "intent": "Represents the C char datatype, and interprets the value as a single character.", "question_id": 1856}
{"snippet": "ctypes.c_char_p", "intent": "Represents the C char * datatype when it points to a zero-terminated string.", "question_id": 1857}
{"snippet": "ctypes.c_double", "intent": "Represents the C double datatype.", "question_id": 1858}
{"snippet": "ctypes.c_longdouble", "intent": "Represents the C long double datatype.", "question_id": 1859}
{"snippet": "ctypes.c_float", "intent": "Represents the C float datatype.", "question_id": 1860}
{"snippet": "ctypes.c_int", "intent": "Represents the C signed int datatype.", "question_id": 1861}
{"snippet": "ctypes.c_int8", "intent": "Represents the C 8-bit signed int datatype.", "question_id": 1862}
{"snippet": "ctypes.c_int16", "intent": "Represents the C 16-bit signed int datatype.", "question_id": 1863}
{"snippet": "ctypes.c_int32", "intent": "Represents the C 32-bit signed int datatype.", "question_id": 1864}
{"snippet": "ctypes.c_int64", "intent": "Represents the C 64-bit signed int datatype.", "question_id": 1865}
{"snippet": "ctypes.c_long", "intent": "Represents the C signed long datatype.", "question_id": 1866}
{"snippet": "ctypes.c_longlong", "intent": "Represents the C signed long long datatype.", "question_id": 1867}
{"snippet": "ctypes.c_short", "intent": "Represents the C signed short datatype.", "question_id": 1868}
{"snippet": "ctypes.c_size_t", "intent": "Represents the C size_t datatype.", "question_id": 1869}
{"snippet": "ctypes.c_ssize_t", "intent": "Represents the C ssize_t datatype.", "question_id": 1870}
{"snippet": "ctypes.c_ubyte", "intent": "Represents the C unsigned char datatype, it interprets the value as small integer.", "question_id": 1871}
{"snippet": "ctypes.c_uint", "intent": "Represents the C unsigned int datatype.", "question_id": 1872}
{"snippet": "ctypes.c_uint8", "intent": "Represents the C 8-bit unsigned int datatype.", "question_id": 1873}
{"snippet": "ctypes.c_uint16", "intent": "Represents the C 16-bit unsigned int datatype.", "question_id": 1874}
{"snippet": "ctypes.c_uint32", "intent": "Represents the C 32-bit unsigned int datatype.", "question_id": 1875}
{"snippet": "ctypes.c_uint64", "intent": "Represents the C 64-bit unsigned int datatype.", "question_id": 1876}
{"snippet": "ctypes.c_ulong", "intent": "Represents the C unsigned long datatype.", "question_id": 1877}
{"snippet": "ctypes.c_ulonglong", "intent": "Represents the C unsigned long long datatype.", "question_id": 1878}
{"snippet": "ctypes.c_ushort", "intent": "Represents the C unsigned short datatype.", "question_id": 1879}
{"snippet": "ctypes.c_void_p", "intent": "Represents the C void * type.", "question_id": 1880}
{"snippet": "ctypes.c_wchar", "intent": "Represents the C wchar_t datatype, and interprets the value as a single character unicode string.", "question_id": 1881}
{"snippet": "ctypes.c_wchar_p", "intent": "Represents the C wchar_t * datatype, which must be a pointer to a zero-terminated wide character string.", "question_id": 1882}
{"snippet": "ctypes.c_bool", "intent": "Represent the C bool datatype (more accurately, _Bool from C99).", "question_id": 1883}
{"snippet": "ctypes.HRESULT", "intent": "Windows only: Represents a HRESULT value, which contains success or error information for a function or method call.", "question_id": 1884}
{"snippet": "ctypes.py_object", "intent": "Represents the C PyObject * datatype.", "question_id": 1885}
{"snippet": "ctypes.Union(*args, **kw)", "intent": "Abstract base class for unions in native byte order . With arguments `*args`, `**kw`.", "question_id": 1886}
{"snippet": "ctypes.BigEndianStructure(*args, **kw)", "intent": "Abstract base class for structures in big endian byte order . With arguments `*args`, `**kw`.", "question_id": 1887}
{"snippet": "ctypes.LittleEndianStructure(*args, **kw)", "intent": "Abstract base class for structures in little endian byte order . With arguments `*args`, `**kw`.", "question_id": 1888}
{"snippet": "ctypes.Structure(*args, **kw)", "intent": "Abstract base class for structures in native byte order . With arguments `*args`, `**kw`.", "question_id": 1889}
{"snippet": "structure._fields_", "intent": "A sequence defining the structure fields.", "question_id": 1890}
{"snippet": "structure._pack_", "intent": "An optional small integer that allows overriding the alignment of structure fields in the instance.", "question_id": 1891}
{"snippet": "structure._anonymous_", "intent": "An optional sequence that lists the names of unnamed (anonymous) fields.", "question_id": 1892}
{"snippet": "ctypes.Array(*args)", "intent": "Abstract base class for arrays . With arguments `*args`.", "question_id": 1893}
{"snippet": "array._length_", "intent": "A positive integer specifying the number of elements in the array.", "question_id": 1894}
{"snippet": "array._type_", "intent": "Specifies the type of each element in the array.", "question_id": 1895}
{"snippet": "ctypes._Pointer", "intent": "Private, abstract base class for pointers.", "question_id": 1896}
{"snippet": "_pointer._type_", "intent": "Specifies the type pointed to.", "question_id": 1897}
{"snippet": "_pointer.contents", "intent": "Returns the object to which to pointer points.", "question_id": 1898}
{"snippet": "curses.ascii.isalnum(c)", "intent": "Checks for an ASCII alphanumeric character ; it is equivalent to isalpha ( `c` ) or isdigit ( c ) .", "question_id": 1899}
{"snippet": "curses.ascii.isalpha(c)", "intent": "Checks for an ASCII alphabetic character ; it is equivalent to isupper ( `c` ) or islower ( c ) .", "question_id": 1900}
{"snippet": "curses.ascii.isascii(c)", "intent": "Checks for a character value that fits in the 7-bit ASCII set . With arguments `c`.", "question_id": 1901}
{"snippet": "curses.ascii.isblank(c)", "intent": "Checks for an ASCII whitespace character ; space or horizontal tab . With arguments `c`.", "question_id": 1902}
{"snippet": "curses.ascii.iscntrl(c)", "intent": "Checks for an ASCII control character ( in the range 0x00 to 0x1f or 0x7f ) . With arguments `c`.", "question_id": 1903}
{"snippet": "curses.ascii.isdigit(c)", "intent": "Checks for an ASCII decimal digit , ' 0 ' through ' 9 ' . This is equivalent to `c` in string.digits .", "question_id": 1904}
{"snippet": "curses.ascii.isgraph(c)", "intent": "Checks for ASCII any printable character except space . With arguments `c`.", "question_id": 1905}
{"snippet": "curses.ascii.islower(c)", "intent": "Checks for an ASCII lower-case character . With arguments `c`.", "question_id": 1906}
{"snippet": "curses.ascii.isprint(c)", "intent": "Checks for any ASCII printable character including space . With arguments `c`.", "question_id": 1907}
{"snippet": "curses.ascii.ispunct(c)", "intent": "Checks for any printable ASCII character which is not a space or an alphanumeric character . With arguments `c`.", "question_id": 1908}
{"snippet": "curses.ascii.isspace(c)", "intent": "Checks for ASCII white-space characters ; space , line feed , carriage return , form feed , horizontal tab , vertical tab . With arguments `c`.", "question_id": 1909}
{"snippet": "curses.ascii.isupper(c)", "intent": "Checks for an ASCII uppercase letter . With arguments `c`.", "question_id": 1910}
{"snippet": "curses.ascii.isxdigit(c)", "intent": "Checks for an ASCII hexadecimal digit . This is equivalent to `c` in string.hexdigits .", "question_id": 1911}
{"snippet": "curses.ascii.isctrl(c)", "intent": "Checks for an ASCII control character ( ordinal values 0 to 31 ) . With arguments `c`.", "question_id": 1912}
{"snippet": "curses.ascii.ismeta(c)", "intent": "Checks for a non-ASCII character ( ordinal values 0x80 and above ) . With arguments `c`.", "question_id": 1913}
{"snippet": "curses.ascii.ascii(c)", "intent": "Return the ASCII value corresponding to the low 7 bits of `c` .", "question_id": 1914}
{"snippet": "curses.ascii.ctrl(c)", "intent": "Return the control character corresponding to the given character ( the character bit value is bitwise-anded with 0x1f ) . With arguments `c`.", "question_id": 1915}
{"snippet": "curses.ascii.alt(c)", "intent": "Return the 8-bit character corresponding to the given ASCII character ( the character bit value is bitwise-ored with 0x80 ) . With arguments `c`.", "question_id": 1916}
{"snippet": "curses.ascii.unctrl(c)", "intent": "Return a string representation of the ASCII character c. If `c` is printable , this string is the character itself .", "question_id": 1917}
{"snippet": "curses.ascii.controlnames", "intent": "A 33-element string array that contains the ASCII mnemonics for the thirty-two ASCII control characters from 0 (NUL) to 0x1f (US), in order, plus the mnemonic SP for the space character.", "question_id": 1918}
{"snippet": "curses.error", "intent": "Exception raised when a curses library function returns an error.", "question_id": 1919}
{"snippet": "curses.baudrate()", "intent": "Return the output speed of the terminal in bits per second .", "question_id": 1920}
{"snippet": "curses.beep()", "intent": "Emit a short attention sound .", "question_id": 1921}
{"snippet": "curses.can_change_color()", "intent": "Return True or False , depending on whether the programmer can change the colors displayed by the terminal .", "question_id": 1922}
{"snippet": "curses.cbreak()", "intent": "Enter cbreak mode .", "question_id": 1923}
{"snippet": "curses.color_content(color_number)", "intent": "Return the intensity of the red , green , and blue ( RGB ) components in the color `color_number` , which must be between 0 and COLORS .", "question_id": 1924}
{"snippet": "curses.color_pair(color_number)", "intent": "Return the attribute value for displaying text in the specified color . With arguments `color_number`.", "question_id": 1925}
{"snippet": "curses.curs_set(visibility)", "intent": "Set the cursor state . `visibility` can be set to 0 , 1 , or 2 , for invisible , normal , or very visible .", "question_id": 1926}
{"snippet": "curses.def_prog_mode()", "intent": "Save the current terminal mode as the \u201c program \u201d mode , the mode when the running program is using curses .", "question_id": 1927}
{"snippet": "curses.def_shell_mode()", "intent": "Save the current terminal mode as the \u201c shell \u201d mode , the mode when the running program is not using curses .", "question_id": 1928}
{"snippet": "curses.delay_output(ms)", "intent": "Insert an `ms` millisecond pause in output .", "question_id": 1929}
{"snippet": "curses.doupdate()", "intent": "Update the physical screen .", "question_id": 1930}
{"snippet": "curses.echo()", "intent": "Enter echo mode .", "question_id": 1931}
{"snippet": "curses.endwin()", "intent": "De-initialize the library , and return terminal to normal status .", "question_id": 1932}
{"snippet": "curses.erasechar()", "intent": "Return the user \u2019 s current erase character as a one-byte bytes object .", "question_id": 1933}
{"snippet": "curses.filter()", "intent": "The filter ( ) routine , if used , must be called before initscr ( ) is called .", "question_id": 1934}
{"snippet": "curses.flash()", "intent": "Flash the screen .", "question_id": 1935}
{"snippet": "curses.flushinp()", "intent": "Flush all input buffers .", "question_id": 1936}
{"snippet": "curses.getmouse()", "intent": "After getch ( ) returns KEY_MOUSE to signal a mouse event , this method should be call to retrieve the queued mouse event , represented as a 5-tuple ( id , x , y , z , bstate ) .", "question_id": 1937}
{"snippet": "curses.getsyx()", "intent": "Return the current coordinates of the virtual screen cursor as a tuple ( y , x ) .", "question_id": 1938}
{"snippet": "curses.getwin(file)", "intent": "Read window related data stored in the `file` by an earlier putwin ( ) call .", "question_id": 1939}
{"snippet": "curses.has_colors()", "intent": "Return True if the terminal can display colors ; otherwise , return False .", "question_id": 1940}
{"snippet": "curses.has_ic()", "intent": "Return True if the terminal has insert- and delete-character capabilities .", "question_id": 1941}
{"snippet": "curses.has_il()", "intent": "Return True if the terminal has insert- and delete-line capabilities , or can simulate them using scrolling regions .", "question_id": 1942}
{"snippet": "curses.has_key(ch)", "intent": "Take a key value `ch` , and return True if the current terminal type recognizes a key with that value .", "question_id": 1943}
{"snippet": "curses.halfdelay(tenths)", "intent": "Used for half-delay mode , which is similar to cbreak mode in that characters typed by the user are immediately available to the program . However , after blocking for `tenths` tenths of seconds , raise an exception if nothing has been typed .", "question_id": 1944}
{"snippet": "curses.init_color(color_number, r, g, b)", "intent": "Change the definition of a color , taking the number of the color to be changed followed by three RGB values ( for the amounts of red , green , and blue components ) . The value of `color_number` must be between 0 and COLORS . Each of `r` , `g` , `b` , must be a value between 0 and 1000 .", "question_id": 1945}
{"snippet": "curses.init_pair(pair_number, fg, bg)", "intent": "Change the definition of a color-pair . The value of `pair_number` must be between 1 and COLOR_PAIRS - 1 ( the 0 color pair is wired to white on black and can not be changed ) . The value of `fg` and `bg` arguments must be between 0 and COLORS .", "question_id": 1946}
{"snippet": "curses.initscr()", "intent": "Initialize the library .", "question_id": 1947}
{"snippet": "curses.is_term_resized(nlines, ncols)", "intent": "Return True if resize_term ( ) would modify the window structure , False otherwise . With arguments `nlines`, `ncols`.", "question_id": 1948}
{"snippet": "curses.isendwin()", "intent": "Return True if endwin ( ) has been called ( that is , the curses library has been deinitialized ) .", "question_id": 1949}
{"snippet": "curses.keyname(k)", "intent": "Return the name of the key numbered `k` as a bytes object .", "question_id": 1950}
{"snippet": "curses.killchar()", "intent": "Return the user \u2019 s current line kill character as a one-byte bytes object .", "question_id": 1951}
{"snippet": "curses.longname()", "intent": "Return a bytes object containing the terminfo long name field describing the current terminal .", "question_id": 1952}
{"snippet": "curses.meta(flag)", "intent": "If `flag` is True , allow 8-bit characters to be input .", "question_id": 1953}
{"snippet": "curses.mouseinterval(interval)", "intent": "Set the maximum time in milliseconds that can elapse between press and release events in order for them to be recognized as a click , and return the previous `interval` value .", "question_id": 1954}
{"snippet": "curses.mousemask(mousemask)", "intent": "Set the mouse events to be reported , and return a tuple ( availmask , oldmask ) . With arguments `mousemask`.", "question_id": 1955}
{"snippet": "curses.napms(ms)", "intent": "Sleep for `ms` milliseconds .", "question_id": 1956}
{"snippet": "curses.newpad(nlines, ncols)", "intent": "Create and return a pointer to a new pad data structure with the given number of lines and columns . With arguments `nlines`, `ncols`.", "question_id": 1957}
{"snippet": "curses.newwin(nlines, ncols)", "intent": "Return a new window , whose left-upper corner is at ( begin_y , begin_x ) , and whose height/width is nlines/ncols . With arguments `nlines`, `ncols`.", "question_id": 1958}
{"snippet": "curses.newwin(nlines, ncols, begin_y, begin_x)", "intent": "Return a new window , whose left-upper corner is at ( `begin_y` , `begin_x` ) , and whose height/width is nlines/ncols . With arguments `nlines`, `ncols`.", "question_id": 1959}
{"snippet": "curses.nl()", "intent": "Enter newline mode .", "question_id": 1960}
{"snippet": "curses.nocbreak()", "intent": "Leave cbreak mode .", "question_id": 1961}
{"snippet": "curses.noecho()", "intent": "Leave echo mode .", "question_id": 1962}
{"snippet": "curses.nonl()", "intent": "Leave newline mode .", "question_id": 1963}
{"snippet": "curses.noqiflush()", "intent": "When the noqiflush ( ) routine is used , normal flush of input and output queues associated with the INTR , QUIT and SUSP characters will not be done .", "question_id": 1964}
{"snippet": "curses.noraw()", "intent": "Leave raw mode .", "question_id": 1965}
{"snippet": "curses.pair_content(pair_number)", "intent": "Return a tuple ( fg , bg ) containing the colors for the requested color pair . The value of `pair_number` must be between 1 and COLOR_PAIRS - 1 .", "question_id": 1966}
{"snippet": "curses.pair_number(attr)", "intent": "Return the number of the color-pair set by the attribute value `attr` .", "question_id": 1967}
{"snippet": "curses.putp(str)", "intent": "Equivalent to tputs ( `str` , 1 , putchar ) ; emit the value of a specified terminfo capability for the current terminal .", "question_id": 1968}
{"snippet": "curses.qiflush(flag)", "intent": "If `flag` is False , the effect is the same as calling noqiflush ( ) .", "question_id": 1969}
{"snippet": "curses.qiflush()", "intent": "If `flag` is False , the effect is the same as calling noqiflush ( ) .", "question_id": 1970}
{"snippet": "curses.raw()", "intent": "Enter raw mode .", "question_id": 1971}
{"snippet": "curses.reset_prog_mode()", "intent": "Restore the terminal to \u201c program \u201d mode , as previously saved by def_prog_mode ( ) .", "question_id": 1972}
{"snippet": "curses.reset_shell_mode()", "intent": "Restore the terminal to \u201c shell \u201d mode , as previously saved by def_shell_mode ( ) .", "question_id": 1973}
{"snippet": "curses.resetty()", "intent": "Restore the state of the terminal modes to what it was at the last call to savetty ( ) .", "question_id": 1974}
{"snippet": "curses.resize_term(nlines, ncols)", "intent": "Backend function used by resizeterm ( ) , performing most of the work ; when resizing the windows , resize_term ( ) blank-fills the areas that are extended . With arguments `nlines`, `ncols`.", "question_id": 1975}
{"snippet": "curses.resizeterm(nlines, ncols)", "intent": "Resize the standard and current windows to the specified dimensions , and adjusts other bookkeeping data used by the curses library that record the window dimensions ( in particular the SIGWINCH handler ) . With arguments `nlines`, `ncols`.", "question_id": 1976}
{"snippet": "curses.savetty()", "intent": "Save the current state of the terminal modes in a buffer , usable by resetty ( ) .", "question_id": 1977}
{"snippet": "curses.setsyx(y, x)", "intent": "Set the virtual screen cursor to `y` , `x` .", "question_id": 1978}
{"snippet": "curses.setupterm()", "intent": "Initialize the terminal .", "question_id": 1979}
{"snippet": "curses.setupterm(term=None)", "intent": "Initialize the terminal . `term` is a string giving the terminal name , or None ; if omitted or None , the value of the TERM environment variable will be used .", "question_id": 1980}
{"snippet": "curses.setupterm(fd=-1)", "intent": "Initialize the terminal . `fd` is the file descriptor to which any initialization sequences will be sent ; if not supplied or -1 , the file descriptor for sys.stdout will be used .", "question_id": 1981}
{"snippet": "curses.setupterm(term=None, fd=-1)", "intent": "Initialize the terminal . `term` is a string giving the terminal name , or None ; if omitted or None , the value of the TERM environment variable will be used . `fd` is the file descriptor to which any initialization sequences will be sent ; if not supplied or -1 , the file descriptor for sys.stdout will be used .", "question_id": 1982}
{"snippet": "curses.start_color()", "intent": "Must be called if the programmer wants to use colors , and before any other color manipulation routine is called .", "question_id": 1983}
{"snippet": "curses.termattrs()", "intent": "Return a logical OR of all video attributes supported by the terminal .", "question_id": 1984}
{"snippet": "curses.termname()", "intent": "Return the value of the environment variable TERM , as a bytes object , truncated to 14 characters .", "question_id": 1985}
{"snippet": "curses.tigetflag(capname)", "intent": "Return the value of the Boolean capability corresponding to the terminfo capability name `capname` as an integer .", "question_id": 1986}
{"snippet": "curses.tigetnum(capname)", "intent": "Return the value of the numeric capability corresponding to the terminfo capability name `capname` as an integer .", "question_id": 1987}
{"snippet": "curses.tigetstr(capname)", "intent": "Return the value of the string capability corresponding to the terminfo capability name `capname` as a bytes object .", "question_id": 1988}
{"snippet": "curses.tparm(str)", "intent": "Instantiate the bytes object `str` with the supplied parameters , where str should be a parameterized string obtained from the terminfo database .", "question_id": 1989}
{"snippet": "curses.tparm()", "intent": "Instantiate the bytes object `str` with the supplied parameters , where str should be a parameterized string obtained from the terminfo database .", "question_id": 1990}
{"snippet": "curses.typeahead(fd)", "intent": "Specify that the file descriptor `fd` be used for typeahead checking .", "question_id": 1991}
{"snippet": "curses.unctrl(ch)", "intent": "Return a bytes object which is a printable representation of the character `ch` .", "question_id": 1992}
{"snippet": "curses.ungetch(ch)", "intent": "Push `ch` so the next getch ( ) will return it .", "question_id": 1993}
{"snippet": "curses.update_lines_cols()", "intent": "Update LINES and COLS .", "question_id": 1994}
{"snippet": "curses.unget_wch(ch)", "intent": "Push `ch` so the next get_wch ( ) will return it .", "question_id": 1995}
{"snippet": "curses.ungetmouse(id, x, y, z, bstate)", "intent": "Push a KEY_MOUSE event onto the input queue , associating the given state data with it . With arguments `id`, `x`, `y`, `z`, `bstate`.", "question_id": 1996}
{"snippet": "curses.use_env(flag)", "intent": "If used , this function should be called before initscr ( ) or newterm are called . When `flag` is False , the values of lines and columns specified in the terminfo database will be used , even if environment variables LINES and COLUMNS ( used by default ) are set , or if curses is running in a window ( in which case default behavior would be to use the window size if LINES and COLUMNS are not set ) .", "question_id": 1997}
{"snippet": "curses.use_default_colors()", "intent": "Allow use of default values for colors on terminals supporting this feature .", "question_id": 1998}
{"snippet": "curses.wrapper(func)", "intent": "Initialize curses and call another callable object , `func` , which should be the rest of your curses-using application .", "question_id": 1999}
{"snippet": "window.addch(ch, attr)", "intent": "Paint character `ch` at ( y , x ) with attributes `attr` , overwriting any character previously painter at that location .", "question_id": 2000}
{"snippet": "window.addch(ch)", "intent": "Paint character `ch` at ( y , x ) with attributes `attr` , overwriting any character previously painter at that location .", "question_id": 2001}
{"snippet": "window.addch(y, x, ch, attr)", "intent": "Paint character `ch` at ( `y` , `x` ) with attributes `attr` , overwriting any character previously painter at that location .", "question_id": 2002}
{"snippet": "window.addch(y, x, ch)", "intent": "Paint character `ch` at ( `y` , `x` ) with attributes `attr` , overwriting any character previously painter at that location .", "question_id": 2003}
{"snippet": "window.addnstr(str, n, attr)", "intent": "Paint at most `n` characters of the character string `str` at ( y , x ) with attributes `attr` , overwriting anything previously on the display .", "question_id": 2004}
{"snippet": "window.addnstr(str, n)", "intent": "Paint at most `n` characters of the character string `str` at ( y , x ) with attributes `attr` , overwriting anything previously on the display .", "question_id": 2005}
{"snippet": "window.addnstr(y, x, str, n, attr)", "intent": "Paint at most `n` characters of the character string `str` at ( `y` , `x` ) with attributes `attr` , overwriting anything previously on the display .", "question_id": 2006}
{"snippet": "window.addnstr(y, x, str, n)", "intent": "Paint at most `n` characters of the character string `str` at ( `y` , `x` ) with attributes `attr` , overwriting anything previously on the display .", "question_id": 2007}
{"snippet": "window.addstr(str, attr)", "intent": "Paint the character string `str` at ( y , x ) with attributes `attr` , overwriting anything previously on the display .", "question_id": 2008}
{"snippet": "window.addstr(str)", "intent": "Paint the character string `str` at ( y , x ) with attributes `attr` , overwriting anything previously on the display .", "question_id": 2009}
{"snippet": "window.addstr(y, x, str, attr)", "intent": "Paint the character string `str` at ( `y` , `x` ) with attributes `attr` , overwriting anything previously on the display .", "question_id": 2010}
{"snippet": "window.addstr(y, x, str)", "intent": "Paint the character string `str` at ( `y` , `x` ) with attributes `attr` , overwriting anything previously on the display .", "question_id": 2011}
{"snippet": "window.attroff(attr)", "intent": "Remove attribute `attr` from the \u201c background \u201d set applied to all writes to the current window .", "question_id": 2012}
{"snippet": "window.attron(attr)", "intent": "Add attribute `attr` from the \u201c background \u201d set applied to all writes to the current window .", "question_id": 2013}
{"snippet": "window.attrset(attr)", "intent": "Set the \u201c background \u201d set of attributes to `attr` .", "question_id": 2014}
{"snippet": "window.bkgd(ch, attr)", "intent": "Set the background property of the window to the character `ch` , with attributes `attr` .", "question_id": 2015}
{"snippet": "window.bkgd(ch)", "intent": "Set the background property of the window to the character `ch` , with attributes `attr` .", "question_id": 2016}
{"snippet": "window.bkgdset(ch, attr)", "intent": "Set the window \u2019 s background . With arguments `ch`, `attr`.", "question_id": 2017}
{"snippet": "window.bkgdset(ch)", "intent": "Set the window \u2019 s background . With arguments `ch`.", "question_id": 2018}
{"snippet": "window.border(ls, rs, ts, bs, tl, tr, bl, br)", "intent": "Draw a border around the edges of the window . With arguments `ls`, `rs`, `ts`, `bs`, `tl`, `tr`, `bl`, `br`.", "question_id": 2019}
{"snippet": "window.border(ls, rs, ts, bs, tl, tr, bl)", "intent": "Draw a border around the edges of the window . With arguments `ls`, `rs`, `ts`, `bs`, `tl`, `tr`, `bl`.", "question_id": 2020}
{"snippet": "window.border(ls, rs, ts, bs, tl, tr)", "intent": "Draw a border around the edges of the window . With arguments `ls`, `rs`, `ts`, `bs`, `tl`, `tr`.", "question_id": 2021}
{"snippet": "window.border(ls, rs, ts, bs, tl)", "intent": "Draw a border around the edges of the window . With arguments `ls`, `rs`, `ts`, `bs`, `tl`.", "question_id": 2022}
{"snippet": "window.border(ls, rs, ts, bs)", "intent": "Draw a border around the edges of the window . With arguments `ls`, `rs`, `ts`, `bs`.", "question_id": 2023}
{"snippet": "window.border(ls, rs, ts)", "intent": "Draw a border around the edges of the window . With arguments `ls`, `rs`, `ts`.", "question_id": 2024}
{"snippet": "window.border(ls, rs)", "intent": "Draw a border around the edges of the window . With arguments `ls`, `rs`.", "question_id": 2025}
{"snippet": "window.border(ls)", "intent": "Draw a border around the edges of the window . With arguments `ls`.", "question_id": 2026}
{"snippet": "window.border()", "intent": "Draw a border around the edges of the window .", "question_id": 2027}
{"snippet": "window.box(vertch, horch)", "intent": "Similar to border ( ) , but both ls and rs are `vertch` and both ts and bs are `horch` .", "question_id": 2028}
{"snippet": "window.box(vertch)", "intent": "Similar to border ( ) , but both ls and rs are `vertch` and both ts and bs are `horch` .", "question_id": 2029}
{"snippet": "window.chgat(attr)", "intent": "Set the attributes of num characters at the current cursor position , or at position ( y , x ) if supplied . With arguments `attr`.", "question_id": 2030}
{"snippet": "window.chgat(num, attr)", "intent": "Set the attributes of `num` characters at the current cursor position , or at position ( y , x ) if supplied . With arguments `attr`.", "question_id": 2031}
{"snippet": "window.chgat(y, x, attr)", "intent": "Set the attributes of num characters at the current cursor position , or at position ( `y` , `x` ) if supplied . With arguments `attr`.", "question_id": 2032}
{"snippet": "window.chgat(y, x, num, attr)", "intent": "Set the attributes of `num` characters at the current cursor position , or at position ( `y` , `x` ) if supplied . With arguments `attr`.", "question_id": 2033}
{"snippet": "window.clear()", "intent": "Like erase ( ) , but also cause the whole window to be repainted upon next call to refresh ( ) .", "question_id": 2034}
{"snippet": "window.clearok(flag)", "intent": "If `flag` is True , the next call to refresh ( ) will clear the window completely .", "question_id": 2035}
{"snippet": "window.clrtobot()", "intent": "Erase from cursor to the end of the window : all lines below the cursor are deleted , and then the equivalent of clrtoeol ( ) is performed .", "question_id": 2036}
{"snippet": "window.clrtoeol()", "intent": "Erase from cursor to the end of the line .", "question_id": 2037}
{"snippet": "window.cursyncup()", "intent": "Update the current cursor position of all the ancestors of the window to reflect the current cursor position of the window .", "question_id": 2038}
{"snippet": "window.delch(y, x)", "intent": "Delete any character at ( `y` , `x` ) .", "question_id": 2039}
{"snippet": "window.delch(y)", "intent": "Delete any character at ( `y` , `x` ) .", "question_id": 2040}
{"snippet": "window.deleteln()", "intent": "Delete the line under the cursor .", "question_id": 2041}
{"snippet": "window.derwin(begin_y, begin_x)", "intent": "An abbreviation for \u201c derive window \u201d , derwin ( ) is the same as calling subwin ( ) , except that `begin_y` and `begin_x` are relative to the origin of the window , rather than relative to the entire screen .", "question_id": 2042}
{"snippet": "window.derwin(nlines, ncols, begin_y, begin_x)", "intent": "An abbreviation for \u201c derive window \u201d , derwin ( ) is the same as calling subwin ( ) , except that `begin_y` and `begin_x` are relative to the origin of the window , rather than relative to the entire screen . With arguments `nlines`, `ncols`.", "question_id": 2043}
{"snippet": "window.echochar(ch, attr)", "intent": "Add character `ch` with attribute `attr` , and immediately call refresh ( ) on the window .", "question_id": 2044}
{"snippet": "window.echochar(ch)", "intent": "Add character `ch` with attribute `attr` , and immediately call refresh ( ) on the window .", "question_id": 2045}
{"snippet": "window.enclose(y, x)", "intent": "Test whether the given pair of screen-relative character-cell coordinates are enclosed by the given window , returning True or False . With arguments `y`, `x`.", "question_id": 2046}
{"snippet": "window.encoding", "intent": "Encoding used to encode method arguments (Unicode strings and characters).", "question_id": 2047}
{"snippet": "window.erase()", "intent": "Clear the window .", "question_id": 2048}
{"snippet": "window.getbegyx()", "intent": "Return a tuple ( y , x ) of co-ordinates of upper-left corner .", "question_id": 2049}
{"snippet": "window.getbkgd()", "intent": "Return the given window \u2019 s current background character/attribute pair .", "question_id": 2050}
{"snippet": "window.getch(y, x)", "intent": "Get a character . With arguments `y`, `x`.", "question_id": 2051}
{"snippet": "window.getch(y)", "intent": "Get a character . With arguments `y`.", "question_id": 2052}
{"snippet": "window.get_wch(y, x)", "intent": "Get a wide character . With arguments `y`, `x`.", "question_id": 2053}
{"snippet": "window.get_wch(y)", "intent": "Get a wide character . With arguments `y`.", "question_id": 2054}
{"snippet": "window.getkey(y, x)", "intent": "Get a character , returning a string instead of an integer , as getch ( ) does . With arguments `y`, `x`.", "question_id": 2055}
{"snippet": "window.getkey(y)", "intent": "Get a character , returning a string instead of an integer , as getch ( ) does . With arguments `y`.", "question_id": 2056}
{"snippet": "window.getmaxyx()", "intent": "Return a tuple ( y , x ) of the height and width of the window .", "question_id": 2057}
{"snippet": "window.getparyx()", "intent": "Return the beginning coordinates of this window relative to its parent window as a tuple ( y , x ) .", "question_id": 2058}
{"snippet": "window.getstr()", "intent": "Read a bytes object from the user , with primitive line editing capacity .", "question_id": 2059}
{"snippet": "window.getstr(n)", "intent": "Read a bytes object from the user , with primitive line editing capacity . With arguments `n`.", "question_id": 2060}
{"snippet": "window.getstr(y, x)", "intent": "Read a bytes object from the user , with primitive line editing capacity . With arguments `y`, `x`.", "question_id": 2061}
{"snippet": "window.getstr(y, x, n)", "intent": "Read a bytes object from the user , with primitive line editing capacity . With arguments `y`, `x`, `n`.", "question_id": 2062}
{"snippet": "window.getyx()", "intent": "Return a tuple ( y , x ) of current cursor position relative to the window \u2019 s upper-left corner .", "question_id": 2063}
{"snippet": "window.hline(ch, n)", "intent": "Display a horizontal line starting at ( y , x ) with length `n` consisting of the character `ch` .", "question_id": 2064}
{"snippet": "window.hline(y, x, ch, n)", "intent": "Display a horizontal line starting at ( `y` , `x` ) with length `n` consisting of the character `ch` .", "question_id": 2065}
{"snippet": "window.idcok(flag)", "intent": "If `flag` is False , curses no longer considers using the hardware insert/delete character feature of the terminal ; if flag is True , use of character insertion and deletion is enabled .", "question_id": 2066}
{"snippet": "window.idlok(flag)", "intent": "If `flag` is True , curses will try and use hardware line editing facilities .", "question_id": 2067}
{"snippet": "window.immedok(flag)", "intent": "If `flag` is True , any change in the window image automatically causes the window to be refreshed ; you no longer have to call refresh ( ) yourself .", "question_id": 2068}
{"snippet": "window.inch(y, x)", "intent": "Return the character at the given position in the window . With arguments `y`, `x`.", "question_id": 2069}
{"snippet": "window.inch(y)", "intent": "Return the character at the given position in the window . With arguments `y`.", "question_id": 2070}
{"snippet": "window.insch(ch, attr)", "intent": "Paint character `ch` at ( y , x ) with attributes `attr` , moving the line from position x right by one character .", "question_id": 2071}
{"snippet": "window.insch(ch)", "intent": "Paint character `ch` at ( y , x ) with attributes `attr` , moving the line from position x right by one character .", "question_id": 2072}
{"snippet": "window.insch(y, x, ch, attr)", "intent": "Paint character `ch` at ( `y` , `x` ) with attributes `attr` , moving the line from position x right by one character .", "question_id": 2073}
{"snippet": "window.insch(y, x, ch)", "intent": "Paint character `ch` at ( `y` , `x` ) with attributes `attr` , moving the line from position x right by one character .", "question_id": 2074}
{"snippet": "window.insdelln(nlines)", "intent": "Insert `nlines` lines into the specified window above the current line .", "question_id": 2075}
{"snippet": "window.insertln()", "intent": "Insert a blank line under the cursor .", "question_id": 2076}
{"snippet": "window.insnstr(str, n, attr)", "intent": "Insert a character string ( as many characters as will fit on the line ) before the character under the cursor , up to `n` characters . With arguments `str`, `attr`.", "question_id": 2077}
{"snippet": "window.insnstr(str, n)", "intent": "Insert a character string ( as many characters as will fit on the line ) before the character under the cursor , up to `n` characters . With arguments `str`.", "question_id": 2078}
{"snippet": "window.insnstr(y, x, str, n, attr)", "intent": "Insert a character string ( as many characters as will fit on the line ) before the character under the cursor , up to `n` characters . The cursor position does not change ( after moving to `y` , `x` , if specified ) . With arguments `str`, `attr`.", "question_id": 2079}
{"snippet": "window.insnstr(y, x, str, n)", "intent": "Insert a character string ( as many characters as will fit on the line ) before the character under the cursor , up to `n` characters . The cursor position does not change ( after moving to `y` , `x` , if specified ) . With arguments `str`.", "question_id": 2080}
{"snippet": "window.insstr(str, attr)", "intent": "Insert a character string ( as many characters as will fit on the line ) before the character under the cursor . With arguments `str`, `attr`.", "question_id": 2081}
{"snippet": "window.insstr(str)", "intent": "Insert a character string ( as many characters as will fit on the line ) before the character under the cursor . With arguments `str`.", "question_id": 2082}
{"snippet": "window.insstr(y, x, str, attr)", "intent": "Insert a character string ( as many characters as will fit on the line ) before the character under the cursor . The cursor position does not change ( after moving to `y` , `x` , if specified ) . With arguments `str`, `attr`.", "question_id": 2083}
{"snippet": "window.insstr(y, x, str)", "intent": "Insert a character string ( as many characters as will fit on the line ) before the character under the cursor . The cursor position does not change ( after moving to `y` , `x` , if specified ) . With arguments `str`.", "question_id": 2084}
{"snippet": "window.instr(n)", "intent": "Return a bytes object of characters , extracted from the window starting at the current cursor position , or at y , x if specified . If `n` is specified , instr ( ) returns a string at most n characters long ( exclusive of the trailing NUL ) .", "question_id": 2085}
{"snippet": "window.instr()", "intent": "Return a bytes object of characters , extracted from the window starting at the current cursor position , or at y , x if specified .", "question_id": 2086}
{"snippet": "window.instr(y, x, n)", "intent": "Return a bytes object of characters , extracted from the window starting at the current cursor position , or at `y` , `x` if specified . If `n` is specified , instr ( ) returns a string at most n characters long ( exclusive of the trailing NUL ) .", "question_id": 2087}
{"snippet": "window.instr(y, x)", "intent": "Return a bytes object of characters , extracted from the window starting at the current cursor position , or at `y` , `x` if specified .", "question_id": 2088}
{"snippet": "window.is_linetouched(line)", "intent": "Return True if the specified `line` was modified since the last call to refresh ( ) ; otherwise return False .", "question_id": 2089}
{"snippet": "window.is_wintouched()", "intent": "Return True if the specified window was modified since the last call to refresh ( ) ; otherwise return False .", "question_id": 2090}
{"snippet": "window.keypad(flag)", "intent": "If `flag` is True , escape sequences generated by some keys ( keypad , function keys ) will be interpreted by curses .", "question_id": 2091}
{"snippet": "window.leaveok(flag)", "intent": "If `flag` is True , cursor is left where it is on update , instead of being at \u201c cursor position. \u201d This reduces cursor movement where possible .", "question_id": 2092}
{"snippet": "window.move(new_y, new_x)", "intent": "Move cursor to ( `new_y` , `new_x` ) .", "question_id": 2093}
{"snippet": "window.mvderwin(y, x)", "intent": "Move the window inside its parent window . With arguments `y`, `x`.", "question_id": 2094}
{"snippet": "window.mvwin(new_y, new_x)", "intent": "Move the window so its upper-left corner is at ( `new_y` , `new_x` ) .", "question_id": 2095}
{"snippet": "window.nodelay(flag)", "intent": "If `flag` is True , getch ( ) will be non-blocking .", "question_id": 2096}
{"snippet": "window.notimeout(flag)", "intent": "If `flag` is True , escape sequences will not be timed out .", "question_id": 2097}
{"snippet": "window.noutrefresh()", "intent": "Mark for refresh but wait .", "question_id": 2098}
{"snippet": "window.overlay(destwin, sminrow, smincol, dminrow, dmincol, dmaxrow, dmaxcol)", "intent": "Overlay the window on top of `destwin` . `sminrow` and `smincol` are the upper-left coordinates of the source window , and the other variables mark a rectangle in the destination window . With arguments `dminrow`, `dmincol`, `dmaxrow`, `dmaxcol`.", "question_id": 2099}
{"snippet": "window.overlay(destwin, sminrow, smincol, dminrow, dmincol, dmaxrow)", "intent": "Overlay the window on top of `destwin` . `sminrow` and `smincol` are the upper-left coordinates of the source window , and the other variables mark a rectangle in the destination window . With arguments `dminrow`, `dmincol`, `dmaxrow`.", "question_id": 2100}
{"snippet": "window.overwrite(destwin, sminrow, smincol, dminrow, dmincol, dmaxrow, dmaxcol)", "intent": "Overwrite the window on top of `destwin` . `sminrow` and `smincol` are the upper-left coordinates of the source window , the other variables mark a rectangle in the destination window . With arguments `dminrow`, `dmincol`, `dmaxrow`, `dmaxcol`.", "question_id": 2101}
{"snippet": "window.overwrite(destwin, sminrow, smincol, dminrow, dmincol, dmaxrow)", "intent": "Overwrite the window on top of `destwin` . `sminrow` and `smincol` are the upper-left coordinates of the source window , the other variables mark a rectangle in the destination window . With arguments `dminrow`, `dmincol`, `dmaxrow`.", "question_id": 2102}
{"snippet": "window.putwin(file)", "intent": "Write all data associated with the window into the provided `file` object .", "question_id": 2103}
{"snippet": "window.redrawln(beg, num)", "intent": "Indicate that the `num` screen lines , starting at line `beg` , are corrupted and should be completely redrawn on the next refresh ( ) call .", "question_id": 2104}
{"snippet": "window.redrawwin()", "intent": "Touch the entire window , causing it to be completely redrawn on the next refresh ( ) call .", "question_id": 2105}
{"snippet": "window.refresh(pminrow, pmincol, sminrow, smincol, smaxrow, smaxcol)", "intent": "Update the display immediately ( sync actual screen with previous drawing/deleting methods ) . `pminrow` and `pmincol` specify the upper left-hand corner of the rectangle to be displayed in the pad . `sminrow` , `smincol` , `smaxrow` , and `smaxcol` specify the edges of the rectangle to be displayed on the screen .", "question_id": 2106}
{"snippet": "window.refresh(pminrow, pmincol, sminrow, smincol, smaxrow)", "intent": "Update the display immediately ( sync actual screen with previous drawing/deleting methods ) . `pminrow` and `pmincol` specify the upper left-hand corner of the rectangle to be displayed in the pad . `sminrow` , `smincol` , `smaxrow` , and `smaxcol` specify the edges of the rectangle to be displayed on the screen .", "question_id": 2107}
{"snippet": "window.resize(nlines, ncols)", "intent": "Reallocate storage for a curses window to adjust its dimensions to the specified values . With arguments `nlines`, `ncols`.", "question_id": 2108}
{"snippet": "window.scroll()", "intent": "Scroll the screen or scrolling region upward by `lines` lines .", "question_id": 2109}
{"snippet": "window.scroll(lines=1)", "intent": "Scroll the screen or scrolling region upward by `lines` lines .", "question_id": 2110}
{"snippet": "window.scroll()", "intent": "Scroll the screen or scrolling region upward by `lines` lines .", "question_id": 2111}
{"snippet": "window.scroll(lines=1)", "intent": "Scroll the screen or scrolling region upward by `lines` lines .", "question_id": 2112}
{"snippet": "window.scrollok(flag)", "intent": "Control what happens when the cursor of a window is moved off the edge of the window or scrolling region , either as a result of a newline action on the bottom line , or typing the last character of the last line . If `flag` is False , the cursor is left on the bottom line .", "question_id": 2113}
{"snippet": "window.setscrreg(top, bottom)", "intent": "Set the scrolling region from line `top` to line `bottom` .", "question_id": 2114}
{"snippet": "window.standend()", "intent": "Turn off the standout attribute .", "question_id": 2115}
{"snippet": "window.standout()", "intent": "Turn on attribute A_STANDOUT .", "question_id": 2116}
{"snippet": "window.subpad(begin_y, begin_x)", "intent": "Return a sub-window , whose upper-left corner is at ( `begin_y` , `begin_x` ) , and whose width/height is ncols/nlines .", "question_id": 2117}
{"snippet": "window.subpad(nlines, ncols, begin_y, begin_x)", "intent": "Return a sub-window , whose upper-left corner is at ( `begin_y` , `begin_x` ) , and whose width/height is ncols/nlines . With arguments `nlines`, `ncols`.", "question_id": 2118}
{"snippet": "window.subwin(begin_y, begin_x)", "intent": "Return a sub-window , whose upper-left corner is at ( `begin_y` , `begin_x` ) , and whose width/height is ncols/nlines .", "question_id": 2119}
{"snippet": "window.subwin(nlines, ncols, begin_y, begin_x)", "intent": "Return a sub-window , whose upper-left corner is at ( `begin_y` , `begin_x` ) , and whose width/height is ncols/nlines . With arguments `nlines`, `ncols`.", "question_id": 2120}
{"snippet": "window.syncdown()", "intent": "Touch each location in the window that has been touched in any of its ancestor windows .", "question_id": 2121}
{"snippet": "window.syncok(flag)", "intent": "If `flag` is True , then syncup ( ) is called automatically whenever there is a change in the window .", "question_id": 2122}
{"snippet": "window.syncup()", "intent": "Touch all locations in ancestors of the window that have been changed in the window .", "question_id": 2123}
{"snippet": "window.timeout(delay)", "intent": "Set blocking or non-blocking read behavior for the window . If `delay` is negative , blocking read is used ( which will wait indefinitely for input ) .", "question_id": 2124}
{"snippet": "window.touchline(start, count, changed)", "intent": "Pretend `count` lines have been `changed` , starting with line `start` .", "question_id": 2125}
{"snippet": "window.touchline(start, count)", "intent": "Pretend `count` lines have been `changed` , starting with line `start` .", "question_id": 2126}
{"snippet": "window.touchwin()", "intent": "Pretend the whole window has been changed , for purposes of drawing optimizations .", "question_id": 2127}
{"snippet": "window.untouchwin()", "intent": "Mark all lines in the window as unchanged since the last call to refresh ( ) .", "question_id": 2128}
{"snippet": "window.vline(ch, n)", "intent": "Display a vertical line starting at ( y , x ) with length `n` consisting of the character `ch` .", "question_id": 2129}
{"snippet": "window.vline(y, x, ch, n)", "intent": "Display a vertical line starting at ( `y` , `x` ) with length `n` consisting of the character `ch` .", "question_id": 2130}
{"snippet": "curses.ERR", "intent": "Some curses routines  that  return  an integer, such as getch(), return ERR upon failure.", "question_id": 2131}
{"snippet": "curses.OK", "intent": "Some curses routines  that  return  an integer, such as  napms(), return OK upon success.", "question_id": 2132}
{"snippet": "curses.version", "intent": "A bytes object representing the current version of the module.", "question_id": 2133}
{"snippet": "curses.textpad.rectangle(win, uly, ulx, lry, lrx)", "intent": "Draw a rectangle . With arguments `win`, `uly`, `ulx`, `lry`, `lrx`.", "question_id": 2134}
{"snippet": "curses.textpad.Textbox(win)", "intent": "Return a textbox widget object . The `win` argument should be a curses window object in which the textbox is to be contained .", "question_id": 2135}
{"snippet": "textbox.edit(validator)", "intent": "This is the entry point you will normally use . If `validator` is supplied , it must be a function .", "question_id": 2136}
{"snippet": "textbox.edit()", "intent": "This is the entry point you will normally use .", "question_id": 2137}
{"snippet": "textbox.do_command(ch)", "intent": "Process a single command keystroke . With arguments `ch`.", "question_id": 2138}
{"snippet": "textbox.gather()", "intent": "Return the window contents as a string ; whether blanks in the window are included is affected by the stripspaces member .", "question_id": 2139}
{"snippet": "textbox.stripspaces", "intent": "This attribute is a flag which controls the interpretation of blanks in the window.", "question_id": 2140}
{"snippet": "curses.panel.bottom_panel()", "intent": "Returns the bottom panel in the panel stack .", "question_id": 2141}
{"snippet": "curses.panel.new_panel(win)", "intent": "Returns a panel object , associating it with the given window `win` .", "question_id": 2142}
{"snippet": "curses.panel.top_panel()", "intent": "Returns the top panel in the panel stack .", "question_id": 2143}
{"snippet": "curses.panel.update_panels()", "intent": "Updates the virtual screen after changes in the panel stack .", "question_id": 2144}
{"snippet": "Panel.above()", "intent": "Returns the panel above the current panel .", "question_id": 2145}
{"snippet": "Panel.below()", "intent": "Returns the panel below the current panel .", "question_id": 2146}
{"snippet": "Panel.bottom()", "intent": "Push the panel to the bottom of the stack .", "question_id": 2147}
{"snippet": "Panel.hidden()", "intent": "Returns True if the panel is hidden ( not visible ) , False otherwise .", "question_id": 2148}
{"snippet": "Panel.hide()", "intent": "Hide the panel .", "question_id": 2149}
{"snippet": "Panel.move(y, x)", "intent": "Move the panel to the screen coordinates ( `y` , `x` ) .", "question_id": 2150}
{"snippet": "Panel.replace(win)", "intent": "Change the window associated with the panel to the window `win` .", "question_id": 2151}
{"snippet": "Panel.set_userptr(obj)", "intent": "Set the panel \u2019 s user pointer to `obj` .", "question_id": 2152}
{"snippet": "Panel.show()", "intent": "Display the panel ( which might have been hidden ) .", "question_id": 2153}
{"snippet": "Panel.top()", "intent": "Push panel to the top of the stack .", "question_id": 2154}
{"snippet": "Panel.userptr()", "intent": "Returns the user pointer for the panel .", "question_id": 2155}
{"snippet": "Panel.window()", "intent": "Returns the window object associated with the panel .", "question_id": 2156}
{"snippet": "@dataclasses.dataclass()", "intent": "This function is a decorator that is used to add generated special methods to classes , as described below .", "question_id": 2157}
{"snippet": "@dataclasses.dataclass(init=True)", "intent": "This function is a decorator that is used to add generated special methods to classes , as described below . With arguments `init`.", "question_id": 2158}
{"snippet": "@dataclasses.dataclass(repr=True)", "intent": "This function is a decorator that is used to add generated special methods to classes , as described below . With arguments `repr`.", "question_id": 2159}
{"snippet": "@dataclasses.dataclass(eq=True)", "intent": "This function is a decorator that is used to add generated special methods to classes , as described below . With arguments `eq`.", "question_id": 2160}
{"snippet": "@dataclasses.dataclass(order=False)", "intent": "This function is a decorator that is used to add generated special methods to classes , as described below . The `order` of the fields in all of the generated methods is the order in which they appear in the class definition .", "question_id": 2161}
{"snippet": "@dataclasses.dataclass(unsafe_hash=False)", "intent": "This function is a decorator that is used to add generated special methods to classes , as described below . With arguments `unsafe_hash`.", "question_id": 2162}
{"snippet": "@dataclasses.dataclass(frozen=False)", "intent": "This function is a decorator that is used to add generated special methods to classes , as described below . With arguments `frozen`.", "question_id": 2163}
{"snippet": "@dataclasses.dataclass(init=True, repr=True)", "intent": "This function is a decorator that is used to add generated special methods to classes , as described below . With arguments `init`, `repr`.", "question_id": 2164}
{"snippet": "@dataclasses.dataclass(init=True, eq=True)", "intent": "This function is a decorator that is used to add generated special methods to classes , as described below . With arguments `init`, `eq`.", "question_id": 2165}
{"snippet": "@dataclasses.dataclass(init=True, order=False)", "intent": "This function is a decorator that is used to add generated special methods to classes , as described below . The `order` of the fields in all of the generated methods is the order in which they appear in the class definition . With arguments `init`.", "question_id": 2166}
{"snippet": "dataclasses.field()", "intent": "For common and simple use cases , no other functionality is required .", "question_id": 2167}
{"snippet": "dataclasses.field(default=MISSING)", "intent": "For common and simple use cases , no other functionality is required . To satisfy this need for additional information , you can replace the `default` field value with a call to the provided field ( ) function .", "question_id": 2168}
{"snippet": "dataclasses.field(default_factory=MISSING)", "intent": "For common and simple use cases , no other functionality is required . As shown above , the MISSING value is a sentinel object used to detect if the default and `default_factory` parameters are provided .", "question_id": 2169}
{"snippet": "dataclasses.field(repr=True)", "intent": "For common and simple use cases , no other functionality is required . With arguments `repr`.", "question_id": 2170}
{"snippet": "dataclasses.field(hash=None)", "intent": "For common and simple use cases , no other functionality is required . With arguments `hash`.", "question_id": 2171}
{"snippet": "dataclasses.field(init=True)", "intent": "For common and simple use cases , no other functionality is required . With arguments `init`.", "question_id": 2172}
{"snippet": "dataclasses.field(compare=True)", "intent": "For common and simple use cases , no other functionality is required . With arguments `compare`.", "question_id": 2173}
{"snippet": "dataclasses.field(metadata=None)", "intent": "For common and simple use cases , no other functionality is required . With arguments `metadata`.", "question_id": 2174}
{"snippet": "dataclasses.field(default=MISSING, default_factory=MISSING)", "intent": "For common and simple use cases , no other functionality is required . To satisfy this need for additional information , you can replace the `default` field value with a call to the provided field ( ) function . As shown above , the MISSING value is a sentinel object used to detect if the default and `default_factory` parameters are provided .", "question_id": 2175}
{"snippet": "dataclasses.field(default=MISSING, repr=True)", "intent": "For common and simple use cases , no other functionality is required . To satisfy this need for additional information , you can replace the `default` field value with a call to the provided field ( ) function . With arguments `repr`.", "question_id": 2176}
{"snippet": "dataclasses.Field", "intent": "Field objects describe each defined field.", "question_id": 2177}
{"snippet": "dataclasses.fields(class_or_instance)", "intent": "Returns a tuple of Field objects that define the fields for this dataclass . With arguments `class_or_instance`.", "question_id": 2178}
{"snippet": "dataclasses.asdict(instance)", "intent": "Converts the dataclass `instance` to a dict ( by using the factory function `dict_factory` ) .", "question_id": 2179}
{"snippet": "dataclasses.asdict(instance, dict_factory=dict)", "intent": "Converts the dataclass `instance` to a dict ( by using the factory function `dict_factory` ) .", "question_id": 2180}
{"snippet": "dataclasses.astuple(instance)", "intent": "Converts the dataclass `instance` to a tuple ( by using the factory function `tuple_factory` ) .", "question_id": 2181}
{"snippet": "dataclasses.astuple(instance, tuple_factory=tuple)", "intent": "Converts the dataclass `instance` to a tuple ( by using the factory function `tuple_factory` ) .", "question_id": 2182}
{"snippet": "dataclasses.make_dataclass(cls_name, fields)", "intent": "Creates a new dataclass with name `cls_name` , `fields` as defined in fields , base classes as given in `bases` , and initialized with a `namespace` as given in namespace .", "question_id": 2183}
{"snippet": "dataclasses.make_dataclass(cls_name, fields, bases=())", "intent": "Creates a new dataclass with name `cls_name` , `fields` as defined in fields , base classes as given in `bases` , and initialized with a `namespace` as given in namespace .", "question_id": 2184}
{"snippet": "dataclasses.make_dataclass(cls_name, fields, namespace=None)", "intent": "Creates a new dataclass with name `cls_name` , `fields` as defined in fields , base classes as given in `bases` , and initialized with a `namespace` as given in namespace .", "question_id": 2185}
{"snippet": "dataclasses.make_dataclass(cls_name, fields, init=True)", "intent": "Creates a new dataclass with name `cls_name` , `fields` as defined in fields , base classes as given in `bases` , and initialized with a `namespace` as given in namespace . The values of `init` , `repr` , `eq` , `order` , `unsafe_hash` , and `frozen` have the same meaning as they do in dataclass ( ) .", "question_id": 2186}
{"snippet": "dataclasses.make_dataclass(cls_name, fields, repr=True)", "intent": "Creates a new dataclass with name `cls_name` , `fields` as defined in fields , base classes as given in `bases` , and initialized with a `namespace` as given in namespace . The values of `init` , `repr` , `eq` , `order` , `unsafe_hash` , and `frozen` have the same meaning as they do in dataclass ( ) .", "question_id": 2187}
{"snippet": "dataclasses.make_dataclass(cls_name, fields, eq=True)", "intent": "Creates a new dataclass with name `cls_name` , `fields` as defined in fields , base classes as given in `bases` , and initialized with a `namespace` as given in namespace . The values of `init` , `repr` , `eq` , `order` , `unsafe_hash` , and `frozen` have the same meaning as they do in dataclass ( ) .", "question_id": 2188}
{"snippet": "dataclasses.make_dataclass(cls_name, fields, order=False)", "intent": "Creates a new dataclass with name `cls_name` , `fields` as defined in fields , base classes as given in `bases` , and initialized with a `namespace` as given in namespace . The values of `init` , `repr` , `eq` , `order` , `unsafe_hash` , and `frozen` have the same meaning as they do in dataclass ( ) .", "question_id": 2189}
{"snippet": "dataclasses.make_dataclass(cls_name, fields, unsafe_hash=False)", "intent": "Creates a new dataclass with name `cls_name` , `fields` as defined in fields , base classes as given in `bases` , and initialized with a `namespace` as given in namespace . The values of `init` , `repr` , `eq` , `order` , `unsafe_hash` , and `frozen` have the same meaning as they do in dataclass ( ) .", "question_id": 2190}
{"snippet": "dataclasses.make_dataclass(cls_name, fields, frozen=False)", "intent": "Creates a new dataclass with name `cls_name` , `fields` as defined in fields , base classes as given in `bases` , and initialized with a `namespace` as given in namespace . The values of `init` , `repr` , `eq` , `order` , `unsafe_hash` , and `frozen` have the same meaning as they do in dataclass ( ) .", "question_id": 2191}
{"snippet": "dataclasses.make_dataclass(cls_name, fields, bases=(), namespace=None)", "intent": "Creates a new dataclass with name `cls_name` , `fields` as defined in fields , base classes as given in `bases` , and initialized with a `namespace` as given in namespace .", "question_id": 2192}
{"snippet": "dataclasses.replace(instance, **changes)", "intent": "Creates a new object of the same type of `instance` , replacing fields with values from changes . With arguments `**changes`.", "question_id": 2193}
{"snippet": "dataclasses.is_dataclass(class_or_instance)", "intent": "Returns True if its parameter is a dataclass or an instance of one , otherwise returns False . With arguments `class_or_instance`.", "question_id": 2194}
{"snippet": "dataclasses.FrozenInstanceError", "intent": "Raised when an implicitly defined __setattr__() or __delattr__() is called on a dataclass which was defined with frozen=True.", "question_id": 2195}
{"snippet": "datetime.MINYEAR", "intent": "The smallest year number allowed in a date or datetime object.", "question_id": 2196}
{"snippet": "datetime.MAXYEAR", "intent": "The largest year number allowed in a date or datetime object.", "question_id": 2197}
{"snippet": "datetime.date", "intent": "An idealized naive date, assuming the current Gregorian calendar always was, and always will be, in effect.", "question_id": 2198}
{"snippet": "datetime.time", "intent": "An idealized time, independent of any particular day, assuming that every day has exactly 24*60*60 seconds (there is no notion of \u201cleap seconds\u201d here).", "question_id": 2199}
{"snippet": "datetime.datetime", "intent": "A combination of a date and a time.", "question_id": 2200}
{"snippet": "datetime.timedelta", "intent": "A duration expressing the difference between two date, time, or datetime instances to microsecond resolution.", "question_id": 2201}
{"snippet": "datetime.tzinfo", "intent": "An abstract base class for time zone information objects.", "question_id": 2202}
{"snippet": "datetime.timezone", "intent": "A class that implements the tzinfo abstract base class as a fixed offset from the UTC.", "question_id": 2203}
{"snippet": "datetime.timedelta()", "intent": "All arguments are optional and default to 0 .", "question_id": 2204}
{"snippet": "datetime.timedelta(days=0)", "intent": "All arguments are optional and default to 0 . Only `days` , `seconds` and `microseconds` are stored internally .", "question_id": 2205}
{"snippet": "datetime.timedelta(seconds=0)", "intent": "All arguments are optional and default to 0 . Only `days` , `seconds` and `microseconds` are stored internally .", "question_id": 2206}
{"snippet": "datetime.timedelta(microseconds=0)", "intent": "All arguments are optional and default to 0 . Only `days` , `seconds` and `microseconds` are stored internally .", "question_id": 2207}
{"snippet": "datetime.timedelta(milliseconds=0)", "intent": "All arguments are optional and default to 0 . With arguments `milliseconds`.", "question_id": 2208}
{"snippet": "datetime.timedelta(minutes=0)", "intent": "All arguments are optional and default to 0 . With arguments `minutes`.", "question_id": 2209}
{"snippet": "datetime.timedelta(hours=0)", "intent": "All arguments are optional and default to 0 . With arguments `hours`.", "question_id": 2210}
{"snippet": "datetime.timedelta(weeks=0)", "intent": "All arguments are optional and default to 0 . With arguments `weeks`.", "question_id": 2211}
{"snippet": "datetime.timedelta(days=0, seconds=0)", "intent": "All arguments are optional and default to 0 . Only `days` , `seconds` and `microseconds` are stored internally .", "question_id": 2212}
{"snippet": "datetime.timedelta(days=0, microseconds=0)", "intent": "All arguments are optional and default to 0 . Only `days` , `seconds` and `microseconds` are stored internally .", "question_id": 2213}
{"snippet": "timedelta.min", "intent": "The most negative timedelta object, timedelta(-999999999).", "question_id": 2214}
{"snippet": "timedelta.max", "intent": "The most positive timedelta object, timedelta(days=999999999, hours=23, minutes=59, seconds=59, microseconds=999999).", "question_id": 2215}
{"snippet": "timedelta.resolution", "intent": "The smallest possible difference between non-equal timedelta objects, timedelta(microseconds=1).", "question_id": 2216}
{"snippet": "timedelta.total_seconds()", "intent": "Return the total number of seconds contained in the duration .", "question_id": 2217}
{"snippet": "datetime.date(year, month, day)", "intent": "All arguments are required . With arguments `year`, `month`, `day`.", "question_id": 2218}
{"snippet": "date.today()", "intent": "Return the current local date .", "question_id": 2219}
{"snippet": "date.fromtimestamp(timestamp)", "intent": "Return the local date corresponding to the POSIX `timestamp` , such as is returned by time.time ( ) .", "question_id": 2220}
{"snippet": "date.fromordinal(ordinal)", "intent": "Return the date corresponding to the proleptic Gregorian `ordinal` , where January 1 of year 1 has ordinal 1 .", "question_id": 2221}
{"snippet": "date.fromisoformat(date_string)", "intent": "Return a date corresponding to a `date_string` in the format emitted by date.isoformat ( ) .", "question_id": 2222}
{"snippet": "date.min", "intent": "The earliest representable date, date(MINYEAR, 1, 1).", "question_id": 2223}
{"snippet": "date.max", "intent": "The latest representable date, date(MAXYEAR, 12, 31).", "question_id": 2224}
{"snippet": "date.resolution", "intent": "The smallest possible difference between non-equal date objects, timedelta(days=1).", "question_id": 2225}
{"snippet": "date.year", "intent": "Between MINYEAR and MAXYEAR inclusive.", "question_id": 2226}
{"snippet": "date.month", "intent": "Between 1 and 12 inclusive.", "question_id": 2227}
{"snippet": "date.day", "intent": "Between 1 and the number of days in the given month of the given year.", "question_id": 2228}
{"snippet": "date.replace()", "intent": "Return a date with the same value , except for those parameters given new values by whichever keyword arguments are specified .", "question_id": 2229}
{"snippet": "date.replace(year=self.year)", "intent": "Return a date with the same value , except for those parameters given new values by whichever keyword arguments are specified . With arguments `year`.", "question_id": 2230}
{"snippet": "date.replace(month=self.month)", "intent": "Return a date with the same value , except for those parameters given new values by whichever keyword arguments are specified . With arguments `month`.", "question_id": 2231}
{"snippet": "date.replace(day=self.day)", "intent": "Return a date with the same value , except for those parameters given new values by whichever keyword arguments are specified . With arguments `day`.", "question_id": 2232}
{"snippet": "date.replace(year=self.year, month=self.month)", "intent": "Return a date with the same value , except for those parameters given new values by whichever keyword arguments are specified . With arguments `year`, `month`.", "question_id": 2233}
{"snippet": "date.replace(year=self.year, day=self.day)", "intent": "Return a date with the same value , except for those parameters given new values by whichever keyword arguments are specified . With arguments `year`, `day`.", "question_id": 2234}
{"snippet": "date.replace(month=self.month, day=self.day)", "intent": "Return a date with the same value , except for those parameters given new values by whichever keyword arguments are specified . With arguments `month`, `day`.", "question_id": 2235}
{"snippet": "date.replace(year=self.year, month=self.month, day=self.day)", "intent": "Return a date with the same value , except for those parameters given new values by whichever keyword arguments are specified . With arguments `year`, `month`, `day`.", "question_id": 2236}
{"snippet": "date.timetuple()", "intent": "Return a time.struct_time such as returned by time.localtime ( ) .", "question_id": 2237}
{"snippet": "date.toordinal()", "intent": "Return the proleptic Gregorian ordinal of the date , where January 1 of year 1 has ordinal 1 .", "question_id": 2238}
{"snippet": "date.weekday()", "intent": "Return the day of the week as an integer , where Monday is 0 and Sunday is 6 .", "question_id": 2239}
{"snippet": "date.isoweekday()", "intent": "Return the day of the week as an integer , where Monday is 1 and Sunday is 7 .", "question_id": 2240}
{"snippet": "date.isocalendar()", "intent": "Return a 3-tuple , ( ISO year , ISO week number , ISO weekday ) .", "question_id": 2241}
{"snippet": "date.isoformat()", "intent": "Return a string representing the date in ISO 8601 format , \u2018 YYYY-MM-DD \u2019 .", "question_id": 2242}
{"snippet": "date.__str__()", "intent": "For a date d , str ( d ) is equivalent to d.isoformat ( ) .", "question_id": 2243}
{"snippet": "date.ctime()", "intent": "Return a string representing the date , for example date ( 2002 , 12 , 4 ) .ctime ( ) == 'Wed Dec 4 00:00:00 2002 ' .", "question_id": 2244}
{"snippet": "date.strftime(format)", "intent": "Return a string representing the date , controlled by an explicit `format` string .", "question_id": 2245}
{"snippet": "date.__format__(format)", "intent": "Same as date.strftime ( ) . This makes it possible to specify a `format` string for a date object in formatted string literals and when using str.format ( ) .", "question_id": 2246}
{"snippet": "datetime.datetime(year, month, day)", "intent": "The `year` , `month` and `day` arguments are required .", "question_id": 2247}
{"snippet": "datetime.datetime(year, month, day, hour=0)", "intent": "The `year` , `month` and `day` arguments are required . With arguments `hour`.", "question_id": 2248}
{"snippet": "datetime.datetime(year, month, day, minute=0)", "intent": "The `year` , `month` and `day` arguments are required . With arguments `minute`.", "question_id": 2249}
{"snippet": "datetime.datetime(year, month, day, second=0)", "intent": "The `year` , `month` and `day` arguments are required . With arguments `second`.", "question_id": 2250}
{"snippet": "datetime.datetime(year, month, day, microsecond=0)", "intent": "The `year` , `month` and `day` arguments are required . With arguments `microsecond`.", "question_id": 2251}
{"snippet": "datetime.datetime(year, month, day, tzinfo=None)", "intent": "The `year` , `month` and `day` arguments are required . `tzinfo` may be None , or an instance of a tzinfo subclass .", "question_id": 2252}
{"snippet": "datetime.datetime(year, month, day, fold=0)", "intent": "The `year` , `month` and `day` arguments are required . With arguments `fold`.", "question_id": 2253}
{"snippet": "datetime.datetime(year, month, day, hour=0, minute=0)", "intent": "The `year` , `month` and `day` arguments are required . With arguments `hour`, `minute`.", "question_id": 2254}
{"snippet": "datetime.datetime(year, month, day, hour=0, second=0)", "intent": "The `year` , `month` and `day` arguments are required . With arguments `hour`, `second`.", "question_id": 2255}
{"snippet": "datetime.datetime(year, month, day, hour=0, microsecond=0)", "intent": "The `year` , `month` and `day` arguments are required . With arguments `hour`, `microsecond`.", "question_id": 2256}
{"snippet": "datetime.today()", "intent": "Return the current local datetime , with tzinfo None .", "question_id": 2257}
{"snippet": "datetime.now()", "intent": "Return the current local date and time .", "question_id": 2258}
{"snippet": "datetime.now(tz=None)", "intent": "Return the current local date and time . If optional argument `tz` is None or not specified , this is like today ( ) , but , if possible , supplies more precision than can be gotten from going through a time.time ( ) timestamp ( for example , this may be possible on platforms supplying the C gettimeofday ( ) function ) .", "question_id": 2259}
{"snippet": "datetime.utcnow()", "intent": "Return the current UTC date and time , with tzinfo None .", "question_id": 2260}
{"snippet": "datetime.fromtimestamp(timestamp)", "intent": "Return the local date and time corresponding to the POSIX `timestamp` , such as is returned by time.time ( ) .", "question_id": 2261}
{"snippet": "datetime.fromtimestamp(timestamp, tz=None)", "intent": "Return the local date and time corresponding to the POSIX `timestamp` , such as is returned by time.time ( ) . If optional argument `tz` is None or not specified , the timestamp is converted to the platform \u2019 s local date and time , and the returned datetime object is naive .", "question_id": 2262}
{"snippet": "datetime.utcfromtimestamp(timestamp)", "intent": "Return the UTC datetime corresponding to the POSIX `timestamp` , with tzinfo None .", "question_id": 2263}
{"snippet": "datetime.fromordinal(ordinal)", "intent": "Return the datetime corresponding to the proleptic Gregorian `ordinal` , where January 1 of year 1 has ordinal 1 .", "question_id": 2264}
{"snippet": "datetime.combine(date, time)", "intent": "Return a new datetime object whose `date` components are equal to the given date object \u2019 s , and whose `time` components are equal to the given time object \u2019 s .", "question_id": 2265}
{"snippet": "datetime.combine(date, time, tzinfo=self.tzinfo)", "intent": "Return a new datetime object whose `date` components are equal to the given date object \u2019 s , and whose `time` components are equal to the given time object \u2019 s . If the `tzinfo` argument is provided , its value is used to set the tzinfo attribute of the result , otherwise the tzinfo attribute of the time argument is used .", "question_id": 2266}
{"snippet": "datetime.fromisoformat(date_string)", "intent": "Return a datetime corresponding to a `date_string` in one of the formats emitted by date.isoformat ( ) and datetime.isoformat ( ) .", "question_id": 2267}
{"snippet": "datetime.strptime(date_string, format)", "intent": "Return a datetime corresponding to `date_string` , parsed according to `format` .", "question_id": 2268}
{"snippet": "datetime.min", "intent": "The earliest representable datetime, datetime(MINYEAR, 1, 1, tzinfo=None).", "question_id": 2269}
{"snippet": "datetime.max", "intent": "The latest representable datetime, datetime(MAXYEAR, 12, 31, 23, 59, 59, 999999, tzinfo=None).", "question_id": 2270}
{"snippet": "datetime.resolution", "intent": "The smallest possible difference between non-equal datetime objects, timedelta(microseconds=1).", "question_id": 2271}
{"snippet": "datetime.year", "intent": "Between MINYEAR and MAXYEAR inclusive.", "question_id": 2272}
{"snippet": "datetime.month", "intent": "Between 1 and 12 inclusive.", "question_id": 2273}
{"snippet": "datetime.day", "intent": "Between 1 and the number of days in the given month of the given year.", "question_id": 2274}
{"snippet": "datetime.hour", "intent": "In range(24).", "question_id": 2275}
{"snippet": "datetime.minute", "intent": "In range(60).", "question_id": 2276}
{"snippet": "datetime.second", "intent": "In range(60).", "question_id": 2277}
{"snippet": "datetime.microsecond", "intent": "In range(1000000).", "question_id": 2278}
{"snippet": "datetime.tzinfo", "intent": "The object passed as the tzinfo argument to the datetime constructor, or None if none was passed.", "question_id": 2279}
{"snippet": "datetime.fold", "intent": "In [0, 1].", "question_id": 2280}
{"snippet": "datetime.date()", "intent": "Return date object with same year , month and day .", "question_id": 2281}
{"snippet": "datetime.time()", "intent": "Return time object with same hour , minute , second , microsecond and fold .", "question_id": 2282}
{"snippet": "datetime.timetz()", "intent": "Return time object with same hour , minute , second , microsecond , fold , and tzinfo attributes .", "question_id": 2283}
{"snippet": "datetime.replace()", "intent": "Return a datetime with the same attributes , except for those attributes given new values by whichever keyword arguments are specified .", "question_id": 2284}
{"snippet": "datetime.replace(year=self.year)", "intent": "Return a datetime with the same attributes , except for those attributes given new values by whichever keyword arguments are specified . With arguments `year`.", "question_id": 2285}
{"snippet": "datetime.replace(month=self.month)", "intent": "Return a datetime with the same attributes , except for those attributes given new values by whichever keyword arguments are specified . With arguments `month`.", "question_id": 2286}
{"snippet": "datetime.replace(day=self.day)", "intent": "Return a datetime with the same attributes , except for those attributes given new values by whichever keyword arguments are specified . With arguments `day`.", "question_id": 2287}
{"snippet": "datetime.replace(hour=self.hour)", "intent": "Return a datetime with the same attributes , except for those attributes given new values by whichever keyword arguments are specified . With arguments `hour`.", "question_id": 2288}
{"snippet": "datetime.replace(minute=self.minute)", "intent": "Return a datetime with the same attributes , except for those attributes given new values by whichever keyword arguments are specified . With arguments `minute`.", "question_id": 2289}
{"snippet": "datetime.replace(second=self.second)", "intent": "Return a datetime with the same attributes , except for those attributes given new values by whichever keyword arguments are specified . With arguments `second`.", "question_id": 2290}
{"snippet": "datetime.replace(microsecond=self.microsecond)", "intent": "Return a datetime with the same attributes , except for those attributes given new values by whichever keyword arguments are specified . With arguments `microsecond`.", "question_id": 2291}
{"snippet": "datetime.replace(tzinfo=self.tzinfo)", "intent": "Return a datetime with the same attributes , except for those attributes given new values by whichever keyword arguments are specified . With arguments `tzinfo`.", "question_id": 2292}
{"snippet": "datetime.replace(* fold=0)", "intent": "Return a datetime with the same attributes , except for those attributes given new values by whichever keyword arguments are specified . With arguments `* fold`.", "question_id": 2293}
{"snippet": "datetime.astimezone()", "intent": "Return a datetime object with new tzinfo attribute `tz` , adjusting the date and time data so the result is the same UTC time as self , but in tz \u2019 s local time .", "question_id": 2294}
{"snippet": "datetime.astimezone(tz=None)", "intent": "Return a datetime object with new tzinfo attribute `tz` , adjusting the date and time data so the result is the same UTC time as self , but in tz \u2019 s local time .", "question_id": 2295}
{"snippet": "datetime.utcoffset()", "intent": "If tzinfo is None , returns None , else returns self.tzinfo.utcoffset ( self ) , and raises an exception if the latter doesn \u2019 t return None or a timedelta object with magnitude less than one day .", "question_id": 2296}
{"snippet": "datetime.dst()", "intent": "If tzinfo is None , returns None , else returns self.tzinfo.dst ( self ) , and raises an exception if the latter doesn \u2019 t return None or a timedelta object with magnitude less than one day .", "question_id": 2297}
{"snippet": "datetime.tzname()", "intent": "If tzinfo is None , returns None , else returns self.tzinfo.tzname ( self ) , raises an exception if the latter doesn \u2019 t return None or a string object ,", "question_id": 2298}
{"snippet": "datetime.timetuple()", "intent": "Return a time.struct_time such as returned by time.localtime ( ) .", "question_id": 2299}
{"snippet": "datetime.utctimetuple()", "intent": "If datetime instance d is naive , this is the same as d.timetuple ( ) except that tm_isdst is forced to 0 regardless of what d.dst ( ) returns .", "question_id": 2300}
{"snippet": "datetime.toordinal()", "intent": "Return the proleptic Gregorian ordinal of the date .", "question_id": 2301}
{"snippet": "datetime.timestamp()", "intent": "Return POSIX timestamp corresponding to the datetime instance .", "question_id": 2302}
{"snippet": "datetime.weekday()", "intent": "Return the day of the week as an integer , where Monday is 0 and Sunday is 6 .", "question_id": 2303}
{"snippet": "datetime.isoweekday()", "intent": "Return the day of the week as an integer , where Monday is 1 and Sunday is 7 .", "question_id": 2304}
{"snippet": "datetime.isocalendar()", "intent": "Return a 3-tuple , ( ISO year , ISO week number , ISO weekday ) .", "question_id": 2305}
{"snippet": "datetime.isoformat()", "intent": "Return a string representing the date and time in ISO 8601 format , YYYY-MM-DDTHH : MM : SS.ffffff or , if microsecond is 0 , YYYY-MM-DDTHH : MM : SS", "question_id": 2306}
{"snippet": "datetime.isoformat(sep='T')", "intent": "Return a string representing the date and time in ISO 8601 format , YYYY-MM-DDTHH : MM : SS.ffffff or , if microsecond is 0 , YYYY-MM-DDTHH : MM : SS The optional argument `sep` ( default 'T ' ) is a one-character separator , placed between the date and time portions of the result .", "question_id": 2307}
{"snippet": "datetime.isoformat(timespec='auto')", "intent": "Return a string representing the date and time in ISO 8601 format , YYYY-MM-DDTHH : MM : SS.ffffff or , if microsecond is 0 , YYYY-MM-DDTHH : MM : SS The optional argument `timespec` specifies the number of additional components of the time to include ( the default is 'auto ' ) .", "question_id": 2308}
{"snippet": "datetime.isoformat(sep='T', timespec='auto')", "intent": "Return a string representing the date and time in ISO 8601 format , YYYY-MM-DDTHH : MM : SS.ffffff or , if microsecond is 0 , YYYY-MM-DDTHH : MM : SS The optional argument `sep` ( default 'T ' ) is a one-character separator , placed between the date and time portions of the result . The optional argument `timespec` specifies the number of additional components of the time to include ( the default is 'auto ' ) .", "question_id": 2309}
{"snippet": "datetime.__str__()", "intent": "For a datetime instance d , str ( d ) is equivalent to d.isoformat ( ' ' ) .", "question_id": 2310}
{"snippet": "datetime.ctime()", "intent": "Return a string representing the date and time , for example datetime ( 2002 , 12 , 4 , 20 , 30 , 40 ) .ctime ( ) == 'Wed Dec 4 20:30:40 2002 ' .", "question_id": 2311}
{"snippet": "datetime.strftime(format)", "intent": "Return a string representing the date and time , controlled by an explicit `format` string .", "question_id": 2312}
{"snippet": "datetime.__format__(format)", "intent": "Same as datetime.strftime ( ) . This makes it possible to specify a `format` string for a datetime object in formatted string literals and when using str.format ( ) .", "question_id": 2313}
{"snippet": "datetime.time()", "intent": "All arguments are optional .", "question_id": 2314}
{"snippet": "datetime.time(hour=0)", "intent": "All arguments are optional . With arguments `hour`.", "question_id": 2315}
{"snippet": "datetime.time(minute=0)", "intent": "All arguments are optional . With arguments `minute`.", "question_id": 2316}
{"snippet": "datetime.time(second=0)", "intent": "All arguments are optional . With arguments `second`.", "question_id": 2317}
{"snippet": "datetime.time(microsecond=0)", "intent": "All arguments are optional . With arguments `microsecond`.", "question_id": 2318}
{"snippet": "datetime.time(tzinfo=None)", "intent": "All arguments are optional . `tzinfo` may be None , or an instance of a tzinfo subclass .", "question_id": 2319}
{"snippet": "datetime.time(fold=0)", "intent": "All arguments are optional . With arguments `fold`.", "question_id": 2320}
{"snippet": "datetime.time(hour=0, minute=0)", "intent": "All arguments are optional . With arguments `hour`, `minute`.", "question_id": 2321}
{"snippet": "datetime.time(hour=0, second=0)", "intent": "All arguments are optional . With arguments `hour`, `second`.", "question_id": 2322}
{"snippet": "datetime.time(hour=0, microsecond=0)", "intent": "All arguments are optional . With arguments `hour`, `microsecond`.", "question_id": 2323}
{"snippet": "time.min", "intent": "The earliest representable time, time(0, 0, 0, 0).", "question_id": 2324}
{"snippet": "time.max", "intent": "The latest representable time, time(23, 59, 59, 999999).", "question_id": 2325}
{"snippet": "time.resolution", "intent": "The smallest possible difference between non-equal time objects, timedelta(microseconds=1), although note that arithmetic on time objects is not supported.", "question_id": 2326}
{"snippet": "time.hour", "intent": "In range(24).", "question_id": 2327}
{"snippet": "time.minute", "intent": "In range(60).", "question_id": 2328}
{"snippet": "time.second", "intent": "In range(60).", "question_id": 2329}
{"snippet": "time.microsecond", "intent": "In range(1000000).", "question_id": 2330}
{"snippet": "time.tzinfo", "intent": "The object passed as the tzinfo argument to the time constructor, or None if none was passed.", "question_id": 2331}
{"snippet": "time.fold", "intent": "In [0, 1].", "question_id": 2332}
{"snippet": "time.fromisoformat(time_string)", "intent": "Return a time corresponding to a `time_string` in one of the formats emitted by time.isoformat ( ) .", "question_id": 2333}
{"snippet": "time.replace()", "intent": "Return a time with the same value , except for those attributes given new values by whichever keyword arguments are specified .", "question_id": 2334}
{"snippet": "time.replace(hour=self.hour)", "intent": "Return a time with the same value , except for those attributes given new values by whichever keyword arguments are specified . With arguments `hour`.", "question_id": 2335}
{"snippet": "time.replace(minute=self.minute)", "intent": "Return a time with the same value , except for those attributes given new values by whichever keyword arguments are specified . With arguments `minute`.", "question_id": 2336}
{"snippet": "time.replace(second=self.second)", "intent": "Return a time with the same value , except for those attributes given new values by whichever keyword arguments are specified . With arguments `second`.", "question_id": 2337}
{"snippet": "time.replace(microsecond=self.microsecond)", "intent": "Return a time with the same value , except for those attributes given new values by whichever keyword arguments are specified . With arguments `microsecond`.", "question_id": 2338}
{"snippet": "time.replace(tzinfo=self.tzinfo)", "intent": "Return a time with the same value , except for those attributes given new values by whichever keyword arguments are specified . With arguments `tzinfo`.", "question_id": 2339}
{"snippet": "time.replace(* fold=0)", "intent": "Return a time with the same value , except for those attributes given new values by whichever keyword arguments are specified . With arguments `* fold`.", "question_id": 2340}
{"snippet": "time.replace(hour=self.hour, minute=self.minute)", "intent": "Return a time with the same value , except for those attributes given new values by whichever keyword arguments are specified . With arguments `hour`, `minute`.", "question_id": 2341}
{"snippet": "time.replace(hour=self.hour, second=self.second)", "intent": "Return a time with the same value , except for those attributes given new values by whichever keyword arguments are specified . With arguments `hour`, `second`.", "question_id": 2342}
{"snippet": "time.replace(hour=self.hour, microsecond=self.microsecond)", "intent": "Return a time with the same value , except for those attributes given new values by whichever keyword arguments are specified . With arguments `hour`, `microsecond`.", "question_id": 2343}
{"snippet": "time.isoformat()", "intent": "Return a string representing the time in ISO 8601 format , HH : MM : SS.ffffff or , if microsecond is 0 , HH : MM : SS If utcoffset ( ) does not return None , a string is appended , giving the UTC offset : HH : MM : SS.ffffff+HH : MM [ : SS [ .ffffff ] ] or , if self.microsecond is 0 , HH : MM : SS+HH : MM [ : SS [ .ffffff ] ] .", "question_id": 2344}
{"snippet": "time.isoformat(timespec='auto')", "intent": "Return a string representing the time in ISO 8601 format , HH : MM : SS.ffffff or , if microsecond is 0 , HH : MM : SS If utcoffset ( ) does not return None , a string is appended , giving the UTC offset : HH : MM : SS.ffffff+HH : MM [ : SS [ .ffffff ] ] or , if self.microsecond is 0 , HH : MM : SS+HH : MM [ : SS [ .ffffff ] ] . The optional argument `timespec` specifies the number of additional components of the time to include ( the default is 'auto ' ) .", "question_id": 2345}
{"snippet": "time.__str__()", "intent": "For a time t , str ( t ) is equivalent to t.isoformat ( ) .", "question_id": 2346}
{"snippet": "time.strftime(format)", "intent": "Return a string representing the time , controlled by an explicit `format` string .", "question_id": 2347}
{"snippet": "time.__format__(format)", "intent": "Same as time.strftime ( ) . This makes it possible to specify a `format` string for a time object in formatted string literals and when using str.format ( ) .", "question_id": 2348}
{"snippet": "time.utcoffset()", "intent": "If tzinfo is None , returns None , else returns self.tzinfo.utcoffset ( None ) , and raises an exception if the latter doesn \u2019 t return None or a timedelta object with magnitude less than one day .", "question_id": 2349}
{"snippet": "time.dst()", "intent": "If tzinfo is None , returns None , else returns self.tzinfo.dst ( None ) , and raises an exception if the latter doesn \u2019 t return None , or a timedelta object with magnitude less than one day .", "question_id": 2350}
{"snippet": "time.tzname()", "intent": "If tzinfo is None , returns None , else returns self.tzinfo.tzname ( None ) , or raises an exception if the latter doesn \u2019 t return None or a string object .", "question_id": 2351}
{"snippet": "datetime.tzinfo", "intent": "This is an abstract base class, meaning that this class should not be instantiated directly.", "question_id": 2352}
{"snippet": "tzinfo.utcoffset(dt)", "intent": "Return offset of local time from UTC , as a timedelta object that is positive east of UTC . With arguments `dt`.", "question_id": 2353}
{"snippet": "tzinfo.dst(dt)", "intent": "Return the daylight saving time ( DST ) adjustment , as a timedelta object or None if DST information isn \u2019 t known . tz.utcoffset ( `dt` ) - tz.dst ( dt )", "question_id": 2354}
{"snippet": "tzinfo.tzname(dt)", "intent": "Return the time zone name corresponding to the datetime object `dt` , as a string .", "question_id": 2355}
{"snippet": "tzinfo.fromutc(dt)", "intent": "This is called from the default datetime.astimezone ( ) implementation . When called from that , dt.tzinfo is self , and `dt` \u2019 s date and time data are to be viewed as expressing a UTC time .", "question_id": 2356}
{"snippet": "datetime.timezone(offset)", "intent": "The `offset` argument must be specified as a timedelta object representing the difference between the local time and UTC .", "question_id": 2357}
{"snippet": "datetime.timezone(offset, name=None)", "intent": "The `offset` argument must be specified as a timedelta object representing the difference between the local time and UTC . The `name` argument is optional .", "question_id": 2358}
{"snippet": "timezone.utcoffset(dt)", "intent": "Return the fixed value specified when the timezone instance is constructed . The `dt` argument is ignored .", "question_id": 2359}
{"snippet": "timezone.tzname(dt)", "intent": "Return the fixed value specified when the timezone instance is constructed . If name is not provided in the constructor , the name returned by tzname ( `dt` ) is generated from the value of the offset as follows .", "question_id": 2360}
{"snippet": "timezone.dst(dt)", "intent": "Always returns None . With arguments `dt`.", "question_id": 2361}
{"snippet": "timezone.fromutc(dt)", "intent": "Return `dt` + offset .", "question_id": 2362}
{"snippet": "timezone.utc", "intent": "The UTC timezone, timezone(timedelta(0)).", "question_id": 2363}
{"snippet": "dbm.error", "intent": "A tuple containing the exceptions that can be raised by each of the supported modules, with a unique exception also named dbm.error as the first item \u2014 the latter is used when dbm.error is raised.", "question_id": 2364}
{"snippet": "dbm.whichdb(filename)", "intent": "This function attempts to guess which of the several simple database modules available \u2014 dbm.gnu , dbm.ndbm or dbm.dumb \u2014 should be used to open a given file . With arguments `filename`.", "question_id": 2365}
{"snippet": "dbm.open(file)", "intent": "Open the database `file` file and return a corresponding object .", "question_id": 2366}
{"snippet": "dbm.open(file, flag='r')", "intent": "Open the database `file` file and return a corresponding object . The optional `flag` argument can be :", "question_id": 2367}
{"snippet": "dbm.open(file, mode=0o666)", "intent": "Open the database `file` file and return a corresponding object . The optional `mode` argument is the Unix mode of the file , used only when the database has to be created .", "question_id": 2368}
{"snippet": "dbm.open(file, flag='r', mode=0o666)", "intent": "Open the database `file` file and return a corresponding object . The optional `flag` argument can be : The optional `mode` argument is the Unix mode of the file , used only when the database has to be created .", "question_id": 2369}
{"snippet": "dbm.gnu.error", "intent": "Raised on dbm.gnu-specific errors, such as I/O errors.", "question_id": 2370}
{"snippet": "dbm.gnu.open(filename, flag, mode)", "intent": "Open a gdbm database and return a gdbm object . The `filename` argument is the name of the database file . The optional `flag` argument can be : The optional `mode` argument is the Unix mode of the file , used only when the database has to be created .", "question_id": 2371}
{"snippet": "dbm.gnu.open(filename, flag)", "intent": "Open a gdbm database and return a gdbm object . The `filename` argument is the name of the database file . The optional `flag` argument can be :", "question_id": 2372}
{"snippet": "dbm.gnu.open(filename)", "intent": "Open a gdbm database and return a gdbm object . The `filename` argument is the name of the database file .", "question_id": 2373}
{"snippet": "gdbm.firstkey()", "intent": "It \u2019 s possible to loop over every key in the database using this method and the nextkey ( ) method .", "question_id": 2374}
{"snippet": "gdbm.nextkey(key)", "intent": "Returns the `key` that follows key in the traversal .", "question_id": 2375}
{"snippet": "gdbm.reorganize()", "intent": "If you have carried out a lot of deletions and would like to shrink the space used by the gdbm file , this routine will reorganize the database .", "question_id": 2376}
{"snippet": "gdbm.sync()", "intent": "When the database has been opened in fast mode , this method forces any unwritten data to be written to the disk .", "question_id": 2377}
{"snippet": "gdbm.close()", "intent": "Close the gdbm database .", "question_id": 2378}
{"snippet": "dbm.ndbm.error", "intent": "Raised on dbm.ndbm-specific errors, such as I/O errors.", "question_id": 2379}
{"snippet": "dbm.ndbm.library", "intent": "Name of the ndbm implementation library used.", "question_id": 2380}
{"snippet": "dbm.ndbm.open(filename, flag, mode)", "intent": "Open a dbm database and return a ndbm object . The `filename` argument is the name of the database file ( without the .dir or .pag extensions ) . The optional `flag` argument must be one of these values : The optional `mode` argument is the Unix mode of the file , used only when the database has to be created .", "question_id": 2381}
{"snippet": "dbm.ndbm.open(filename, flag)", "intent": "Open a dbm database and return a ndbm object . The `filename` argument is the name of the database file ( without the .dir or .pag extensions ) . The optional `flag` argument must be one of these values :", "question_id": 2382}
{"snippet": "dbm.ndbm.open(filename)", "intent": "Open a dbm database and return a ndbm object . The `filename` argument is the name of the database file ( without the .dir or .pag extensions ) .", "question_id": 2383}
{"snippet": "ndbm.close()", "intent": "Close the ndbm database .", "question_id": 2384}
{"snippet": "dbm.dumb.error", "intent": "Raised on dbm.dumb-specific errors, such as I/O errors.", "question_id": 2385}
{"snippet": "dbm.dumb.open(filename, flag, mode)", "intent": "Open a dumbdbm database and return a dumbdbm object . The `filename` argument is the basename of the database file ( without any specific extensions ) . The optional `flag` argument supports only the semantics of ' c ' and ' n ' values . The optional `mode` argument is the Unix mode of the file , used only when the database has to be created .", "question_id": 2386}
{"snippet": "dbm.dumb.open(filename, flag)", "intent": "Open a dumbdbm database and return a dumbdbm object . The `filename` argument is the basename of the database file ( without any specific extensions ) . The optional `flag` argument supports only the semantics of ' c ' and ' n ' values .", "question_id": 2387}
{"snippet": "dbm.dumb.open(filename)", "intent": "Open a dumbdbm database and return a dumbdbm object . The `filename` argument is the basename of the database file ( without any specific extensions ) .", "question_id": 2388}
{"snippet": "dumbdbm.sync()", "intent": "Synchronize the on-disk directory and data files .", "question_id": 2389}
{"snippet": "dumbdbm.close()", "intent": "Close the dumbdbm database .", "question_id": 2390}
{"snippet": "decimal.Decimal()", "intent": "Construct a new Decimal object based from `value` .", "question_id": 2391}
{"snippet": "decimal.Decimal(value=\"0\")", "intent": "Construct a new Decimal object based from `value` .", "question_id": 2392}
{"snippet": "decimal.Decimal(context=None)", "intent": "Construct a new Decimal object based from `value` . The `context` precision does not affect how many digits are stored .", "question_id": 2393}
{"snippet": "decimal.Decimal(value=\"0\", context=None)", "intent": "Construct a new Decimal object based from `value` . The `context` precision does not affect how many digits are stored .", "question_id": 2394}
{"snippet": "decimal.adjusted()", "intent": "Return the adjusted exponent after shifting out the coefficient \u2019 s rightmost digits until only the lead digit remains : Decimal ( '321e+5 ' ) .adjusted ( ) returns seven .", "question_id": 2395}
{"snippet": "decimal.as_integer_ratio()", "intent": "Return a pair ( n , d ) of integers that represent the given Decimal instance as a fraction , in lowest terms and with a positive denominator :", "question_id": 2396}
{"snippet": "decimal.as_tuple()", "intent": "Return a named tuple representation of the number : DecimalTuple ( sign , digits , exponent ) .", "question_id": 2397}
{"snippet": "decimal.canonical()", "intent": "Return the canonical encoding of the argument .", "question_id": 2398}
{"snippet": "decimal.compare(other)", "intent": "Compare the values of two Decimal instances . With arguments `other`.", "question_id": 2399}
{"snippet": "decimal.compare(other, context=None)", "intent": "Compare the values of two Decimal instances . With arguments `other`, `context`.", "question_id": 2400}
{"snippet": "decimal.compare_signal(other)", "intent": "This operation is identical to the compare ( ) method , except that all NaNs signal . With arguments `other`.", "question_id": 2401}
{"snippet": "decimal.compare_signal(other, context=None)", "intent": "This operation is identical to the compare ( ) method , except that all NaNs signal . With arguments `other`, `context`.", "question_id": 2402}
{"snippet": "decimal.compare_total(other)", "intent": "Compare two operands using their abstract representation rather than their numerical value . With arguments `other`.", "question_id": 2403}
{"snippet": "decimal.compare_total(other, context=None)", "intent": "Compare two operands using their abstract representation rather than their numerical value . This operation is unaffected by `context` and is quiet : no flags are changed and no rounding is performed . With arguments `other`.", "question_id": 2404}
{"snippet": "decimal.compare_total_mag(other)", "intent": "Compare two operands using their abstract representation rather than their value as in compare_total ( ) , but ignoring the sign of each operand . With arguments `other`.", "question_id": 2405}
{"snippet": "decimal.compare_total_mag(other, context=None)", "intent": "Compare two operands using their abstract representation rather than their value as in compare_total ( ) , but ignoring the sign of each operand . This operation is unaffected by `context` and is quiet : no flags are changed and no rounding is performed . With arguments `other`.", "question_id": 2406}
{"snippet": "decimal.conjugate()", "intent": "Just returns self , this method is only to comply with the Decimal Specification .", "question_id": 2407}
{"snippet": "decimal.copy_abs()", "intent": "Return the absolute value of the argument .", "question_id": 2408}
{"snippet": "decimal.copy_negate()", "intent": "Return the negation of the argument .", "question_id": 2409}
{"snippet": "decimal.copy_sign(other)", "intent": "Return a copy of the first operand with the sign set to be the same as the sign of the second operand . With arguments `other`.", "question_id": 2410}
{"snippet": "decimal.copy_sign(other, context=None)", "intent": "Return a copy of the first operand with the sign set to be the same as the sign of the second operand . This operation is unaffected by `context` and is quiet : no flags are changed and no rounding is performed . With arguments `other`.", "question_id": 2411}
{"snippet": "decimal.exp()", "intent": "Return the value of the ( natural ) exponential function e**x at the given number .", "question_id": 2412}
{"snippet": "decimal.exp(context=None)", "intent": "Return the value of the ( natural ) exponential function e**x at the given number . With arguments `context`.", "question_id": 2413}
{"snippet": "decimal.from_float(f)", "intent": "Classmethod that converts a float to a decimal number , exactly . With arguments `f`.", "question_id": 2414}
{"snippet": "decimal.fma(other, third)", "intent": "Fused multiply-add . With arguments `other`, `third`.", "question_id": 2415}
{"snippet": "decimal.fma(other, third, context=None)", "intent": "Fused multiply-add . With arguments `other`, `third`, `context`.", "question_id": 2416}
{"snippet": "decimal.is_canonical()", "intent": "Return True if the argument is canonical and False otherwise .", "question_id": 2417}
{"snippet": "decimal.is_finite()", "intent": "Return True if the argument is a finite number , and False if the argument is an infinity or a NaN .", "question_id": 2418}
{"snippet": "decimal.is_infinite()", "intent": "Return True if the argument is either positive or negative infinity and False otherwise .", "question_id": 2419}
{"snippet": "decimal.is_nan()", "intent": "Return True if the argument is a ( quiet or signaling ) NaN and False otherwise .", "question_id": 2420}
{"snippet": "decimal.is_normal()", "intent": "Return True if the argument is a normal finite number .", "question_id": 2421}
{"snippet": "decimal.is_normal(context=None)", "intent": "Return True if the argument is a normal finite number . With arguments `context`.", "question_id": 2422}
{"snippet": "decimal.is_qnan()", "intent": "Return True if the argument is a quiet NaN , and False otherwise .", "question_id": 2423}
{"snippet": "decimal.is_signed()", "intent": "Return True if the argument has a negative sign and False otherwise .", "question_id": 2424}
{"snippet": "decimal.is_snan()", "intent": "Return True if the argument is a signaling NaN and False otherwise .", "question_id": 2425}
{"snippet": "decimal.is_subnormal()", "intent": "Return True if the argument is subnormal , and False otherwise .", "question_id": 2426}
{"snippet": "decimal.is_subnormal(context=None)", "intent": "Return True if the argument is subnormal , and False otherwise . With arguments `context`.", "question_id": 2427}
{"snippet": "decimal.is_zero()", "intent": "Return True if the argument is a ( positive or negative ) zero and False otherwise .", "question_id": 2428}
{"snippet": "decimal.ln()", "intent": "Return the natural ( base e ) logarithm of the operand .", "question_id": 2429}
{"snippet": "decimal.ln(context=None)", "intent": "Return the natural ( base e ) logarithm of the operand . With arguments `context`.", "question_id": 2430}
{"snippet": "decimal.log10()", "intent": "Return the base ten logarithm of the operand .", "question_id": 2431}
{"snippet": "decimal.log10(context=None)", "intent": "Return the base ten logarithm of the operand . With arguments `context`.", "question_id": 2432}
{"snippet": "decimal.logb()", "intent": "For a nonzero number , return the adjusted exponent of its operand as a Decimal instance .", "question_id": 2433}
{"snippet": "decimal.logb(context=None)", "intent": "For a nonzero number , return the adjusted exponent of its operand as a Decimal instance . With arguments `context`.", "question_id": 2434}
{"snippet": "decimal.logical_and(other)", "intent": "logical_and ( ) is a logical operation which takes two logical operands ( see Logical operands ) . With arguments `other`.", "question_id": 2435}
{"snippet": "decimal.logical_and(other, context=None)", "intent": "logical_and ( ) is a logical operation which takes two logical operands ( see Logical operands ) . With arguments `other`, `context`.", "question_id": 2436}
{"snippet": "decimal.logical_invert()", "intent": "logical_invert ( ) is a logical operation .", "question_id": 2437}
{"snippet": "decimal.logical_invert(context=None)", "intent": "logical_invert ( ) is a logical operation . With arguments `context`.", "question_id": 2438}
{"snippet": "decimal.logical_or(other)", "intent": "logical_or ( ) is a logical operation which takes two logical operands ( see Logical operands ) . With arguments `other`.", "question_id": 2439}
{"snippet": "decimal.logical_or(other, context=None)", "intent": "logical_or ( ) is a logical operation which takes two logical operands ( see Logical operands ) . With arguments `other`, `context`.", "question_id": 2440}
{"snippet": "decimal.logical_xor(other)", "intent": "logical_xor ( ) is a logical operation which takes two logical operands ( see Logical operands ) . With arguments `other`.", "question_id": 2441}
{"snippet": "decimal.logical_xor(other, context=None)", "intent": "logical_xor ( ) is a logical operation which takes two logical operands ( see Logical operands ) . With arguments `other`, `context`.", "question_id": 2442}
{"snippet": "decimal.max(other)", "intent": "Like max ( self , `other` ) except that the `context` rounding rule is applied before returning and that NaN values are either signaled or ignored ( depending on the context and whether they are signaling or quiet ) .", "question_id": 2443}
{"snippet": "decimal.max(other, context=None)", "intent": "Like max ( self , `other` ) except that the `context` rounding rule is applied before returning and that NaN values are either signaled or ignored ( depending on the context and whether they are signaling or quiet ) .", "question_id": 2444}
{"snippet": "decimal.max_mag(other)", "intent": "Similar to the max ( ) method , but the comparison is done using the absolute values of the operands . With arguments `other`.", "question_id": 2445}
{"snippet": "decimal.max_mag(other, context=None)", "intent": "Similar to the max ( ) method , but the comparison is done using the absolute values of the operands . With arguments `other`, `context`.", "question_id": 2446}
{"snippet": "decimal.min(other)", "intent": "Like min ( self , `other` ) except that the `context` rounding rule is applied before returning and that NaN values are either signaled or ignored ( depending on the context and whether they are signaling or quiet ) .", "question_id": 2447}
{"snippet": "decimal.min(other, context=None)", "intent": "Like min ( self , `other` ) except that the `context` rounding rule is applied before returning and that NaN values are either signaled or ignored ( depending on the context and whether they are signaling or quiet ) .", "question_id": 2448}
{"snippet": "decimal.min_mag(other)", "intent": "Similar to the min ( ) method , but the comparison is done using the absolute values of the operands . With arguments `other`.", "question_id": 2449}
{"snippet": "decimal.min_mag(other, context=None)", "intent": "Similar to the min ( ) method , but the comparison is done using the absolute values of the operands . With arguments `other`, `context`.", "question_id": 2450}
{"snippet": "decimal.next_minus()", "intent": "Return the largest number representable in the given `context` ( or in the current thread \u2019 s context if no context is given ) that is smaller than the given operand .", "question_id": 2451}
{"snippet": "decimal.next_minus(context=None)", "intent": "Return the largest number representable in the given `context` ( or in the current thread \u2019 s context if no context is given ) that is smaller than the given operand .", "question_id": 2452}
{"snippet": "decimal.next_plus()", "intent": "Return the smallest number representable in the given `context` ( or in the current thread \u2019 s context if no context is given ) that is larger than the given operand .", "question_id": 2453}
{"snippet": "decimal.next_plus(context=None)", "intent": "Return the smallest number representable in the given `context` ( or in the current thread \u2019 s context if no context is given ) that is larger than the given operand .", "question_id": 2454}
{"snippet": "decimal.next_toward(other)", "intent": "If the two operands are unequal , return the number closest to the first operand in the direction of the second operand . With arguments `other`.", "question_id": 2455}
{"snippet": "decimal.next_toward(other, context=None)", "intent": "If the two operands are unequal , return the number closest to the first operand in the direction of the second operand . With arguments `other`, `context`.", "question_id": 2456}
{"snippet": "decimal.normalize()", "intent": "Normalize the number by stripping the rightmost trailing zeros and converting any result equal to Decimal ( ' 0 ' ) to Decimal ( '0e0 ' ) .", "question_id": 2457}
{"snippet": "decimal.normalize(context=None)", "intent": "Normalize the number by stripping the rightmost trailing zeros and converting any result equal to Decimal ( ' 0 ' ) to Decimal ( '0e0 ' ) . With arguments `context`.", "question_id": 2458}
{"snippet": "decimal.number_class()", "intent": "Return a string describing the class of the operand .", "question_id": 2459}
{"snippet": "decimal.number_class(context=None)", "intent": "Return a string describing the class of the operand . With arguments `context`.", "question_id": 2460}
{"snippet": "decimal.quantize(exp)", "intent": "Return a value equal to the first operand after `rounding` and having the exponent of the second operand . With arguments `exp`.", "question_id": 2461}
{"snippet": "decimal.quantize(exp, rounding=None)", "intent": "Return a value equal to the first operand after `rounding` and having the exponent of the second operand . With arguments `exp`.", "question_id": 2462}
{"snippet": "decimal.quantize(exp, context=None)", "intent": "Return a value equal to the first operand after `rounding` and having the exponent of the second operand . In this case , the rounding mode is determined by the rounding argument if given , else by the given `context` argument ; if neither argument is given the rounding mode of the current thread \u2019 s context is used . With arguments `exp`.", "question_id": 2463}
{"snippet": "decimal.quantize(exp, rounding=None, context=None)", "intent": "Return a value equal to the first operand after `rounding` and having the exponent of the second operand . In this case , the rounding mode is determined by the rounding argument if given , else by the given `context` argument ; if neither argument is given the rounding mode of the current thread \u2019 s context is used . With arguments `exp`.", "question_id": 2464}
{"snippet": "decimal.radix()", "intent": "Return Decimal ( 10 ) , the radix ( base ) in which the Decimal class does all its arithmetic .", "question_id": 2465}
{"snippet": "decimal.remainder_near(other)", "intent": "Return the remainder from dividing self by `other` .", "question_id": 2466}
{"snippet": "decimal.remainder_near(other, context=None)", "intent": "Return the remainder from dividing self by `other` . With arguments `context`.", "question_id": 2467}
{"snippet": "decimal.rotate(other)", "intent": "Return the result of rotating the digits of the first operand by an amount specified by the second operand . With arguments `other`.", "question_id": 2468}
{"snippet": "decimal.rotate(other, context=None)", "intent": "Return the result of rotating the digits of the first operand by an amount specified by the second operand . With arguments `other`, `context`.", "question_id": 2469}
{"snippet": "decimal.same_quantum(other)", "intent": "Test whether self and `other` have the same exponent or whether both are NaN .", "question_id": 2470}
{"snippet": "decimal.same_quantum(other, context=None)", "intent": "Test whether self and `other` have the same exponent or whether both are NaN . This operation is unaffected by `context` and is quiet : no flags are changed and no rounding is performed .", "question_id": 2471}
{"snippet": "decimal.scaleb(other)", "intent": "Return the first operand with exponent adjusted by the second . With arguments `other`.", "question_id": 2472}
{"snippet": "decimal.scaleb(other, context=None)", "intent": "Return the first operand with exponent adjusted by the second . With arguments `other`, `context`.", "question_id": 2473}
{"snippet": "decimal.shift(other)", "intent": "Return the result of shifting the digits of the first operand by an amount specified by the second operand . With arguments `other`.", "question_id": 2474}
{"snippet": "decimal.shift(other, context=None)", "intent": "Return the result of shifting the digits of the first operand by an amount specified by the second operand . With arguments `other`, `context`.", "question_id": 2475}
{"snippet": "decimal.sqrt()", "intent": "Return the square root of the argument to full precision .", "question_id": 2476}
{"snippet": "decimal.sqrt(context=None)", "intent": "Return the square root of the argument to full precision . With arguments `context`.", "question_id": 2477}
{"snippet": "decimal.to_eng_string()", "intent": "Convert to a string , using engineering notation if an exponent is needed .", "question_id": 2478}
{"snippet": "decimal.to_eng_string(context=None)", "intent": "Convert to a string , using engineering notation if an exponent is needed . With arguments `context`.", "question_id": 2479}
{"snippet": "decimal.to_integral()", "intent": "Identical to the to_integral_value ( ) method .", "question_id": 2480}
{"snippet": "decimal.to_integral(rounding=None)", "intent": "Identical to the to_integral_value ( ) method . With arguments `rounding`.", "question_id": 2481}
{"snippet": "decimal.to_integral(context=None)", "intent": "Identical to the to_integral_value ( ) method . With arguments `context`.", "question_id": 2482}
{"snippet": "decimal.to_integral(rounding=None, context=None)", "intent": "Identical to the to_integral_value ( ) method . With arguments `rounding`, `context`.", "question_id": 2483}
{"snippet": "decimal.to_integral_exact()", "intent": "Round to the nearest integer , signaling Inexact or Rounded as appropriate if `rounding` occurs .", "question_id": 2484}
{"snippet": "decimal.to_integral_exact(rounding=None)", "intent": "Round to the nearest integer , signaling Inexact or Rounded as appropriate if `rounding` occurs .", "question_id": 2485}
{"snippet": "decimal.to_integral_exact(context=None)", "intent": "Round to the nearest integer , signaling Inexact or Rounded as appropriate if `rounding` occurs . The rounding mode is determined by the rounding parameter if given , else by the given `context` .", "question_id": 2486}
{"snippet": "decimal.to_integral_exact(rounding=None, context=None)", "intent": "Round to the nearest integer , signaling Inexact or Rounded as appropriate if `rounding` occurs . The rounding mode is determined by the rounding parameter if given , else by the given `context` .", "question_id": 2487}
{"snippet": "decimal.to_integral_value()", "intent": "Round to the nearest integer without signaling Inexact or Rounded .", "question_id": 2488}
{"snippet": "decimal.to_integral_value(rounding=None)", "intent": "Round to the nearest integer without signaling Inexact or Rounded . If given , applies `rounding` ; otherwise , uses the rounding method in either the supplied `context` or the current context .", "question_id": 2489}
{"snippet": "decimal.to_integral_value(context=None)", "intent": "Round to the nearest integer without signaling Inexact or Rounded . If given , applies `rounding` ; otherwise , uses the rounding method in either the supplied `context` or the current context .", "question_id": 2490}
{"snippet": "decimal.to_integral_value(rounding=None, context=None)", "intent": "Round to the nearest integer without signaling Inexact or Rounded . If given , applies `rounding` ; otherwise , uses the rounding method in either the supplied `context` or the current context .", "question_id": 2491}
{"snippet": "decimal.getcontext()", "intent": "Return the current context for the active thread .", "question_id": 2492}
{"snippet": "decimal.setcontext(c)", "intent": "Set the current context for the active thread to `c` .", "question_id": 2493}
{"snippet": "decimal.localcontext()", "intent": "Return a context manager that will set the current context for the active thread to a copy of `ctx` on entry to the with-statement and restore the previous context when exiting the with-statement .", "question_id": 2494}
{"snippet": "decimal.localcontext(ctx=None)", "intent": "Return a context manager that will set the current context for the active thread to a copy of `ctx` on entry to the with-statement and restore the previous context when exiting the with-statement .", "question_id": 2495}
{"snippet": "decimal.BasicContext", "intent": "This is a standard context defined by the General Decimal Arithmetic Specification.", "question_id": 2496}
{"snippet": "decimal.ExtendedContext", "intent": "This is a standard context defined by the General Decimal Arithmetic Specification.", "question_id": 2497}
{"snippet": "decimal.DefaultContext", "intent": "This context is used by the Context constructor as a prototype for new contexts.", "question_id": 2498}
{"snippet": "decimal.Context()", "intent": "Creates a new context .", "question_id": 2499}
{"snippet": "decimal.Context(prec=None)", "intent": "Creates a new context . `prec` is an integer in the range [ 1 , MAX_PREC ] that sets the precision for arithmetic operations in the context .", "question_id": 2500}
{"snippet": "decimal.Context(rounding=None)", "intent": "Creates a new context . The `rounding` option is one of the constants listed in the section Rounding Modes .", "question_id": 2501}
{"snippet": "decimal.Context(Emin=None)", "intent": "Creates a new context . The `Emin` and `Emax` fields are integers specifying the outer limits allowable for exponents .", "question_id": 2502}
{"snippet": "decimal.Context(Emax=None)", "intent": "Creates a new context . The `Emin` and `Emax` fields are integers specifying the outer limits allowable for exponents .", "question_id": 2503}
{"snippet": "decimal.Context(capitals=None)", "intent": "Creates a new context . The `capitals` field is either 0 or 1 ( the default ) .", "question_id": 2504}
{"snippet": "decimal.Context(clamp=None)", "intent": "Creates a new context . The `clamp` field is either 0 ( the default ) or 1 .", "question_id": 2505}
{"snippet": "decimal.Context(flags=None)", "intent": "Creates a new context . If the `flags` field is not specified or is None , all flags are cleared .", "question_id": 2506}
{"snippet": "decimal.Context(traps=None)", "intent": "Creates a new context . The `traps` and flags fields list any signals to be set .", "question_id": 2507}
{"snippet": "decimal.Context(prec=None, rounding=None)", "intent": "Creates a new context . `prec` is an integer in the range [ 1 , MAX_PREC ] that sets the precision for arithmetic operations in the context . The `rounding` option is one of the constants listed in the section Rounding Modes .", "question_id": 2508}
{"snippet": "context.clear_flags()", "intent": "Resets all of the flags to 0 .", "question_id": 2509}
{"snippet": "context.clear_traps()", "intent": "Resets all of the traps to 0 .", "question_id": 2510}
{"snippet": "context.copy()", "intent": "Return a duplicate of the context .", "question_id": 2511}
{"snippet": "context.copy_decimal(num)", "intent": "Return a copy of the Decimal instance `num` .", "question_id": 2512}
{"snippet": "context.create_decimal(num)", "intent": "Creates a new Decimal instance from `num` but using self as context .", "question_id": 2513}
{"snippet": "context.create_decimal_from_float(f)", "intent": "Creates a new Decimal instance from a float `f` but rounding using self as the context .", "question_id": 2514}
{"snippet": "context.Etiny()", "intent": "Returns a value equal to Emin - prec + 1 which is the minimum exponent value for subnormal results .", "question_id": 2515}
{"snippet": "context.Etop()", "intent": "Returns a value equal to Emax - prec + 1 .", "question_id": 2516}
{"snippet": "context.abs(x)", "intent": "Returns the absolute value of `x` .", "question_id": 2517}
{"snippet": "context.add(x, y)", "intent": "Return the sum of `x` and `y` .", "question_id": 2518}
{"snippet": "context.canonical(x)", "intent": "Returns the same Decimal object `x` .", "question_id": 2519}
{"snippet": "context.compare(x, y)", "intent": "Compares `x` and `y` numerically .", "question_id": 2520}
{"snippet": "context.compare_signal(x, y)", "intent": "Compares the values of the two operands numerically . With arguments `x`, `y`.", "question_id": 2521}
{"snippet": "context.compare_total(x, y)", "intent": "Compares two operands using their abstract representation . With arguments `x`, `y`.", "question_id": 2522}
{"snippet": "context.compare_total_mag(x, y)", "intent": "Compares two operands using their abstract representation , ignoring sign . With arguments `x`, `y`.", "question_id": 2523}
{"snippet": "context.copy_abs(x)", "intent": "Returns a copy of `x` with the sign set to 0 .", "question_id": 2524}
{"snippet": "context.copy_negate(x)", "intent": "Returns a copy of `x` with the sign inverted .", "question_id": 2525}
{"snippet": "context.copy_sign(x, y)", "intent": "Copies the sign from `y` to `x` .", "question_id": 2526}
{"snippet": "context.divide(x, y)", "intent": "Return `x` divided by `y` .", "question_id": 2527}
{"snippet": "context.divide_int(x, y)", "intent": "Return `x` divided by `y` , truncated to an integer .", "question_id": 2528}
{"snippet": "context.divmod(x, y)", "intent": "Divides two numbers and returns the integer part of the result . With arguments `x`, `y`.", "question_id": 2529}
{"snippet": "context.exp(x)", "intent": "Returns e ** `x` .", "question_id": 2530}
{"snippet": "context.fma(x, y, z)", "intent": "Returns `x` multiplied by `y` , plus `z` .", "question_id": 2531}
{"snippet": "context.is_canonical(x)", "intent": "Returns True if `x` is canonical ; otherwise returns False .", "question_id": 2532}
{"snippet": "context.is_finite(x)", "intent": "Returns True if `x` is finite ; otherwise returns False .", "question_id": 2533}
{"snippet": "context.is_infinite(x)", "intent": "Returns True if `x` is infinite ; otherwise returns False .", "question_id": 2534}
{"snippet": "context.is_nan(x)", "intent": "Returns True if `x` is a qNaN or sNaN ; otherwise returns False .", "question_id": 2535}
{"snippet": "context.is_normal(x)", "intent": "Returns True if `x` is a normal number ; otherwise returns False .", "question_id": 2536}
{"snippet": "context.is_qnan(x)", "intent": "Returns True if `x` is a quiet NaN ; otherwise returns False .", "question_id": 2537}
{"snippet": "context.is_signed(x)", "intent": "Returns True if `x` is negative ; otherwise returns False .", "question_id": 2538}
{"snippet": "context.is_snan(x)", "intent": "Returns True if `x` is a signaling NaN ; otherwise returns False .", "question_id": 2539}
{"snippet": "context.is_subnormal(x)", "intent": "Returns True if `x` is subnormal ; otherwise returns False .", "question_id": 2540}
{"snippet": "context.is_zero(x)", "intent": "Returns True if `x` is a zero ; otherwise returns False .", "question_id": 2541}
{"snippet": "context.ln(x)", "intent": "Returns the natural ( base e ) logarithm of `x` .", "question_id": 2542}
{"snippet": "context.log10(x)", "intent": "Returns the base 10 logarithm of `x` .", "question_id": 2543}
{"snippet": "context.logb(x)", "intent": "Returns the exponent of the magnitude of the operand \u2019 s MSD . With arguments `x`.", "question_id": 2544}
{"snippet": "context.logical_and(x, y)", "intent": "Applies the logical operation and between each operand \u2019 s digits . With arguments `x`, `y`.", "question_id": 2545}
{"snippet": "context.logical_invert(x)", "intent": "Invert all the digits in `x` .", "question_id": 2546}
{"snippet": "context.logical_or(x, y)", "intent": "Applies the logical operation or between each operand \u2019 s digits . With arguments `x`, `y`.", "question_id": 2547}
{"snippet": "context.logical_xor(x, y)", "intent": "Applies the logical operation xor between each operand \u2019 s digits . With arguments `x`, `y`.", "question_id": 2548}
{"snippet": "context.max(x, y)", "intent": "Compares two values numerically and returns the maximum . With arguments `x`, `y`.", "question_id": 2549}
{"snippet": "context.max_mag(x, y)", "intent": "Compares the values numerically with their sign ignored . With arguments `x`, `y`.", "question_id": 2550}
{"snippet": "context.min(x, y)", "intent": "Compares two values numerically and returns the minimum . With arguments `x`, `y`.", "question_id": 2551}
{"snippet": "context.min_mag(x, y)", "intent": "Compares the values numerically with their sign ignored . With arguments `x`, `y`.", "question_id": 2552}
{"snippet": "context.minus(x)", "intent": "Minus corresponds to the unary prefix minus operator in Python . With arguments `x`.", "question_id": 2553}
{"snippet": "context.multiply(x, y)", "intent": "Return the product of `x` and `y` .", "question_id": 2554}
{"snippet": "context.next_minus(x)", "intent": "Returns the largest representable number smaller than `x` .", "question_id": 2555}
{"snippet": "context.next_plus(x)", "intent": "Returns the smallest representable number larger than `x` .", "question_id": 2556}
{"snippet": "context.next_toward(x, y)", "intent": "Returns the number closest to `x` , in direction towards `y` .", "question_id": 2557}
{"snippet": "context.normalize(x)", "intent": "Reduces `x` to its simplest form .", "question_id": 2558}
{"snippet": "context.number_class(x)", "intent": "Returns an indication of the class of `x` .", "question_id": 2559}
{"snippet": "context.plus(x)", "intent": "Plus corresponds to the unary prefix plus operator in Python . With arguments `x`.", "question_id": 2560}
{"snippet": "context.power(x, y)", "intent": "Return `x` to the power of `y` , reduced `modulo` modulo if given .", "question_id": 2561}
{"snippet": "context.power(x, y, modulo=None)", "intent": "Return `x` to the power of `y` , reduced `modulo` modulo if given .", "question_id": 2562}
{"snippet": "context.quantize(x, y)", "intent": "Returns a value equal to `x` ( rounded ) , having the exponent of `y` .", "question_id": 2563}
{"snippet": "context.radix()", "intent": "Just returns 10 , as this is Decimal , : )", "question_id": 2564}
{"snippet": "context.remainder(x, y)", "intent": "Returns the remainder from integer division . With arguments `x`, `y`.", "question_id": 2565}
{"snippet": "context.remainder_near(x, y)", "intent": "Returns `x` - `y` * n , where n is the integer nearest the exact value of x / y ( if the result is 0 then its sign will be the sign of x ) .", "question_id": 2566}
{"snippet": "context.rotate(x, y)", "intent": "Returns a rotated copy of `x` , `y` times .", "question_id": 2567}
{"snippet": "context.same_quantum(x, y)", "intent": "Returns True if the two operands have the same exponent . With arguments `x`, `y`.", "question_id": 2568}
{"snippet": "context.scaleb(x, y)", "intent": "Returns the first operand after adding the second value its exp . With arguments `x`, `y`.", "question_id": 2569}
{"snippet": "context.shift(x, y)", "intent": "Returns a shifted copy of `x` , `y` times .", "question_id": 2570}
{"snippet": "context.sqrt(x)", "intent": "Square root of a non-negative number to context precision . With arguments `x`.", "question_id": 2571}
{"snippet": "context.subtract(x, y)", "intent": "Return the difference between `x` and `y` .", "question_id": 2572}
{"snippet": "context.to_eng_string(x)", "intent": "Convert to a string , using engineering notation if an exponent is needed . With arguments `x`.", "question_id": 2573}
{"snippet": "context.to_integral_exact(x)", "intent": "Rounds to an integer . With arguments `x`.", "question_id": 2574}
{"snippet": "context.to_sci_string(x)", "intent": "Converts a number to a string using scientific notation . With arguments `x`.", "question_id": 2575}
{"snippet": "decimal.HAVE_THREADS", "intent": "The default value is True.", "question_id": 2576}
{"snippet": "decimal.ROUND_CEILING", "intent": "Round towards Infinity.", "question_id": 2577}
{"snippet": "decimal.ROUND_DOWN", "intent": "Round towards zero.", "question_id": 2578}
{"snippet": "decimal.ROUND_FLOOR", "intent": "Round towards -Infinity.", "question_id": 2579}
{"snippet": "decimal.ROUND_HALF_DOWN", "intent": "Round to nearest with ties going towards zero.", "question_id": 2580}
{"snippet": "decimal.ROUND_HALF_EVEN", "intent": "Round to nearest with ties going to nearest even integer.", "question_id": 2581}
{"snippet": "decimal.ROUND_HALF_UP", "intent": "Round to nearest with ties going away from zero.", "question_id": 2582}
{"snippet": "decimal.ROUND_UP", "intent": "Round away from zero.", "question_id": 2583}
{"snippet": "decimal.ROUND_05UP", "intent": "Round away from zero if last digit after rounding towards zero would have been 0 or 5; otherwise round towards zero.", "question_id": 2584}
{"snippet": "decimal.Clamped", "intent": "Altered an exponent to fit representation constraints.", "question_id": 2585}
{"snippet": "decimal.DecimalException", "intent": "Base class for other signals and a subclass of ArithmeticError.", "question_id": 2586}
{"snippet": "decimal.DivisionByZero", "intent": "Signals the division of a non-infinite number by zero.", "question_id": 2587}
{"snippet": "decimal.Inexact", "intent": "Indicates that rounding occurred and the result is not exact.", "question_id": 2588}
{"snippet": "decimal.InvalidOperation", "intent": "An invalid operation was performed.", "question_id": 2589}
{"snippet": "decimal.Overflow", "intent": "Numerical overflow.", "question_id": 2590}
{"snippet": "decimal.Rounded", "intent": "Rounding occurred though possibly no information was lost.", "question_id": 2591}
{"snippet": "decimal.Subnormal", "intent": "Exponent was lower than Emin prior to rounding.", "question_id": 2592}
{"snippet": "decimal.Underflow", "intent": "Numerical underflow with result rounded to zero.", "question_id": 2593}
{"snippet": "decimal.FloatOperation", "intent": "Enable stricter semantics for mixing floats and Decimals.", "question_id": 2594}
{"snippet": "difflib.SequenceMatcher", "intent": "This is a flexible class for comparing pairs of sequences of any type, so long as the sequence elements are hashable.", "question_id": 2595}
{"snippet": "difflib.Differ", "intent": "This is a class for comparing sequences of lines of text, and producing human-readable differences or deltas.", "question_id": 2596}
{"snippet": "difflib.HtmlDiff", "intent": "This class can be used to create an HTML table (or a complete HTML file containing the table) showing a side by side, line by line comparison of text with inter-line and intra-line change highlights.", "question_id": 2597}
{"snippet": "html_diff.__init__()", "intent": "Initializes instance of HtmlDiff .", "question_id": 2598}
{"snippet": "html_diff.__init__(tabsize=8)", "intent": "Initializes instance of HtmlDiff . `tabsize` is an optional keyword argument to specify tab stop spacing and defaults to 8 .", "question_id": 2599}
{"snippet": "html_diff.__init__(wrapcolumn=None)", "intent": "Initializes instance of HtmlDiff . `wrapcolumn` is an optional keyword to specify column number where lines are broken and wrapped , defaults to None where lines are not wrapped .", "question_id": 2600}
{"snippet": "html_diff.__init__(linejunk=None)", "intent": "Initializes instance of HtmlDiff . `linejunk` and `charjunk` are optional keyword arguments passed into ndiff ( ) ( used by HtmlDiff to generate the side by side HTML differences ) .", "question_id": 2601}
{"snippet": "html_diff.__init__(charjunk=IS_CHARACTER_JUNK)", "intent": "Initializes instance of HtmlDiff . `linejunk` and `charjunk` are optional keyword arguments passed into ndiff ( ) ( used by HtmlDiff to generate the side by side HTML differences ) .", "question_id": 2602}
{"snippet": "html_diff.__init__(tabsize=8, wrapcolumn=None)", "intent": "Initializes instance of HtmlDiff . `tabsize` is an optional keyword argument to specify tab stop spacing and defaults to 8 . `wrapcolumn` is an optional keyword to specify column number where lines are broken and wrapped , defaults to None where lines are not wrapped .", "question_id": 2603}
{"snippet": "html_diff.__init__(tabsize=8, linejunk=None)", "intent": "Initializes instance of HtmlDiff . `tabsize` is an optional keyword argument to specify tab stop spacing and defaults to 8 . `linejunk` and `charjunk` are optional keyword arguments passed into ndiff ( ) ( used by HtmlDiff to generate the side by side HTML differences ) .", "question_id": 2604}
{"snippet": "html_diff.__init__(tabsize=8, charjunk=IS_CHARACTER_JUNK)", "intent": "Initializes instance of HtmlDiff . `tabsize` is an optional keyword argument to specify tab stop spacing and defaults to 8 . `linejunk` and `charjunk` are optional keyword arguments passed into ndiff ( ) ( used by HtmlDiff to generate the side by side HTML differences ) .", "question_id": 2605}
{"snippet": "html_diff.__init__(wrapcolumn=None, linejunk=None)", "intent": "Initializes instance of HtmlDiff . `wrapcolumn` is an optional keyword to specify column number where lines are broken and wrapped , defaults to None where lines are not wrapped . `linejunk` and `charjunk` are optional keyword arguments passed into ndiff ( ) ( used by HtmlDiff to generate the side by side HTML differences ) .", "question_id": 2606}
{"snippet": "html_diff.__init__(wrapcolumn=None, charjunk=IS_CHARACTER_JUNK)", "intent": "Initializes instance of HtmlDiff . `wrapcolumn` is an optional keyword to specify column number where lines are broken and wrapped , defaults to None where lines are not wrapped . `linejunk` and `charjunk` are optional keyword arguments passed into ndiff ( ) ( used by HtmlDiff to generate the side by side HTML differences ) .", "question_id": 2607}
{"snippet": "html_diff.make_file(fromlines, tolines)", "intent": "Compares `fromlines` and `tolines` ( lists of strings ) and returns a string which is a complete HTML file containing a table showing line by line differences with inter-line and intra-line changes highlighted .", "question_id": 2608}
{"snippet": "html_diff.make_file(fromlines, tolines, fromdesc='')", "intent": "Compares `fromlines` and `tolines` ( lists of strings ) and returns a string which is a complete HTML file containing a table showing line by line differences with inter-line and intra-line changes highlighted . `fromdesc` and `todesc` are optional keyword arguments to specify from/to file column header strings ( both default to an empty string ) .", "question_id": 2609}
{"snippet": "html_diff.make_file(fromlines, tolines, todesc='')", "intent": "Compares `fromlines` and `tolines` ( lists of strings ) and returns a string which is a complete HTML file containing a table showing line by line differences with inter-line and intra-line changes highlighted . `fromdesc` and `todesc` are optional keyword arguments to specify from/to file column header strings ( both default to an empty string ) .", "question_id": 2610}
{"snippet": "html_diff.make_file(fromlines, tolines, context=False)", "intent": "Compares `fromlines` and `tolines` ( lists of strings ) and returns a string which is a complete HTML file containing a table showing line by line differences with inter-line and intra-line changes highlighted . `context` and `numlines` are both optional keyword arguments .", "question_id": 2611}
{"snippet": "html_diff.make_file(fromlines, tolines, numlines=5)", "intent": "Compares `fromlines` and `tolines` ( lists of strings ) and returns a string which is a complete HTML file containing a table showing line by line differences with inter-line and intra-line changes highlighted . `context` and `numlines` are both optional keyword arguments .", "question_id": 2612}
{"snippet": "html_diff.make_file(fromlines, tolines, charset='utf-8')", "intent": "Compares `fromlines` and `tolines` ( lists of strings ) and returns a string which is a complete HTML file containing a table showing line by line differences with inter-line and intra-line changes highlighted . With arguments `charset`.", "question_id": 2613}
{"snippet": "html_diff.make_file(fromlines, tolines, fromdesc='', todesc='')", "intent": "Compares `fromlines` and `tolines` ( lists of strings ) and returns a string which is a complete HTML file containing a table showing line by line differences with inter-line and intra-line changes highlighted . `fromdesc` and `todesc` are optional keyword arguments to specify from/to file column header strings ( both default to an empty string ) .", "question_id": 2614}
{"snippet": "html_diff.make_file(fromlines, tolines, fromdesc='', context=False)", "intent": "Compares `fromlines` and `tolines` ( lists of strings ) and returns a string which is a complete HTML file containing a table showing line by line differences with inter-line and intra-line changes highlighted . `fromdesc` and `todesc` are optional keyword arguments to specify from/to file column header strings ( both default to an empty string ) . `context` and `numlines` are both optional keyword arguments .", "question_id": 2615}
{"snippet": "html_diff.make_file(fromlines, tolines, fromdesc='', numlines=5)", "intent": "Compares `fromlines` and `tolines` ( lists of strings ) and returns a string which is a complete HTML file containing a table showing line by line differences with inter-line and intra-line changes highlighted . `fromdesc` and `todesc` are optional keyword arguments to specify from/to file column header strings ( both default to an empty string ) . `context` and `numlines` are both optional keyword arguments .", "question_id": 2616}
{"snippet": "html_diff.make_file(fromlines, tolines, fromdesc='', charset='utf-8')", "intent": "Compares `fromlines` and `tolines` ( lists of strings ) and returns a string which is a complete HTML file containing a table showing line by line differences with inter-line and intra-line changes highlighted . `fromdesc` and `todesc` are optional keyword arguments to specify from/to file column header strings ( both default to an empty string ) . With arguments `charset`.", "question_id": 2617}
{"snippet": "html_diff.make_table(fromlines, tolines)", "intent": "Compares `fromlines` and `tolines` ( lists of strings ) and returns a string which is a complete HTML table showing line by line differences with inter-line and intra-line changes highlighted .", "question_id": 2618}
{"snippet": "html_diff.make_table(fromlines, tolines, fromdesc='')", "intent": "Compares `fromlines` and `tolines` ( lists of strings ) and returns a string which is a complete HTML table showing line by line differences with inter-line and intra-line changes highlighted . With arguments `fromdesc`.", "question_id": 2619}
{"snippet": "html_diff.make_table(fromlines, tolines, todesc='')", "intent": "Compares `fromlines` and `tolines` ( lists of strings ) and returns a string which is a complete HTML table showing line by line differences with inter-line and intra-line changes highlighted . With arguments `todesc`.", "question_id": 2620}
{"snippet": "html_diff.make_table(fromlines, tolines, context=False)", "intent": "Compares `fromlines` and `tolines` ( lists of strings ) and returns a string which is a complete HTML table showing line by line differences with inter-line and intra-line changes highlighted . With arguments `context`.", "question_id": 2621}
{"snippet": "html_diff.make_table(fromlines, tolines, numlines=5)", "intent": "Compares `fromlines` and `tolines` ( lists of strings ) and returns a string which is a complete HTML table showing line by line differences with inter-line and intra-line changes highlighted . With arguments `numlines`.", "question_id": 2622}
{"snippet": "html_diff.make_table(fromlines, tolines, fromdesc='', todesc='')", "intent": "Compares `fromlines` and `tolines` ( lists of strings ) and returns a string which is a complete HTML table showing line by line differences with inter-line and intra-line changes highlighted . With arguments `fromdesc`, `todesc`.", "question_id": 2623}
{"snippet": "html_diff.make_table(fromlines, tolines, fromdesc='', context=False)", "intent": "Compares `fromlines` and `tolines` ( lists of strings ) and returns a string which is a complete HTML table showing line by line differences with inter-line and intra-line changes highlighted . With arguments `fromdesc`, `context`.", "question_id": 2624}
{"snippet": "html_diff.make_table(fromlines, tolines, fromdesc='', numlines=5)", "intent": "Compares `fromlines` and `tolines` ( lists of strings ) and returns a string which is a complete HTML table showing line by line differences with inter-line and intra-line changes highlighted . With arguments `fromdesc`, `numlines`.", "question_id": 2625}
{"snippet": "html_diff.make_table(fromlines, tolines, todesc='', context=False)", "intent": "Compares `fromlines` and `tolines` ( lists of strings ) and returns a string which is a complete HTML table showing line by line differences with inter-line and intra-line changes highlighted . With arguments `todesc`, `context`.", "question_id": 2626}
{"snippet": "html_diff.make_table(fromlines, tolines, todesc='', numlines=5)", "intent": "Compares `fromlines` and `tolines` ( lists of strings ) and returns a string which is a complete HTML table showing line by line differences with inter-line and intra-line changes highlighted . With arguments `todesc`, `numlines`.", "question_id": 2627}
{"snippet": "difflib.context_diff(a, b)", "intent": "Compare `a` and `b` ( lists of strings ) ; return a delta ( a generator generating the delta lines ) in context diff format .", "question_id": 2628}
{"snippet": "difflib.context_diff(a, b, fromfile='')", "intent": "Compare `a` and `b` ( lists of strings ) ; return a delta ( a generator generating the delta lines ) in context diff format . Any or all of these may be specified using strings for `fromfile` , `tofile` , `fromfiledate` , and `tofiledate` .", "question_id": 2629}
{"snippet": "difflib.context_diff(a, b, tofile='')", "intent": "Compare `a` and `b` ( lists of strings ) ; return a delta ( a generator generating the delta lines ) in context diff format . Any or all of these may be specified using strings for `fromfile` , `tofile` , `fromfiledate` , and `tofiledate` .", "question_id": 2630}
{"snippet": "difflib.context_diff(a, b, fromfiledate='')", "intent": "Compare `a` and `b` ( lists of strings ) ; return a delta ( a generator generating the delta lines ) in context diff format . Any or all of these may be specified using strings for `fromfile` , `tofile` , `fromfiledate` , and `tofiledate` .", "question_id": 2631}
{"snippet": "difflib.context_diff(a, b, tofiledate='')", "intent": "Compare `a` and `b` ( lists of strings ) ; return a delta ( a generator generating the delta lines ) in context diff format . Any or all of these may be specified using strings for `fromfile` , `tofile` , `fromfiledate` , and `tofiledate` .", "question_id": 2632}
{"snippet": "difflib.context_diff(a, b, n=3)", "intent": "Compare `a` and `b` ( lists of strings ) ; return a delta ( a generator generating the delta lines ) in context diff format . The number of context lines is set by `n` which defaults to three .", "question_id": 2633}
{"snippet": "difflib.context_diff(a, b, lineterm='\\n')", "intent": "Compare `a` and `b` ( lists of strings ) ; return a delta ( a generator generating the delta lines ) in context diff format . For inputs that do not have trailing newlines , set the `lineterm` argument to `` '' so that the output will be uniformly newline free .", "question_id": 2634}
{"snippet": "difflib.context_diff(a, b, fromfile='', tofile='')", "intent": "Compare `a` and `b` ( lists of strings ) ; return a delta ( a generator generating the delta lines ) in context diff format . Any or all of these may be specified using strings for `fromfile` , `tofile` , `fromfiledate` , and `tofiledate` .", "question_id": 2635}
{"snippet": "difflib.context_diff(a, b, fromfile='', fromfiledate='')", "intent": "Compare `a` and `b` ( lists of strings ) ; return a delta ( a generator generating the delta lines ) in context diff format . Any or all of these may be specified using strings for `fromfile` , `tofile` , `fromfiledate` , and `tofiledate` .", "question_id": 2636}
{"snippet": "difflib.context_diff(a, b, fromfile='', tofiledate='')", "intent": "Compare `a` and `b` ( lists of strings ) ; return a delta ( a generator generating the delta lines ) in context diff format . Any or all of these may be specified using strings for `fromfile` , `tofile` , `fromfiledate` , and `tofiledate` .", "question_id": 2637}
{"snippet": "difflib.get_close_matches(word, possibilities)", "intent": "Return a list of the best \u201c good enough \u201d matches . `word` is a sequence for which close matches are desired ( typically a string ) , and `possibilities` is a list of sequences against which to match word ( typically a list of strings ) .", "question_id": 2638}
{"snippet": "difflib.get_close_matches(word, possibilities, n=3)", "intent": "Return a list of the best \u201c good enough \u201d matches . `word` is a sequence for which close matches are desired ( typically a string ) , and `possibilities` is a list of sequences against which to match word ( typically a list of strings ) . Optional argument `n` ( default 3 ) is the maximum number of close matches to return ; n must be greater than 0 .", "question_id": 2639}
{"snippet": "difflib.get_close_matches(word, possibilities, cutoff=0.6)", "intent": "Return a list of the best \u201c good enough \u201d matches . `word` is a sequence for which close matches are desired ( typically a string ) , and `possibilities` is a list of sequences against which to match word ( typically a list of strings ) . Optional argument `cutoff` ( default 0.6 ) is a float in the range [ 0 , 1 ] .", "question_id": 2640}
{"snippet": "difflib.get_close_matches(word, possibilities, n=3, cutoff=0.6)", "intent": "Return a list of the best \u201c good enough \u201d matches . `word` is a sequence for which close matches are desired ( typically a string ) , and `possibilities` is a list of sequences against which to match word ( typically a list of strings ) . Optional argument `n` ( default 3 ) is the maximum number of close matches to return ; n must be greater than 0 . Optional argument `cutoff` ( default 0.6 ) is a float in the range [ 0 , 1 ] .", "question_id": 2641}
{"snippet": "difflib.ndiff(a, b)", "intent": "Compare `a` and `b` ( lists of strings ) ; return a Differ-style delta ( a generator generating the delta lines ) .", "question_id": 2642}
{"snippet": "difflib.ndiff(a, b, linejunk=None)", "intent": "Compare `a` and `b` ( lists of strings ) ; return a Differ-style delta ( a generator generating the delta lines ) . Optional keyword parameters `linejunk` and `charjunk` are filtering functions ( or None ) :", "question_id": 2643}
{"snippet": "difflib.ndiff(a, b, charjunk=IS_CHARACTER_JUNK)", "intent": "Compare `a` and `b` ( lists of strings ) ; return a Differ-style delta ( a generator generating the delta lines ) . Optional keyword parameters `linejunk` and `charjunk` are filtering functions ( or None ) :", "question_id": 2644}
{"snippet": "difflib.ndiff(a, b, linejunk=None, charjunk=IS_CHARACTER_JUNK)", "intent": "Compare `a` and `b` ( lists of strings ) ; return a Differ-style delta ( a generator generating the delta lines ) . Optional keyword parameters `linejunk` and `charjunk` are filtering functions ( or None ) :", "question_id": 2645}
{"snippet": "difflib.restore(sequence, which)", "intent": "Return one of the two sequences that generated a delta . Given a `sequence` produced by Differ.compare ( ) or ndiff ( ) , extract lines originating from file 1 or 2 ( parameter `which` ) , stripping off line prefixes .", "question_id": 2646}
{"snippet": "difflib.unified_diff(a, b)", "intent": "Compare `a` and `b` ( lists of strings ) ; return a delta ( a generator generating the delta lines ) in unified diff format .", "question_id": 2647}
{"snippet": "difflib.unified_diff(a, b, fromfile='')", "intent": "Compare `a` and `b` ( lists of strings ) ; return a delta ( a generator generating the delta lines ) in unified diff format . Any or all of these may be specified using strings for `fromfile` , `tofile` , `fromfiledate` , and `tofiledate` .", "question_id": 2648}
{"snippet": "difflib.unified_diff(a, b, tofile='')", "intent": "Compare `a` and `b` ( lists of strings ) ; return a delta ( a generator generating the delta lines ) in unified diff format . Any or all of these may be specified using strings for `fromfile` , `tofile` , `fromfiledate` , and `tofiledate` .", "question_id": 2649}
{"snippet": "difflib.unified_diff(a, b, fromfiledate='')", "intent": "Compare `a` and `b` ( lists of strings ) ; return a delta ( a generator generating the delta lines ) in unified diff format . Any or all of these may be specified using strings for `fromfile` , `tofile` , `fromfiledate` , and `tofiledate` .", "question_id": 2650}
{"snippet": "difflib.unified_diff(a, b, tofiledate='')", "intent": "Compare `a` and `b` ( lists of strings ) ; return a delta ( a generator generating the delta lines ) in unified diff format . Any or all of these may be specified using strings for `fromfile` , `tofile` , `fromfiledate` , and `tofiledate` .", "question_id": 2651}
{"snippet": "difflib.unified_diff(a, b, n=3)", "intent": "Compare `a` and `b` ( lists of strings ) ; return a delta ( a generator generating the delta lines ) in unified diff format . The number of context lines is set by `n` which defaults to three .", "question_id": 2652}
{"snippet": "difflib.unified_diff(a, b, lineterm='\\n')", "intent": "Compare `a` and `b` ( lists of strings ) ; return a delta ( a generator generating the delta lines ) in unified diff format . For inputs that do not have trailing newlines , set the `lineterm` argument to `` '' so that the output will be uniformly newline free .", "question_id": 2653}
{"snippet": "difflib.unified_diff(a, b, fromfile='', tofile='')", "intent": "Compare `a` and `b` ( lists of strings ) ; return a delta ( a generator generating the delta lines ) in unified diff format . Any or all of these may be specified using strings for `fromfile` , `tofile` , `fromfiledate` , and `tofiledate` .", "question_id": 2654}
{"snippet": "difflib.unified_diff(a, b, fromfile='', fromfiledate='')", "intent": "Compare `a` and `b` ( lists of strings ) ; return a delta ( a generator generating the delta lines ) in unified diff format . Any or all of these may be specified using strings for `fromfile` , `tofile` , `fromfiledate` , and `tofiledate` .", "question_id": 2655}
{"snippet": "difflib.unified_diff(a, b, fromfile='', tofiledate='')", "intent": "Compare `a` and `b` ( lists of strings ) ; return a delta ( a generator generating the delta lines ) in unified diff format . Any or all of these may be specified using strings for `fromfile` , `tofile` , `fromfiledate` , and `tofiledate` .", "question_id": 2656}
{"snippet": "difflib.diff_bytes(dfunc, a, b)", "intent": "Compare `a` and `b` ( lists of bytes objects ) using `dfunc` ; yield a sequence of delta lines ( also bytes ) in the format returned by dfunc .", "question_id": 2657}
{"snippet": "difflib.diff_bytes(dfunc, a, b, fromfile=b'')", "intent": "Compare `a` and `b` ( lists of bytes objects ) using `dfunc` ; yield a sequence of delta lines ( also bytes ) in the format returned by dfunc . Works by losslessly converting all inputs ( except n ) to str , and calling dfunc ( a , b , `fromfile` , `tofile` , `fromfiledate` , `tofiledate` , n , `lineterm` ) .", "question_id": 2658}
{"snippet": "difflib.diff_bytes(dfunc, a, b, tofile=b'')", "intent": "Compare `a` and `b` ( lists of bytes objects ) using `dfunc` ; yield a sequence of delta lines ( also bytes ) in the format returned by dfunc . Works by losslessly converting all inputs ( except n ) to str , and calling dfunc ( a , b , `fromfile` , `tofile` , `fromfiledate` , `tofiledate` , n , `lineterm` ) .", "question_id": 2659}
{"snippet": "difflib.diff_bytes(dfunc, a, b, fromfiledate=b'')", "intent": "Compare `a` and `b` ( lists of bytes objects ) using `dfunc` ; yield a sequence of delta lines ( also bytes ) in the format returned by dfunc . Works by losslessly converting all inputs ( except n ) to str , and calling dfunc ( a , b , `fromfile` , `tofile` , `fromfiledate` , `tofiledate` , n , `lineterm` ) .", "question_id": 2660}
{"snippet": "difflib.diff_bytes(dfunc, a, b, tofiledate=b'')", "intent": "Compare `a` and `b` ( lists of bytes objects ) using `dfunc` ; yield a sequence of delta lines ( also bytes ) in the format returned by dfunc . Works by losslessly converting all inputs ( except n ) to str , and calling dfunc ( a , b , `fromfile` , `tofile` , `fromfiledate` , `tofiledate` , n , `lineterm` ) .", "question_id": 2661}
{"snippet": "difflib.diff_bytes(dfunc, a, b, n=3)", "intent": "Compare `a` and `b` ( lists of bytes objects ) using `dfunc` ; yield a sequence of delta lines ( also bytes ) in the format returned by dfunc . All inputs except `n` must be bytes objects , not str .", "question_id": 2662}
{"snippet": "difflib.diff_bytes(dfunc, a, b, lineterm=b'\\n')", "intent": "Compare `a` and `b` ( lists of bytes objects ) using `dfunc` ; yield a sequence of delta lines ( also bytes ) in the format returned by dfunc . Works by losslessly converting all inputs ( except n ) to str , and calling dfunc ( a , b , `fromfile` , `tofile` , `fromfiledate` , `tofiledate` , n , `lineterm` ) .", "question_id": 2663}
{"snippet": "difflib.diff_bytes(dfunc, a, b, fromfile=b'', tofile=b'')", "intent": "Compare `a` and `b` ( lists of bytes objects ) using `dfunc` ; yield a sequence of delta lines ( also bytes ) in the format returned by dfunc . Works by losslessly converting all inputs ( except n ) to str , and calling dfunc ( a , b , `fromfile` , `tofile` , `fromfiledate` , `tofiledate` , n , `lineterm` ) .", "question_id": 2664}
{"snippet": "difflib.diff_bytes(dfunc, a, b, fromfile=b'', fromfiledate=b'')", "intent": "Compare `a` and `b` ( lists of bytes objects ) using `dfunc` ; yield a sequence of delta lines ( also bytes ) in the format returned by dfunc . Works by losslessly converting all inputs ( except n ) to str , and calling dfunc ( a , b , `fromfile` , `tofile` , `fromfiledate` , `tofiledate` , n , `lineterm` ) .", "question_id": 2665}
{"snippet": "difflib.diff_bytes(dfunc, a, b, fromfile=b'', tofiledate=b'')", "intent": "Compare `a` and `b` ( lists of bytes objects ) using `dfunc` ; yield a sequence of delta lines ( also bytes ) in the format returned by dfunc . Works by losslessly converting all inputs ( except n ) to str , and calling dfunc ( a , b , `fromfile` , `tofile` , `fromfiledate` , `tofiledate` , n , `lineterm` ) .", "question_id": 2666}
{"snippet": "difflib.IS_LINE_JUNK(line)", "intent": "Return true for ignorable lines . The `line` line is ignorable if line is blank or contains a single ' # ' , otherwise it is not ignorable .", "question_id": 2667}
{"snippet": "difflib.IS_CHARACTER_JUNK(ch)", "intent": "Return true for ignorable characters . The character `ch` is ignorable if ch is a space or tab , otherwise it is not ignorable .", "question_id": 2668}
{"snippet": "difflib.SequenceMatcher()", "intent": "Optional argument `isjunk` must be None ( the default ) or `a` one-argument function that takes a sequence element and returns true if and only if the element is \u201c junk \u201d and should be ignored .", "question_id": 2669}
{"snippet": "difflib.SequenceMatcher(isjunk=None)", "intent": "Optional argument `isjunk` must be None ( the default ) or `a` one-argument function that takes a sequence element and returns true if and only if the element is \u201c junk \u201d and should be ignored .", "question_id": 2670}
{"snippet": "difflib.SequenceMatcher(a='')", "intent": "Optional argument `isjunk` must be None ( the default ) or `a` one-argument function that takes a sequence element and returns true if and only if the element is \u201c junk \u201d and should be ignored .", "question_id": 2671}
{"snippet": "difflib.SequenceMatcher(b='')", "intent": "Optional argument `isjunk` must be None ( the default ) or `a` one-argument function that takes a sequence element and returns true if and only if the element is \u201c junk \u201d and should be ignored . The optional arguments a and `b` are sequences to be compared ; both default to empty strings .", "question_id": 2672}
{"snippet": "difflib.SequenceMatcher(autojunk=True)", "intent": "Optional argument `isjunk` must be None ( the default ) or `a` one-argument function that takes a sequence element and returns true if and only if the element is \u201c junk \u201d and should be ignored . The optional argument `autojunk` can be used to disable the automatic junk heuristic .", "question_id": 2673}
{"snippet": "difflib.SequenceMatcher(isjunk=None, a='')", "intent": "Optional argument `isjunk` must be None ( the default ) or `a` one-argument function that takes a sequence element and returns true if and only if the element is \u201c junk \u201d and should be ignored .", "question_id": 2674}
{"snippet": "difflib.SequenceMatcher(isjunk=None, b='')", "intent": "Optional argument `isjunk` must be None ( the default ) or `a` one-argument function that takes a sequence element and returns true if and only if the element is \u201c junk \u201d and should be ignored . The optional arguments a and `b` are sequences to be compared ; both default to empty strings .", "question_id": 2675}
{"snippet": "difflib.SequenceMatcher(isjunk=None, autojunk=True)", "intent": "Optional argument `isjunk` must be None ( the default ) or `a` one-argument function that takes a sequence element and returns true if and only if the element is \u201c junk \u201d and should be ignored . The optional argument `autojunk` can be used to disable the automatic junk heuristic .", "question_id": 2676}
{"snippet": "difflib.SequenceMatcher(a='', b='')", "intent": "Optional argument `isjunk` must be None ( the default ) or `a` one-argument function that takes a sequence element and returns true if and only if the element is \u201c junk \u201d and should be ignored . The optional arguments a and `b` are sequences to be compared ; both default to empty strings .", "question_id": 2677}
{"snippet": "difflib.SequenceMatcher(a='', autojunk=True)", "intent": "Optional argument `isjunk` must be None ( the default ) or `a` one-argument function that takes a sequence element and returns true if and only if the element is \u201c junk \u201d and should be ignored . The optional argument `autojunk` can be used to disable the automatic junk heuristic .", "question_id": 2678}
{"snippet": "sequence_matcher.set_seqs(a, b)", "intent": "Set the two sequences to be compared . With arguments `a`, `b`.", "question_id": 2679}
{"snippet": "sequence_matcher.set_seq1(a)", "intent": "Set the first sequence to be compared . With arguments `a`.", "question_id": 2680}
{"snippet": "sequence_matcher.set_seq2(b)", "intent": "Set the second sequence to be compared . With arguments `b`.", "question_id": 2681}
{"snippet": "sequence_matcher.find_longest_match(alo, ahi, blo, bhi)", "intent": "Find longest matching block in a [ `alo` : `ahi` ] and b [ `blo` : `bhi` ] .", "question_id": 2682}
{"snippet": "sequence_matcher.get_matching_blocks()", "intent": "Return list of triples describing non-overlapping matching subsequences .", "question_id": 2683}
{"snippet": "sequence_matcher.get_opcodes()", "intent": "Return list of 5-tuples describing how to turn a into b .", "question_id": 2684}
{"snippet": "sequence_matcher.get_grouped_opcodes()", "intent": "Return a generator of groups with up to `n` lines of context .", "question_id": 2685}
{"snippet": "sequence_matcher.get_grouped_opcodes(n=3)", "intent": "Return a generator of groups with up to `n` lines of context .", "question_id": 2686}
{"snippet": "sequence_matcher.ratio()", "intent": "Return a measure of the sequences \u2019 similarity as a float in the range [ 0 , 1 ] .", "question_id": 2687}
{"snippet": "sequence_matcher.quick_ratio()", "intent": "Return an upper bound on ratio ( ) relatively quickly .", "question_id": 2688}
{"snippet": "sequence_matcher.real_quick_ratio()", "intent": "Return an upper bound on ratio ( ) very quickly .", "question_id": 2689}
{"snippet": "difflib.Differ()", "intent": "Optional keyword parameters `linejunk` and `charjunk` are for filter functions ( or None ) :", "question_id": 2690}
{"snippet": "difflib.Differ(linejunk=None)", "intent": "Optional keyword parameters `linejunk` and `charjunk` are for filter functions ( or None ) :", "question_id": 2691}
{"snippet": "difflib.Differ(charjunk=None)", "intent": "Optional keyword parameters `linejunk` and `charjunk` are for filter functions ( or None ) :", "question_id": 2692}
{"snippet": "difflib.Differ(linejunk=None, charjunk=None)", "intent": "Optional keyword parameters `linejunk` and `charjunk` are for filter functions ( or None ) :", "question_id": 2693}
{"snippet": "differ.compare(a, b)", "intent": "Compare two sequences of lines , and generate the delta ( `a` sequence of lines ) . With arguments `b`.", "question_id": 2694}
{"snippet": "dis.Bytecode(x)", "intent": "Analyse the bytecode corresponding to a function , generator , asynchronous generator , coroutine , method , string of source code , or a code object ( as returned by compile ( ) ) . With arguments `x`.", "question_id": 2695}
{"snippet": "dis.Bytecode(x, first_line=None)", "intent": "Analyse the bytecode corresponding to a function , generator , asynchronous generator , coroutine , method , string of source code , or a code object ( as returned by compile ( ) ) . If `first_line` is not None , it indicates the line number that should be reported for the first source line in the disassembled code . With arguments `x`.", "question_id": 2696}
{"snippet": "dis.Bytecode(x, current_offset=None)", "intent": "Analyse the bytecode corresponding to a function , generator , asynchronous generator , coroutine , method , string of source code , or a code object ( as returned by compile ( ) ) . If `current_offset` is not None , it refers to an instruction offset in the disassembled code . With arguments `x`.", "question_id": 2697}
{"snippet": "dis.Bytecode(x, first_line=None, current_offset=None)", "intent": "Analyse the bytecode corresponding to a function , generator , asynchronous generator , coroutine , method , string of source code , or a code object ( as returned by compile ( ) ) . If `first_line` is not None , it indicates the line number that should be reported for the first source line in the disassembled code . If `current_offset` is not None , it refers to an instruction offset in the disassembled code . With arguments `x`.", "question_id": 2698}
{"snippet": "bytecode.from_traceback(tb)", "intent": "Construct a Bytecode instance from the given traceback , setting current_offset to the instruction responsible for the exception . With arguments `tb`.", "question_id": 2699}
{"snippet": "codeobj", "intent": "The compiled code object.", "question_id": 2700}
{"snippet": "first_line", "intent": "The first source line of the code object (if available)", "question_id": 2701}
{"snippet": "bytecode.dis()", "intent": "Return a formatted view of the bytecode operations ( the same as printed by dis.dis ( ) , but returned as a multi-line string ) .", "question_id": 2702}
{"snippet": "bytecode.info()", "intent": "Return a formatted multi-line string with detailed information about the code object , like code_info ( ) .", "question_id": 2703}
{"snippet": "dis.code_info(x)", "intent": "Return a formatted multi-line string with detailed code object information for the supplied function , generator , asynchronous generator , coroutine , method , source code string or code object . With arguments `x`.", "question_id": 2704}
{"snippet": "dis.show_code(x)", "intent": "Print detailed code object information for the supplied function , method , source code string or code object to `file` ( or sys.stdout if file is not specified ) . This is a convenient shorthand for print ( code_info ( `x` ) , file=file ) , intended for interactive exploration at the interpreter prompt .", "question_id": 2705}
{"snippet": "dis.show_code(x, file=None)", "intent": "Print detailed code object information for the supplied function , method , source code string or code object to `file` ( or sys.stdout if file is not specified ) . This is a convenient shorthand for print ( code_info ( `x` ) , file=file ) , intended for interactive exploration at the interpreter prompt .", "question_id": 2706}
{"snippet": "dis.dis()", "intent": "Disassemble the `x` object .", "question_id": 2707}
{"snippet": "dis.dis(x=None)", "intent": "Disassemble the `x` object .", "question_id": 2708}
{"snippet": "dis.dis(file=None)", "intent": "Disassemble the `x` object . The disassembly is written as text to the supplied `file` argument if provided and to sys.stdout otherwise .", "question_id": 2709}
{"snippet": "dis.dis(depth=None)", "intent": "Disassemble the `x` object . The maximal `depth` of recursion is limited by depth unless it is None .", "question_id": 2710}
{"snippet": "dis.dis(x=None, file=None)", "intent": "Disassemble the `x` object . The disassembly is written as text to the supplied `file` argument if provided and to sys.stdout otherwise .", "question_id": 2711}
{"snippet": "dis.dis(x=None, depth=None)", "intent": "Disassemble the `x` object . The maximal `depth` of recursion is limited by depth unless it is None .", "question_id": 2712}
{"snippet": "dis.dis(file=None, depth=None)", "intent": "Disassemble the `x` object . The disassembly is written as text to the supplied `file` argument if provided and to sys.stdout otherwise . The maximal `depth` of recursion is limited by depth unless it is None .", "question_id": 2713}
{"snippet": "dis.dis(x=None, file=None, depth=None)", "intent": "Disassemble the `x` object . The disassembly is written as text to the supplied `file` argument if provided and to sys.stdout otherwise . The maximal `depth` of recursion is limited by depth unless it is None .", "question_id": 2714}
{"snippet": "dis.distb()", "intent": "Disassemble the top-of-stack function of a traceback , using the last traceback if none was passed .", "question_id": 2715}
{"snippet": "dis.distb(tb=None)", "intent": "Disassemble the top-of-stack function of a traceback , using the last traceback if none was passed . With arguments `tb`.", "question_id": 2716}
{"snippet": "dis.distb(file=None)", "intent": "Disassemble the top-of-stack function of a traceback , using the last traceback if none was passed . The disassembly is written as text to the supplied `file` argument if provided and to sys.stdout otherwise .", "question_id": 2717}
{"snippet": "dis.distb(tb=None, file=None)", "intent": "Disassemble the top-of-stack function of a traceback , using the last traceback if none was passed . The disassembly is written as text to the supplied `file` argument if provided and to sys.stdout otherwise . With arguments `tb`.", "question_id": 2718}
{"snippet": "dis.disassemble(code)", "intent": "Disassemble a `code` object , indicating the last instruction if `lasti` was provided .", "question_id": 2719}
{"snippet": "dis.disassemble(code, lasti=-1)", "intent": "Disassemble a `code` object , indicating the last instruction if `lasti` was provided .", "question_id": 2720}
{"snippet": "dis.disassemble(code, file=None)", "intent": "Disassemble a `code` object , indicating the last instruction if `lasti` was provided . The disassembly is written as text to the supplied `file` argument if provided and to sys.stdout otherwise .", "question_id": 2721}
{"snippet": "dis.disassemble(code, lasti=-1, file=None)", "intent": "Disassemble a `code` object , indicating the last instruction if `lasti` was provided . The disassembly is written as text to the supplied `file` argument if provided and to sys.stdout otherwise .", "question_id": 2722}
{"snippet": "dis.disco(code)", "intent": "Disassemble a `code` object , indicating the last instruction if `lasti` was provided .", "question_id": 2723}
{"snippet": "dis.disco(code, lasti=-1)", "intent": "Disassemble a `code` object , indicating the last instruction if `lasti` was provided .", "question_id": 2724}
{"snippet": "dis.disco(code, file=None)", "intent": "Disassemble a `code` object , indicating the last instruction if `lasti` was provided . The disassembly is written as text to the supplied `file` argument if provided and to sys.stdout otherwise .", "question_id": 2725}
{"snippet": "dis.disco(code, lasti=-1, file=None)", "intent": "Disassemble a `code` object , indicating the last instruction if `lasti` was provided . The disassembly is written as text to the supplied `file` argument if provided and to sys.stdout otherwise .", "question_id": 2726}
{"snippet": "dis.get_instructions(x)", "intent": "Return an iterator over the instructions in the supplied function , method , source code string or code object . With arguments `x`.", "question_id": 2727}
{"snippet": "dis.get_instructions(x, first_line=None)", "intent": "Return an iterator over the instructions in the supplied function , method , source code string or code object . If `first_line` is not None , it indicates the line number that should be reported for the first source line in the disassembled code . With arguments `x`.", "question_id": 2728}
{"snippet": "dis.findlinestarts(code)", "intent": "This generator function uses the co_firstlineno and co_lnotab attributes of the `code` object code to find the offsets which are starts of lines in the source code .", "question_id": 2729}
{"snippet": "dis.findlabels(code)", "intent": "Detect all offsets in the `code` object code which are jump targets , and return a list of these offsets .", "question_id": 2730}
{"snippet": "dis.stack_effect(opcode, oparg)", "intent": "Compute the stack effect of `opcode` with argument `oparg` .", "question_id": 2731}
{"snippet": "dis.stack_effect(opcode)", "intent": "Compute the stack effect of `opcode` with argument `oparg` .", "question_id": 2732}
{"snippet": "dis.Instruction", "intent": "Details for a bytecode operation", "question_id": 2733}
{"snippet": "opcode", "intent": "numeric code for operation, corresponding to the opcode values listed below and the bytecode values in the Opcode collections.", "question_id": 2734}
{"snippet": "opname", "intent": "human readable name for operation", "question_id": 2735}
{"snippet": "arg", "intent": "numeric argument to operation (if any), otherwise None", "question_id": 2736}
{"snippet": "argval", "intent": "resolved arg value (if known), otherwise same as arg", "question_id": 2737}
{"snippet": "argrepr", "intent": "human readable description of operation argument", "question_id": 2738}
{"snippet": "offset", "intent": "start index of operation within bytecode sequence", "question_id": 2739}
{"snippet": "starts_line", "intent": "line started by this opcode (if any), otherwise None", "question_id": 2740}
{"snippet": "is_jump_target", "intent": "True if other code jumps to here, otherwise False", "question_id": 2741}
{"snippet": "dis.opname", "intent": "Sequence of operation names, indexable using the bytecode.", "question_id": 2742}
{"snippet": "dis.opmap", "intent": "Dictionary mapping operation names to bytecodes.", "question_id": 2743}
{"snippet": "dis.cmp_op", "intent": "Sequence of all compare operation names.", "question_id": 2744}
{"snippet": "dis.hasconst", "intent": "Sequence of bytecodes that access a constant.", "question_id": 2745}
{"snippet": "dis.hasfree", "intent": "Sequence of bytecodes that access a free variable (note that \u2018free\u2019 in this context refers to names in the current scope that are referenced by inner scopes or names in outer scopes that are referenced from this scope.", "question_id": 2746}
{"snippet": "dis.hasname", "intent": "Sequence of bytecodes that access an attribute by name.", "question_id": 2747}
{"snippet": "dis.hasjrel", "intent": "Sequence of bytecodes that have a relative jump target.", "question_id": 2748}
{"snippet": "dis.hasjabs", "intent": "Sequence of bytecodes that have an absolute jump target.", "question_id": 2749}
{"snippet": "dis.haslocal", "intent": "Sequence of bytecodes that access a local variable.", "question_id": 2750}
{"snippet": "dis.hascompare", "intent": "Sequence of bytecodes of Boolean operations.", "question_id": 2751}
{"snippet": "doctest.DONT_ACCEPT_TRUE_FOR_1", "intent": "By default, if an expected output block contains just 1, an actual output block containing just 1 or just True is considered to be a match, and similarly for 0 versus False.", "question_id": 2752}
{"snippet": "doctest.DONT_ACCEPT_BLANKLINE", "intent": "By default, if an expected output block contains a line containing only the string <BLANKLINE>, then that line will match a blank line in the actual output.", "question_id": 2753}
{"snippet": "doctest.NORMALIZE_WHITESPACE", "intent": "When specified, all sequences of whitespace (blanks and newlines) are treated as equal.", "question_id": 2754}
{"snippet": "doctest.ELLIPSIS", "intent": "When specified, an ellipsis marker (...) in the expected output can match any substring in the actual output.", "question_id": 2755}
{"snippet": "doctest.IGNORE_EXCEPTION_DETAIL", "intent": "When specified, an example that expects an exception passes if an exception of the expected type is raised, even if the exception detail does not match.", "question_id": 2756}
{"snippet": "doctest.SKIP", "intent": "When specified, do not run the example at all.", "question_id": 2757}
{"snippet": "doctest.COMPARISON_FLAGS", "intent": "A bitmask or\u2019ing together all the comparison flags above.", "question_id": 2758}
{"snippet": "doctest.REPORT_UDIFF", "intent": "When specified, failures that involve multi-line expected and actual outputs are displayed using a unified diff.", "question_id": 2759}
{"snippet": "doctest.REPORT_CDIFF", "intent": "When specified, failures that involve multi-line expected and actual outputs will be displayed using a context diff.", "question_id": 2760}
{"snippet": "doctest.REPORT_NDIFF", "intent": "When specified, differences are computed by difflib.Differ, using the same algorithm as the popular ndiff.py utility.", "question_id": 2761}
{"snippet": "doctest.REPORT_ONLY_FIRST_FAILURE", "intent": "When specified, display the first failing example in each doctest, but suppress output for all remaining examples.", "question_id": 2762}
{"snippet": "doctest.FAIL_FAST", "intent": "When specified, exit after the first failing example and don\u2019t attempt to run the remaining examples.", "question_id": 2763}
{"snippet": "doctest.REPORTING_FLAGS", "intent": "A bitmask or\u2019ing together all the reporting flags above.", "question_id": 2764}
{"snippet": "doctest.register_optionflag(name)", "intent": "Create a new option flag with a given `name` , and return the new flag \u2019 s integer value .", "question_id": 2765}
{"snippet": "doctest.testfile(filename)", "intent": "All arguments except `filename` are optional , and should be specified in keyword form .", "question_id": 2766}
{"snippet": "doctest.testfile(filename, module_relative=True)", "intent": "All arguments except `filename` are optional , and should be specified in keyword form . Optional argument `module_relative` specifies how the filename should be interpreted :", "question_id": 2767}
{"snippet": "doctest.testfile(filename, name=None)", "intent": "All arguments except `filename` are optional , and should be specified in keyword form . Optional argument `name` gives the name of the test ; by default , or if None , os.path.basename ( filename ) is used .", "question_id": 2768}
{"snippet": "doctest.testfile(filename, package=None)", "intent": "All arguments except `filename` are optional , and should be specified in keyword form . Optional argument `package` is a Python package or the name of a Python package whose directory should be used as the base directory for a module-relative filename .", "question_id": 2769}
{"snippet": "doctest.testfile(filename, globs=None)", "intent": "All arguments except `filename` are optional , and should be specified in keyword form . Optional argument `globs` gives a dict to be used as the globals when executing examples .", "question_id": 2770}
{"snippet": "doctest.testfile(filename, verbose=None)", "intent": "All arguments except `filename` are optional , and should be specified in keyword form . Optional argument `verbose` prints lots of stuff if true , and prints only failures if false ; by default , or if None , it \u2019 s true if and only if '-v ' is in sys.argv .", "question_id": 2771}
{"snippet": "doctest.testfile(filename, report=True)", "intent": "All arguments except `filename` are optional , and should be specified in keyword form . Optional argument `report` prints a summary at the end when true , else prints nothing at the end .", "question_id": 2772}
{"snippet": "doctest.testfile(filename, optionflags=0)", "intent": "All arguments except `filename` are optional , and should be specified in keyword form . Optional argument `optionflags` ( default value 0 ) takes the bitwise OR of option flags .", "question_id": 2773}
{"snippet": "doctest.testfile(filename, extraglobs=None)", "intent": "All arguments except `filename` are optional , and should be specified in keyword form . Optional argument `extraglobs` gives a dict merged into the globals used to execute examples .", "question_id": 2774}
{"snippet": "doctest.testfile(filename, raise_on_error=False)", "intent": "All arguments except `filename` are optional , and should be specified in keyword form . Optional argument `raise_on_error` defaults to false .", "question_id": 2775}
{"snippet": "doctest.testmod()", "intent": "All arguments are optional , and all except for `m` should be specified in keyword form .", "question_id": 2776}
{"snippet": "doctest.testmod(m=None)", "intent": "All arguments are optional , and all except for `m` should be specified in keyword form .", "question_id": 2777}
{"snippet": "doctest.testmod(name=None)", "intent": "All arguments are optional , and all except for `m` should be specified in keyword form . Optional argument `name` gives the name of the module ; by default , or if None , m.__name__ is used .", "question_id": 2778}
{"snippet": "doctest.testmod(globs=None)", "intent": "All arguments are optional , and all except for `m` should be specified in keyword form . Optional arguments `extraglobs` , `verbose` , `report` , `optionflags` , `raise_on_error` , and `globs` are the same as for function testfile ( ) above , except that globs defaults to m.__dict__ .", "question_id": 2779}
{"snippet": "doctest.testmod(verbose=None)", "intent": "All arguments are optional , and all except for `m` should be specified in keyword form . Optional arguments `extraglobs` , `verbose` , `report` , `optionflags` , `raise_on_error` , and `globs` are the same as for function testfile ( ) above , except that globs defaults to m.__dict__ .", "question_id": 2780}
{"snippet": "doctest.testmod(report=True)", "intent": "All arguments are optional , and all except for `m` should be specified in keyword form . Optional arguments `extraglobs` , `verbose` , `report` , `optionflags` , `raise_on_error` , and `globs` are the same as for function testfile ( ) above , except that globs defaults to m.__dict__ .", "question_id": 2781}
{"snippet": "doctest.testmod(optionflags=0)", "intent": "All arguments are optional , and all except for `m` should be specified in keyword form . Optional arguments `extraglobs` , `verbose` , `report` , `optionflags` , `raise_on_error` , and `globs` are the same as for function testfile ( ) above , except that globs defaults to m.__dict__ .", "question_id": 2782}
{"snippet": "doctest.testmod(extraglobs=None)", "intent": "All arguments are optional , and all except for `m` should be specified in keyword form . Optional arguments `extraglobs` , `verbose` , `report` , `optionflags` , `raise_on_error` , and `globs` are the same as for function testfile ( ) above , except that globs defaults to m.__dict__ .", "question_id": 2783}
{"snippet": "doctest.testmod(raise_on_error=False)", "intent": "All arguments are optional , and all except for `m` should be specified in keyword form . Optional arguments `extraglobs` , `verbose` , `report` , `optionflags` , `raise_on_error` , and `globs` are the same as for function testfile ( ) above , except that globs defaults to m.__dict__ .", "question_id": 2784}
{"snippet": "doctest.testmod(exclude_empty=False)", "intent": "All arguments are optional , and all except for `m` should be specified in keyword form . Optional argument `exclude_empty` defaults to false .", "question_id": 2785}
{"snippet": "doctest.run_docstring_examples(f, globs)", "intent": "Test examples associated with object `f` ; for example , f may be a string , a module , a function , or a class object . A shallow copy of dictionary argument `globs` is used for the execution context .", "question_id": 2786}
{"snippet": "doctest.run_docstring_examples(f, globs, verbose=False)", "intent": "Test examples associated with object `f` ; for example , f may be a string , a module , a function , or a class object . A shallow copy of dictionary argument `globs` is used for the execution context . If optional argument `verbose` is true , output is generated even if there are no failures .", "question_id": 2787}
{"snippet": "doctest.run_docstring_examples(f, globs, name=\"NoName\")", "intent": "Test examples associated with object `f` ; for example , f may be a string , a module , a function , or a class object . A shallow copy of dictionary argument `globs` is used for the execution context . Optional argument `name` is used in failure messages , and defaults to `` NoName '' .", "question_id": 2788}
{"snippet": "doctest.run_docstring_examples(f, globs, compileflags=None)", "intent": "Test examples associated with object `f` ; for example , f may be a string , a module , a function , or a class object . A shallow copy of dictionary argument `globs` is used for the execution context . Optional argument `compileflags` gives the set of flags that should be used by the Python compiler when running the examples .", "question_id": 2789}
{"snippet": "doctest.run_docstring_examples(f, globs, optionflags=0)", "intent": "Test examples associated with object `f` ; for example , f may be a string , a module , a function , or a class object . A shallow copy of dictionary argument `globs` is used for the execution context . Optional argument `optionflags` works as for function testfile ( ) above .", "question_id": 2790}
{"snippet": "doctest.run_docstring_examples(f, globs, verbose=False, name=\"NoName\")", "intent": "Test examples associated with object `f` ; for example , f may be a string , a module , a function , or a class object . A shallow copy of dictionary argument `globs` is used for the execution context . If optional argument `verbose` is true , output is generated even if there are no failures . Optional argument `name` is used in failure messages , and defaults to `` NoName '' .", "question_id": 2791}
{"snippet": "doctest.run_docstring_examples(f, globs, verbose=False, compileflags=None)", "intent": "Test examples associated with object `f` ; for example , f may be a string , a module , a function , or a class object . A shallow copy of dictionary argument `globs` is used for the execution context . If optional argument `verbose` is true , output is generated even if there are no failures . Optional argument `compileflags` gives the set of flags that should be used by the Python compiler when running the examples .", "question_id": 2792}
{"snippet": "doctest.run_docstring_examples(f, globs, verbose=False, optionflags=0)", "intent": "Test examples associated with object `f` ; for example , f may be a string , a module , a function , or a class object . A shallow copy of dictionary argument `globs` is used for the execution context . If optional argument `verbose` is true , output is generated even if there are no failures . Optional argument `optionflags` works as for function testfile ( ) above .", "question_id": 2793}
{"snippet": "doctest.run_docstring_examples(f, globs, name=\"NoName\", compileflags=None)", "intent": "Test examples associated with object `f` ; for example , f may be a string , a module , a function , or a class object . A shallow copy of dictionary argument `globs` is used for the execution context . Optional argument `name` is used in failure messages , and defaults to `` NoName '' . Optional argument `compileflags` gives the set of flags that should be used by the Python compiler when running the examples .", "question_id": 2794}
{"snippet": "doctest.run_docstring_examples(f, globs, name=\"NoName\", optionflags=0)", "intent": "Test examples associated with object `f` ; for example , f may be a string , a module , a function , or a class object . A shallow copy of dictionary argument `globs` is used for the execution context . Optional argument `name` is used in failure messages , and defaults to `` NoName '' . Optional argument `optionflags` works as for function testfile ( ) above .", "question_id": 2795}
{"snippet": "doctest.DocFileSuite(*paths)", "intent": "Convert doctest tests from one or more text files to a unittest.TestSuite . With arguments `*paths`.", "question_id": 2796}
{"snippet": "doctest.DocFileSuite(*paths, module_relative=True)", "intent": "Convert doctest tests from one or more text files to a unittest.TestSuite . Optional argument `module_relative` specifies how the filenames in paths should be interpreted : With arguments `*paths`.", "question_id": 2797}
{"snippet": "doctest.DocFileSuite(*paths, package=None)", "intent": "Convert doctest tests from one or more text files to a unittest.TestSuite . Optional argument `package` is a Python package or the name of a Python package whose directory should be used as the base directory for module-relative filenames in paths . With arguments `*paths`.", "question_id": 2798}
{"snippet": "doctest.DocFileSuite(*paths, setUp=None)", "intent": "Convert doctest tests from one or more text files to a unittest.TestSuite . Optional argument `setUp` specifies a set-up function for the test suite . With arguments `*paths`.", "question_id": 2799}
{"snippet": "doctest.DocFileSuite(*paths, tearDown=None)", "intent": "Convert doctest tests from one or more text files to a unittest.TestSuite . Optional argument `tearDown` specifies a tear-down function for the test suite . With arguments `*paths`.", "question_id": 2800}
{"snippet": "doctest.DocFileSuite(*paths, globs=None)", "intent": "Convert doctest tests from one or more text files to a unittest.TestSuite . The setUp function can access the test globals as the `globs` attribute of the test passed . With arguments `*paths`.", "question_id": 2801}
{"snippet": "doctest.DocFileSuite(*paths, optionflags=0)", "intent": "Convert doctest tests from one or more text files to a unittest.TestSuite . Optional argument `optionflags` specifies the default doctest options for the tests , created by or-ing together individual option flags . With arguments `*paths`.", "question_id": 2802}
{"snippet": "doctest.DocFileSuite(*paths, parser=DocTestParser())", "intent": "Convert doctest tests from one or more text files to a unittest.TestSuite . Optional argument `parser` specifies a DocTestParser ( or subclass ) that should be used to extract tests from the files . With arguments `*paths`.", "question_id": 2803}
{"snippet": "doctest.DocFileSuite(*paths, encoding=None)", "intent": "Convert doctest tests from one or more text files to a unittest.TestSuite . Optional argument `encoding` specifies an encoding that should be used to convert the file to unicode . With arguments `*paths`.", "question_id": 2804}
{"snippet": "doctest.DocFileSuite(*paths, module_relative=True, package=None)", "intent": "Convert doctest tests from one or more text files to a unittest.TestSuite . Optional argument `module_relative` specifies how the filenames in paths should be interpreted : Optional argument `package` is a Python package or the name of a Python package whose directory should be used as the base directory for module-relative filenames in paths . With arguments `*paths`.", "question_id": 2805}
{"snippet": "doctest.DocTestSuite()", "intent": "Convert doctest tests for a `module` to a unittest.TestSuite .", "question_id": 2806}
{"snippet": "doctest.DocTestSuite(module=None)", "intent": "Convert doctest tests for a `module` to a unittest.TestSuite .", "question_id": 2807}
{"snippet": "doctest.DocTestSuite(globs=None)", "intent": "Convert doctest tests for a `module` to a unittest.TestSuite . Optional argument `globs` is a dictionary containing the initial global variables for the tests .", "question_id": 2808}
{"snippet": "doctest.DocTestSuite(extraglobs=None)", "intent": "Convert doctest tests for a `module` to a unittest.TestSuite . Optional argument `extraglobs` specifies an extra set of global variables , which is merged into globs .", "question_id": 2809}
{"snippet": "doctest.DocTestSuite(test_finder=None)", "intent": "Convert doctest tests for a `module` to a unittest.TestSuite . Optional argument `test_finder` is the DocTestFinder object ( or a drop-in replacement ) that is used to extract doctests from the module .", "question_id": 2810}
{"snippet": "doctest.DocTestSuite(setUp=None)", "intent": "Convert doctest tests for a `module` to a unittest.TestSuite . Optional arguments `setUp` , `tearDown` , and optionflags are the same as for function DocFileSuite ( ) above .", "question_id": 2811}
{"snippet": "doctest.DocTestSuite(tearDown=None)", "intent": "Convert doctest tests for a `module` to a unittest.TestSuite . Optional arguments `setUp` , `tearDown` , and optionflags are the same as for function DocFileSuite ( ) above .", "question_id": 2812}
{"snippet": "doctest.DocTestSuite(checker=None)", "intent": "Convert doctest tests for a `module` to a unittest.TestSuite . With arguments `checker`.", "question_id": 2813}
{"snippet": "doctest.DocTestSuite(module=None, globs=None)", "intent": "Convert doctest tests for a `module` to a unittest.TestSuite . Optional argument `globs` is a dictionary containing the initial global variables for the tests .", "question_id": 2814}
{"snippet": "doctest.DocTestSuite(module=None, extraglobs=None)", "intent": "Convert doctest tests for a `module` to a unittest.TestSuite . Optional argument `extraglobs` specifies an extra set of global variables , which is merged into globs .", "question_id": 2815}
{"snippet": "doctest.set_unittest_reportflags(flags)", "intent": "Set the doctest reporting `flags` to use .", "question_id": 2816}
{"snippet": "doctest.DocTest(examples, globs, name, filename, lineno, docstring)", "intent": "A collection of doctest `examples` that should be run in a single namespace . With arguments `globs`, `name`, `filename`, `lineno`, `docstring`.", "question_id": 2817}
{"snippet": "doc_test.examples", "intent": "A list of Example objects encoding the individual interactive Python examples that should be run by this test.", "question_id": 2818}
{"snippet": "doc_test.globs", "intent": "The namespace (aka globals) that the examples should be run in.", "question_id": 2819}
{"snippet": "doc_test.name", "intent": "A string name identifying the DocTest.", "question_id": 2820}
{"snippet": "doc_test.filename", "intent": "The name of the file that this DocTest was extracted from; or None if the filename is unknown, or if the DocTest was not extracted from a file.", "question_id": 2821}
{"snippet": "doc_test.lineno", "intent": "The line number within filename where this DocTest begins, or None if the line number is unavailable.", "question_id": 2822}
{"snippet": "doc_test.docstring", "intent": "The string that the test was extracted from, or None if the string is unavailable, or if the test was not extracted from a string.", "question_id": 2823}
{"snippet": "doctest.Example(source, want)", "intent": "A single interactive example , consisting of a Python statement and its expected output . With arguments `source`, `want`.", "question_id": 2824}
{"snippet": "doctest.Example(source, want, exc_msg=None)", "intent": "A single interactive example , consisting of a Python statement and its expected output . With arguments `source`, `want`, `exc_msg`.", "question_id": 2825}
{"snippet": "doctest.Example(source, want, lineno=0)", "intent": "A single interactive example , consisting of a Python statement and its expected output . With arguments `source`, `want`, `lineno`.", "question_id": 2826}
{"snippet": "doctest.Example(source, want, indent=0)", "intent": "A single interactive example , consisting of a Python statement and its expected output . With arguments `source`, `want`, `indent`.", "question_id": 2827}
{"snippet": "doctest.Example(source, want, options=None)", "intent": "A single interactive example , consisting of a Python statement and its expected output . With arguments `source`, `want`, `options`.", "question_id": 2828}
{"snippet": "doctest.Example(source, want, exc_msg=None, lineno=0)", "intent": "A single interactive example , consisting of a Python statement and its expected output . With arguments `source`, `want`, `exc_msg`, `lineno`.", "question_id": 2829}
{"snippet": "doctest.Example(source, want, exc_msg=None, indent=0)", "intent": "A single interactive example , consisting of a Python statement and its expected output . With arguments `source`, `want`, `exc_msg`, `indent`.", "question_id": 2830}
{"snippet": "doctest.Example(source, want, exc_msg=None, options=None)", "intent": "A single interactive example , consisting of a Python statement and its expected output . With arguments `source`, `want`, `exc_msg`, `options`.", "question_id": 2831}
{"snippet": "doctest.Example(source, want, lineno=0, indent=0)", "intent": "A single interactive example , consisting of a Python statement and its expected output . With arguments `source`, `want`, `lineno`, `indent`.", "question_id": 2832}
{"snippet": "doctest.Example(source, want, lineno=0, options=None)", "intent": "A single interactive example , consisting of a Python statement and its expected output . With arguments `source`, `want`, `lineno`, `options`.", "question_id": 2833}
{"snippet": "example.source", "intent": "A string containing the example\u2019s source code.", "question_id": 2834}
{"snippet": "example.want", "intent": "The expected output from running the example\u2019s source code (either from stdout, or a traceback in case of exception).", "question_id": 2835}
{"snippet": "example.exc_msg", "intent": "The exception message generated by the example, if the example is expected to generate an exception; or None if it is not expected to generate an exception.", "question_id": 2836}
{"snippet": "example.lineno", "intent": "The line number within the string containing this example where the example begins.", "question_id": 2837}
{"snippet": "example.indent", "intent": "The example\u2019s indentation in the containing string, i.e., the number of space characters that precede the example\u2019s first prompt.", "question_id": 2838}
{"snippet": "example.options", "intent": "A dictionary mapping from option flags to True or False, which is used to override default options for this example.", "question_id": 2839}
{"snippet": "doctest.DocTestFinder()", "intent": "A processing class used to extract the DocTests that are relevant to a given object , from its docstring and the docstrings of its contained objects .", "question_id": 2840}
{"snippet": "doctest.DocTestFinder(verbose=False)", "intent": "A processing class used to extract the DocTests that are relevant to a given object , from its docstring and the docstrings of its contained objects . The optional argument `verbose` can be used to display the objects searched by the finder .", "question_id": 2841}
{"snippet": "doctest.DocTestFinder(parser=DocTestParser())", "intent": "A processing class used to extract the DocTests that are relevant to a given object , from its docstring and the docstrings of its contained objects . The optional argument `parser` specifies the DocTestParser object ( or a drop-in replacement ) that is used to extract doctests from docstrings .", "question_id": 2842}
{"snippet": "doctest.DocTestFinder(recurse=True)", "intent": "A processing class used to extract the DocTests that are relevant to a given object , from its docstring and the docstrings of its contained objects . If the optional argument `recurse` is false , then DocTestFinder.find ( ) will only examine the given object , and not any contained objects .", "question_id": 2843}
{"snippet": "doctest.DocTestFinder(exclude_empty=True)", "intent": "A processing class used to extract the DocTests that are relevant to a given object , from its docstring and the docstrings of its contained objects . If the optional argument `exclude_empty` is false , then DocTestFinder.find ( ) will include tests for objects with empty docstrings .", "question_id": 2844}
{"snippet": "doctest.DocTestFinder(verbose=False, parser=DocTestParser())", "intent": "A processing class used to extract the DocTests that are relevant to a given object , from its docstring and the docstrings of its contained objects . The optional argument `verbose` can be used to display the objects searched by the finder . The optional argument `parser` specifies the DocTestParser object ( or a drop-in replacement ) that is used to extract doctests from docstrings .", "question_id": 2845}
{"snippet": "doctest.DocTestFinder(verbose=False, recurse=True)", "intent": "A processing class used to extract the DocTests that are relevant to a given object , from its docstring and the docstrings of its contained objects . The optional argument `verbose` can be used to display the objects searched by the finder . If the optional argument `recurse` is false , then DocTestFinder.find ( ) will only examine the given object , and not any contained objects .", "question_id": 2846}
{"snippet": "doctest.DocTestFinder(verbose=False, exclude_empty=True)", "intent": "A processing class used to extract the DocTests that are relevant to a given object , from its docstring and the docstrings of its contained objects . The optional argument `verbose` can be used to display the objects searched by the finder . If the optional argument `exclude_empty` is false , then DocTestFinder.find ( ) will include tests for objects with empty docstrings .", "question_id": 2847}
{"snippet": "doctest.DocTestFinder(parser=DocTestParser(), recurse=True)", "intent": "A processing class used to extract the DocTests that are relevant to a given object , from its docstring and the docstrings of its contained objects . The optional argument `parser` specifies the DocTestParser object ( or a drop-in replacement ) that is used to extract doctests from docstrings . If the optional argument `recurse` is false , then DocTestFinder.find ( ) will only examine the given object , and not any contained objects .", "question_id": 2848}
{"snippet": "doctest.DocTestFinder(parser=DocTestParser(), exclude_empty=True)", "intent": "A processing class used to extract the DocTests that are relevant to a given object , from its docstring and the docstrings of its contained objects . The optional argument `parser` specifies the DocTestParser object ( or a drop-in replacement ) that is used to extract doctests from docstrings . If the optional argument `exclude_empty` is false , then DocTestFinder.find ( ) will include tests for objects with empty docstrings .", "question_id": 2849}
{"snippet": "doc_test_finder.find(obj, name, module, globs, extraglobs)", "intent": "Return a list of the DocTests that are defined by `obj` \u2019 s docstring , or by any of its contained objects \u2019 docstrings . The optional argument `name` specifies the object \u2019 s name ; this name will be used to construct names for the returned DocTests . The optional parameter `module` is the module that contains the given object . The globals for each DocTest is formed by combining `globs` and `extraglobs` ( bindings in extraglobs override bindings in globs ) .", "question_id": 2850}
{"snippet": "doc_test_finder.find(obj, name, module, globs)", "intent": "Return a list of the DocTests that are defined by `obj` \u2019 s docstring , or by any of its contained objects \u2019 docstrings . The optional argument `name` specifies the object \u2019 s name ; this name will be used to construct names for the returned DocTests . The optional parameter `module` is the module that contains the given object . The globals for each DocTest is formed by combining `globs` and `extraglobs` ( bindings in extraglobs override bindings in globs ) .", "question_id": 2851}
{"snippet": "doc_test_finder.find(obj, name, module)", "intent": "Return a list of the DocTests that are defined by `obj` \u2019 s docstring , or by any of its contained objects \u2019 docstrings . The optional argument `name` specifies the object \u2019 s name ; this name will be used to construct names for the returned DocTests . The optional parameter `module` is the module that contains the given object .", "question_id": 2852}
{"snippet": "doc_test_finder.find(obj, name)", "intent": "Return a list of the DocTests that are defined by `obj` \u2019 s docstring , or by any of its contained objects \u2019 docstrings . The optional argument `name` specifies the object \u2019 s name ; this name will be used to construct names for the returned DocTests .", "question_id": 2853}
{"snippet": "doc_test_finder.find(obj)", "intent": "Return a list of the DocTests that are defined by `obj` \u2019 s docstring , or by any of its contained objects \u2019 docstrings .", "question_id": 2854}
{"snippet": "doctest.DocTestParser", "intent": "A processing class used to extract interactive examples from a string, and use them to create a DocTest object.", "question_id": 2855}
{"snippet": "doc_test_parser.get_doctest(string, globs, name, filename, lineno)", "intent": "Extract all doctest examples from the given `string` , and collect them into a DocTest object . `globs` , `name` , `filename` , and `lineno` are attributes for the new DocTest object .", "question_id": 2856}
{"snippet": "doc_test_parser.get_examples(string)", "intent": "Extract all doctest examples from the given `string` , and return them as a list of Example objects .", "question_id": 2857}
{"snippet": "doc_test_parser.get_examples(string, name='<string>')", "intent": "Extract all doctest examples from the given `string` , and return them as a list of Example objects . The optional argument `name` is a name identifying this string , and is only used for error messages .", "question_id": 2858}
{"snippet": "doc_test_parser.parse(string)", "intent": "Divide the given `string` into examples and intervening text , and return them as a list of alternating Examples and strings .", "question_id": 2859}
{"snippet": "doc_test_parser.parse(string, name='<string>')", "intent": "Divide the given `string` into examples and intervening text , and return them as a list of alternating Examples and strings . The optional argument `name` is a name identifying this string , and is only used for error messages .", "question_id": 2860}
{"snippet": "doctest.DocTestRunner()", "intent": "A processing class used to execute and verify the interactive examples in a DocTest .", "question_id": 2861}
{"snippet": "doctest.DocTestRunner(checker=None)", "intent": "A processing class used to execute and verify the interactive examples in a DocTest . The optional keyword argument `checker` specifies the OutputChecker object ( or drop-in replacement ) that should be used to compare the expected outputs to the actual outputs of doctest examples .", "question_id": 2862}
{"snippet": "doctest.DocTestRunner(verbose=None)", "intent": "A processing class used to execute and verify the interactive examples in a DocTest . The optional keyword argument `verbose` controls the DocTestRunner \u2019 s verbosity .", "question_id": 2863}
{"snippet": "doctest.DocTestRunner(optionflags=0)", "intent": "A processing class used to execute and verify the interactive examples in a DocTest . The optional keyword argument `optionflags` can be used to control how the test runner compares expected output to actual output , and how it displays failures .", "question_id": 2864}
{"snippet": "doctest.DocTestRunner(checker=None, verbose=None)", "intent": "A processing class used to execute and verify the interactive examples in a DocTest . The optional keyword argument `checker` specifies the OutputChecker object ( or drop-in replacement ) that should be used to compare the expected outputs to the actual outputs of doctest examples . The optional keyword argument `verbose` controls the DocTestRunner \u2019 s verbosity .", "question_id": 2865}
{"snippet": "doctest.DocTestRunner(checker=None, optionflags=0)", "intent": "A processing class used to execute and verify the interactive examples in a DocTest . The optional keyword argument `checker` specifies the OutputChecker object ( or drop-in replacement ) that should be used to compare the expected outputs to the actual outputs of doctest examples . The optional keyword argument `optionflags` can be used to control how the test runner compares expected output to actual output , and how it displays failures .", "question_id": 2866}
{"snippet": "doctest.DocTestRunner(verbose=None, optionflags=0)", "intent": "A processing class used to execute and verify the interactive examples in a DocTest . The optional keyword argument `verbose` controls the DocTestRunner \u2019 s verbosity . The optional keyword argument `optionflags` can be used to control how the test runner compares expected output to actual output , and how it displays failures .", "question_id": 2867}
{"snippet": "doctest.DocTestRunner(checker=None, verbose=None, optionflags=0)", "intent": "A processing class used to execute and verify the interactive examples in a DocTest . The optional keyword argument `checker` specifies the OutputChecker object ( or drop-in replacement ) that should be used to compare the expected outputs to the actual outputs of doctest examples . The optional keyword argument `verbose` controls the DocTestRunner \u2019 s verbosity . The optional keyword argument `optionflags` can be used to control how the test runner compares expected output to actual output , and how it displays failures .", "question_id": 2868}
{"snippet": "doc_test_runner.report_start(out, test, example)", "intent": "Report that the `test` runner is about to process the given `example` . `out` is the output function that was passed to DocTestRunner.run ( ) .", "question_id": 2869}
{"snippet": "doc_test_runner.report_success(out, test, example, got)", "intent": "Report that the given `example` ran successfully . `out` is the output function that was passed to DocTestRunner.run ( ) . `test` is the test containing example . `got` is the actual output from the example .", "question_id": 2870}
{"snippet": "doc_test_runner.report_failure(out, test, example, got)", "intent": "Report that the given `example` failed . `out` is the output function that was passed to DocTestRunner.run ( ) . `test` is the test containing example . `got` is the actual output from the example .", "question_id": 2871}
{"snippet": "doc_test_runner.report_unexpected_exception(out, test, example, exc_info)", "intent": "Report that the given `example` raised an unexpected exception . `out` is the output function that was passed to DocTestRunner.run ( ) . `test` is the test containing example . `exc_info` is a tuple containing information about the unexpected exception ( as returned by sys.exc_info ( ) ) .", "question_id": 2872}
{"snippet": "doc_test_runner.run(test)", "intent": "Run the examples in `test` ( a DocTest object ) , and display the results using the writer function `out` .", "question_id": 2873}
{"snippet": "doc_test_runner.run(test, compileflags=None)", "intent": "Run the examples in `test` ( a DocTest object ) , and display the results using the writer function `out` . `compileflags` gives the set of flags that should be used by the Python compiler when running the examples .", "question_id": 2874}
{"snippet": "doc_test_runner.run(test, out=None)", "intent": "Run the examples in `test` ( a DocTest object ) , and display the results using the writer function `out` .", "question_id": 2875}
{"snippet": "doc_test_runner.run(test, clear_globs=True)", "intent": "Run the examples in `test` ( a DocTest object ) , and display the results using the writer function `out` . If `clear_globs` is true ( the default ) , then this namespace will be cleared after the test runs , to help with garbage collection .", "question_id": 2876}
{"snippet": "doc_test_runner.run(test, compileflags=None, out=None)", "intent": "Run the examples in `test` ( a DocTest object ) , and display the results using the writer function `out` . `compileflags` gives the set of flags that should be used by the Python compiler when running the examples .", "question_id": 2877}
{"snippet": "doc_test_runner.run(test, compileflags=None, clear_globs=True)", "intent": "Run the examples in `test` ( a DocTest object ) , and display the results using the writer function `out` . `compileflags` gives the set of flags that should be used by the Python compiler when running the examples . If `clear_globs` is true ( the default ) , then this namespace will be cleared after the test runs , to help with garbage collection .", "question_id": 2878}
{"snippet": "doc_test_runner.run(test, out=None, clear_globs=True)", "intent": "Run the examples in `test` ( a DocTest object ) , and display the results using the writer function `out` . If `clear_globs` is true ( the default ) , then this namespace will be cleared after the test runs , to help with garbage collection .", "question_id": 2879}
{"snippet": "doc_test_runner.run(test, compileflags=None, out=None, clear_globs=True)", "intent": "Run the examples in `test` ( a DocTest object ) , and display the results using the writer function `out` . `compileflags` gives the set of flags that should be used by the Python compiler when running the examples . If `clear_globs` is true ( the default ) , then this namespace will be cleared after the test runs , to help with garbage collection .", "question_id": 2880}
{"snippet": "doc_test_runner.summarize()", "intent": "Print a summary of all the test cases that have been run by this DocTestRunner , and return a named tuple TestResults ( failed , attempted ) .", "question_id": 2881}
{"snippet": "doc_test_runner.summarize(verbose=None)", "intent": "Print a summary of all the test cases that have been run by this DocTestRunner , and return a named tuple TestResults ( failed , attempted ) . The optional `verbose` argument controls how detailed the summary is .", "question_id": 2882}
{"snippet": "doctest.OutputChecker", "intent": "A class used to check the whether the actual output from a doctest example matches the expected output.", "question_id": 2883}
{"snippet": "output_checker.check_output(want, got, optionflags)", "intent": "Return True iff the actual output from an example ( `got` ) matches the expected output ( `want` ) . With arguments `optionflags`.", "question_id": 2884}
{"snippet": "output_checker.output_difference(example, got, optionflags)", "intent": "Return a string describing the differences between the expected output for a given `example` ( example ) and the actual output ( `got` ) . `optionflags` is the set of option flags used to compare want and got .", "question_id": 2885}
{"snippet": "doctest.script_from_examples(s)", "intent": "Convert text with examples to a script . Argument `s` is a string containing doctest examples .", "question_id": 2886}
{"snippet": "doctest.testsource(module, name)", "intent": "Convert the doctest for an object to a script . Argument `module` is a module object , or dotted `name` of a module , containing the object whose doctests are of interest .", "question_id": 2887}
{"snippet": "doctest.debug(module, name)", "intent": "Debug the doctests for an object . The `module` and `name` arguments are the same as for function testsource ( ) above .", "question_id": 2888}
{"snippet": "doctest.debug(module, name, pm=False)", "intent": "Debug the doctests for an object . The `module` and `name` arguments are the same as for function testsource ( ) above . Optional argument `pm` controls whether post-mortem debugging is used .", "question_id": 2889}
{"snippet": "doctest.debug_src(src)", "intent": "Debug the doctests in a string . This is like function debug ( ) above , except that a string containing doctest examples is specified directly , via the `src` argument .", "question_id": 2890}
{"snippet": "doctest.debug_src(src, pm=False)", "intent": "Debug the doctests in a string . This is like function debug ( ) above , except that a string containing doctest examples is specified directly , via the `src` argument . Optional argument `pm` has the same meaning as in function debug ( ) above .", "question_id": 2891}
{"snippet": "doctest.debug_src(src, globs=None)", "intent": "Debug the doctests in a string . This is like function debug ( ) above , except that a string containing doctest examples is specified directly , via the `src` argument . Optional argument `globs` gives a dictionary to use as both local and global execution context .", "question_id": 2892}
{"snippet": "doctest.debug_src(src, pm=False, globs=None)", "intent": "Debug the doctests in a string . This is like function debug ( ) above , except that a string containing doctest examples is specified directly , via the `src` argument . Optional argument `pm` has the same meaning as in function debug ( ) above . Optional argument `globs` gives a dictionary to use as both local and global execution context .", "question_id": 2893}
{"snippet": "doctest.DebugRunner()", "intent": "A subclass of DocTestRunner that raises an exception as soon as a failure is encountered .", "question_id": 2894}
{"snippet": "doctest.DebugRunner(checker=None)", "intent": "A subclass of DocTestRunner that raises an exception as soon as a failure is encountered . With arguments `checker`.", "question_id": 2895}
{"snippet": "doctest.DebugRunner(verbose=None)", "intent": "A subclass of DocTestRunner that raises an exception as soon as a failure is encountered . With arguments `verbose`.", "question_id": 2896}
{"snippet": "doctest.DebugRunner(optionflags=0)", "intent": "A subclass of DocTestRunner that raises an exception as soon as a failure is encountered . With arguments `optionflags`.", "question_id": 2897}
{"snippet": "doctest.DebugRunner(checker=None, verbose=None)", "intent": "A subclass of DocTestRunner that raises an exception as soon as a failure is encountered . With arguments `checker`, `verbose`.", "question_id": 2898}
{"snippet": "doctest.DebugRunner(checker=None, optionflags=0)", "intent": "A subclass of DocTestRunner that raises an exception as soon as a failure is encountered . With arguments `checker`, `optionflags`.", "question_id": 2899}
{"snippet": "doctest.DebugRunner(verbose=None, optionflags=0)", "intent": "A subclass of DocTestRunner that raises an exception as soon as a failure is encountered . With arguments `verbose`, `optionflags`.", "question_id": 2900}
{"snippet": "doctest.DebugRunner(checker=None, verbose=None, optionflags=0)", "intent": "A subclass of DocTestRunner that raises an exception as soon as a failure is encountered . With arguments `checker`, `verbose`, `optionflags`.", "question_id": 2901}
{"snippet": "doctest.DocTestFailure(test, example, got)", "intent": "An exception raised by DocTestRunner to signal that a doctest `example` \u2019 s actual output did not match its expected output . With arguments `test`, `got`.", "question_id": 2902}
{"snippet": "DocTestFailure.test", "intent": "The DocTest object that was being run when the example failed.", "question_id": 2903}
{"snippet": "DocTestFailure.example", "intent": "The Example that failed.", "question_id": 2904}
{"snippet": "DocTestFailure.got", "intent": "The example\u2019s actual output.", "question_id": 2905}
{"snippet": "doctest.UnexpectedException(test, example, exc_info)", "intent": "An exception raised by DocTestRunner to signal that a doctest `example` raised an unexpected exception . With arguments `test`, `exc_info`.", "question_id": 2906}
{"snippet": "UnexpectedException.test", "intent": "The DocTest object that was being run when the example failed.", "question_id": 2907}
{"snippet": "UnexpectedException.example", "intent": "The Example that failed.", "question_id": 2908}
{"snippet": "UnexpectedException.exc_info", "intent": "A tuple containing information about the unexpected exception, as returned by sys.exc_info().", "question_id": 2909}
{"snippet": "email.charset.Charset()", "intent": "Map character sets to their email properties .", "question_id": 2910}
{"snippet": "email.charset.Charset(input_charset=DEFAULT_CHARSET)", "intent": "Map character sets to their email properties . Optional `input_charset` is as described below ; it is always coerced to lower case .", "question_id": 2911}
{"snippet": "charset.input_charset", "intent": "The initial character set specified.", "question_id": 2912}
{"snippet": "charset.header_encoding", "intent": "If the character set must be encoded before it can be used in an email header, this attribute will be set to Charset.QP (for quoted-printable), Charset.BASE64 (for base64 encoding), or Charset.SHORTEST for the shortest of QP or BASE64 encoding.", "question_id": 2913}
{"snippet": "charset.body_encoding", "intent": "Same as header_encoding, but describes the encoding for the mail message\u2019s body, which indeed may be different than the header encoding.", "question_id": 2914}
{"snippet": "charset.output_charset", "intent": "Some character sets must be converted before they can be used in email headers or bodies.", "question_id": 2915}
{"snippet": "charset.input_codec", "intent": "The name of the Python codec used to convert the input_charset to Unicode.", "question_id": 2916}
{"snippet": "charset.output_codec", "intent": "The name of the Python codec used to convert Unicode to the output_charset.", "question_id": 2917}
{"snippet": "charset.get_body_encoding()", "intent": "Return the content transfer encoding used for body encoding .", "question_id": 2918}
{"snippet": "charset.get_output_charset()", "intent": "Return the output character set .", "question_id": 2919}
{"snippet": "charset.header_encode(string)", "intent": "Header-encode the `string` string .", "question_id": 2920}
{"snippet": "charset.header_encode_lines(string, maxlengths)", "intent": "Header-encode a `string` by converting it first to bytes . This is similar to header_encode ( ) except that the string is fit into maximum line lengths as given by the argument `maxlengths` , which must be an iterator : each element returned from this iterator will provide the next maximum line length .", "question_id": 2921}
{"snippet": "charset.body_encode(string)", "intent": "Body-encode the `string` string .", "question_id": 2922}
{"snippet": "charset.__str__()", "intent": "Returns input_charset as a string coerced to lower case .", "question_id": 2923}
{"snippet": "charset.__eq__(other)", "intent": "This method allows you to compare two Charset instances for equality . With arguments `other`.", "question_id": 2924}
{"snippet": "charset.__ne__(other)", "intent": "This method allows you to compare two Charset instances for inequality . With arguments `other`.", "question_id": 2925}
{"snippet": "email.charset.add_charset(charset)", "intent": "Add character properties to the global registry . `charset` is the input character set , and must be the canonical name of a character set .", "question_id": 2926}
{"snippet": "email.charset.add_charset(charset, header_enc=None)", "intent": "Add character properties to the global registry . `charset` is the input character set , and must be the canonical name of a character set . Optional `header_enc` and `body_enc` is either Charset.QP for quoted-printable , Charset.BASE64 for base64 encoding , Charset.SHORTEST for the shortest of quoted-printable or base64 encoding , or None for no encoding .", "question_id": 2927}
{"snippet": "email.charset.add_charset(charset, body_enc=None)", "intent": "Add character properties to the global registry . `charset` is the input character set , and must be the canonical name of a character set . Optional `header_enc` and `body_enc` is either Charset.QP for quoted-printable , Charset.BASE64 for base64 encoding , Charset.SHORTEST for the shortest of quoted-printable or base64 encoding , or None for no encoding .", "question_id": 2928}
{"snippet": "email.charset.add_charset(charset, output_charset=None)", "intent": "Add character properties to the global registry . `charset` is the input character set , and must be the canonical name of a character set . Optional `output_charset` is the character set that the output should be in .", "question_id": 2929}
{"snippet": "email.charset.add_charset(charset, header_enc=None, body_enc=None)", "intent": "Add character properties to the global registry . `charset` is the input character set , and must be the canonical name of a character set . Optional `header_enc` and `body_enc` is either Charset.QP for quoted-printable , Charset.BASE64 for base64 encoding , Charset.SHORTEST for the shortest of quoted-printable or base64 encoding , or None for no encoding .", "question_id": 2930}
{"snippet": "email.charset.add_charset(charset, header_enc=None, output_charset=None)", "intent": "Add character properties to the global registry . `charset` is the input character set , and must be the canonical name of a character set . Optional `header_enc` and `body_enc` is either Charset.QP for quoted-printable , Charset.BASE64 for base64 encoding , Charset.SHORTEST for the shortest of quoted-printable or base64 encoding , or None for no encoding . Optional `output_charset` is the character set that the output should be in .", "question_id": 2931}
{"snippet": "email.charset.add_charset(charset, body_enc=None, output_charset=None)", "intent": "Add character properties to the global registry . `charset` is the input character set , and must be the canonical name of a character set . Optional `header_enc` and `body_enc` is either Charset.QP for quoted-printable , Charset.BASE64 for base64 encoding , Charset.SHORTEST for the shortest of quoted-printable or base64 encoding , or None for no encoding . Optional `output_charset` is the character set that the output should be in .", "question_id": 2932}
{"snippet": "email.charset.add_charset(charset, header_enc=None, body_enc=None, output_charset=None)", "intent": "Add character properties to the global registry . `charset` is the input character set , and must be the canonical name of a character set . Optional `header_enc` and `body_enc` is either Charset.QP for quoted-printable , Charset.BASE64 for base64 encoding , Charset.SHORTEST for the shortest of quoted-printable or base64 encoding , or None for no encoding . Optional `output_charset` is the character set that the output should be in .", "question_id": 2933}
{"snippet": "email.charset.add_alias(alias, canonical)", "intent": "Add a character set `alias` . `canonical` is the character set \u2019 s canonical name , e.g .", "question_id": 2934}
{"snippet": "email.charset.add_codec(charset, codecname)", "intent": "Add a codec that map characters in the given character set to and from Unicode . `charset` is the canonical name of a character set . `codecname` is the name of a Python codec , as appropriate for the second argument to the str \u2019 s encode ( ) method .", "question_id": 2935}
{"snippet": "email.message.Message()", "intent": "If `policy` is specified ( it must be an instance of a policy class ) use the rules it specifies to update and serialize the representation of the message .", "question_id": 2936}
{"snippet": "email.message.Message(policy=compat32)", "intent": "If `policy` is specified ( it must be an instance of a policy class ) use the rules it specifies to update and serialize the representation of the message .", "question_id": 2937}
{"snippet": "message.as_string()", "intent": "Return the entire message flattened as a string .", "question_id": 2938}
{"snippet": "message.as_string(unixfrom=False)", "intent": "Return the entire message flattened as a string . When optional `unixfrom` is true , the envelope header is included in the returned string .", "question_id": 2939}
{"snippet": "message.as_string(maxheaderlen=0)", "intent": "Return the entire message flattened as a string . For backward compatibility reasons , `maxheaderlen` defaults to 0 , so if you want a different value you must override it explicitly ( the value specified for max_line_length in the `policy` will be ignored by this method ) .", "question_id": 2940}
{"snippet": "message.as_string(policy=None)", "intent": "Return the entire message flattened as a string . For backward compatibility reasons , `maxheaderlen` defaults to 0 , so if you want a different value you must override it explicitly ( the value specified for max_line_length in the `policy` will be ignored by this method ) .", "question_id": 2941}
{"snippet": "message.as_string(unixfrom=False, maxheaderlen=0)", "intent": "Return the entire message flattened as a string . When optional `unixfrom` is true , the envelope header is included in the returned string . For backward compatibility reasons , `maxheaderlen` defaults to 0 , so if you want a different value you must override it explicitly ( the value specified for max_line_length in the `policy` will be ignored by this method ) .", "question_id": 2942}
{"snippet": "message.as_string(unixfrom=False, policy=None)", "intent": "Return the entire message flattened as a string . When optional `unixfrom` is true , the envelope header is included in the returned string . For backward compatibility reasons , `maxheaderlen` defaults to 0 , so if you want a different value you must override it explicitly ( the value specified for max_line_length in the `policy` will be ignored by this method ) .", "question_id": 2943}
{"snippet": "message.as_string(maxheaderlen=0, policy=None)", "intent": "Return the entire message flattened as a string . For backward compatibility reasons , `maxheaderlen` defaults to 0 , so if you want a different value you must override it explicitly ( the value specified for max_line_length in the `policy` will be ignored by this method ) .", "question_id": 2944}
{"snippet": "message.as_string(unixfrom=False, maxheaderlen=0, policy=None)", "intent": "Return the entire message flattened as a string . When optional `unixfrom` is true , the envelope header is included in the returned string . For backward compatibility reasons , `maxheaderlen` defaults to 0 , so if you want a different value you must override it explicitly ( the value specified for max_line_length in the `policy` will be ignored by this method ) .", "question_id": 2945}
{"snippet": "message.__str__()", "intent": "Equivalent to as_string ( ) .", "question_id": 2946}
{"snippet": "message.as_bytes()", "intent": "Return the entire message flattened as a bytes object .", "question_id": 2947}
{"snippet": "message.as_bytes(unixfrom=False)", "intent": "Return the entire message flattened as a bytes object . When optional `unixfrom` is true , the envelope header is included in the returned string .", "question_id": 2948}
{"snippet": "message.as_bytes(policy=None)", "intent": "Return the entire message flattened as a bytes object . The `policy` argument may be used to override the default policy obtained from the message instance .", "question_id": 2949}
{"snippet": "message.as_bytes(unixfrom=False, policy=None)", "intent": "Return the entire message flattened as a bytes object . When optional `unixfrom` is true , the envelope header is included in the returned string . The `policy` argument may be used to override the default policy obtained from the message instance .", "question_id": 2950}
{"snippet": "message.__bytes__()", "intent": "Equivalent to as_bytes ( ) .", "question_id": 2951}
{"snippet": "message.is_multipart()", "intent": "Return True if the message \u2019 s payload is a list of sub-Message objects , otherwise return False .", "question_id": 2952}
{"snippet": "message.set_unixfrom(unixfrom)", "intent": "Set the message \u2019 s envelope header to `unixfrom` , which should be a string .", "question_id": 2953}
{"snippet": "message.get_unixfrom()", "intent": "Return the message \u2019 s envelope header .", "question_id": 2954}
{"snippet": "message.attach(payload)", "intent": "Add the given `payload` to the current payload , which must be None or a list of Message objects before the call .", "question_id": 2955}
{"snippet": "message.get_payload()", "intent": "Return the current payload , which will be a list of Message objects when is_multipart ( ) is True , or a string when is_multipart ( ) is False .", "question_id": 2956}
{"snippet": "message.get_payload(i=None)", "intent": "Return the current payload , which will be a list of Message objects when is_multipart ( ) is True , or a string when is_multipart ( ) is False . With optional argument `i` , get_payload ( ) will return the i-th element of the payload , counting from zero , if is_multipart ( ) is True .", "question_id": 2957}
{"snippet": "message.get_payload(decode=False)", "intent": "Return the current payload , which will be a list of Message objects when is_multipart ( ) is True , or a string when is_multipart ( ) is False . Optional `decode` is a flag indicating whether the payload should be decoded or not , according to the Content-Transfer-Encoding header .", "question_id": 2958}
{"snippet": "message.get_payload(i=None, decode=False)", "intent": "Return the current payload , which will be a list of Message objects when is_multipart ( ) is True , or a string when is_multipart ( ) is False . With optional argument `i` , get_payload ( ) will return the i-th element of the payload , counting from zero , if is_multipart ( ) is True . Optional `decode` is a flag indicating whether the payload should be decoded or not , according to the Content-Transfer-Encoding header .", "question_id": 2959}
{"snippet": "message.set_payload(payload)", "intent": "Set the entire message object \u2019 s `payload` to payload .", "question_id": 2960}
{"snippet": "message.set_payload(payload, charset=None)", "intent": "Set the entire message object \u2019 s `payload` to payload . Optional `charset` sets the message \u2019 s default character set ; see set_charset ( ) for details .", "question_id": 2961}
{"snippet": "message.set_charset(charset)", "intent": "Set the character set of the payload to `charset` , which can either be a Charset instance ( see email.charset ) , a string naming a character set , or None .", "question_id": 2962}
{"snippet": "message.get_charset()", "intent": "Return the Charset instance associated with the message \u2019 s payload .", "question_id": 2963}
{"snippet": "message.__len__()", "intent": "Return the total number of headers , including duplicates .", "question_id": 2964}
{"snippet": "message.__contains__(name)", "intent": "Return true if the message object has a field named `name` .", "question_id": 2965}
{"snippet": "message.__getitem__(name)", "intent": "Return the value of the named header field . `name` should not include the colon field separator .", "question_id": 2966}
{"snippet": "message.__setitem__(name, val)", "intent": "Add a header to the message with field `name` name and value `val` .", "question_id": 2967}
{"snippet": "message.__delitem__(name)", "intent": "Delete all occurrences of the field with `name` name from the message \u2019 s headers .", "question_id": 2968}
{"snippet": "message.keys()", "intent": "Return a list of all the message \u2019 s header field names .", "question_id": 2969}
{"snippet": "message.values()", "intent": "Return a list of all the message \u2019 s field values .", "question_id": 2970}
{"snippet": "message.items()", "intent": "Return a list of 2-tuples containing all the message \u2019 s field headers and values .", "question_id": 2971}
{"snippet": "message.get(name)", "intent": "Return the value of the named header field . With arguments `name`.", "question_id": 2972}
{"snippet": "message.get(name, failobj=None)", "intent": "Return the value of the named header field . This is identical to __getitem__ ( ) except that optional `failobj` is returned if the named header is missing ( defaults to None ) . With arguments `name`.", "question_id": 2973}
{"snippet": "message.get_all(name)", "intent": "Return a list of all the values for the field named `name` .", "question_id": 2974}
{"snippet": "message.get_all(name, failobj=None)", "intent": "Return a list of all the values for the field named `name` . If there are no such named headers in the message , `failobj` is returned ( defaults to None ) .", "question_id": 2975}
{"snippet": "message.add_header(_name, _value, **_params)", "intent": "Extended header setting . `_name` is the header field to add and `_value` is the primary value for the header . With arguments `**_params`.", "question_id": 2976}
{"snippet": "message.replace_header(_name, _value)", "intent": "Replace a header . Replace the first header found in the message that matches `_name` , retaining header order and field name case . With arguments `_value`.", "question_id": 2977}
{"snippet": "message.get_content_type()", "intent": "Return the message \u2019 s content type .", "question_id": 2978}
{"snippet": "message.get_content_maintype()", "intent": "Return the message \u2019 s main content type .", "question_id": 2979}
{"snippet": "message.get_content_subtype()", "intent": "Return the message \u2019 s sub-content type .", "question_id": 2980}
{"snippet": "message.get_default_type()", "intent": "Return the default content type .", "question_id": 2981}
{"snippet": "message.set_default_type(ctype)", "intent": "Set the default content type . `ctype` should either be text/plain or message/rfc822 , although this is not enforced .", "question_id": 2982}
{"snippet": "message.get_params()", "intent": "Return the message \u2019 s Content-Type parameters , as a list .", "question_id": 2983}
{"snippet": "message.get_params(failobj=None)", "intent": "Return the message \u2019 s Content-Type parameters , as a list . Optional `failobj` is the object to return if there is no Content-Type `header` .", "question_id": 2984}
{"snippet": "message.get_params(header='content-type')", "intent": "Return the message \u2019 s Content-Type parameters , as a list . Optional `failobj` is the object to return if there is no Content-Type `header` .", "question_id": 2985}
{"snippet": "message.get_params(unquote=True)", "intent": "Return the message \u2019 s Content-Type parameters , as a list . If there is no '= ' sign in the parameter the value is the empty string , otherwise the value is as described in get_param ( ) and is unquoted if optional `unquote` is True ( the default ) .", "question_id": 2986}
{"snippet": "message.get_params(failobj=None, header='content-type')", "intent": "Return the message \u2019 s Content-Type parameters , as a list . Optional `failobj` is the object to return if there is no Content-Type `header` .", "question_id": 2987}
{"snippet": "message.get_params(failobj=None, unquote=True)", "intent": "Return the message \u2019 s Content-Type parameters , as a list . Optional `failobj` is the object to return if there is no Content-Type `header` . If there is no '= ' sign in the parameter the value is the empty string , otherwise the value is as described in get_param ( ) and is unquoted if optional `unquote` is True ( the default ) .", "question_id": 2988}
{"snippet": "message.get_params(header='content-type', unquote=True)", "intent": "Return the message \u2019 s Content-Type parameters , as a list . Optional `failobj` is the object to return if there is no Content-Type `header` . If there is no '= ' sign in the parameter the value is the empty string , otherwise the value is as described in get_param ( ) and is unquoted if optional `unquote` is True ( the default ) .", "question_id": 2989}
{"snippet": "message.get_params(failobj=None, header='content-type', unquote=True)", "intent": "Return the message \u2019 s Content-Type parameters , as a list . Optional `failobj` is the object to return if there is no Content-Type `header` . If there is no '= ' sign in the parameter the value is the empty string , otherwise the value is as described in get_param ( ) and is unquoted if optional `unquote` is True ( the default ) .", "question_id": 2990}
{"snippet": "message.get_param(param)", "intent": "Return the value of the Content-Type `header` \u2019 s parameter `param` as a string .", "question_id": 2991}
{"snippet": "message.get_param(param, failobj=None)", "intent": "Return the value of the Content-Type `header` \u2019 s parameter `param` as a string . If the message has no Content-Type header or if there is no such parameter , then `failobj` is returned ( defaults to None ) .", "question_id": 2992}
{"snippet": "message.get_param(param, header='content-type')", "intent": "Return the value of the Content-Type `header` \u2019 s parameter `param` as a string .", "question_id": 2993}
{"snippet": "message.get_param(param, unquote=True)", "intent": "Return the value of the Content-Type `header` \u2019 s parameter `param` as a string . In any case , the parameter value ( either the returned string , or the VALUE item in the 3-tuple ) is always unquoted , unless `unquote` is set to False .", "question_id": 2994}
{"snippet": "message.get_param(param, failobj=None, header='content-type')", "intent": "Return the value of the Content-Type `header` \u2019 s parameter `param` as a string . If the message has no Content-Type header or if there is no such parameter , then `failobj` is returned ( defaults to None ) .", "question_id": 2995}
{"snippet": "message.get_param(param, failobj=None, unquote=True)", "intent": "Return the value of the Content-Type `header` \u2019 s parameter `param` as a string . If the message has no Content-Type header or if there is no such parameter , then `failobj` is returned ( defaults to None ) . In any case , the parameter value ( either the returned string , or the VALUE item in the 3-tuple ) is always unquoted , unless `unquote` is set to False .", "question_id": 2996}
{"snippet": "message.get_param(param, header='content-type', unquote=True)", "intent": "Return the value of the Content-Type `header` \u2019 s parameter `param` as a string . In any case , the parameter value ( either the returned string , or the VALUE item in the 3-tuple ) is always unquoted , unless `unquote` is set to False .", "question_id": 2997}
{"snippet": "message.get_param(param, failobj=None, header='content-type', unquote=True)", "intent": "Return the value of the Content-Type `header` \u2019 s parameter `param` as a string . If the message has no Content-Type header or if there is no such parameter , then `failobj` is returned ( defaults to None ) . In any case , the parameter value ( either the returned string , or the VALUE item in the 3-tuple ) is always unquoted , unless `unquote` is set to False .", "question_id": 2998}
{"snippet": "message.set_param(param, value)", "intent": "Set a parameter in the Content-Type `header` . If the parameter already exists in the header , its `value` will be replaced with value . With arguments `param`.", "question_id": 2999}
{"snippet": "message.set_param(param, value, header='Content-Type')", "intent": "Set a parameter in the Content-Type `header` . If the parameter already exists in the header , its `value` will be replaced with value . With arguments `param`.", "question_id": 3000}
{"snippet": "message.set_param(param, value, requote=True)", "intent": "Set a parameter in the Content-Type `header` . If the parameter already exists in the header , its `value` will be replaced with value . Optional header specifies an alternative header to Content-Type , and all parameters will be quoted as necessary unless optional `requote` is False ( the default is True ) . With arguments `param`.", "question_id": 3001}
{"snippet": "message.set_param(param, value, charset=None)", "intent": "Set a parameter in the Content-Type `header` . If the parameter already exists in the header , its `value` will be replaced with value . If optional `charset` is specified , the parameter will be encoded according to RFC 2231 . With arguments `param`.", "question_id": 3002}
{"snippet": "message.set_param(param, value, language='')", "intent": "Set a parameter in the Content-Type `header` . If the parameter already exists in the header , its `value` will be replaced with value . Optional `language` specifies the RFC 2231 language , defaulting to the empty string . With arguments `param`.", "question_id": 3003}
{"snippet": "message.set_param(param, value, replace=False)", "intent": "Set a parameter in the Content-Type `header` . If the parameter already exists in the header , its `value` will be replaced with value . If `replace` is False ( the default ) the header is moved to the end of the list of headers . With arguments `param`.", "question_id": 3004}
{"snippet": "message.set_param(param, value, header='Content-Type', requote=True)", "intent": "Set a parameter in the Content-Type `header` . If the parameter already exists in the header , its `value` will be replaced with value . Optional header specifies an alternative header to Content-Type , and all parameters will be quoted as necessary unless optional `requote` is False ( the default is True ) . With arguments `param`.", "question_id": 3005}
{"snippet": "message.set_param(param, value, header='Content-Type', charset=None)", "intent": "Set a parameter in the Content-Type `header` . If the parameter already exists in the header , its `value` will be replaced with value . If optional `charset` is specified , the parameter will be encoded according to RFC 2231 . With arguments `param`.", "question_id": 3006}
{"snippet": "message.set_param(param, value, header='Content-Type', language='')", "intent": "Set a parameter in the Content-Type `header` . If the parameter already exists in the header , its `value` will be replaced with value . Optional `language` specifies the RFC 2231 language , defaulting to the empty string . With arguments `param`.", "question_id": 3007}
{"snippet": "message.set_param(param, value, header='Content-Type', replace=False)", "intent": "Set a parameter in the Content-Type `header` . If the parameter already exists in the header , its `value` will be replaced with value . If `replace` is False ( the default ) the header is moved to the end of the list of headers . With arguments `param`.", "question_id": 3008}
{"snippet": "message.del_param(param)", "intent": "Remove the given parameter completely from the Content-Type `header` . With arguments `param`.", "question_id": 3009}
{"snippet": "message.del_param(param, header='content-type')", "intent": "Remove the given parameter completely from the Content-Type `header` . With arguments `param`.", "question_id": 3010}
{"snippet": "message.del_param(param, requote=True)", "intent": "Remove the given parameter completely from the Content-Type `header` . All values will be quoted as necessary unless `requote` is False ( the default is True ) . With arguments `param`.", "question_id": 3011}
{"snippet": "message.del_param(param, header='content-type', requote=True)", "intent": "Remove the given parameter completely from the Content-Type `header` . All values will be quoted as necessary unless `requote` is False ( the default is True ) . With arguments `param`.", "question_id": 3012}
{"snippet": "message.set_type(type)", "intent": "Set the main `type` and subtype for the Content-Type `header` .", "question_id": 3013}
{"snippet": "message.set_type(type, header='Content-Type')", "intent": "Set the main `type` and subtype for the Content-Type `header` .", "question_id": 3014}
{"snippet": "message.set_type(type, requote=True)", "intent": "Set the main `type` and subtype for the Content-Type `header` . If `requote` is False , this leaves the existing header \u2019 s quoting as is , otherwise the parameters will be quoted ( the default ) .", "question_id": 3015}
{"snippet": "message.set_type(type, header='Content-Type', requote=True)", "intent": "Set the main `type` and subtype for the Content-Type `header` . If `requote` is False , this leaves the existing header \u2019 s quoting as is , otherwise the parameters will be quoted ( the default ) .", "question_id": 3016}
{"snippet": "message.get_filename()", "intent": "Return the value of the filename parameter of the Content-Disposition header of the message .", "question_id": 3017}
{"snippet": "message.get_filename(failobj=None)", "intent": "Return the value of the filename parameter of the Content-Disposition header of the message . If neither is found , or the header is missing , then `failobj` is returned .", "question_id": 3018}
{"snippet": "message.get_boundary()", "intent": "Return the value of the boundary parameter of the Content-Type header of the message , or `failobj` if either the header is missing , or has no boundary parameter .", "question_id": 3019}
{"snippet": "message.get_boundary(failobj=None)", "intent": "Return the value of the boundary parameter of the Content-Type header of the message , or `failobj` if either the header is missing , or has no boundary parameter .", "question_id": 3020}
{"snippet": "message.set_boundary(boundary)", "intent": "Set the `boundary` parameter of the Content-Type header to boundary .", "question_id": 3021}
{"snippet": "message.get_content_charset()", "intent": "Return the charset parameter of the Content-Type header , coerced to lower case .", "question_id": 3022}
{"snippet": "message.get_content_charset(failobj=None)", "intent": "Return the charset parameter of the Content-Type header , coerced to lower case . If there is no Content-Type header , or if that header has no charset parameter , `failobj` is returned .", "question_id": 3023}
{"snippet": "message.get_charsets()", "intent": "Return a list containing the character set names in the message .", "question_id": 3024}
{"snippet": "message.get_charsets(failobj=None)", "intent": "Return a list containing the character set names in the message . However , if the subpart has no Content-Type header , no charset parameter , or is not of the text main MIME type , then that item in the returned list will be `failobj` .", "question_id": 3025}
{"snippet": "message.get_content_disposition()", "intent": "Return the lowercased value ( without parameters ) of the message \u2019 s Content-Disposition header if it has one , or None .", "question_id": 3026}
{"snippet": "message.walk()", "intent": "The walk ( ) method is an all-purpose generator which can be used to iterate over all the parts and subparts of a message object tree , in depth-first traversal order .", "question_id": 3027}
{"snippet": "message.preamble", "intent": "The format of a MIME document allows for some text between the blank line following the headers, and the first multipart boundary string.", "question_id": 3028}
{"snippet": "message.epilogue", "intent": "The epilogue attribute acts the same way as the preamble attribute, except that it contains text that appears between the last boundary and the end of the message.", "question_id": 3029}
{"snippet": "message.defects", "intent": "The defects attribute contains a list of all the problems found when parsing this message.", "question_id": 3030}
{"snippet": "email.contentmanager.ContentManager", "intent": "Base class for content managers.", "question_id": 3031}
{"snippet": "content_manager.get_content(msg, *args, **kw)", "intent": "Look up a handler function based on the mimetype of `msg` ( see next paragraph ) , call it , passing through all arguments , and return the result of the call . With arguments `*args`, `**kw`.", "question_id": 3032}
{"snippet": "content_manager.set_content(msg, obj, *args, **kw)", "intent": "If the maintype is multipart , raise a TypeError ; otherwise look up a handler function based on the type of `obj` ( see next paragraph ) , call clear_content ( ) on the `msg` , and call the handler function , passing through all arguments . With arguments `*args`, `**kw`.", "question_id": 3033}
{"snippet": "content_manager.add_get_handler(key, handler)", "intent": "Record the function `handler` as the handler for `key` .", "question_id": 3034}
{"snippet": "content_manager.add_set_handler(typekey, handler)", "intent": "Record `handler` as the function to call when an object of a type matching `typekey` is passed to set_content ( ) .", "question_id": 3035}
{"snippet": "email.contentmanager.raw_data_manager", "intent": "This content manager provides only a minimum interface beyond that provided by Message itself:  it deals only with text, raw byte strings, and Message objects.", "question_id": 3036}
{"snippet": "email.contentmanager.get_content(msg)", "intent": "Return the payload of the part as either a string ( for text parts ) , an EmailMessage object ( for message/rfc822 parts ) , or a bytes object ( for all other non-multipart types ) . With arguments `msg`.", "question_id": 3037}
{"snippet": "email.contentmanager.get_content(msg, errors='replace')", "intent": "Return the payload of the part as either a string ( for text parts ) , an EmailMessage object ( for message/rfc822 parts ) , or a bytes object ( for all other non-multipart types ) . If the part is a text part and `errors` is specified , use it as the error handler when decoding the payload to unicode . With arguments `msg`.", "question_id": 3038}
{"snippet": "email.contentmanager.set_content(msg, <'str'>)", "intent": "Add `headers` and payload to `msg` : With arguments `<'str'>`.", "question_id": 3039}
{"snippet": "email.contentmanager.set_content(msg, <'str'>, subtype=\"plain\")", "intent": "Add `headers` and payload to `msg` : With arguments `<'str'>`, `subtype`.", "question_id": 3040}
{"snippet": "email.contentmanager.set_content(msg, <'str'>, charset='utf-8'                     cte=None)", "intent": "Add `headers` and payload to `msg` : If `charset` is provided ( which is valid only for str ) , encode the string to bytes using the specified character set . With arguments `<'str'>`.", "question_id": 3041}
{"snippet": "email.contentmanager.set_content(msg, <'str'>, disposition=None)", "intent": "Add `headers` and payload to `msg` : If `disposition` is set , use it as the value of the Content-Disposition header . With arguments `<'str'>`.", "question_id": 3042}
{"snippet": "email.contentmanager.set_content(msg, <'str'>, filename=None)", "intent": "Add `headers` and payload to `msg` : If not specified , and `filename` is specified , add the header with the value attachment . With arguments `<'str'>`.", "question_id": 3043}
{"snippet": "email.contentmanager.set_content(msg, <'str'>, cid=None)", "intent": "Add `headers` and payload to `msg` : If `cid` is specified , add a Content-ID header with cid as its value . With arguments `<'str'>`.", "question_id": 3044}
{"snippet": "email.contentmanager.set_content(msg, <'str'>, params=None)", "intent": "Add `headers` and payload to `msg` : If `params` is specified , iterate its items method and use the resulting ( key , value ) pairs to set additional parameters on the Content-Type header . With arguments `<'str'>`.", "question_id": 3045}
{"snippet": "email.contentmanager.set_content(msg, <'str'>, headers=None)", "intent": "Add `headers` and payload to `msg` : With arguments `<'str'>`.", "question_id": 3046}
{"snippet": "email.contentmanager.set_content(msg, <'str'>, subtype=\"plain\", charset='utf-8'                     cte=None)", "intent": "Add `headers` and payload to `msg` : If `charset` is provided ( which is valid only for str ) , encode the string to bytes using the specified character set . With arguments `<'str'>`, `subtype`.", "question_id": 3047}
{"snippet": "email.contentmanager.set_content(msg, <'str'>, subtype=\"plain\", disposition=None)", "intent": "Add `headers` and payload to `msg` : If `disposition` is set , use it as the value of the Content-Disposition header . With arguments `<'str'>`, `subtype`.", "question_id": 3048}
{"snippet": "email.contentmanager.set_content(msg, <'bytes'>, maintype, subtype)", "intent": "Add `headers` and payload to `msg` : With arguments `<'bytes'>`, `maintype`, `subtype`.", "question_id": 3049}
{"snippet": "email.contentmanager.set_content(msg, <'bytes'>, maintype, subtype, cte=\"base64\")", "intent": "Add `headers` and payload to `msg` : If `cte` is set , encode the payload using the specified content transfer encoding , and set the Content-Transfer-Encoding header to that value . With arguments `<'bytes'>`, `maintype`, `subtype`.", "question_id": 3050}
{"snippet": "email.contentmanager.set_content(msg, <'bytes'>, maintype, subtype, disposition=None)", "intent": "Add `headers` and payload to `msg` : If `disposition` is set , use it as the value of the Content-Disposition header . With arguments `<'bytes'>`, `maintype`, `subtype`.", "question_id": 3051}
{"snippet": "email.contentmanager.set_content(msg, <'bytes'>, maintype, subtype, filename=None)", "intent": "Add `headers` and payload to `msg` : If not specified , and `filename` is specified , add the header with the value attachment . With arguments `<'bytes'>`, `maintype`, `subtype`.", "question_id": 3052}
{"snippet": "email.contentmanager.set_content(msg, <'bytes'>, maintype, subtype, cid=None)", "intent": "Add `headers` and payload to `msg` : If `cid` is specified , add a Content-ID header with cid as its value . With arguments `<'bytes'>`, `maintype`, `subtype`.", "question_id": 3053}
{"snippet": "email.contentmanager.set_content(msg, <'bytes'>, maintype, subtype, params=None)", "intent": "Add `headers` and payload to `msg` : If `params` is specified , iterate its items method and use the resulting ( key , value ) pairs to set additional parameters on the Content-Type header . With arguments `<'bytes'>`, `maintype`, `subtype`.", "question_id": 3054}
{"snippet": "email.contentmanager.set_content(msg, <'bytes'>, maintype, subtype, headers=None)", "intent": "Add `headers` and payload to `msg` : With arguments `<'bytes'>`, `maintype`, `subtype`.", "question_id": 3055}
{"snippet": "email.contentmanager.set_content(msg, <'bytes'>, maintype, subtype, cte=\"base64\", disposition=None)", "intent": "Add `headers` and payload to `msg` : If `cte` is set , encode the payload using the specified content transfer encoding , and set the Content-Transfer-Encoding header to that value . If `disposition` is set , use it as the value of the Content-Disposition header . With arguments `<'bytes'>`, `maintype`, `subtype`.", "question_id": 3056}
{"snippet": "email.contentmanager.set_content(msg, <'bytes'>, maintype, subtype, cte=\"base64\", filename=None)", "intent": "Add `headers` and payload to `msg` : If `cte` is set , encode the payload using the specified content transfer encoding , and set the Content-Transfer-Encoding header to that value . If not specified , and `filename` is specified , add the header with the value attachment . With arguments `<'bytes'>`, `maintype`, `subtype`.", "question_id": 3057}
{"snippet": "email.contentmanager.set_content(msg, <'bytes'>, maintype, subtype, cte=\"base64\", cid=None)", "intent": "Add `headers` and payload to `msg` : If `cte` is set , encode the payload using the specified content transfer encoding , and set the Content-Transfer-Encoding header to that value . If `cid` is specified , add a Content-ID header with cid as its value . With arguments `<'bytes'>`, `maintype`, `subtype`.", "question_id": 3058}
{"snippet": "email.contentmanager.set_content(msg, <'EmailMessage'>)", "intent": "Add `headers` and payload to `msg` : With arguments `<'EmailMessage'>`.", "question_id": 3059}
{"snippet": "email.contentmanager.set_content(msg, <'EmailMessage'>, cte=None)", "intent": "Add `headers` and payload to `msg` : If `cte` is set , encode the payload using the specified content transfer encoding , and set the Content-Transfer-Encoding header to that value . With arguments `<'EmailMessage'>`.", "question_id": 3060}
{"snippet": "email.contentmanager.set_content(msg, <'EmailMessage'>, disposition=None)", "intent": "Add `headers` and payload to `msg` : If `disposition` is set , use it as the value of the Content-Disposition header . With arguments `<'EmailMessage'>`.", "question_id": 3061}
{"snippet": "email.contentmanager.set_content(msg, <'EmailMessage'>, filename=None)", "intent": "Add `headers` and payload to `msg` : If not specified , and `filename` is specified , add the header with the value attachment . With arguments `<'EmailMessage'>`.", "question_id": 3062}
{"snippet": "email.contentmanager.set_content(msg, <'EmailMessage'>, cid=None)", "intent": "Add `headers` and payload to `msg` : If `cid` is specified , add a Content-ID header with cid as its value . With arguments `<'EmailMessage'>`.", "question_id": 3063}
{"snippet": "email.contentmanager.set_content(msg, <'EmailMessage'>, params=None)", "intent": "Add `headers` and payload to `msg` : If `params` is specified , iterate its items method and use the resulting ( key , value ) pairs to set additional parameters on the Content-Type header . With arguments `<'EmailMessage'>`.", "question_id": 3064}
{"snippet": "email.contentmanager.set_content(msg, <'EmailMessage'>, headers=None)", "intent": "Add `headers` and payload to `msg` : With arguments `<'EmailMessage'>`.", "question_id": 3065}
{"snippet": "email.contentmanager.set_content(msg, <'EmailMessage'>, cte=None, disposition=None)", "intent": "Add `headers` and payload to `msg` : If `cte` is set , encode the payload using the specified content transfer encoding , and set the Content-Transfer-Encoding header to that value . If `disposition` is set , use it as the value of the Content-Disposition header . With arguments `<'EmailMessage'>`.", "question_id": 3066}
{"snippet": "email.contentmanager.set_content(msg, <'EmailMessage'>, cte=None, filename=None)", "intent": "Add `headers` and payload to `msg` : If `cte` is set , encode the payload using the specified content transfer encoding , and set the Content-Transfer-Encoding header to that value . If not specified , and `filename` is specified , add the header with the value attachment . With arguments `<'EmailMessage'>`.", "question_id": 3067}
{"snippet": "email.contentmanager.set_content(msg, <'EmailMessage'>, cte=None, cid=None)", "intent": "Add `headers` and payload to `msg` : If `cte` is set , encode the payload using the specified content transfer encoding , and set the Content-Transfer-Encoding header to that value . If `cid` is specified , add a Content-ID header with cid as its value . With arguments `<'EmailMessage'>`.", "question_id": 3068}
{"snippet": "email.encoders.encode_quopri(msg)", "intent": "Encodes the payload into quoted-printable form and sets the Content-Transfer-Encoding header to quoted-printable 1 . With arguments `msg`.", "question_id": 3069}
{"snippet": "email.encoders.encode_base64(msg)", "intent": "Encodes the payload into base64 form and sets the Content-Transfer-Encoding header to base64 . With arguments `msg`.", "question_id": 3070}
{"snippet": "email.encoders.encode_7or8bit(msg)", "intent": "This doesn \u2019 t actually modify the message \u2019 s payload , but it does set the Content-Transfer-Encoding header to either 7bit or 8bit as appropriate , based on the payload data . With arguments `msg`.", "question_id": 3071}
{"snippet": "email.encoders.encode_noop(msg)", "intent": "This does nothing ; it doesn \u2019 t even set the Content-Transfer-Encoding header . With arguments `msg`.", "question_id": 3072}
{"snippet": "email.errors.MessageError", "intent": "This is the base class for all exceptions that the email package can raise.", "question_id": 3073}
{"snippet": "email.errors.MessageParseError", "intent": "This is the base class for exceptions raised by the Parser class.", "question_id": 3074}
{"snippet": "email.errors.HeaderParseError", "intent": "Raised under some error conditions when parsing the RFC 5322 headers of a message, this class is derived from MessageParseError.", "question_id": 3075}
{"snippet": "email.errors.BoundaryError", "intent": "Deprecated and no longer used.", "question_id": 3076}
{"snippet": "email.errors.MultipartConversionError", "intent": "Raised when a payload is added to a Message object using add_payload(), but the payload is already a scalar and the message\u2019s Content-Type main type is not either multipart or missing.", "question_id": 3077}
{"snippet": "email.generator.BytesGenerator(outfp)", "intent": "Return a BytesGenerator object that will write any message provided to the flatten ( ) method , or any surrogateescape encoded text provided to the write ( ) method , to the file-like object `outfp` .", "question_id": 3078}
{"snippet": "email.generator.BytesGenerator(outfp, mangle_from_=None)", "intent": "Return a BytesGenerator object that will write any message provided to the flatten ( ) method , or any surrogateescape encoded text provided to the write ( ) method , to the file-like object `outfp` . If optional `mangle_from_` is True , put a > character in front of any line in the body that starts with the exact string `` From `` , that is From followed by a space at the beginning of a line .", "question_id": 3079}
{"snippet": "email.generator.BytesGenerator(outfp, maxheaderlen=None)", "intent": "Return a BytesGenerator object that will write any message provided to the flatten ( ) method , or any surrogateescape encoded text provided to the write ( ) method , to the file-like object `outfp` . If `maxheaderlen` is not None , refold any header lines that are longer than maxheaderlen , or if 0 , do not rewrap any headers .", "question_id": 3080}
{"snippet": "email.generator.BytesGenerator(outfp, policy=None)", "intent": "Return a BytesGenerator object that will write any message provided to the flatten ( ) method , or any surrogateescape encoded text provided to the write ( ) method , to the file-like object `outfp` . mangle_from_ defaults to the value of the mangle_from_ setting of the `policy` ( which is True for the compat32 policy and False for all others ) .", "question_id": 3081}
{"snippet": "email.generator.BytesGenerator(outfp, mangle_from_=None, maxheaderlen=None)", "intent": "Return a BytesGenerator object that will write any message provided to the flatten ( ) method , or any surrogateescape encoded text provided to the write ( ) method , to the file-like object `outfp` . If optional `mangle_from_` is True , put a > character in front of any line in the body that starts with the exact string `` From `` , that is From followed by a space at the beginning of a line . If `maxheaderlen` is not None , refold any header lines that are longer than maxheaderlen , or if 0 , do not rewrap any headers .", "question_id": 3082}
{"snippet": "email.generator.BytesGenerator(outfp, mangle_from_=None, policy=None)", "intent": "Return a BytesGenerator object that will write any message provided to the flatten ( ) method , or any surrogateescape encoded text provided to the write ( ) method , to the file-like object `outfp` . If optional `mangle_from_` is True , put a > character in front of any line in the body that starts with the exact string `` From `` , that is From followed by a space at the beginning of a line . mangle_from_ defaults to the value of the mangle_from_ setting of the `policy` ( which is True for the compat32 policy and False for all others ) .", "question_id": 3083}
{"snippet": "email.generator.BytesGenerator(outfp, maxheaderlen=None, policy=None)", "intent": "Return a BytesGenerator object that will write any message provided to the flatten ( ) method , or any surrogateescape encoded text provided to the write ( ) method , to the file-like object `outfp` . If `maxheaderlen` is not None , refold any header lines that are longer than maxheaderlen , or if 0 , do not rewrap any headers . mangle_from_ defaults to the value of the mangle_from_ setting of the `policy` ( which is True for the compat32 policy and False for all others ) .", "question_id": 3084}
{"snippet": "email.generator.BytesGenerator(outfp, mangle_from_=None, maxheaderlen=None, policy=None)", "intent": "Return a BytesGenerator object that will write any message provided to the flatten ( ) method , or any surrogateescape encoded text provided to the write ( ) method , to the file-like object `outfp` . If optional `mangle_from_` is True , put a > character in front of any line in the body that starts with the exact string `` From `` , that is From followed by a space at the beginning of a line . If `maxheaderlen` is not None , refold any header lines that are longer than maxheaderlen , or if 0 , do not rewrap any headers . mangle_from_ defaults to the value of the mangle_from_ setting of the `policy` ( which is True for the compat32 policy and False for all others ) .", "question_id": 3085}
{"snippet": "bytes_generator.flatten(msg)", "intent": "Print the textual representation of the message object structure rooted at `msg` to the output file specified when the BytesGenerator instance was created .", "question_id": 3086}
{"snippet": "bytes_generator.flatten(msg, unixfrom=False)", "intent": "Print the textual representation of the message object structure rooted at `msg` to the output file specified when the BytesGenerator instance was created . If `unixfrom` is True , print the envelope header delimiter used by the Unix mailbox format ( see mailbox ) before the first of the RFC 5322 headers of the root message object .", "question_id": 3087}
{"snippet": "bytes_generator.flatten(msg, linesep=None)", "intent": "Print the textual representation of the message object structure rooted at `msg` to the output file specified when the BytesGenerator instance was created . If `linesep` is not None , use it as the separator character between all the lines of the flattened message .", "question_id": 3088}
{"snippet": "bytes_generator.flatten(msg, unixfrom=False, linesep=None)", "intent": "Print the textual representation of the message object structure rooted at `msg` to the output file specified when the BytesGenerator instance was created . If `unixfrom` is True , print the envelope header delimiter used by the Unix mailbox format ( see mailbox ) before the first of the RFC 5322 headers of the root message object . If `linesep` is not None , use it as the separator character between all the lines of the flattened message .", "question_id": 3089}
{"snippet": "bytes_generator.clone(fp)", "intent": "Return an independent clone of this BytesGenerator instance with the exact same option settings , and `fp` as the new outfp .", "question_id": 3090}
{"snippet": "bytes_generator.write(s)", "intent": "Encode `s` using the ASCII codec and the surrogateescape error handler , and pass it to the write method of the outfp passed to the BytesGenerator \u2019 s constructor .", "question_id": 3091}
{"snippet": "email.generator.Generator(outfp)", "intent": "Return a Generator object that will write any message provided to the flatten ( ) method , or any text provided to the write ( ) method , to the file-like object `outfp` .", "question_id": 3092}
{"snippet": "email.generator.Generator(outfp, mangle_from_=None)", "intent": "Return a Generator object that will write any message provided to the flatten ( ) method , or any text provided to the write ( ) method , to the file-like object `outfp` . If optional `mangle_from_` is True , put a > character in front of any line in the body that starts with the exact string `` From `` , that is From followed by a space at the beginning of a line .", "question_id": 3093}
{"snippet": "email.generator.Generator(outfp, maxheaderlen=None)", "intent": "Return a Generator object that will write any message provided to the flatten ( ) method , or any text provided to the write ( ) method , to the file-like object `outfp` . If `maxheaderlen` is not None , refold any header lines that are longer than maxheaderlen , or if 0 , do not rewrap any headers .", "question_id": 3094}
{"snippet": "email.generator.Generator(outfp, policy=None)", "intent": "Return a Generator object that will write any message provided to the flatten ( ) method , or any text provided to the write ( ) method , to the file-like object `outfp` . mangle_from_ defaults to the value of the mangle_from_ setting of the `policy` ( which is True for the compat32 policy and False for all others ) .", "question_id": 3095}
{"snippet": "email.generator.Generator(outfp, mangle_from_=None, maxheaderlen=None)", "intent": "Return a Generator object that will write any message provided to the flatten ( ) method , or any text provided to the write ( ) method , to the file-like object `outfp` . If optional `mangle_from_` is True , put a > character in front of any line in the body that starts with the exact string `` From `` , that is From followed by a space at the beginning of a line . If `maxheaderlen` is not None , refold any header lines that are longer than maxheaderlen , or if 0 , do not rewrap any headers .", "question_id": 3096}
{"snippet": "email.generator.Generator(outfp, mangle_from_=None, policy=None)", "intent": "Return a Generator object that will write any message provided to the flatten ( ) method , or any text provided to the write ( ) method , to the file-like object `outfp` . If optional `mangle_from_` is True , put a > character in front of any line in the body that starts with the exact string `` From `` , that is From followed by a space at the beginning of a line . mangle_from_ defaults to the value of the mangle_from_ setting of the `policy` ( which is True for the compat32 policy and False for all others ) .", "question_id": 3097}
{"snippet": "email.generator.Generator(outfp, maxheaderlen=None, policy=None)", "intent": "Return a Generator object that will write any message provided to the flatten ( ) method , or any text provided to the write ( ) method , to the file-like object `outfp` . If `maxheaderlen` is not None , refold any header lines that are longer than maxheaderlen , or if 0 , do not rewrap any headers . mangle_from_ defaults to the value of the mangle_from_ setting of the `policy` ( which is True for the compat32 policy and False for all others ) .", "question_id": 3098}
{"snippet": "email.generator.Generator(outfp, mangle_from_=None, maxheaderlen=None, policy=None)", "intent": "Return a Generator object that will write any message provided to the flatten ( ) method , or any text provided to the write ( ) method , to the file-like object `outfp` . If optional `mangle_from_` is True , put a > character in front of any line in the body that starts with the exact string `` From `` , that is From followed by a space at the beginning of a line . If `maxheaderlen` is not None , refold any header lines that are longer than maxheaderlen , or if 0 , do not rewrap any headers . mangle_from_ defaults to the value of the mangle_from_ setting of the `policy` ( which is True for the compat32 policy and False for all others ) .", "question_id": 3099}
{"snippet": "generator.flatten(msg)", "intent": "Print the textual representation of the message object structure rooted at `msg` to the output file specified when the Generator instance was created .", "question_id": 3100}
{"snippet": "generator.flatten(msg, unixfrom=False)", "intent": "Print the textual representation of the message object structure rooted at `msg` to the output file specified when the Generator instance was created . If `unixfrom` is True , print the envelope header delimiter used by the Unix mailbox format ( see mailbox ) before the first of the RFC 5322 headers of the root message object .", "question_id": 3101}
{"snippet": "generator.flatten(msg, linesep=None)", "intent": "Print the textual representation of the message object structure rooted at `msg` to the output file specified when the Generator instance was created . If `linesep` is not None , use it as the separator character between all the lines of the flattened message .", "question_id": 3102}
{"snippet": "generator.flatten(msg, unixfrom=False, linesep=None)", "intent": "Print the textual representation of the message object structure rooted at `msg` to the output file specified when the Generator instance was created . If `unixfrom` is True , print the envelope header delimiter used by the Unix mailbox format ( see mailbox ) before the first of the RFC 5322 headers of the root message object . If `linesep` is not None , use it as the separator character between all the lines of the flattened message .", "question_id": 3103}
{"snippet": "generator.clone(fp)", "intent": "Return an independent clone of this Generator instance with the exact same options , and `fp` as the new outfp .", "question_id": 3104}
{"snippet": "generator.write(s)", "intent": "Write `s` to the write method of the outfp passed to the Generator \u2019 s constructor .", "question_id": 3105}
{"snippet": "email.generator.DecodedGenerator(outfp)", "intent": "Act like Generator , except that for any subpart of the message passed to Generator.flatten ( ) , if the subpart is of main type text , print the decoded payload of the subpart , and if the main type is not text , instead of printing it fill in the string `fmt` using information from the part and print the resulting filled-in string . With arguments `outfp`.", "question_id": 3106}
{"snippet": "email.generator.DecodedGenerator(outfp, mangle_from_=None)", "intent": "Act like Generator , except that for any subpart of the message passed to Generator.flatten ( ) , if the subpart is of main type text , print the decoded payload of the subpart , and if the main type is not text , instead of printing it fill in the string `fmt` using information from the part and print the resulting filled-in string . With arguments `outfp`, `mangle_from_`.", "question_id": 3107}
{"snippet": "email.generator.DecodedGenerator(outfp, maxheaderlen=None)", "intent": "Act like Generator , except that for any subpart of the message passed to Generator.flatten ( ) , if the subpart is of main type text , print the decoded payload of the subpart , and if the main type is not text , instead of printing it fill in the string `fmt` using information from the part and print the resulting filled-in string . Optional _mangle_from_ and `maxheaderlen` are as with the Generator base class . With arguments `outfp`.", "question_id": 3108}
{"snippet": "email.generator.DecodedGenerator(outfp, fmt=None)", "intent": "Act like Generator , except that for any subpart of the message passed to Generator.flatten ( ) , if the subpart is of main type text , print the decoded payload of the subpart , and if the main type is not text , instead of printing it fill in the string `fmt` using information from the part and print the resulting filled-in string . With arguments `outfp`.", "question_id": 3109}
{"snippet": "email.generator.DecodedGenerator(outfp, policy=None)", "intent": "Act like Generator , except that for any subpart of the message passed to Generator.flatten ( ) , if the subpart is of main type text , print the decoded payload of the subpart , and if the main type is not text , instead of printing it fill in the string `fmt` using information from the part and print the resulting filled-in string . With arguments `outfp`, `policy`.", "question_id": 3110}
{"snippet": "email.generator.DecodedGenerator(outfp, mangle_from_=None, maxheaderlen=None)", "intent": "Act like Generator , except that for any subpart of the message passed to Generator.flatten ( ) , if the subpart is of main type text , print the decoded payload of the subpart , and if the main type is not text , instead of printing it fill in the string `fmt` using information from the part and print the resulting filled-in string . Optional _mangle_from_ and `maxheaderlen` are as with the Generator base class . With arguments `outfp`, `mangle_from_`.", "question_id": 3111}
{"snippet": "email.generator.DecodedGenerator(outfp, mangle_from_=None, fmt=None)", "intent": "Act like Generator , except that for any subpart of the message passed to Generator.flatten ( ) , if the subpart is of main type text , print the decoded payload of the subpart , and if the main type is not text , instead of printing it fill in the string `fmt` using information from the part and print the resulting filled-in string . With arguments `outfp`, `mangle_from_`.", "question_id": 3112}
{"snippet": "email.generator.DecodedGenerator(outfp, mangle_from_=None, policy=None)", "intent": "Act like Generator , except that for any subpart of the message passed to Generator.flatten ( ) , if the subpart is of main type text , print the decoded payload of the subpart , and if the main type is not text , instead of printing it fill in the string `fmt` using information from the part and print the resulting filled-in string . With arguments `outfp`, `mangle_from_`, `policy`.", "question_id": 3113}
{"snippet": "email.generator.DecodedGenerator(outfp, maxheaderlen=None, fmt=None)", "intent": "Act like Generator , except that for any subpart of the message passed to Generator.flatten ( ) , if the subpart is of main type text , print the decoded payload of the subpart , and if the main type is not text , instead of printing it fill in the string `fmt` using information from the part and print the resulting filled-in string . Optional _mangle_from_ and `maxheaderlen` are as with the Generator base class . With arguments `outfp`.", "question_id": 3114}
{"snippet": "email.generator.DecodedGenerator(outfp, maxheaderlen=None, policy=None)", "intent": "Act like Generator , except that for any subpart of the message passed to Generator.flatten ( ) , if the subpart is of main type text , print the decoded payload of the subpart , and if the main type is not text , instead of printing it fill in the string `fmt` using information from the part and print the resulting filled-in string . Optional _mangle_from_ and `maxheaderlen` are as with the Generator base class . With arguments `outfp`, `policy`.", "question_id": 3115}
{"snippet": "email.header.Header()", "intent": "Create a MIME-compliant header that can contain strings in different character sets .", "question_id": 3116}
{"snippet": "email.header.Header(s=None)", "intent": "Create a MIME-compliant header that can contain strings in different character sets . Optional `s` is the initial header value .", "question_id": 3117}
{"snippet": "email.header.Header(charset=None)", "intent": "Create a MIME-compliant header that can contain strings in different character sets . Optional `charset` serves two purposes : it has the same meaning as the charset argument to the append ( ) method .", "question_id": 3118}
{"snippet": "email.header.Header(maxlinelen=None)", "intent": "Create a MIME-compliant header that can contain strings in different character sets . The maximum line length can be specified explicitly via `maxlinelen` .", "question_id": 3119}
{"snippet": "email.header.Header(header_name=None)", "intent": "Create a MIME-compliant header that can contain strings in different character sets . Subject ) pass in the name of the field in `header_name` .", "question_id": 3120}
{"snippet": "email.header.Header(continuation_ws=' ')", "intent": "Create a MIME-compliant header that can contain strings in different character sets . Optional `continuation_ws` must be RFC 2822-compliant folding whitespace , and is usually either a space or a hard tab character .", "question_id": 3121}
{"snippet": "email.header.Header(errors='strict')", "intent": "Create a MIME-compliant header that can contain strings in different character sets . Optional `errors` is passed straight through to the append ( ) method .", "question_id": 3122}
{"snippet": "email.header.Header(s=None, charset=None)", "intent": "Create a MIME-compliant header that can contain strings in different character sets . Optional `s` is the initial header value . Optional `charset` serves two purposes : it has the same meaning as the charset argument to the append ( ) method .", "question_id": 3123}
{"snippet": "email.header.Header(s=None, maxlinelen=None)", "intent": "Create a MIME-compliant header that can contain strings in different character sets . Optional `s` is the initial header value . The maximum line length can be specified explicitly via `maxlinelen` .", "question_id": 3124}
{"snippet": "email.header.Header(s=None, header_name=None)", "intent": "Create a MIME-compliant header that can contain strings in different character sets . Optional `s` is the initial header value . Subject ) pass in the name of the field in `header_name` .", "question_id": 3125}
{"snippet": "header.append(s)", "intent": "Append the string `s` to the MIME header .", "question_id": 3126}
{"snippet": "header.append(s, charset=None)", "intent": "Append the string `s` to the MIME header . Optional `charset` , if given , should be a Charset instance ( see email.charset ) or the name of a character set , which will be converted to a Charset instance .", "question_id": 3127}
{"snippet": "header.append(s, errors='strict')", "intent": "Append the string `s` to the MIME header . Optional `errors` is passed as the errors argument to the decode call if s is a byte string .", "question_id": 3128}
{"snippet": "header.append(s, charset=None, errors='strict')", "intent": "Append the string `s` to the MIME header . Optional `charset` , if given , should be a Charset instance ( see email.charset ) or the name of a character set , which will be converted to a Charset instance . Optional `errors` is passed as the errors argument to the decode call if s is a byte string .", "question_id": 3129}
{"snippet": "header.encode(\\t')", "intent": "Encode a message header into an RFC-compliant format , possibly wrapping long lines and encapsulating non-ASCII parts in base64 or quoted-printable encodings . With arguments `\\t'`.", "question_id": 3130}
{"snippet": "header.encode(\\t', splitchars=';)", "intent": "Encode a message header into an RFC-compliant format , possibly wrapping long lines and encapsulating non-ASCII parts in base64 or quoted-printable encodings . Optional `splitchars` is a string containing characters which should be given extra weight by the splitting algorithm during normal header wrapping . With arguments `\\t'`.", "question_id": 3131}
{"snippet": "header.encode(\\t', maxlinelen=None)", "intent": "Encode a message header into an RFC-compliant format , possibly wrapping long lines and encapsulating non-ASCII parts in base64 or quoted-printable encodings . `maxlinelen` , if given , overrides the instance \u2019 s value for the maximum line length . With arguments `\\t'`.", "question_id": 3132}
{"snippet": "header.encode(\\t', linesep='\\n')", "intent": "Encode a message header into an RFC-compliant format , possibly wrapping long lines and encapsulating non-ASCII parts in base64 or quoted-printable encodings . `linesep` specifies the characters used to separate the lines of the folded header . With arguments `\\t'`.", "question_id": 3133}
{"snippet": "header.encode(\\t', splitchars=';, maxlinelen=None)", "intent": "Encode a message header into an RFC-compliant format , possibly wrapping long lines and encapsulating non-ASCII parts in base64 or quoted-printable encodings . Optional `splitchars` is a string containing characters which should be given extra weight by the splitting algorithm during normal header wrapping . `maxlinelen` , if given , overrides the instance \u2019 s value for the maximum line length . With arguments `\\t'`.", "question_id": 3134}
{"snippet": "header.encode(\\t', splitchars=';, linesep='\\n')", "intent": "Encode a message header into an RFC-compliant format , possibly wrapping long lines and encapsulating non-ASCII parts in base64 or quoted-printable encodings . Optional `splitchars` is a string containing characters which should be given extra weight by the splitting algorithm during normal header wrapping . `linesep` specifies the characters used to separate the lines of the folded header . With arguments `\\t'`.", "question_id": 3135}
{"snippet": "header.encode(\\t', maxlinelen=None, linesep='\\n')", "intent": "Encode a message header into an RFC-compliant format , possibly wrapping long lines and encapsulating non-ASCII parts in base64 or quoted-printable encodings . `maxlinelen` , if given , overrides the instance \u2019 s value for the maximum line length . `linesep` specifies the characters used to separate the lines of the folded header . With arguments `\\t'`.", "question_id": 3136}
{"snippet": "header.encode(\\t', splitchars=';, maxlinelen=None, linesep='\\n')", "intent": "Encode a message header into an RFC-compliant format , possibly wrapping long lines and encapsulating non-ASCII parts in base64 or quoted-printable encodings . Optional `splitchars` is a string containing characters which should be given extra weight by the splitting algorithm during normal header wrapping . `maxlinelen` , if given , overrides the instance \u2019 s value for the maximum line length . `linesep` specifies the characters used to separate the lines of the folded header . With arguments `\\t'`.", "question_id": 3137}
{"snippet": "header.__str__()", "intent": "Returns an approximation of the Header as a string , using an unlimited line length .", "question_id": 3138}
{"snippet": "header.__eq__(other)", "intent": "This method allows you to compare two Header instances for equality . With arguments `other`.", "question_id": 3139}
{"snippet": "header.__ne__(other)", "intent": "This method allows you to compare two Header instances for inequality . With arguments `other`.", "question_id": 3140}
{"snippet": "email.header.decode_header(header)", "intent": "Decode a message `header` value without converting the character set .", "question_id": 3141}
{"snippet": "email.header.make_header(decoded_seq)", "intent": "Create a Header instance from a sequence of pairs as returned by decode_header ( ) . With arguments `decoded_seq`.", "question_id": 3142}
{"snippet": "email.header.make_header(decoded_seq, maxlinelen=None)", "intent": "Create a Header instance from a sequence of pairs as returned by decode_header ( ) . Optional `maxlinelen` , `header_name` , and `continuation_ws` are as in the Header constructor . With arguments `decoded_seq`.", "question_id": 3143}
{"snippet": "email.header.make_header(decoded_seq, header_name=None)", "intent": "Create a Header instance from a sequence of pairs as returned by decode_header ( ) . Optional `maxlinelen` , `header_name` , and `continuation_ws` are as in the Header constructor . With arguments `decoded_seq`.", "question_id": 3144}
{"snippet": "email.header.make_header(decoded_seq, continuation_ws=' ')", "intent": "Create a Header instance from a sequence of pairs as returned by decode_header ( ) . Optional `maxlinelen` , `header_name` , and `continuation_ws` are as in the Header constructor . With arguments `decoded_seq`.", "question_id": 3145}
{"snippet": "email.header.make_header(decoded_seq, maxlinelen=None, header_name=None)", "intent": "Create a Header instance from a sequence of pairs as returned by decode_header ( ) . Optional `maxlinelen` , `header_name` , and `continuation_ws` are as in the Header constructor . With arguments `decoded_seq`.", "question_id": 3146}
{"snippet": "email.header.make_header(decoded_seq, maxlinelen=None, continuation_ws=' ')", "intent": "Create a Header instance from a sequence of pairs as returned by decode_header ( ) . Optional `maxlinelen` , `header_name` , and `continuation_ws` are as in the Header constructor . With arguments `decoded_seq`.", "question_id": 3147}
{"snippet": "email.header.make_header(decoded_seq, header_name=None, continuation_ws=' ')", "intent": "Create a Header instance from a sequence of pairs as returned by decode_header ( ) . Optional `maxlinelen` , `header_name` , and `continuation_ws` are as in the Header constructor . With arguments `decoded_seq`.", "question_id": 3148}
{"snippet": "email.header.make_header(decoded_seq, maxlinelen=None, header_name=None, continuation_ws=' ')", "intent": "Create a Header instance from a sequence of pairs as returned by decode_header ( ) . Optional `maxlinelen` , `header_name` , and `continuation_ws` are as in the Header constructor . With arguments `decoded_seq`.", "question_id": 3149}
{"snippet": "email.headerregistry.BaseHeader(name, value)", "intent": "`name` and `value` are passed to BaseHeader from the header_factory call .", "question_id": 3150}
{"snippet": "base_header.name", "intent": "The name of the header (the portion of the field before the \u2018:\u2019).", "question_id": 3151}
{"snippet": "base_header.defects", "intent": "A tuple of HeaderDefect instances reporting any RFC compliance problems found during parsing.", "question_id": 3152}
{"snippet": "base_header.max_count", "intent": "The maximum number of headers of this type that can have the same name.", "question_id": 3153}
{"snippet": "base_header.fold(policy)", "intent": "Return a string containing linesep characters as required to correctly fold the header according to `policy` .", "question_id": 3154}
{"snippet": "email.headerregistry.UnstructuredHeader", "intent": "An \u201cunstructured\u201d header is the default type of header in RFC 5322.", "question_id": 3155}
{"snippet": "email.headerregistry.DateHeader", "intent": "RFC 5322 specifies a very specific format for dates within email headers.", "question_id": 3156}
{"snippet": "date_header.datetime", "intent": "If the header value can be recognized as a valid date of one form or another, this attribute will contain a datetime instance representing that date.", "question_id": 3157}
{"snippet": "email.headerregistry.AddressHeader", "intent": "Address headers are one of the most complex structured header types.", "question_id": 3158}
{"snippet": "address_header.groups", "intent": "A tuple of Group objects encoding the addresses and groups found in the header value.", "question_id": 3159}
{"snippet": "address_header.addresses", "intent": "A tuple of Address objects encoding all of the individual addresses from the header value.", "question_id": 3160}
{"snippet": "email.headerregistry.SingleAddressHeader", "intent": "A subclass of AddressHeader that adds one additional attribute:", "question_id": 3161}
{"snippet": "single_address_header.address", "intent": "The single address encoded by the header value.", "question_id": 3162}
{"snippet": "email.headerregistry.MIMEVersionHeader", "intent": "There is really only one valid value for the MIME-Version header, and that is 1.0.", "question_id": 3163}
{"snippet": "mime_version_header.version", "intent": "The version number as a string, with any whitespace and/or comments removed.", "question_id": 3164}
{"snippet": "mime_version_header.major", "intent": "The major version number as an integer", "question_id": 3165}
{"snippet": "mime_version_header.minor", "intent": "The minor version number as an integer", "question_id": 3166}
{"snippet": "email.headerregistry.ParameterizedMIMEHeader", "intent": "MIME headers all start with the prefix \u2018Content-\u2018.", "question_id": 3167}
{"snippet": "parameterized_mime_header.params", "intent": "A dictionary mapping parameter names to parameter values.", "question_id": 3168}
{"snippet": "email.headerregistry.ContentTypeHeader", "intent": "A ParameterizedMIMEHeader class that handles the Content-Type header.", "question_id": 3169}
{"snippet": "content_type_header.content_type", "intent": "The content type string, in the form maintype/subtype.", "question_id": 3170}
{"snippet": "email.headerregistry.ContentDispositionHeader", "intent": "A ParameterizedMIMEHeader class that handles the Content-Disposition header.", "question_id": 3171}
{"snippet": "content_disposition_header.content-disposition", "intent": "inline and attachment are the only valid values in common use.", "question_id": 3172}
{"snippet": "email.headerregistry.ContentTransferEncoding", "intent": "Handles the Content-Transfer-Encoding header.", "question_id": 3173}
{"snippet": "content_transfer_encoding.cte", "intent": "Valid values are 7bit, 8bit, base64, and quoted-printable.", "question_id": 3174}
{"snippet": "email.headerregistry.HeaderRegistry()", "intent": "This is the factory used by EmailPolicy by default .", "question_id": 3175}
{"snippet": "email.headerregistry.HeaderRegistry(base_class=BaseHeader)", "intent": "This is the factory used by EmailPolicy by default . HeaderRegistry builds the class used to create a header instance dynamically , using `base_class` and a specialized class retrieved from a registry that it holds .", "question_id": 3176}
{"snippet": "email.headerregistry.HeaderRegistry(default_class=UnstructuredHeader)", "intent": "This is the factory used by EmailPolicy by default . When a given header name does not appear in the registry , the class specified by `default_class` is used as the specialized class .", "question_id": 3177}
{"snippet": "email.headerregistry.HeaderRegistry(use_default_map=True)", "intent": "This is the factory used by EmailPolicy by default . When `use_default_map` is True ( the default ) , the standard mapping of header names to classes is copied in to the registry during initialization .", "question_id": 3178}
{"snippet": "email.headerregistry.HeaderRegistry(base_class=BaseHeader, default_class=UnstructuredHeader)", "intent": "This is the factory used by EmailPolicy by default . HeaderRegistry builds the class used to create a header instance dynamically , using `base_class` and a specialized class retrieved from a registry that it holds . When a given header name does not appear in the registry , the class specified by `default_class` is used as the specialized class .", "question_id": 3179}
{"snippet": "email.headerregistry.HeaderRegistry(base_class=BaseHeader, use_default_map=True)", "intent": "This is the factory used by EmailPolicy by default . HeaderRegistry builds the class used to create a header instance dynamically , using `base_class` and a specialized class retrieved from a registry that it holds . When `use_default_map` is True ( the default ) , the standard mapping of header names to classes is copied in to the registry during initialization .", "question_id": 3180}
{"snippet": "email.headerregistry.HeaderRegistry(default_class=UnstructuredHeader, use_default_map=True)", "intent": "This is the factory used by EmailPolicy by default . When a given header name does not appear in the registry , the class specified by `default_class` is used as the specialized class . When `use_default_map` is True ( the default ) , the standard mapping of header names to classes is copied in to the registry during initialization .", "question_id": 3181}
{"snippet": "email.headerregistry.HeaderRegistry(base_class=BaseHeader, default_class=UnstructuredHeader, use_default_map=True)", "intent": "This is the factory used by EmailPolicy by default . HeaderRegistry builds the class used to create a header instance dynamically , using `base_class` and a specialized class retrieved from a registry that it holds . When a given header name does not appear in the registry , the class specified by `default_class` is used as the specialized class . When `use_default_map` is True ( the default ) , the standard mapping of header names to classes is copied in to the registry during initialization .", "question_id": 3182}
{"snippet": "header_registry.map_to_type(self, name, cls)", "intent": "`name` is the name of the header to be mapped . `cls` is the specialized class to be used , along with base_class , to create the class used to instantiate headers that match name . With arguments `self`.", "question_id": 3183}
{"snippet": "header_registry.__getitem__(name)", "intent": "Construct and return a class to handle creating a `name` header .", "question_id": 3184}
{"snippet": "header_registry.__call__(name, value)", "intent": "Retrieves the specialized header associated with `name` from the registry ( using default_class if name does not appear in the registry ) and composes it with base_class to produce a class , calls the constructed class \u2019 s constructor , passing it the same argument list , and finally returns the class instance created thereby . With arguments `value`.", "question_id": 3185}
{"snippet": "email.headerregistry.Address()", "intent": "The class used to represent an email address .", "question_id": 3186}
{"snippet": "email.headerregistry.Address(display_name='')", "intent": "The class used to represent an email address . With arguments `display_name`.", "question_id": 3187}
{"snippet": "email.headerregistry.Address(username='')", "intent": "The class used to represent an email address . As a convenience `addr_spec` can be specified instead of `username` and `domain` , in which case username and domain will be parsed from the addr_spec .", "question_id": 3188}
{"snippet": "email.headerregistry.Address(domain='')", "intent": "The class used to represent an email address . As a convenience `addr_spec` can be specified instead of `username` and `domain` , in which case username and domain will be parsed from the addr_spec .", "question_id": 3189}
{"snippet": "email.headerregistry.Address(addr_spec=None)", "intent": "The class used to represent an email address . As a convenience `addr_spec` can be specified instead of `username` and `domain` , in which case username and domain will be parsed from the addr_spec .", "question_id": 3190}
{"snippet": "email.headerregistry.Address(display_name='', username='')", "intent": "The class used to represent an email address . As a convenience `addr_spec` can be specified instead of `username` and `domain` , in which case username and domain will be parsed from the addr_spec . With arguments `display_name`.", "question_id": 3191}
{"snippet": "email.headerregistry.Address(display_name='', domain='')", "intent": "The class used to represent an email address . As a convenience `addr_spec` can be specified instead of `username` and `domain` , in which case username and domain will be parsed from the addr_spec . With arguments `display_name`.", "question_id": 3192}
{"snippet": "email.headerregistry.Address(display_name='', addr_spec=None)", "intent": "The class used to represent an email address . As a convenience `addr_spec` can be specified instead of `username` and `domain` , in which case username and domain will be parsed from the addr_spec . With arguments `display_name`.", "question_id": 3193}
{"snippet": "email.headerregistry.Address(username='', domain='')", "intent": "The class used to represent an email address . As a convenience `addr_spec` can be specified instead of `username` and `domain` , in which case username and domain will be parsed from the addr_spec .", "question_id": 3194}
{"snippet": "email.headerregistry.Address(username='', addr_spec=None)", "intent": "The class used to represent an email address . As a convenience `addr_spec` can be specified instead of `username` and `domain` , in which case username and domain will be parsed from the addr_spec .", "question_id": 3195}
{"snippet": "address.display_name", "intent": "The display name portion of the address, if any, with all quoting removed.", "question_id": 3196}
{"snippet": "address.username", "intent": "The username portion of the address, with all quoting removed.", "question_id": 3197}
{"snippet": "address.domain", "intent": "The domain portion of the address.", "question_id": 3198}
{"snippet": "address.addr_spec", "intent": "The username@domain portion of the address, correctly quoted for use as a bare address (the second form shown above).", "question_id": 3199}
{"snippet": "address.__str__()", "intent": "The str value of the object is the address quoted according to RFC 5322 rules , but with no Content Transfer Encoding of any non-ASCII characters .", "question_id": 3200}
{"snippet": "email.headerregistry.Group()", "intent": "The class used to represent an address group .", "question_id": 3201}
{"snippet": "email.headerregistry.Group(display_name=None)", "intent": "The class used to represent an address group . As a convenience for processing lists of `addresses` that consist of a mixture of groups and single addresses , a Group may also be used to represent single addresses that are not part of a group by setting `display_name` to None and providing a list of the single address as addresses .", "question_id": 3202}
{"snippet": "email.headerregistry.Group(addresses=None)", "intent": "The class used to represent an address group . As a convenience for processing lists of `addresses` that consist of a mixture of groups and single addresses , a Group may also be used to represent single addresses that are not part of a group by setting `display_name` to None and providing a list of the single address as addresses .", "question_id": 3203}
{"snippet": "email.headerregistry.Group(display_name=None, addresses=None)", "intent": "The class used to represent an address group . As a convenience for processing lists of `addresses` that consist of a mixture of groups and single addresses , a Group may also be used to represent single addresses that are not part of a group by setting `display_name` to None and providing a list of the single address as addresses .", "question_id": 3204}
{"snippet": "group.display_name", "intent": "The display_name of the group.", "question_id": 3205}
{"snippet": "group.addresses", "intent": "A possibly empty tuple of Address objects representing the addresses in the group.", "question_id": 3206}
{"snippet": "group.__str__()", "intent": "The str value of a Group is formatted according to RFC 5322 , but with no Content Transfer Encoding of any non-ASCII characters .", "question_id": 3207}
{"snippet": "email.iterators.body_line_iterator(msg)", "intent": "This iterates over all the payloads in all the subparts of `msg` , returning the string payloads line-by-line .", "question_id": 3208}
{"snippet": "email.iterators.body_line_iterator(msg, decode=False)", "intent": "This iterates over all the payloads in all the subparts of `msg` , returning the string payloads line-by-line . Optional `decode` is passed through to Message.get_payload .", "question_id": 3209}
{"snippet": "email.iterators.typed_subpart_iterator(msg)", "intent": "This iterates over all the subparts of `msg` , returning only those subparts that match the MIME type specified by `maintype` and `subtype` .", "question_id": 3210}
{"snippet": "email.iterators.typed_subpart_iterator(msg, maintype='text')", "intent": "This iterates over all the subparts of `msg` , returning only those subparts that match the MIME type specified by `maintype` and `subtype` .", "question_id": 3211}
{"snippet": "email.iterators.typed_subpart_iterator(msg, subtype=None)", "intent": "This iterates over all the subparts of `msg` , returning only those subparts that match the MIME type specified by `maintype` and `subtype` .", "question_id": 3212}
{"snippet": "email.iterators.typed_subpart_iterator(msg, maintype='text', subtype=None)", "intent": "This iterates over all the subparts of `msg` , returning only those subparts that match the MIME type specified by `maintype` and `subtype` .", "question_id": 3213}
{"snippet": "email.iterators._structure(msg)", "intent": "Prints an indented representation of the content types of the message object structure . With arguments `msg`.", "question_id": 3214}
{"snippet": "email.iterators._structure(msg, fp=None)", "intent": "Prints an indented representation of the content types of the message object structure . Optional `fp` is a file-like object to print the output to . With arguments `msg`.", "question_id": 3215}
{"snippet": "email.iterators._structure(msg, level=0)", "intent": "Prints an indented representation of the content types of the message object structure . `level` is used internally . With arguments `msg`.", "question_id": 3216}
{"snippet": "email.iterators._structure(msg, include_default=False)", "intent": "Prints an indented representation of the content types of the message object structure . `include_default` , if true , prints the default type as well . With arguments `msg`.", "question_id": 3217}
{"snippet": "email.iterators._structure(msg, fp=None, level=0)", "intent": "Prints an indented representation of the content types of the message object structure . Optional `fp` is a file-like object to print the output to . `level` is used internally . With arguments `msg`.", "question_id": 3218}
{"snippet": "email.iterators._structure(msg, fp=None, include_default=False)", "intent": "Prints an indented representation of the content types of the message object structure . Optional `fp` is a file-like object to print the output to . `include_default` , if true , prints the default type as well . With arguments `msg`.", "question_id": 3219}
{"snippet": "email.iterators._structure(msg, level=0, include_default=False)", "intent": "Prints an indented representation of the content types of the message object structure . `level` is used internally . `include_default` , if true , prints the default type as well . With arguments `msg`.", "question_id": 3220}
{"snippet": "email.iterators._structure(msg, fp=None, level=0, include_default=False)", "intent": "Prints an indented representation of the content types of the message object structure . Optional `fp` is a file-like object to print the output to . `level` is used internally . `include_default` , if true , prints the default type as well . With arguments `msg`.", "question_id": 3221}
{"snippet": "email.message.EmailMessage()", "intent": "If `policy` is specified use the rules it specifies to update and serialize the representation of the message .", "question_id": 3222}
{"snippet": "email.message.EmailMessage(policy=default)", "intent": "If `policy` is specified use the rules it specifies to update and serialize the representation of the message .", "question_id": 3223}
{"snippet": "email_message.as_string()", "intent": "Return the entire message flattened as a string .", "question_id": 3224}
{"snippet": "email_message.as_string(unixfrom=False)", "intent": "Return the entire message flattened as a string . When optional `unixfrom` is true , the envelope header is included in the returned string .", "question_id": 3225}
{"snippet": "email_message.as_string(maxheaderlen=None)", "intent": "Return the entire message flattened as a string . For backward compatibility with the base Message class `maxheaderlen` is accepted , but defaults to None , which means that by default the line length is controlled by the max_line_length of the `policy` .", "question_id": 3226}
{"snippet": "email_message.as_string(policy=None)", "intent": "Return the entire message flattened as a string . For backward compatibility with the base Message class `maxheaderlen` is accepted , but defaults to None , which means that by default the line length is controlled by the max_line_length of the `policy` .", "question_id": 3227}
{"snippet": "email_message.as_string(unixfrom=False, maxheaderlen=None)", "intent": "Return the entire message flattened as a string . When optional `unixfrom` is true , the envelope header is included in the returned string . For backward compatibility with the base Message class `maxheaderlen` is accepted , but defaults to None , which means that by default the line length is controlled by the max_line_length of the `policy` .", "question_id": 3228}
{"snippet": "email_message.as_string(unixfrom=False, policy=None)", "intent": "Return the entire message flattened as a string . When optional `unixfrom` is true , the envelope header is included in the returned string . For backward compatibility with the base Message class `maxheaderlen` is accepted , but defaults to None , which means that by default the line length is controlled by the max_line_length of the `policy` .", "question_id": 3229}
{"snippet": "email_message.as_string(maxheaderlen=None, policy=None)", "intent": "Return the entire message flattened as a string . For backward compatibility with the base Message class `maxheaderlen` is accepted , but defaults to None , which means that by default the line length is controlled by the max_line_length of the `policy` .", "question_id": 3230}
{"snippet": "email_message.as_string(unixfrom=False, maxheaderlen=None, policy=None)", "intent": "Return the entire message flattened as a string . When optional `unixfrom` is true , the envelope header is included in the returned string . For backward compatibility with the base Message class `maxheaderlen` is accepted , but defaults to None , which means that by default the line length is controlled by the max_line_length of the `policy` .", "question_id": 3231}
{"snippet": "email_message.__str__()", "intent": "Equivalent to as_string ( policy=self.policy.clone ( utf8=True ) ) .", "question_id": 3232}
{"snippet": "email_message.as_bytes()", "intent": "Return the entire message flattened as a bytes object .", "question_id": 3233}
{"snippet": "email_message.as_bytes(unixfrom=False)", "intent": "Return the entire message flattened as a bytes object . When optional `unixfrom` is true , the envelope header is included in the returned string .", "question_id": 3234}
{"snippet": "email_message.as_bytes(policy=None)", "intent": "Return the entire message flattened as a bytes object . The `policy` argument may be used to override the default policy obtained from the message instance .", "question_id": 3235}
{"snippet": "email_message.as_bytes(unixfrom=False, policy=None)", "intent": "Return the entire message flattened as a bytes object . When optional `unixfrom` is true , the envelope header is included in the returned string . The `policy` argument may be used to override the default policy obtained from the message instance .", "question_id": 3236}
{"snippet": "email_message.__bytes__()", "intent": "Equivalent to as_bytes ( ) .", "question_id": 3237}
{"snippet": "email_message.is_multipart()", "intent": "Return True if the message \u2019 s payload is a list of sub-EmailMessage objects , otherwise return False .", "question_id": 3238}
{"snippet": "email_message.set_unixfrom(unixfrom)", "intent": "Set the message \u2019 s envelope header to `unixfrom` , which should be a string .", "question_id": 3239}
{"snippet": "email_message.get_unixfrom()", "intent": "Return the message \u2019 s envelope header .", "question_id": 3240}
{"snippet": "email_message.__len__()", "intent": "Return the total number of headers , including duplicates .", "question_id": 3241}
{"snippet": "email_message.__contains__(name)", "intent": "Return true if the message object has a field named `name` .", "question_id": 3242}
{"snippet": "email_message.__getitem__(name)", "intent": "Return the value of the named header field . `name` does not include the colon field separator .", "question_id": 3243}
{"snippet": "email_message.__setitem__(name, val)", "intent": "Add a header to the message with field `name` name and value `val` .", "question_id": 3244}
{"snippet": "email_message.__delitem__(name)", "intent": "Delete all occurrences of the field with `name` name from the message \u2019 s headers .", "question_id": 3245}
{"snippet": "email_message.keys()", "intent": "Return a list of all the message \u2019 s header field names .", "question_id": 3246}
{"snippet": "email_message.values()", "intent": "Return a list of all the message \u2019 s field values .", "question_id": 3247}
{"snippet": "email_message.items()", "intent": "Return a list of 2-tuples containing all the message \u2019 s field headers and values .", "question_id": 3248}
{"snippet": "email_message.get(name)", "intent": "Return the value of the named header field . With arguments `name`.", "question_id": 3249}
{"snippet": "email_message.get(name, failobj=None)", "intent": "Return the value of the named header field . This is identical to __getitem__ ( ) except that optional `failobj` is returned if the named header is missing ( failobj defaults to None ) . With arguments `name`.", "question_id": 3250}
{"snippet": "email_message.get_all(name)", "intent": "Return a list of all the values for the field named `name` .", "question_id": 3251}
{"snippet": "email_message.get_all(name, failobj=None)", "intent": "Return a list of all the values for the field named `name` . If there are no such named headers in the message , `failobj` is returned ( defaults to None ) .", "question_id": 3252}
{"snippet": "email_message.add_header(_name, _value, **_params)", "intent": "Extended header setting . `_name` is the header field to add and `_value` is the primary value for the header . With arguments `**_params`.", "question_id": 3253}
{"snippet": "email_message.replace_header(_name, _value)", "intent": "Replace a header . Replace the first header found in the message that matches `_name` , retaining header order and field name case of the original header . With arguments `_value`.", "question_id": 3254}
{"snippet": "email_message.get_content_type()", "intent": "Return the message \u2019 s content type , coerced to lower case of the form maintype/subtype .", "question_id": 3255}
{"snippet": "email_message.get_content_maintype()", "intent": "Return the message \u2019 s main content type .", "question_id": 3256}
{"snippet": "email_message.get_content_subtype()", "intent": "Return the message \u2019 s sub-content type .", "question_id": 3257}
{"snippet": "email_message.get_default_type()", "intent": "Return the default content type .", "question_id": 3258}
{"snippet": "email_message.set_default_type(ctype)", "intent": "Set the default content type . `ctype` should either be text/plain or message/rfc822 , although this is not enforced .", "question_id": 3259}
{"snippet": "email_message.set_param(param, value)", "intent": "Set a parameter in the Content-Type `header` . If the parameter already exists in the header , `replace` its `value` with value . With arguments `param`.", "question_id": 3260}
{"snippet": "email_message.set_param(param, value, header='Content-Type')", "intent": "Set a parameter in the Content-Type `header` . If the parameter already exists in the header , `replace` its `value` with value . With arguments `param`.", "question_id": 3261}
{"snippet": "email_message.set_param(param, value, requote=True)", "intent": "Set a parameter in the Content-Type `header` . If the parameter already exists in the header , `replace` its `value` with value . Use of the `requote` parameter with EmailMessage objects is deprecated . With arguments `param`.", "question_id": 3262}
{"snippet": "email_message.set_param(param, value, charset=None)", "intent": "Set a parameter in the Content-Type `header` . If the parameter already exists in the header , `replace` its `value` with value . If the value contains non-ASCII characters , the `charset` and `language` may be explicitly specified using the optional charset and language parameters . With arguments `param`.", "question_id": 3263}
{"snippet": "email_message.set_param(param, value, language='')", "intent": "Set a parameter in the Content-Type `header` . If the parameter already exists in the header , `replace` its `value` with value . If the value contains non-ASCII characters , the `charset` and `language` may be explicitly specified using the optional charset and language parameters . With arguments `param`.", "question_id": 3264}
{"snippet": "email_message.set_param(param, value, replace=False)", "intent": "Set a parameter in the Content-Type `header` . If the parameter already exists in the header , `replace` its `value` with value . With arguments `param`.", "question_id": 3265}
{"snippet": "email_message.set_param(param, value, header='Content-Type', requote=True)", "intent": "Set a parameter in the Content-Type `header` . If the parameter already exists in the header , `replace` its `value` with value . Use of the `requote` parameter with EmailMessage objects is deprecated . With arguments `param`.", "question_id": 3266}
{"snippet": "email_message.set_param(param, value, header='Content-Type', charset=None)", "intent": "Set a parameter in the Content-Type `header` . If the parameter already exists in the header , `replace` its `value` with value . If the value contains non-ASCII characters , the `charset` and `language` may be explicitly specified using the optional charset and language parameters . With arguments `param`.", "question_id": 3267}
{"snippet": "email_message.set_param(param, value, header='Content-Type', language='')", "intent": "Set a parameter in the Content-Type `header` . If the parameter already exists in the header , `replace` its `value` with value . If the value contains non-ASCII characters , the `charset` and `language` may be explicitly specified using the optional charset and language parameters . With arguments `param`.", "question_id": 3268}
{"snippet": "email_message.set_param(param, value, header='Content-Type', replace=False)", "intent": "Set a parameter in the Content-Type `header` . If the parameter already exists in the header , `replace` its `value` with value . With arguments `param`.", "question_id": 3269}
{"snippet": "email_message.del_param(param)", "intent": "Remove the given parameter completely from the Content-Type `header` . With arguments `param`.", "question_id": 3270}
{"snippet": "email_message.del_param(param, header='content-type')", "intent": "Remove the given parameter completely from the Content-Type `header` . With arguments `param`.", "question_id": 3271}
{"snippet": "email_message.del_param(param, requote=True)", "intent": "Remove the given parameter completely from the Content-Type `header` . Use of the `requote` parameter with EmailMessage objects is deprecated . With arguments `param`.", "question_id": 3272}
{"snippet": "email_message.del_param(param, header='content-type', requote=True)", "intent": "Remove the given parameter completely from the Content-Type `header` . Use of the `requote` parameter with EmailMessage objects is deprecated . With arguments `param`.", "question_id": 3273}
{"snippet": "email_message.get_filename()", "intent": "Return the value of the filename parameter of the Content-Disposition header of the message .", "question_id": 3274}
{"snippet": "email_message.get_filename(failobj=None)", "intent": "Return the value of the filename parameter of the Content-Disposition header of the message . If neither is found , or the header is missing , then `failobj` is returned .", "question_id": 3275}
{"snippet": "email_message.get_boundary()", "intent": "Return the value of the boundary parameter of the Content-Type header of the message , or `failobj` if either the header is missing , or has no boundary parameter .", "question_id": 3276}
{"snippet": "email_message.get_boundary(failobj=None)", "intent": "Return the value of the boundary parameter of the Content-Type header of the message , or `failobj` if either the header is missing , or has no boundary parameter .", "question_id": 3277}
{"snippet": "email_message.set_boundary(boundary)", "intent": "Set the `boundary` parameter of the Content-Type header to boundary .", "question_id": 3278}
{"snippet": "email_message.get_content_charset()", "intent": "Return the charset parameter of the Content-Type header , coerced to lower case .", "question_id": 3279}
{"snippet": "email_message.get_content_charset(failobj=None)", "intent": "Return the charset parameter of the Content-Type header , coerced to lower case . If there is no Content-Type header , or if that header has no charset parameter , `failobj` is returned .", "question_id": 3280}
{"snippet": "email_message.get_charsets()", "intent": "Return a list containing the character set names in the message .", "question_id": 3281}
{"snippet": "email_message.get_charsets(failobj=None)", "intent": "Return a list containing the character set names in the message . If the subpart has no Content-Type header , no charset parameter , or is not of the text main MIME type , then that item in the returned list will be `failobj` .", "question_id": 3282}
{"snippet": "email_message.is_attachment()", "intent": "Return True if there is a Content-Disposition header and its ( case insensitive ) value is attachment , False otherwise .", "question_id": 3283}
{"snippet": "email_message.get_content_disposition()", "intent": "Return the lowercased value ( without parameters ) of the message \u2019 s Content-Disposition header if it has one , or None .", "question_id": 3284}
{"snippet": "email_message.walk()", "intent": "The walk ( ) method is an all-purpose generator which can be used to iterate over all the parts and subparts of a message object tree , in depth-first traversal order .", "question_id": 3285}
{"snippet": "email_message.get_body('html', 'plain'))", "intent": "Return the MIME part that is the best candidate to be the \u201c body \u201d of the message . With arguments `'html'`, `'plain')`.", "question_id": 3286}
{"snippet": "email_message.get_body('html', 'plain'), preferencelist=('related')", "intent": "Return the MIME part that is the best candidate to be the \u201c body \u201d of the message . `preferencelist` must be a sequence of strings from the set related , html , and plain , and indicates the order of preference for the content type of the part returned . With arguments `'html'`, `'plain')`.", "question_id": 3287}
{"snippet": "email_message.iter_attachments()", "intent": "Return an iterator over all of the immediate sub-parts of the message that are not candidate \u201c body \u201d parts .", "question_id": 3288}
{"snippet": "email_message.iter_parts()", "intent": "Return an iterator over all of the immediate sub-parts of the message , which will be empty for a non-multipart .", "question_id": 3289}
{"snippet": "email_message.get_content(*args, **kw)", "intent": "Call the get_content ( ) method of the `content_manager` , passing self as the message object , and passing along any other arguments or keywords as additional arguments . With arguments `*args`, `**kw`.", "question_id": 3290}
{"snippet": "email_message.get_content(*args, **kw, content_manager=None)", "intent": "Call the get_content ( ) method of the `content_manager` , passing self as the message object , and passing along any other arguments or keywords as additional arguments . With arguments `*args`, `**kw`.", "question_id": 3291}
{"snippet": "email_message.set_content(*args, **kw)", "intent": "Call the set_content ( ) method of the `content_manager` , passing self as the message object , and passing along any other arguments or keywords as additional arguments . With arguments `*args`, `**kw`.", "question_id": 3292}
{"snippet": "email_message.set_content(*args, **kw, content_manager=None)", "intent": "Call the set_content ( ) method of the `content_manager` , passing self as the message object , and passing along any other arguments or keywords as additional arguments . With arguments `*args`, `**kw`.", "question_id": 3293}
{"snippet": "email_message.make_related()", "intent": "Convert a non-multipart message into a multipart/related message , moving any existing Content- headers and payload into a ( new ) first part of the multipart .", "question_id": 3294}
{"snippet": "email_message.make_related(boundary=None)", "intent": "Convert a non-multipart message into a multipart/related message , moving any existing Content- headers and payload into a ( new ) first part of the multipart . If `boundary` is specified , use it as the boundary string in the multipart , otherwise leave the boundary to be automatically created when it is needed ( for example , when the message is serialized ) .", "question_id": 3295}
{"snippet": "email_message.make_alternative()", "intent": "Convert a non-multipart or a multipart/related into a multipart/alternative , moving any existing Content- headers and payload into a ( new ) first part of the multipart .", "question_id": 3296}
{"snippet": "email_message.make_alternative(boundary=None)", "intent": "Convert a non-multipart or a multipart/related into a multipart/alternative , moving any existing Content- headers and payload into a ( new ) first part of the multipart . If `boundary` is specified , use it as the boundary string in the multipart , otherwise leave the boundary to be automatically created when it is needed ( for example , when the message is serialized ) .", "question_id": 3297}
{"snippet": "email_message.make_mixed()", "intent": "Convert a non-multipart , a multipart/related , or a multipart-alternative into a multipart/mixed , moving any existing Content- headers and payload into a ( new ) first part of the multipart .", "question_id": 3298}
{"snippet": "email_message.make_mixed(boundary=None)", "intent": "Convert a non-multipart , a multipart/related , or a multipart-alternative into a multipart/mixed , moving any existing Content- headers and payload into a ( new ) first part of the multipart . If `boundary` is specified , use it as the boundary string in the multipart , otherwise leave the boundary to be automatically created when it is needed ( for example , when the message is serialized ) .", "question_id": 3299}
{"snippet": "email_message.add_related(*args, **kw)", "intent": "If the message is a multipart/related , create a new message object , pass all of the arguments to its set_content ( ) method , and attach ( ) it to the multipart . With arguments `*args`, `**kw`.", "question_id": 3300}
{"snippet": "email_message.add_related(*args, **kw, content_manager=None)", "intent": "If the message is a multipart/related , create a new message object , pass all of the arguments to its set_content ( ) method , and attach ( ) it to the multipart . If `content_manager` is not specified , use the content_manager specified by the current policy . With arguments `*args`, `**kw`.", "question_id": 3301}
{"snippet": "email_message.add_alternative(*args, **kw)", "intent": "If the message is a multipart/alternative , create a new message object , pass all of the arguments to its set_content ( ) method , and attach ( ) it to the multipart . With arguments `*args`, `**kw`.", "question_id": 3302}
{"snippet": "email_message.add_alternative(*args, **kw, content_manager=None)", "intent": "If the message is a multipart/alternative , create a new message object , pass all of the arguments to its set_content ( ) method , and attach ( ) it to the multipart . If `content_manager` is not specified , use the content_manager specified by the current policy . With arguments `*args`, `**kw`.", "question_id": 3303}
{"snippet": "email_message.add_attachment(*args, **kw)", "intent": "If the message is a multipart/mixed , create a new message object , pass all of the arguments to its set_content ( ) method , and attach ( ) it to the multipart . With arguments `*args`, `**kw`.", "question_id": 3304}
{"snippet": "email_message.add_attachment(*args, **kw, content_manager=None)", "intent": "If the message is a multipart/mixed , create a new message object , pass all of the arguments to its set_content ( ) method , and attach ( ) it to the multipart . If `content_manager` is not specified , use the content_manager specified by the current policy . With arguments `*args`, `**kw`.", "question_id": 3305}
{"snippet": "email_message.clear()", "intent": "Remove the payload and all of the headers .", "question_id": 3306}
{"snippet": "email_message.clear_content()", "intent": "Remove the payload and all of the Content- headers , leaving all other headers intact and in their original order .", "question_id": 3307}
{"snippet": "email_message.preamble", "intent": "The format of a MIME document allows for some text between the blank line following the headers, and the first multipart boundary string.", "question_id": 3308}
{"snippet": "email_message.epilogue", "intent": "The epilogue attribute acts the same way as the preamble attribute, except that it contains text that appears between the last boundary and the end of the message.", "question_id": 3309}
{"snippet": "email_message.defects", "intent": "The defects attribute contains a list of all the problems found when parsing this message.", "question_id": 3310}
{"snippet": "email.message.MIMEPart()", "intent": "This class represents a subpart of a MIME message .", "question_id": 3311}
{"snippet": "email.message.MIMEPart(policy=default)", "intent": "This class represents a subpart of a MIME message . With arguments `policy`.", "question_id": 3312}
{"snippet": "email.mime.base.MIMEBase(_maintype, _subtype, **_params)", "intent": "Module : email.mime.base `_maintype` is the Content-Type major type ( e.g . text or image ) , and `_subtype` is the Content-Type minor type ( e.g . With arguments `**_params`.", "question_id": 3313}
{"snippet": "email.mime.base.MIMEBase(_maintype, _subtype, **_params, policy=compat32)", "intent": "Module : email.mime.base `_maintype` is the Content-Type major type ( e.g . text or image ) , and `_subtype` is the Content-Type minor type ( e.g . If `policy` is specified , ( defaults to the compat32 policy ) it will be passed to Message . With arguments `**_params`.", "question_id": 3314}
{"snippet": "email.mime.nonmultipart.MIMENonMultipart", "intent": "Module: email.mime.nonmultipart", "question_id": 3315}
{"snippet": "email.mime.multipart.MIMEMultipart(**_params)", "intent": "Module : email.mime.multipart With arguments `**_params`.", "question_id": 3316}
{"snippet": "email.mime.multipart.MIMEMultipart(**_params, _subtype='mixed')", "intent": "Module : email.mime.multipart Optional `_subtype` defaults to mixed , but can be used to specify the subtype of the message . With arguments `**_params`.", "question_id": 3317}
{"snippet": "email.mime.multipart.MIMEMultipart(**_params, boundary=None)", "intent": "Module : email.mime.multipart Optional `boundary` is the multipart boundary string . With arguments `**_params`.", "question_id": 3318}
{"snippet": "email.mime.multipart.MIMEMultipart(**_params, _subparts=None)", "intent": "Module : email.mime.multipart `_subparts` is a sequence of initial subparts for the payload . With arguments `**_params`.", "question_id": 3319}
{"snippet": "email.mime.multipart.MIMEMultipart(**_params, policy=compat32)", "intent": "Module : email.mime.multipart Optional `policy` argument defaults to compat32 . With arguments `**_params`.", "question_id": 3320}
{"snippet": "email.mime.multipart.MIMEMultipart(**_params, _subtype='mixed', boundary=None)", "intent": "Module : email.mime.multipart Optional `_subtype` defaults to mixed , but can be used to specify the subtype of the message . Optional `boundary` is the multipart boundary string . With arguments `**_params`.", "question_id": 3321}
{"snippet": "email.mime.multipart.MIMEMultipart(**_params, _subtype='mixed', _subparts=None)", "intent": "Module : email.mime.multipart Optional `_subtype` defaults to mixed , but can be used to specify the subtype of the message . `_subparts` is a sequence of initial subparts for the payload . With arguments `**_params`.", "question_id": 3322}
{"snippet": "email.mime.multipart.MIMEMultipart(**_params, _subtype='mixed', policy=compat32)", "intent": "Module : email.mime.multipart Optional `_subtype` defaults to mixed , but can be used to specify the subtype of the message . Optional `policy` argument defaults to compat32 . With arguments `**_params`.", "question_id": 3323}
{"snippet": "email.mime.multipart.MIMEMultipart(**_params, boundary=None, _subparts=None)", "intent": "Module : email.mime.multipart Optional `boundary` is the multipart boundary string . `_subparts` is a sequence of initial subparts for the payload . With arguments `**_params`.", "question_id": 3324}
{"snippet": "email.mime.multipart.MIMEMultipart(**_params, boundary=None, policy=compat32)", "intent": "Module : email.mime.multipart Optional `boundary` is the multipart boundary string . Optional `policy` argument defaults to compat32 . With arguments `**_params`.", "question_id": 3325}
{"snippet": "email.mime.application.MIMEApplication(_data, **_params)", "intent": "Module : email.mime.application `_data` is a string containing the raw byte data . With arguments `**_params`.", "question_id": 3326}
{"snippet": "email.mime.application.MIMEApplication(_data, **_params, _subtype='octet-stream')", "intent": "Module : email.mime.application `_data` is a string containing the raw byte data . Optional `_subtype` specifies the MIME subtype and defaults to octet-stream . With arguments `**_params`.", "question_id": 3327}
{"snippet": "email.mime.application.MIMEApplication(_data, **_params, _encoder=email.encoders.encode_base64)", "intent": "Module : email.mime.application `_data` is a string containing the raw byte data . Optional `_encoder` is a callable ( i.e . With arguments `**_params`.", "question_id": 3328}
{"snippet": "email.mime.application.MIMEApplication(_data, **_params, policy=compat32)", "intent": "Module : email.mime.application `_data` is a string containing the raw byte data . Optional `policy` argument defaults to compat32 . With arguments `**_params`.", "question_id": 3329}
{"snippet": "email.mime.application.MIMEApplication(_data, **_params, _subtype='octet-stream', _encoder=email.encoders.encode_base64)", "intent": "Module : email.mime.application `_data` is a string containing the raw byte data . Optional `_subtype` specifies the MIME subtype and defaults to octet-stream . Optional `_encoder` is a callable ( i.e . With arguments `**_params`.", "question_id": 3330}
{"snippet": "email.mime.application.MIMEApplication(_data, **_params, _subtype='octet-stream', policy=compat32)", "intent": "Module : email.mime.application `_data` is a string containing the raw byte data . Optional `_subtype` specifies the MIME subtype and defaults to octet-stream . Optional `policy` argument defaults to compat32 . With arguments `**_params`.", "question_id": 3331}
{"snippet": "email.mime.application.MIMEApplication(_data, **_params, _encoder=email.encoders.encode_base64, policy=compat32)", "intent": "Module : email.mime.application `_data` is a string containing the raw byte data . Optional `_encoder` is a callable ( i.e . Optional `policy` argument defaults to compat32 . With arguments `**_params`.", "question_id": 3332}
{"snippet": "email.mime.application.MIMEApplication(_data, **_params, _subtype='octet-stream', _encoder=email.encoders.encode_base64, policy=compat32)", "intent": "Module : email.mime.application `_data` is a string containing the raw byte data . Optional `_subtype` specifies the MIME subtype and defaults to octet-stream . Optional `_encoder` is a callable ( i.e . Optional `policy` argument defaults to compat32 . With arguments `**_params`.", "question_id": 3333}
{"snippet": "email.mime.audio.MIMEAudio(_audiodata, **_params)", "intent": "Module : email.mime.audio `_audiodata` is a string containing the raw audio data . With arguments `**_params`.", "question_id": 3334}
{"snippet": "email.mime.audio.MIMEAudio(_audiodata, **_params, _subtype=None)", "intent": "Module : email.mime.audio `_audiodata` is a string containing the raw audio data . Otherwise you can explicitly specify the audio subtype via the `_subtype` argument . With arguments `**_params`.", "question_id": 3335}
{"snippet": "email.mime.audio.MIMEAudio(_audiodata, **_params, _encoder=email.encoders.encode_base64)", "intent": "Module : email.mime.audio `_audiodata` is a string containing the raw audio data . Optional `_encoder` is a callable ( i.e . With arguments `**_params`.", "question_id": 3336}
{"snippet": "email.mime.audio.MIMEAudio(_audiodata, **_params, policy=compat32)", "intent": "Module : email.mime.audio `_audiodata` is a string containing the raw audio data . Optional `policy` argument defaults to compat32 . With arguments `**_params`.", "question_id": 3337}
{"snippet": "email.mime.audio.MIMEAudio(_audiodata, **_params, _subtype=None, _encoder=email.encoders.encode_base64)", "intent": "Module : email.mime.audio `_audiodata` is a string containing the raw audio data . Otherwise you can explicitly specify the audio subtype via the `_subtype` argument . Optional `_encoder` is a callable ( i.e . With arguments `**_params`.", "question_id": 3338}
{"snippet": "email.mime.audio.MIMEAudio(_audiodata, **_params, _subtype=None, policy=compat32)", "intent": "Module : email.mime.audio `_audiodata` is a string containing the raw audio data . Otherwise you can explicitly specify the audio subtype via the `_subtype` argument . Optional `policy` argument defaults to compat32 . With arguments `**_params`.", "question_id": 3339}
{"snippet": "email.mime.audio.MIMEAudio(_audiodata, **_params, _encoder=email.encoders.encode_base64, policy=compat32)", "intent": "Module : email.mime.audio `_audiodata` is a string containing the raw audio data . Optional `_encoder` is a callable ( i.e . Optional `policy` argument defaults to compat32 . With arguments `**_params`.", "question_id": 3340}
{"snippet": "email.mime.audio.MIMEAudio(_audiodata, **_params, _subtype=None, _encoder=email.encoders.encode_base64, policy=compat32)", "intent": "Module : email.mime.audio `_audiodata` is a string containing the raw audio data . Otherwise you can explicitly specify the audio subtype via the `_subtype` argument . Optional `_encoder` is a callable ( i.e . Optional `policy` argument defaults to compat32 . With arguments `**_params`.", "question_id": 3341}
{"snippet": "email.mime.image.MIMEImage(_imagedata, **_params)", "intent": "Module : email.mime.image `_imagedata` is a string containing the raw image data . With arguments `**_params`.", "question_id": 3342}
{"snippet": "email.mime.image.MIMEImage(_imagedata, **_params, _subtype=None)", "intent": "Module : email.mime.image `_imagedata` is a string containing the raw image data . Otherwise you can explicitly specify the image subtype via the `_subtype` argument . With arguments `**_params`.", "question_id": 3343}
{"snippet": "email.mime.image.MIMEImage(_imagedata, **_params, _encoder=email.encoders.encode_base64)", "intent": "Module : email.mime.image `_imagedata` is a string containing the raw image data . Optional `_encoder` is a callable ( i.e . With arguments `**_params`.", "question_id": 3344}
{"snippet": "email.mime.image.MIMEImage(_imagedata, **_params, policy=compat32)", "intent": "Module : email.mime.image `_imagedata` is a string containing the raw image data . Optional `policy` argument defaults to compat32 . With arguments `**_params`.", "question_id": 3345}
{"snippet": "email.mime.image.MIMEImage(_imagedata, **_params, _subtype=None, _encoder=email.encoders.encode_base64)", "intent": "Module : email.mime.image `_imagedata` is a string containing the raw image data . Otherwise you can explicitly specify the image subtype via the `_subtype` argument . Optional `_encoder` is a callable ( i.e . With arguments `**_params`.", "question_id": 3346}
{"snippet": "email.mime.image.MIMEImage(_imagedata, **_params, _subtype=None, policy=compat32)", "intent": "Module : email.mime.image `_imagedata` is a string containing the raw image data . Otherwise you can explicitly specify the image subtype via the `_subtype` argument . Optional `policy` argument defaults to compat32 . With arguments `**_params`.", "question_id": 3347}
{"snippet": "email.mime.image.MIMEImage(_imagedata, **_params, _encoder=email.encoders.encode_base64, policy=compat32)", "intent": "Module : email.mime.image `_imagedata` is a string containing the raw image data . Optional `_encoder` is a callable ( i.e . Optional `policy` argument defaults to compat32 . With arguments `**_params`.", "question_id": 3348}
{"snippet": "email.mime.image.MIMEImage(_imagedata, **_params, _subtype=None, _encoder=email.encoders.encode_base64, policy=compat32)", "intent": "Module : email.mime.image `_imagedata` is a string containing the raw image data . Otherwise you can explicitly specify the image subtype via the `_subtype` argument . Optional `_encoder` is a callable ( i.e . Optional `policy` argument defaults to compat32 . With arguments `**_params`.", "question_id": 3349}
{"snippet": "email.mime.message.MIMEMessage(_msg)", "intent": "Module : email.mime.message `_msg` is used as the payload , and must be an instance of class Message ( or a subclass thereof ) , otherwise a TypeError is raised .", "question_id": 3350}
{"snippet": "email.mime.message.MIMEMessage(_msg, _subtype='rfc822')", "intent": "Module : email.mime.message `_msg` is used as the payload , and must be an instance of class Message ( or a subclass thereof ) , otherwise a TypeError is raised . Optional `_subtype` sets the subtype of the message ; it defaults to rfc822 .", "question_id": 3351}
{"snippet": "email.mime.message.MIMEMessage(_msg, policy=compat32)", "intent": "Module : email.mime.message `_msg` is used as the payload , and must be an instance of class Message ( or a subclass thereof ) , otherwise a TypeError is raised . Optional `policy` argument defaults to compat32 .", "question_id": 3352}
{"snippet": "email.mime.message.MIMEMessage(_msg, _subtype='rfc822', policy=compat32)", "intent": "Module : email.mime.message `_msg` is used as the payload , and must be an instance of class Message ( or a subclass thereof ) , otherwise a TypeError is raised . Optional `_subtype` sets the subtype of the message ; it defaults to rfc822 . Optional `policy` argument defaults to compat32 .", "question_id": 3353}
{"snippet": "email.mime.text.MIMEText(_text)", "intent": "Module : email.mime.text `_text` is the string for the payload .", "question_id": 3354}
{"snippet": "email.mime.text.MIMEText(_text, _subtype='plain')", "intent": "Module : email.mime.text `_text` is the string for the payload . `_subtype` is the minor type and defaults to plain .", "question_id": 3355}
{"snippet": "email.mime.text.MIMEText(_text, _charset=None)", "intent": "Module : email.mime.text `_text` is the string for the payload . `_charset` is the character set of the text and is passed as an argument to the MIMENonMultipart constructor ; it defaults to us-ascii if the string contains only ascii code points , and utf-8 otherwise .", "question_id": 3356}
{"snippet": "email.mime.text.MIMEText(_text, policy=compat32)", "intent": "Module : email.mime.text `_text` is the string for the payload . Optional `policy` argument defaults to compat32 .", "question_id": 3357}
{"snippet": "email.mime.text.MIMEText(_text, _subtype='plain', _charset=None)", "intent": "Module : email.mime.text `_text` is the string for the payload . `_subtype` is the minor type and defaults to plain . `_charset` is the character set of the text and is passed as an argument to the MIMENonMultipart constructor ; it defaults to us-ascii if the string contains only ascii code points , and utf-8 otherwise .", "question_id": 3358}
{"snippet": "email.mime.text.MIMEText(_text, _subtype='plain', policy=compat32)", "intent": "Module : email.mime.text `_text` is the string for the payload . `_subtype` is the minor type and defaults to plain . Optional `policy` argument defaults to compat32 .", "question_id": 3359}
{"snippet": "email.mime.text.MIMEText(_text, _charset=None, policy=compat32)", "intent": "Module : email.mime.text `_text` is the string for the payload . `_charset` is the character set of the text and is passed as an argument to the MIMENonMultipart constructor ; it defaults to us-ascii if the string contains only ascii code points , and utf-8 otherwise . Optional `policy` argument defaults to compat32 .", "question_id": 3360}
{"snippet": "email.mime.text.MIMEText(_text, _subtype='plain', _charset=None, policy=compat32)", "intent": "Module : email.mime.text `_text` is the string for the payload . `_subtype` is the minor type and defaults to plain . `_charset` is the character set of the text and is passed as an argument to the MIMENonMultipart constructor ; it defaults to us-ascii if the string contains only ascii code points , and utf-8 otherwise . Optional `policy` argument defaults to compat32 .", "question_id": 3361}
{"snippet": "email.parser.BytesFeedParser()", "intent": "Create a BytesFeedParser instance .", "question_id": 3362}
{"snippet": "email.parser.BytesFeedParser(_factory=None)", "intent": "Create a BytesFeedParser instance . Optional `_factory` is a no-argument callable ; if not specified use the message_factory from the `policy` .", "question_id": 3363}
{"snippet": "email.parser.BytesFeedParser(policy=policy.compat32)", "intent": "Create a BytesFeedParser instance . Optional `_factory` is a no-argument callable ; if not specified use the message_factory from the `policy` .", "question_id": 3364}
{"snippet": "email.parser.BytesFeedParser(_factory=None, policy=policy.compat32)", "intent": "Create a BytesFeedParser instance . Optional `_factory` is a no-argument callable ; if not specified use the message_factory from the `policy` .", "question_id": 3365}
{"snippet": "bytes_feed_parser.feed(data)", "intent": "Feed the parser some more `data` .", "question_id": 3366}
{"snippet": "bytes_feed_parser.close()", "intent": "Complete the parsing of all previously fed data and return the root message object .", "question_id": 3367}
{"snippet": "email.parser.FeedParser()", "intent": "Works like BytesFeedParser except that the input to the feed ( ) method must be a string .", "question_id": 3368}
{"snippet": "email.parser.FeedParser(_factory=None)", "intent": "Works like BytesFeedParser except that the input to the feed ( ) method must be a string . With arguments `_factory`.", "question_id": 3369}
{"snippet": "email.parser.FeedParser(policy=policy.compat32)", "intent": "Works like BytesFeedParser except that the input to the feed ( ) method must be a string . With arguments `policy`.", "question_id": 3370}
{"snippet": "email.parser.FeedParser(_factory=None, policy=policy.compat32)", "intent": "Works like BytesFeedParser except that the input to the feed ( ) method must be a string . With arguments `_factory`, `policy`.", "question_id": 3371}
{"snippet": "email.parser.BytesParser()", "intent": "Create a BytesParser instance .", "question_id": 3372}
{"snippet": "email.parser.BytesParser(_class=None)", "intent": "Create a BytesParser instance . The `_class` and `policy` arguments have the same meaning and semantics as the _factory and policy arguments of BytesFeedParser .", "question_id": 3373}
{"snippet": "email.parser.BytesParser(policy=policy.compat32)", "intent": "Create a BytesParser instance . The `_class` and `policy` arguments have the same meaning and semantics as the _factory and policy arguments of BytesFeedParser .", "question_id": 3374}
{"snippet": "email.parser.BytesParser(_class=None, policy=policy.compat32)", "intent": "Create a BytesParser instance . The `_class` and `policy` arguments have the same meaning and semantics as the _factory and policy arguments of BytesFeedParser .", "question_id": 3375}
{"snippet": "bytes_parser.parse(fp)", "intent": "Read all the data from the binary file-like object `fp` , parse the resulting bytes , and return the message object .", "question_id": 3376}
{"snippet": "bytes_parser.parse(fp, headersonly=False)", "intent": "Read all the data from the binary file-like object `fp` , parse the resulting bytes , and return the message object . Optional `headersonly` is a flag specifying whether to stop parsing after reading the headers or not .", "question_id": 3377}
{"snippet": "bytes_parser.parsebytes(bytes)", "intent": "Similar to the parse ( ) method , except it takes a bytes-like object instead of a file-like object . Calling this method on a bytes-like object is equivalent to wrapping `bytes` in a BytesIO instance first and calling parse ( ) .", "question_id": 3378}
{"snippet": "bytes_parser.parsebytes(bytes, headersonly=False)", "intent": "Similar to the parse ( ) method , except it takes a bytes-like object instead of a file-like object . Calling this method on a bytes-like object is equivalent to wrapping `bytes` in a BytesIO instance first and calling parse ( ) . Optional `headersonly` is as with the parse ( ) method .", "question_id": 3379}
{"snippet": "email.parser.BytesHeaderParser()", "intent": "Exactly like BytesParser , except that headersonly defaults to True .", "question_id": 3380}
{"snippet": "email.parser.BytesHeaderParser(_class=None)", "intent": "Exactly like BytesParser , except that headersonly defaults to True . With arguments `_class`.", "question_id": 3381}
{"snippet": "email.parser.BytesHeaderParser(policy=policy.compat32)", "intent": "Exactly like BytesParser , except that headersonly defaults to True . With arguments `policy`.", "question_id": 3382}
{"snippet": "email.parser.BytesHeaderParser(_class=None, policy=policy.compat32)", "intent": "Exactly like BytesParser , except that headersonly defaults to True . With arguments `_class`, `policy`.", "question_id": 3383}
{"snippet": "email.parser.Parser()", "intent": "This class is parallel to BytesParser , but handles string input .", "question_id": 3384}
{"snippet": "email.parser.Parser(_class=None)", "intent": "This class is parallel to BytesParser , but handles string input . With arguments `_class`.", "question_id": 3385}
{"snippet": "email.parser.Parser(policy=policy.compat32)", "intent": "This class is parallel to BytesParser , but handles string input . With arguments `policy`.", "question_id": 3386}
{"snippet": "email.parser.Parser(_class=None, policy=policy.compat32)", "intent": "This class is parallel to BytesParser , but handles string input . With arguments `_class`, `policy`.", "question_id": 3387}
{"snippet": "parser.parse(fp)", "intent": "Read all the data from the text-mode file-like object `fp` , parse the resulting text , and return the root message object .", "question_id": 3388}
{"snippet": "parser.parse(fp, headersonly=False)", "intent": "Read all the data from the text-mode file-like object `fp` , parse the resulting text , and return the root message object . With arguments `headersonly`.", "question_id": 3389}
{"snippet": "parser.parsestr(text)", "intent": "Similar to the parse ( ) method , except it takes a string object instead of a file-like object . Calling this method on a string is equivalent to wrapping `text` in a StringIO instance first and calling parse ( ) .", "question_id": 3390}
{"snippet": "parser.parsestr(text, headersonly=False)", "intent": "Similar to the parse ( ) method , except it takes a string object instead of a file-like object . Calling this method on a string is equivalent to wrapping `text` in a StringIO instance first and calling parse ( ) . Optional `headersonly` is as with the parse ( ) method .", "question_id": 3391}
{"snippet": "email.parser.HeaderParser()", "intent": "Exactly like Parser , except that headersonly defaults to True .", "question_id": 3392}
{"snippet": "email.parser.HeaderParser(_class=None)", "intent": "Exactly like Parser , except that headersonly defaults to True . With arguments `_class`.", "question_id": 3393}
{"snippet": "email.parser.HeaderParser(policy=policy.compat32)", "intent": "Exactly like Parser , except that headersonly defaults to True . With arguments `policy`.", "question_id": 3394}
{"snippet": "email.parser.HeaderParser(_class=None, policy=policy.compat32)", "intent": "Exactly like Parser , except that headersonly defaults to True . With arguments `_class`, `policy`.", "question_id": 3395}
{"snippet": "email.message_from_bytes(s)", "intent": "Return a message object structure from a bytes-like object . This is equivalent to BytesParser ( ) .parsebytes ( `s` ) .", "question_id": 3396}
{"snippet": "email.message_from_bytes(s, _class=None)", "intent": "Return a message object structure from a bytes-like object . This is equivalent to BytesParser ( ) .parsebytes ( `s` ) . Optional `_class` and `policy` are interpreted as with the BytesParser class constructor .", "question_id": 3397}
{"snippet": "email.message_from_bytes(s, policy=policy.compat32)", "intent": "Return a message object structure from a bytes-like object . This is equivalent to BytesParser ( ) .parsebytes ( `s` ) . Optional `_class` and `policy` are interpreted as with the BytesParser class constructor .", "question_id": 3398}
{"snippet": "email.message_from_bytes(s, _class=None, policy=policy.compat32)", "intent": "Return a message object structure from a bytes-like object . This is equivalent to BytesParser ( ) .parsebytes ( `s` ) . Optional `_class` and `policy` are interpreted as with the BytesParser class constructor .", "question_id": 3399}
{"snippet": "email.message_from_binary_file(fp)", "intent": "Return a message object structure tree from an open binary file object . This is equivalent to BytesParser ( ) .parse ( `fp` ) .", "question_id": 3400}
{"snippet": "email.message_from_binary_file(fp, _class=None)", "intent": "Return a message object structure tree from an open binary file object . This is equivalent to BytesParser ( ) .parse ( `fp` ) . `_class` and `policy` are interpreted as with the BytesParser class constructor .", "question_id": 3401}
{"snippet": "email.message_from_binary_file(fp, policy=policy.compat32)", "intent": "Return a message object structure tree from an open binary file object . This is equivalent to BytesParser ( ) .parse ( `fp` ) . `_class` and `policy` are interpreted as with the BytesParser class constructor .", "question_id": 3402}
{"snippet": "email.message_from_binary_file(fp, _class=None, policy=policy.compat32)", "intent": "Return a message object structure tree from an open binary file object . This is equivalent to BytesParser ( ) .parse ( `fp` ) . `_class` and `policy` are interpreted as with the BytesParser class constructor .", "question_id": 3403}
{"snippet": "email.message_from_string(s)", "intent": "Return a message object structure from a string . This is equivalent to Parser ( ) .parsestr ( `s` ) .", "question_id": 3404}
{"snippet": "email.message_from_string(s, _class=None)", "intent": "Return a message object structure from a string . This is equivalent to Parser ( ) .parsestr ( `s` ) . `_class` and `policy` are interpreted as with the Parser class constructor .", "question_id": 3405}
{"snippet": "email.message_from_string(s, policy=policy.compat32)", "intent": "Return a message object structure from a string . This is equivalent to Parser ( ) .parsestr ( `s` ) . `_class` and `policy` are interpreted as with the Parser class constructor .", "question_id": 3406}
{"snippet": "email.message_from_string(s, _class=None, policy=policy.compat32)", "intent": "Return a message object structure from a string . This is equivalent to Parser ( ) .parsestr ( `s` ) . `_class` and `policy` are interpreted as with the Parser class constructor .", "question_id": 3407}
{"snippet": "email.message_from_file(fp)", "intent": "Return a message object structure tree from an open file object . This is equivalent to Parser ( ) .parse ( `fp` ) .", "question_id": 3408}
{"snippet": "email.message_from_file(fp, _class=None)", "intent": "Return a message object structure tree from an open file object . This is equivalent to Parser ( ) .parse ( `fp` ) . `_class` and `policy` are interpreted as with the Parser class constructor .", "question_id": 3409}
{"snippet": "email.message_from_file(fp, policy=policy.compat32)", "intent": "Return a message object structure tree from an open file object . This is equivalent to Parser ( ) .parse ( `fp` ) . `_class` and `policy` are interpreted as with the Parser class constructor .", "question_id": 3410}
{"snippet": "email.message_from_file(fp, _class=None, policy=policy.compat32)", "intent": "Return a message object structure tree from an open file object . This is equivalent to Parser ( ) .parse ( `fp` ) . `_class` and `policy` are interpreted as with the Parser class constructor .", "question_id": 3411}
{"snippet": "email.policy.Policy(**kw)", "intent": "This is the abstract base class for all policy classes . With arguments `**kw`.", "question_id": 3412}
{"snippet": "policy.max_line_length", "intent": "The maximum length of any line in the serialized output, not counting the end of line character(s).", "question_id": 3413}
{"snippet": "policy.linesep", "intent": "The string to be used to terminate lines in serialized output.", "question_id": 3414}
{"snippet": "policy.cte_type", "intent": "Controls the type of Content Transfer Encodings that may be or are required to be used.", "question_id": 3415}
{"snippet": "policy.raise_on_defect", "intent": "If True, any defects encountered will be raised as errors.", "question_id": 3416}
{"snippet": "policy.mangle_from_", "intent": "If True, lines starting with \u201cFrom \u201c in the body are escaped by putting a > in front of them.", "question_id": 3417}
{"snippet": "policy.message_factory", "intent": "A factory function for constructing a new empty message object.", "question_id": 3418}
{"snippet": "policy.clone(**kw)", "intent": "Return a new Policy instance whose attributes have the same values as the current instance , except where those attributes are given new values by the keyword arguments . With arguments `**kw`.", "question_id": 3419}
{"snippet": "policy.handle_defect(obj, defect)", "intent": "Handle a `defect` found on `obj` .", "question_id": 3420}
{"snippet": "policy.register_defect(obj, defect)", "intent": "Register a `defect` on `obj` .", "question_id": 3421}
{"snippet": "policy.header_max_count(name)", "intent": "Return the maximum allowed number of headers named `name` .", "question_id": 3422}
{"snippet": "policy.header_source_parse(sourcelines)", "intent": "The email package calls this method with a list of strings , each string ending with the line separation characters found in the source being parsed . `sourcelines` may contain surrogateescaped binary data .", "question_id": 3423}
{"snippet": "policy.header_store_parse(name, value)", "intent": "The email package calls this method with the `name` and `value` provided by the application program when the application program is modifying a Message programmatically ( as opposed to a Message created by a parser ) .", "question_id": 3424}
{"snippet": "policy.header_fetch_parse(name, value)", "intent": "The email package calls this method with the `name` and `value` currently stored in the Message when that header is requested by the application program , and whatever the method returns is what is passed back to the application as the value of the header being retrieved .", "question_id": 3425}
{"snippet": "policy.fold(name, value)", "intent": "The email package calls this method with the `name` and `value` currently stored in the Message for a given header .", "question_id": 3426}
{"snippet": "policy.fold_binary(name, value)", "intent": "The same as fold ( ) , except that the returned `value` should be a bytes object rather than a string . With arguments `name`.", "question_id": 3427}
{"snippet": "email.policy.EmailPolicy(**kw)", "intent": "This concrete Policy provides behavior that is intended to be fully compliant with the current email RFCs . With arguments `**kw`.", "question_id": 3428}
{"snippet": "email_policy.utf8", "intent": "If False, follow RFC 5322, supporting non-ASCII characters in headers by encoding them as \u201cencoded words\u201d.", "question_id": 3429}
{"snippet": "email_policy.refold_source", "intent": "If the value for a header in the Message object originated from a parser (as opposed to being set by a program), this attribute indicates whether or not a generator should refold that value when transforming the message back into serialized form.", "question_id": 3430}
{"snippet": "email_policy.header_factory", "intent": "A callable that takes two arguments, name and value, where name is a header field name and value is an unfolded header field value, and returns a string subclass that represents that header.", "question_id": 3431}
{"snippet": "email_policy.content_manager", "intent": "An object with at least two methods: get_content and set_content.", "question_id": 3432}
{"snippet": "email_policy.header_max_count(name)", "intent": "Returns the value of the max_count attribute of the specialized class used to represent the header with the given `name` .", "question_id": 3433}
{"snippet": "email_policy.header_source_parse(sourcelines)", "intent": "The name is parsed as everything up to the \u2018 : \u2019 and returned unmodified . With arguments `sourcelines`.", "question_id": 3434}
{"snippet": "email_policy.header_store_parse(name, value)", "intent": "The `name` is returned unchanged . If the input `value` has a name attribute and it matches name ignoring case , the value is returned unchanged .", "question_id": 3435}
{"snippet": "email_policy.header_fetch_parse(name, value)", "intent": "If the `value` has a `name` attribute , it is returned to unmodified .", "question_id": 3436}
{"snippet": "email_policy.fold(name, value)", "intent": "Header folding is controlled by the refold_source policy setting . A `value` is considered to be a \u2018 source value \u2019 if and only if it does not have a `name` attribute ( having a name attribute means it is a header object of some sort ) .", "question_id": 3437}
{"snippet": "email_policy.fold_binary(name, value)", "intent": "The same as fold ( ) if cte_type is 7bit , except that the returned `value` is bytes . With arguments `name`.", "question_id": 3438}
{"snippet": "email.policy.default", "intent": "An instance of EmailPolicy with all defaults unchanged.", "question_id": 3439}
{"snippet": "email.policy.SMTP", "intent": "Suitable for serializing messages in conformance with the email RFCs.", "question_id": 3440}
{"snippet": "email.policy.SMTPUTF8", "intent": "The same as SMTP except that utf8 is True.", "question_id": 3441}
{"snippet": "email.policy.HTTP", "intent": "Suitable for serializing headers with for use in HTTP traffic.", "question_id": 3442}
{"snippet": "email.policy.strict", "intent": "Convenience instance.", "question_id": 3443}
{"snippet": "email.policy.Compat32(**kw)", "intent": "This concrete Policy is the backward compatibility policy . With arguments `**kw`.", "question_id": 3444}
{"snippet": "compat32.mangle_from_", "intent": "The default is True.", "question_id": 3445}
{"snippet": "compat32.header_source_parse(sourcelines)", "intent": "The name is parsed as everything up to the \u2018 : \u2019 and returned unmodified . With arguments `sourcelines`.", "question_id": 3446}
{"snippet": "compat32.header_store_parse(name, value)", "intent": "The `name` and `value` are returned unmodified .", "question_id": 3447}
{"snippet": "compat32.header_fetch_parse(name, value)", "intent": "If the `value` contains binary data , it is converted into a Header object using the unknown-8bit charset . With arguments `name`.", "question_id": 3448}
{"snippet": "compat32.fold(name, value)", "intent": "Headers are folded using the Header folding algorithm , which preserves existing line breaks in the `value` , and wraps each resulting line to the max_line_length . With arguments `name`.", "question_id": 3449}
{"snippet": "compat32.fold_binary(name, value)", "intent": "Headers are folded using the Header folding algorithm , which preserves existing line breaks in the `value` , and wraps each resulting line to the max_line_length . With arguments `name`.", "question_id": 3450}
{"snippet": "email.policy.compat32", "intent": "An instance of Compat32, providing  backward compatibility with the behavior of the email package in Python 3.2.", "question_id": 3451}
{"snippet": "email.utils.localtime()", "intent": "Return local time as an aware datetime object .", "question_id": 3452}
{"snippet": "email.utils.localtime(dt=None)", "intent": "Return local time as an aware datetime object . Otherwise `dt` argument should be a datetime instance , and it is converted to the local time zone according to the system time zone database .", "question_id": 3453}
{"snippet": "email.utils.make_msgid()", "intent": "Returns a string suitable for an RFC 2822-compliant Message-ID header .", "question_id": 3454}
{"snippet": "email.utils.make_msgid(idstring=None)", "intent": "Returns a string suitable for an RFC 2822-compliant Message-ID header . Optional `idstring` if given , is a string used to strengthen the uniqueness of the message id .", "question_id": 3455}
{"snippet": "email.utils.make_msgid(domain=None)", "intent": "Returns a string suitable for an RFC 2822-compliant Message-ID header . Optional `domain` if given provides the portion of the msgid after the \u2018 @ \u2019 .", "question_id": 3456}
{"snippet": "email.utils.make_msgid(idstring=None, domain=None)", "intent": "Returns a string suitable for an RFC 2822-compliant Message-ID header . Optional `idstring` if given , is a string used to strengthen the uniqueness of the message id . Optional `domain` if given provides the portion of the msgid after the \u2018 @ \u2019 .", "question_id": 3457}
{"snippet": "email.utils.quote(str)", "intent": "Return a new string with backslashes in `str` replaced by two backslashes , and double quotes replaced by backslash-double quote .", "question_id": 3458}
{"snippet": "email.utils.unquote(str)", "intent": "Return a new string which is an unquoted version of `str` .", "question_id": 3459}
{"snippet": "email.utils.parseaddr(address)", "intent": "Parse `address` \u2013 which should be the value of some address-containing field such as To or Cc \u2013 into its constituent realname and email address parts .", "question_id": 3460}
{"snippet": "email.utils.formataddr(pair)", "intent": "The inverse of parseaddr ( ) , this takes a 2-tuple of the form ( realname , email_address ) and returns the string value suitable for a To or Cc header . If the first element of `pair` is false , then the second element is returned unmodified .", "question_id": 3461}
{"snippet": "email.utils.formataddr(pair, charset='utf-8')", "intent": "The inverse of parseaddr ( ) , this takes a 2-tuple of the form ( realname , email_address ) and returns the string value suitable for a To or Cc header . If the first element of `pair` is false , then the second element is returned unmodified . Optional `charset` is the character set that will be used in the RFC 2047 encoding of the realname if the realname contains non-ASCII characters .", "question_id": 3462}
{"snippet": "email.utils.getaddresses(fieldvalues)", "intent": "This method returns a list of 2-tuples of the form returned by parseaddr ( ) . `fieldvalues` is a sequence of header field values as might be returned by Message.get_all .", "question_id": 3463}
{"snippet": "email.utils.parsedate(date)", "intent": "Attempts to parse a `date` according to the rules in RFC 2822. however , some mailers don \u2019 t follow that format as specified , so parsedate ( ) tries to guess correctly in such cases .", "question_id": 3464}
{"snippet": "email.utils.parsedate_tz(date)", "intent": "Performs the same function as parsedate ( ) , but returns either None or a 10-tuple ; the first 9 elements make up a tuple that can be passed directly to time.mktime ( ) , and the tenth is the offset of the `date` \u2019 s timezone from UTC ( which is the official term for Greenwich Mean Time ) 1 .", "question_id": 3465}
{"snippet": "email.utils.parsedate_to_datetime(date)", "intent": "The inverse of format_datetime ( ) . If the input `date` has a timezone of -0000 , the datetime will be a naive datetime , and if the date is conforming to the RFCs it will represent a time in UTC but with no indication of the actual source timezone of the message the date comes from .", "question_id": 3466}
{"snippet": "email.utils.mktime_tz(tuple)", "intent": "Turn a 10-tuple as returned by parsedate_tz ( ) into a UTC timestamp ( seconds since the Epoch ) . If the timezone item in the `tuple` is None , assume local time .", "question_id": 3467}
{"snippet": "email.utils.formatdate()", "intent": "Returns a date string as per RFC 2822 , e.g .", "question_id": 3468}
{"snippet": "email.utils.formatdate(timeval=None)", "intent": "Returns a date string as per RFC 2822 , e.g . Optional `timeval` if given is a floating point time value as accepted by time.gmtime ( ) and time.localtime ( ) , otherwise the current time is used .", "question_id": 3469}
{"snippet": "email.utils.formatdate(localtime=False)", "intent": "Returns a date string as per RFC 2822 , e.g . Optional `localtime` is a flag that when True , interprets timeval , and returns a date relative to the local timezone instead of UTC , properly taking daylight savings time into account .", "question_id": 3470}
{"snippet": "email.utils.formatdate(usegmt=False)", "intent": "Returns a date string as per RFC 2822 , e.g . Optional `usegmt` is a flag that when True , outputs a date string with the timezone as an ascii string GMT , rather than a numeric -0000 .", "question_id": 3471}
{"snippet": "email.utils.formatdate(timeval=None, localtime=False)", "intent": "Returns a date string as per RFC 2822 , e.g . Optional `timeval` if given is a floating point time value as accepted by time.gmtime ( ) and time.localtime ( ) , otherwise the current time is used . Optional `localtime` is a flag that when True , interprets timeval , and returns a date relative to the local timezone instead of UTC , properly taking daylight savings time into account .", "question_id": 3472}
{"snippet": "email.utils.formatdate(timeval=None, usegmt=False)", "intent": "Returns a date string as per RFC 2822 , e.g . Optional `timeval` if given is a floating point time value as accepted by time.gmtime ( ) and time.localtime ( ) , otherwise the current time is used . Optional `usegmt` is a flag that when True , outputs a date string with the timezone as an ascii string GMT , rather than a numeric -0000 .", "question_id": 3473}
{"snippet": "email.utils.formatdate(localtime=False, usegmt=False)", "intent": "Returns a date string as per RFC 2822 , e.g . Optional `localtime` is a flag that when True , interprets timeval , and returns a date relative to the local timezone instead of UTC , properly taking daylight savings time into account . Optional `usegmt` is a flag that when True , outputs a date string with the timezone as an ascii string GMT , rather than a numeric -0000 .", "question_id": 3474}
{"snippet": "email.utils.formatdate(timeval=None, localtime=False, usegmt=False)", "intent": "Returns a date string as per RFC 2822 , e.g . Optional `timeval` if given is a floating point time value as accepted by time.gmtime ( ) and time.localtime ( ) , otherwise the current time is used . Optional `localtime` is a flag that when True , interprets timeval , and returns a date relative to the local timezone instead of UTC , properly taking daylight savings time into account . Optional `usegmt` is a flag that when True , outputs a date string with the timezone as an ascii string GMT , rather than a numeric -0000 .", "question_id": 3475}
{"snippet": "email.utils.format_datetime(dt)", "intent": "Like formatdate , but the input is a datetime instance . With arguments `dt`.", "question_id": 3476}
{"snippet": "email.utils.format_datetime(dt, usegmt=False)", "intent": "Like formatdate , but the input is a datetime instance . If it is an aware timezone with offset zero , then `usegmt` may be set to True , in which case the string GMT is used instead of the numeric timezone offset . With arguments `dt`.", "question_id": 3477}
{"snippet": "email.utils.decode_rfc2231(s)", "intent": "Decode the string `s` according to RFC 2231 .", "question_id": 3478}
{"snippet": "email.utils.encode_rfc2231(s)", "intent": "Encode the string `s` according to RFC 2231 .", "question_id": 3479}
{"snippet": "email.utils.encode_rfc2231(s, charset=None)", "intent": "Encode the string `s` according to RFC 2231 . Optional `charset` and `language` , if given is the character set name and language name to use .", "question_id": 3480}
{"snippet": "email.utils.encode_rfc2231(s, language=None)", "intent": "Encode the string `s` according to RFC 2231 . Optional `charset` and `language` , if given is the character set name and language name to use .", "question_id": 3481}
{"snippet": "email.utils.encode_rfc2231(s, charset=None, language=None)", "intent": "Encode the string `s` according to RFC 2231 . Optional `charset` and `language` , if given is the character set name and language name to use .", "question_id": 3482}
{"snippet": "email.utils.collapse_rfc2231_value(value)", "intent": "When a header parameter is encoded in RFC 2231 format , Message.get_param may return a 3-tuple containing the character set , language , and `value` .", "question_id": 3483}
{"snippet": "email.utils.collapse_rfc2231_value(value, errors='replace')", "intent": "When a header parameter is encoded in RFC 2231 format , Message.get_param may return a 3-tuple containing the character set , language , and `value` . Optional `errors` is passed to the errors argument of str \u2019 s encode ( ) method ; it defaults to 'replace ' .", "question_id": 3484}
{"snippet": "email.utils.collapse_rfc2231_value(value, fallback_charset='us-ascii')", "intent": "When a header parameter is encoded in RFC 2231 format , Message.get_param may return a 3-tuple containing the character set , language , and `value` . Optional `fallback_charset` specifies the character set to use if the one in the RFC 2231 header is not known by Python ; it defaults to 'us-ascii ' .", "question_id": 3485}
{"snippet": "email.utils.collapse_rfc2231_value(value, errors='replace', fallback_charset='us-ascii')", "intent": "When a header parameter is encoded in RFC 2231 format , Message.get_param may return a 3-tuple containing the character set , language , and `value` . Optional `errors` is passed to the errors argument of str \u2019 s encode ( ) method ; it defaults to 'replace ' . Optional `fallback_charset` specifies the character set to use if the one in the RFC 2231 header is not known by Python ; it defaults to 'us-ascii ' .", "question_id": 3486}
{"snippet": "email.utils.decode_params(params)", "intent": "Decode parameters list according to RFC 2231. `params` is a sequence of 2-tuples containing elements of the form ( content-type , string-value ) .", "question_id": 3487}
{"snippet": "ensurepip.version()", "intent": "Returns a string specifying the bundled version of pip that will be installed when bootstrapping an environment .", "question_id": 3488}
{"snippet": "ensurepip.bootstrap()", "intent": "Bootstraps pip into the current or designated environment .", "question_id": 3489}
{"snippet": "ensurepip.bootstrap(root=None)", "intent": "Bootstraps pip into the current or designated environment . `root` specifies an alternative root directory to install relative to .", "question_id": 3490}
{"snippet": "ensurepip.bootstrap(upgrade=False)", "intent": "Bootstraps pip into the current or designated environment . `upgrade` indicates whether or not to upgrade an existing installation of an earlier version of pip to the bundled version .", "question_id": 3491}
{"snippet": "ensurepip.bootstrap(user=False)", "intent": "Bootstraps pip into the current or designated environment . `user` indicates whether to use the user scheme rather than installing globally .", "question_id": 3492}
{"snippet": "ensurepip.bootstrap(altinstall=False)", "intent": "Bootstraps pip into the current or designated environment . If `altinstall` is set , then pipX will not be installed .", "question_id": 3493}
{"snippet": "ensurepip.bootstrap(default_pip=False)", "intent": "Bootstraps pip into the current or designated environment . If `default_pip` is set , then pip will be installed in addition to the two regular scripts .", "question_id": 3494}
{"snippet": "ensurepip.bootstrap(verbosity=0)", "intent": "Bootstraps pip into the current or designated environment . `verbosity` controls the level of output to sys.stdout from the bootstrapping operation .", "question_id": 3495}
{"snippet": "ensurepip.bootstrap(root=None, upgrade=False)", "intent": "Bootstraps pip into the current or designated environment . `root` specifies an alternative root directory to install relative to . `upgrade` indicates whether or not to upgrade an existing installation of an earlier version of pip to the bundled version .", "question_id": 3496}
{"snippet": "ensurepip.bootstrap(root=None, user=False)", "intent": "Bootstraps pip into the current or designated environment . `root` specifies an alternative root directory to install relative to . `user` indicates whether to use the user scheme rather than installing globally .", "question_id": 3497}
{"snippet": "ensurepip.bootstrap(root=None, altinstall=False)", "intent": "Bootstraps pip into the current or designated environment . `root` specifies an alternative root directory to install relative to . If `altinstall` is set , then pipX will not be installed .", "question_id": 3498}
{"snippet": "enum.Enum", "intent": "Base class for creating enumerated constants.", "question_id": 3499}
{"snippet": "enum.IntEnum", "intent": "Base class for creating enumerated constants that are also subclasses of int.", "question_id": 3500}
{"snippet": "enum.IntFlag", "intent": "Base class for creating enumerated constants that can be combined using the bitwise operators without losing their IntFlag membership.", "question_id": 3501}
{"snippet": "enum.Flag", "intent": "Base class for creating enumerated constants that can be combined using the bitwise operations without losing their Flag membership.", "question_id": 3502}
{"snippet": "enum.unique()", "intent": "Enum class decorator that ensures only one name is bound to any one value .", "question_id": 3503}
{"snippet": "enum.auto", "intent": "Instances are replaced with an appropriate value for Enum members.", "question_id": 3504}
{"snippet": "errno.errorcode", "intent": "Dictionary providing a mapping from the errno value to the string name in the underlying system.", "question_id": 3505}
{"snippet": "errno.EPERM", "intent": "Operation not permitted", "question_id": 3506}
{"snippet": "errno.ENOENT", "intent": "No such file or directory", "question_id": 3507}
{"snippet": "errno.ESRCH", "intent": "No such process", "question_id": 3508}
{"snippet": "errno.EINTR", "intent": "Interrupted system call.", "question_id": 3509}
{"snippet": "errno.EIO", "intent": "I/O error", "question_id": 3510}
{"snippet": "errno.ENXIO", "intent": "No such device or address", "question_id": 3511}
{"snippet": "errno.E2BIG", "intent": "Arg list too long", "question_id": 3512}
{"snippet": "errno.ENOEXEC", "intent": "Exec format error", "question_id": 3513}
{"snippet": "errno.EBADF", "intent": "Bad file number", "question_id": 3514}
{"snippet": "errno.ECHILD", "intent": "No child processes", "question_id": 3515}
{"snippet": "errno.EAGAIN", "intent": "Try again", "question_id": 3516}
{"snippet": "errno.ENOMEM", "intent": "Out of memory", "question_id": 3517}
{"snippet": "errno.EACCES", "intent": "Permission denied", "question_id": 3518}
{"snippet": "errno.EFAULT", "intent": "Bad address", "question_id": 3519}
{"snippet": "errno.ENOTBLK", "intent": "Block device required", "question_id": 3520}
{"snippet": "errno.EBUSY", "intent": "Device or resource busy", "question_id": 3521}
{"snippet": "errno.EEXIST", "intent": "File exists", "question_id": 3522}
{"snippet": "errno.EXDEV", "intent": "Cross-device link", "question_id": 3523}
{"snippet": "errno.ENODEV", "intent": "No such device", "question_id": 3524}
{"snippet": "errno.ENOTDIR", "intent": "Not a directory", "question_id": 3525}
{"snippet": "errno.EISDIR", "intent": "Is a directory", "question_id": 3526}
{"snippet": "errno.EINVAL", "intent": "Invalid argument", "question_id": 3527}
{"snippet": "errno.ENFILE", "intent": "File table overflow", "question_id": 3528}
{"snippet": "errno.EMFILE", "intent": "Too many open files", "question_id": 3529}
{"snippet": "errno.ENOTTY", "intent": "Not a typewriter", "question_id": 3530}
{"snippet": "errno.ETXTBSY", "intent": "Text file busy", "question_id": 3531}
{"snippet": "errno.EFBIG", "intent": "File too large", "question_id": 3532}
{"snippet": "errno.ENOSPC", "intent": "No space left on device", "question_id": 3533}
{"snippet": "errno.ESPIPE", "intent": "Illegal seek", "question_id": 3534}
{"snippet": "errno.EROFS", "intent": "Read-only file system", "question_id": 3535}
{"snippet": "errno.EMLINK", "intent": "Too many links", "question_id": 3536}
{"snippet": "errno.EPIPE", "intent": "Broken pipe", "question_id": 3537}
{"snippet": "errno.EDOM", "intent": "Math argument out of domain of func", "question_id": 3538}
{"snippet": "errno.ERANGE", "intent": "Math result not representable", "question_id": 3539}
{"snippet": "errno.EDEADLK", "intent": "Resource deadlock would occur", "question_id": 3540}
{"snippet": "errno.ENAMETOOLONG", "intent": "File name too long", "question_id": 3541}
{"snippet": "errno.ENOLCK", "intent": "No record locks available", "question_id": 3542}
{"snippet": "errno.ENOSYS", "intent": "Function not implemented", "question_id": 3543}
{"snippet": "errno.ENOTEMPTY", "intent": "Directory not empty", "question_id": 3544}
{"snippet": "errno.ELOOP", "intent": "Too many symbolic links encountered", "question_id": 3545}
{"snippet": "errno.EWOULDBLOCK", "intent": "Operation would block", "question_id": 3546}
{"snippet": "errno.ENOMSG", "intent": "No message of desired type", "question_id": 3547}
{"snippet": "errno.EIDRM", "intent": "Identifier removed", "question_id": 3548}
{"snippet": "errno.ECHRNG", "intent": "Channel number out of range", "question_id": 3549}
{"snippet": "errno.EL2NSYNC", "intent": "Level 2 not synchronized", "question_id": 3550}
{"snippet": "errno.EL3HLT", "intent": "Level 3 halted", "question_id": 3551}
{"snippet": "errno.EL3RST", "intent": "Level 3 reset", "question_id": 3552}
{"snippet": "errno.ELNRNG", "intent": "Link number out of range", "question_id": 3553}
{"snippet": "errno.EUNATCH", "intent": "Protocol driver not attached", "question_id": 3554}
{"snippet": "errno.ENOCSI", "intent": "No CSI structure available", "question_id": 3555}
{"snippet": "errno.EL2HLT", "intent": "Level 2 halted", "question_id": 3556}
{"snippet": "errno.EBADE", "intent": "Invalid exchange", "question_id": 3557}
{"snippet": "errno.EBADR", "intent": "Invalid request descriptor", "question_id": 3558}
{"snippet": "errno.EXFULL", "intent": "Exchange full", "question_id": 3559}
{"snippet": "errno.ENOANO", "intent": "No anode", "question_id": 3560}
{"snippet": "errno.EBADRQC", "intent": "Invalid request code", "question_id": 3561}
{"snippet": "errno.EBADSLT", "intent": "Invalid slot", "question_id": 3562}
{"snippet": "errno.EDEADLOCK", "intent": "File locking deadlock error", "question_id": 3563}
{"snippet": "errno.EBFONT", "intent": "Bad font file format", "question_id": 3564}
{"snippet": "errno.ENOSTR", "intent": "Device not a stream", "question_id": 3565}
{"snippet": "errno.ENODATA", "intent": "No data available", "question_id": 3566}
{"snippet": "errno.ETIME", "intent": "Timer expired", "question_id": 3567}
{"snippet": "errno.ENOSR", "intent": "Out of streams resources", "question_id": 3568}
{"snippet": "errno.ENONET", "intent": "Machine is not on the network", "question_id": 3569}
{"snippet": "errno.ENOPKG", "intent": "Package not installed", "question_id": 3570}
{"snippet": "errno.EREMOTE", "intent": "Object is remote", "question_id": 3571}
{"snippet": "errno.ENOLINK", "intent": "Link has been severed", "question_id": 3572}
{"snippet": "errno.EADV", "intent": "Advertise error", "question_id": 3573}
{"snippet": "errno.ESRMNT", "intent": "Srmount error", "question_id": 3574}
{"snippet": "errno.ECOMM", "intent": "Communication error on send", "question_id": 3575}
{"snippet": "errno.EPROTO", "intent": "Protocol error", "question_id": 3576}
{"snippet": "errno.EMULTIHOP", "intent": "Multihop attempted", "question_id": 3577}
{"snippet": "errno.EDOTDOT", "intent": "RFS specific error", "question_id": 3578}
{"snippet": "errno.EBADMSG", "intent": "Not a data message", "question_id": 3579}
{"snippet": "errno.EOVERFLOW", "intent": "Value too large for defined data type", "question_id": 3580}
{"snippet": "errno.ENOTUNIQ", "intent": "Name not unique on network", "question_id": 3581}
{"snippet": "errno.EBADFD", "intent": "File descriptor in bad state", "question_id": 3582}
{"snippet": "errno.EREMCHG", "intent": "Remote address changed", "question_id": 3583}
{"snippet": "errno.ELIBACC", "intent": "Can not access a needed shared library", "question_id": 3584}
{"snippet": "errno.ELIBBAD", "intent": "Accessing a corrupted shared library", "question_id": 3585}
{"snippet": "errno.ELIBSCN", "intent": ".lib section in a.out corrupted", "question_id": 3586}
{"snippet": "errno.ELIBMAX", "intent": "Attempting to link in too many shared libraries", "question_id": 3587}
{"snippet": "errno.ELIBEXEC", "intent": "Cannot exec a shared library directly", "question_id": 3588}
{"snippet": "errno.EILSEQ", "intent": "Illegal byte sequence", "question_id": 3589}
{"snippet": "errno.ERESTART", "intent": "Interrupted system call should be restarted", "question_id": 3590}
{"snippet": "errno.ESTRPIPE", "intent": "Streams pipe error", "question_id": 3591}
{"snippet": "errno.EUSERS", "intent": "Too many users", "question_id": 3592}
{"snippet": "errno.ENOTSOCK", "intent": "Socket operation on non-socket", "question_id": 3593}
{"snippet": "errno.EDESTADDRREQ", "intent": "Destination address required", "question_id": 3594}
{"snippet": "errno.EMSGSIZE", "intent": "Message too long", "question_id": 3595}
{"snippet": "errno.EPROTOTYPE", "intent": "Protocol wrong type for socket", "question_id": 3596}
{"snippet": "errno.ENOPROTOOPT", "intent": "Protocol not available", "question_id": 3597}
{"snippet": "errno.EPROTONOSUPPORT", "intent": "Protocol not supported", "question_id": 3598}
{"snippet": "errno.ESOCKTNOSUPPORT", "intent": "Socket type not supported", "question_id": 3599}
{"snippet": "errno.EOPNOTSUPP", "intent": "Operation not supported on transport endpoint", "question_id": 3600}
{"snippet": "errno.EPFNOSUPPORT", "intent": "Protocol family not supported", "question_id": 3601}
{"snippet": "errno.EAFNOSUPPORT", "intent": "Address family not supported by protocol", "question_id": 3602}
{"snippet": "errno.EADDRINUSE", "intent": "Address already in use", "question_id": 3603}
{"snippet": "errno.EADDRNOTAVAIL", "intent": "Cannot assign requested address", "question_id": 3604}
{"snippet": "errno.ENETDOWN", "intent": "Network is down", "question_id": 3605}
{"snippet": "errno.ENETUNREACH", "intent": "Network is unreachable", "question_id": 3606}
{"snippet": "errno.ENETRESET", "intent": "Network dropped connection because of reset", "question_id": 3607}
{"snippet": "errno.ECONNABORTED", "intent": "Software caused connection abort", "question_id": 3608}
{"snippet": "errno.ECONNRESET", "intent": "Connection reset by peer", "question_id": 3609}
{"snippet": "errno.ENOBUFS", "intent": "No buffer space available", "question_id": 3610}
{"snippet": "errno.EISCONN", "intent": "Transport endpoint is already connected", "question_id": 3611}
{"snippet": "errno.ENOTCONN", "intent": "Transport endpoint is not connected", "question_id": 3612}
{"snippet": "errno.ESHUTDOWN", "intent": "Cannot send after transport endpoint shutdown", "question_id": 3613}
{"snippet": "errno.ETOOMANYREFS", "intent": "Too many references: cannot splice", "question_id": 3614}
{"snippet": "errno.ETIMEDOUT", "intent": "Connection timed out", "question_id": 3615}
{"snippet": "errno.ECONNREFUSED", "intent": "Connection refused", "question_id": 3616}
{"snippet": "errno.EHOSTDOWN", "intent": "Host is down", "question_id": 3617}
{"snippet": "errno.EHOSTUNREACH", "intent": "No route to host", "question_id": 3618}
{"snippet": "errno.EALREADY", "intent": "Operation already in progress", "question_id": 3619}
{"snippet": "errno.EINPROGRESS", "intent": "Operation now in progress", "question_id": 3620}
{"snippet": "errno.ESTALE", "intent": "Stale NFS file handle", "question_id": 3621}
{"snippet": "errno.EUCLEAN", "intent": "Structure needs cleaning", "question_id": 3622}
{"snippet": "errno.ENOTNAM", "intent": "Not a XENIX named type file", "question_id": 3623}
{"snippet": "errno.ENAVAIL", "intent": "No XENIX semaphores available", "question_id": 3624}
{"snippet": "errno.EISNAM", "intent": "Is a named type file", "question_id": 3625}
{"snippet": "errno.EREMOTEIO", "intent": "Remote I/O error", "question_id": 3626}
{"snippet": "errno.EDQUOT", "intent": "Quota exceeded", "question_id": 3627}
{"snippet": "BaseException", "intent": "The base class for all built-in exceptions.", "question_id": 3628}
{"snippet": "auto.args", "intent": "The tuple of arguments given to the exception constructor.", "question_id": 3629}
{"snippet": "auto.with_traceback(tb)", "intent": "This method sets `tb` as the new traceback for the exception and returns the exception object .", "question_id": 3630}
{"snippet": "Exception", "intent": "All built-in, non-system-exiting exceptions are derived from this class.", "question_id": 3631}
{"snippet": "ArithmeticError", "intent": "The base class for those built-in exceptions that are raised for various arithmetic errors: OverflowError, ZeroDivisionError, FloatingPointError.", "question_id": 3632}
{"snippet": "BufferError", "intent": "Raised when a buffer related operation cannot be performed.", "question_id": 3633}
{"snippet": "LookupError", "intent": "The base class for the exceptions that are raised when a key or index used on a mapping or sequence is invalid: IndexError, KeyError.", "question_id": 3634}
{"snippet": "AssertionError", "intent": "Raised when an assert statement fails.", "question_id": 3635}
{"snippet": "AttributeError", "intent": "Raised when an attribute reference (see Attribute references) or assignment fails.", "question_id": 3636}
{"snippet": "EOFError", "intent": "Raised when the input() function hits an end-of-file condition (EOF) without reading any data.", "question_id": 3637}
{"snippet": "FloatingPointError", "intent": "Not currently used.", "question_id": 3638}
{"snippet": "GeneratorExit", "intent": "Raised when a generator or coroutine is closed; see generator.close() and coroutine.close().", "question_id": 3639}
{"snippet": "ImportError", "intent": "Raised when the import statement has troubles trying to load a module.", "question_id": 3640}
{"snippet": "ModuleNotFoundError", "intent": "A subclass of ImportError which is raised by import when a module could not be located.", "question_id": 3641}
{"snippet": "IndexError", "intent": "Raised when a sequence subscript is out of range.", "question_id": 3642}
{"snippet": "KeyError", "intent": "Raised when a mapping (dictionary) key is not found in the set of existing keys.", "question_id": 3643}
{"snippet": "KeyboardInterrupt", "intent": "Raised when the user hits the interrupt key (normally Control-C or Delete).", "question_id": 3644}
{"snippet": "MemoryError", "intent": "Raised when an operation runs out of memory but the situation may still be rescued (by deleting some objects).", "question_id": 3645}
{"snippet": "NameError", "intent": "Raised when a local or global name is not found.", "question_id": 3646}
{"snippet": "NotImplementedError", "intent": "This exception is derived from RuntimeError.", "question_id": 3647}
{"snippet": "OSError(arg)", "intent": "This exception is raised when a system function returns a system-related error , including I/O failures such as \u201c file not found \u201d or \u201c disk full \u201d ( not for illegal argument types or other incidental errors ) . With arguments `arg`.", "question_id": 3648}
{"snippet": "OSError()", "intent": "This exception is raised when a system function returns a system-related error , including I/O failures such as \u201c file not found \u201d or \u201c disk full \u201d ( not for illegal argument types or other incidental errors ) .", "question_id": 3649}
{"snippet": "OSError(errno, strerror, filename, winerror, filename2)", "intent": "This exception is raised when a system function returns a system-related error , including I/O failures such as \u201c file not found \u201d or \u201c disk full \u201d ( not for illegal argument types or other incidental errors ) . The particular subclass depends on the final `errno` value . With arguments `strerror`, `filename`, `winerror`, `filename2`.", "question_id": 3650}
{"snippet": "OSError(errno, strerror, filename, winerror)", "intent": "This exception is raised when a system function returns a system-related error , including I/O failures such as \u201c file not found \u201d or \u201c disk full \u201d ( not for illegal argument types or other incidental errors ) . The particular subclass depends on the final `errno` value . With arguments `strerror`, `filename`, `winerror`.", "question_id": 3651}
{"snippet": "OSError(errno, strerror, filename)", "intent": "This exception is raised when a system function returns a system-related error , including I/O failures such as \u201c file not found \u201d or \u201c disk full \u201d ( not for illegal argument types or other incidental errors ) . The particular subclass depends on the final `errno` value . With arguments `strerror`, `filename`.", "question_id": 3652}
{"snippet": "OSError(errno, strerror)", "intent": "This exception is raised when a system function returns a system-related error , including I/O failures such as \u201c file not found \u201d or \u201c disk full \u201d ( not for illegal argument types or other incidental errors ) . The particular subclass depends on the final `errno` value . With arguments `strerror`.", "question_id": 3653}
{"snippet": "auto.errno", "intent": "A numeric error code from the C variable errno.", "question_id": 3654}
{"snippet": "auto.winerror", "intent": "Under Windows, this gives you the native Windows error code.", "question_id": 3655}
{"snippet": "auto.strerror", "intent": "The corresponding error message, as provided by the operating system.", "question_id": 3656}
{"snippet": "auto.filename", "intent": "For exceptions that involve a file system path (such as open() or os.unlink()), filename is the file name passed to the function.", "question_id": 3657}
{"snippet": "auto.filename2", "intent": "For exceptions that involve a file system path (such as open() or os.unlink()), filename is the file name passed to the function.", "question_id": 3658}
{"snippet": "OverflowError", "intent": "Raised when the result of an arithmetic operation is too large to be represented.", "question_id": 3659}
{"snippet": "RecursionError", "intent": "This exception is derived from RuntimeError.", "question_id": 3660}
{"snippet": "ReferenceError", "intent": "This exception is raised when a weak reference proxy, created by the weakref.proxy() function, is used to access an attribute of the referent after it has been garbage collected.", "question_id": 3661}
{"snippet": "RuntimeError", "intent": "Raised when an error is detected that doesn\u2019t fall in any of the other categories.", "question_id": 3662}
{"snippet": "StopIteration", "intent": "Raised by built-in function next() and an iterator\u2019s __next__() method to signal that there are no further items produced by the iterator.", "question_id": 3663}
{"snippet": "StopAsyncIteration", "intent": "Must be raised by __anext__() method of an asynchronous iterator object to stop the iteration.", "question_id": 3664}
{"snippet": "SyntaxError", "intent": "Raised when the parser encounters a syntax error.", "question_id": 3665}
{"snippet": "IndentationError", "intent": "Base class for syntax errors related to incorrect indentation.", "question_id": 3666}
{"snippet": "TabError", "intent": "Raised when indentation contains an inconsistent use of tabs and spaces.", "question_id": 3667}
{"snippet": "SystemError", "intent": "Raised when the interpreter finds an internal error, but the situation does not look so serious to cause it to abandon all hope.", "question_id": 3668}
{"snippet": "SystemExit", "intent": "This exception is raised by the sys.exit() function.", "question_id": 3669}
{"snippet": "auto.code", "intent": "The exit status or error message that is passed to the constructor.", "question_id": 3670}
{"snippet": "TypeError", "intent": "Raised when an operation or function is applied to an object of inappropriate type.", "question_id": 3671}
{"snippet": "UnboundLocalError", "intent": "Raised when a reference is made to a local variable in a function or method, but no value has been bound to that variable.", "question_id": 3672}
{"snippet": "UnicodeError", "intent": "Raised when a Unicode-related encoding or decoding error occurs.", "question_id": 3673}
{"snippet": "auto.encoding", "intent": "The name of the encoding that raised the error.", "question_id": 3674}
{"snippet": "auto.reason", "intent": "A string describing the specific codec error.", "question_id": 3675}
{"snippet": "auto.object", "intent": "The object the codec was attempting to encode or decode.", "question_id": 3676}
{"snippet": "auto.start", "intent": "The first index of invalid data in object.", "question_id": 3677}
{"snippet": "auto.end", "intent": "The index after the last invalid data in object.", "question_id": 3678}
{"snippet": "UnicodeEncodeError", "intent": "Raised when a Unicode-related error occurs during encoding.", "question_id": 3679}
{"snippet": "UnicodeDecodeError", "intent": "Raised when a Unicode-related error occurs during decoding.", "question_id": 3680}
{"snippet": "UnicodeTranslateError", "intent": "Raised when a Unicode-related error occurs during translating.", "question_id": 3681}
{"snippet": "ValueError", "intent": "Raised when an operation or function receives an argument that has the right type but an inappropriate value, and the situation is not described by a more precise exception such as IndexError.", "question_id": 3682}
{"snippet": "ZeroDivisionError", "intent": "Raised when the second argument of a division or modulo operation is zero.", "question_id": 3683}
{"snippet": "WindowsError", "intent": "Only available on Windows.", "question_id": 3684}
{"snippet": "BlockingIOError", "intent": "Raised when an operation would block on an object (e.g.", "question_id": 3685}
{"snippet": "auto.characters_written", "intent": "An integer containing the number of characters written to the stream before it blocked.", "question_id": 3686}
{"snippet": "ChildProcessError", "intent": "Raised when an operation on a child process failed.", "question_id": 3687}
{"snippet": "ConnectionError", "intent": "A base class for connection-related issues.", "question_id": 3688}
{"snippet": "BrokenPipeError", "intent": "A subclass of ConnectionError, raised when trying to write on a pipe while the other end has been closed, or trying to write on a socket which has been shutdown for writing.", "question_id": 3689}
{"snippet": "ConnectionAbortedError", "intent": "A subclass of ConnectionError, raised when a connection attempt is aborted by the peer.", "question_id": 3690}
{"snippet": "ConnectionRefusedError", "intent": "A subclass of ConnectionError, raised when a connection attempt is refused by the peer.", "question_id": 3691}
{"snippet": "ConnectionResetError", "intent": "A subclass of ConnectionError, raised when a connection is reset by the peer.", "question_id": 3692}
{"snippet": "FileExistsError", "intent": "Raised when trying to create a file or directory which already exists.", "question_id": 3693}
{"snippet": "FileNotFoundError", "intent": "Raised when a file or directory is requested but doesn\u2019t exist.", "question_id": 3694}
{"snippet": "InterruptedError", "intent": "Raised when a system call is interrupted by an incoming signal.", "question_id": 3695}
{"snippet": "IsADirectoryError", "intent": "Raised when a file operation (such as os.remove()) is requested on a directory.", "question_id": 3696}
{"snippet": "NotADirectoryError", "intent": "Raised when a directory operation (such as os.listdir()) is requested on something which is not a directory.", "question_id": 3697}
{"snippet": "PermissionError", "intent": "Raised when trying to run an operation without the adequate access rights - for example filesystem permissions.", "question_id": 3698}
{"snippet": "ProcessLookupError", "intent": "Raised when a given process doesn\u2019t exist.", "question_id": 3699}
{"snippet": "TimeoutError", "intent": "Raised when a system function timed out at the system level.", "question_id": 3700}
{"snippet": "Warning", "intent": "Base class for warning categories.", "question_id": 3701}
{"snippet": "UserWarning", "intent": "Base class for warnings generated by user code.", "question_id": 3702}
{"snippet": "DeprecationWarning", "intent": "Base class for warnings about deprecated features when those warnings are intended for other Python developers.", "question_id": 3703}
{"snippet": "PendingDeprecationWarning", "intent": "Base class for warnings about features which are obsolete and expected to be deprecated in the future, but are not deprecated at the moment.", "question_id": 3704}
{"snippet": "SyntaxWarning", "intent": "Base class for warnings about dubious syntax.", "question_id": 3705}
{"snippet": "RuntimeWarning", "intent": "Base class for warnings about dubious runtime behavior.", "question_id": 3706}
{"snippet": "FutureWarning", "intent": "Base class for warnings about deprecated features when those warnings are intended for end users of applications that are written in Python.", "question_id": 3707}
{"snippet": "ImportWarning", "intent": "Base class for warnings about probable mistakes in module imports.", "question_id": 3708}
{"snippet": "UnicodeWarning", "intent": "Base class for warnings related to Unicode.", "question_id": 3709}
{"snippet": "BytesWarning", "intent": "Base class for warnings related to bytes and bytearray.", "question_id": 3710}
{"snippet": "ResourceWarning", "intent": "Base class for warnings related to resource usage.", "question_id": 3711}
{"snippet": "faulthandler.dump_traceback()", "intent": "Dump the tracebacks of all threads into `file` .", "question_id": 3712}
{"snippet": "faulthandler.dump_traceback(file=sys.stderr)", "intent": "Dump the tracebacks of all threads into `file` .", "question_id": 3713}
{"snippet": "faulthandler.dump_traceback(all_threads=True)", "intent": "Dump the tracebacks of all threads into `file` . If `all_threads` is False , dump only the current thread .", "question_id": 3714}
{"snippet": "faulthandler.dump_traceback(file=sys.stderr, all_threads=True)", "intent": "Dump the tracebacks of all threads into `file` . If `all_threads` is False , dump only the current thread .", "question_id": 3715}
{"snippet": "faulthandler.enable()", "intent": "Enable the fault handler : install handlers for the SIGSEGV , SIGFPE , SIGABRT , SIGBUS and SIGILL signals to dump the Python traceback .", "question_id": 3716}
{"snippet": "faulthandler.enable(file=sys.stderr)", "intent": "Enable the fault handler : install handlers for the SIGSEGV , SIGFPE , SIGABRT , SIGBUS and SIGILL signals to dump the Python traceback . The `file` must be kept open until the fault handler is disabled : see issue with file descriptors .", "question_id": 3717}
{"snippet": "faulthandler.enable(all_threads=True)", "intent": "Enable the fault handler : install handlers for the SIGSEGV , SIGFPE , SIGABRT , SIGBUS and SIGILL signals to dump the Python traceback . If `all_threads` is True , produce tracebacks for every running thread .", "question_id": 3718}
{"snippet": "faulthandler.enable(file=sys.stderr, all_threads=True)", "intent": "Enable the fault handler : install handlers for the SIGSEGV , SIGFPE , SIGABRT , SIGBUS and SIGILL signals to dump the Python traceback . The `file` must be kept open until the fault handler is disabled : see issue with file descriptors . If `all_threads` is True , produce tracebacks for every running thread .", "question_id": 3719}
{"snippet": "faulthandler.disable()", "intent": "Disable the fault handler : uninstall the signal handlers installed by enable ( ) .", "question_id": 3720}
{"snippet": "faulthandler.is_enabled()", "intent": "Check if the fault handler is enabled .", "question_id": 3721}
{"snippet": "faulthandler.dump_traceback_later(timeout)", "intent": "Dump the tracebacks of all threads , after a `timeout` of timeout seconds , or every timeout seconds if `repeat` is True .", "question_id": 3722}
{"snippet": "faulthandler.dump_traceback_later(timeout, repeat=False)", "intent": "Dump the tracebacks of all threads , after a `timeout` of timeout seconds , or every timeout seconds if `repeat` is True .", "question_id": 3723}
{"snippet": "faulthandler.dump_traceback_later(timeout, file=sys.stderr)", "intent": "Dump the tracebacks of all threads , after a `timeout` of timeout seconds , or every timeout seconds if `repeat` is True . ( Note _exit ( ) exits the process immediately , which means it doesn \u2019 t do any cleanup like flushing `file` buffers . )", "question_id": 3724}
{"snippet": "faulthandler.dump_traceback_later(timeout, exit=False)", "intent": "Dump the tracebacks of all threads , after a `timeout` of timeout seconds , or every timeout seconds if `repeat` is True . If `exit` is True , call _exit ( ) with status=1 after dumping the tracebacks .", "question_id": 3725}
{"snippet": "faulthandler.dump_traceback_later(timeout, repeat=False, file=sys.stderr)", "intent": "Dump the tracebacks of all threads , after a `timeout` of timeout seconds , or every timeout seconds if `repeat` is True . ( Note _exit ( ) exits the process immediately , which means it doesn \u2019 t do any cleanup like flushing `file` buffers . )", "question_id": 3726}
{"snippet": "faulthandler.dump_traceback_later(timeout, repeat=False, exit=False)", "intent": "Dump the tracebacks of all threads , after a `timeout` of timeout seconds , or every timeout seconds if `repeat` is True . If `exit` is True , call _exit ( ) with status=1 after dumping the tracebacks .", "question_id": 3727}
{"snippet": "faulthandler.dump_traceback_later(timeout, file=sys.stderr, exit=False)", "intent": "Dump the tracebacks of all threads , after a `timeout` of timeout seconds , or every timeout seconds if `repeat` is True . ( Note _exit ( ) exits the process immediately , which means it doesn \u2019 t do any cleanup like flushing `file` buffers . ) If `exit` is True , call _exit ( ) with status=1 after dumping the tracebacks .", "question_id": 3728}
{"snippet": "faulthandler.dump_traceback_later(timeout, repeat=False, file=sys.stderr, exit=False)", "intent": "Dump the tracebacks of all threads , after a `timeout` of timeout seconds , or every timeout seconds if `repeat` is True . ( Note _exit ( ) exits the process immediately , which means it doesn \u2019 t do any cleanup like flushing `file` buffers . ) If `exit` is True , call _exit ( ) with status=1 after dumping the tracebacks .", "question_id": 3729}
{"snippet": "faulthandler.cancel_dump_traceback_later()", "intent": "Cancel the last call to dump_traceback_later ( ) .", "question_id": 3730}
{"snippet": "faulthandler.register(signum)", "intent": "Register a user signal : install a handler for the `signum` signal to dump the traceback of all threads , or of the current thread if `all_threads` is False , into `file` .", "question_id": 3731}
{"snippet": "faulthandler.register(signum, file=sys.stderr)", "intent": "Register a user signal : install a handler for the `signum` signal to dump the traceback of all threads , or of the current thread if `all_threads` is False , into `file` .", "question_id": 3732}
{"snippet": "faulthandler.register(signum, all_threads=True)", "intent": "Register a user signal : install a handler for the `signum` signal to dump the traceback of all threads , or of the current thread if `all_threads` is False , into `file` .", "question_id": 3733}
{"snippet": "faulthandler.register(signum, chain=False)", "intent": "Register a user signal : install a handler for the `signum` signal to dump the traceback of all threads , or of the current thread if `all_threads` is False , into `file` . Call the previous handler if `chain` is True .", "question_id": 3734}
{"snippet": "faulthandler.register(signum, file=sys.stderr, all_threads=True)", "intent": "Register a user signal : install a handler for the `signum` signal to dump the traceback of all threads , or of the current thread if `all_threads` is False , into `file` .", "question_id": 3735}
{"snippet": "faulthandler.register(signum, file=sys.stderr, chain=False)", "intent": "Register a user signal : install a handler for the `signum` signal to dump the traceback of all threads , or of the current thread if `all_threads` is False , into `file` . Call the previous handler if `chain` is True .", "question_id": 3736}
{"snippet": "faulthandler.register(signum, all_threads=True, chain=False)", "intent": "Register a user signal : install a handler for the `signum` signal to dump the traceback of all threads , or of the current thread if `all_threads` is False , into `file` . Call the previous handler if `chain` is True .", "question_id": 3737}
{"snippet": "faulthandler.register(signum, file=sys.stderr, all_threads=True, chain=False)", "intent": "Register a user signal : install a handler for the `signum` signal to dump the traceback of all threads , or of the current thread if `all_threads` is False , into `file` . Call the previous handler if `chain` is True .", "question_id": 3738}
{"snippet": "faulthandler.unregister(signum)", "intent": "Unregister a user signal : uninstall the handler of the `signum` signal installed by register ( ) .", "question_id": 3739}
{"snippet": "fcntl.fcntl(fd, cmd)", "intent": "Perform the operation `cmd` on file descriptor `fd` ( file objects providing a fileno ( ) method are accepted as well ) .", "question_id": 3740}
{"snippet": "fcntl.fcntl(fd, cmd, arg=0)", "intent": "Perform the operation `cmd` on file descriptor `fd` ( file objects providing a fileno ( ) method are accepted as well ) . The argument `arg` can either be an integer value , or a bytes object .", "question_id": 3741}
{"snippet": "fcntl.ioctl(fd, request)", "intent": "This function is identical to the fcntl ( ) function , except that the argument handling is even more complicated . The `request` parameter is limited to values that can fit in 32-bits . With arguments `fd`.", "question_id": 3742}
{"snippet": "fcntl.ioctl(fd, request, arg=0)", "intent": "This function is identical to the fcntl ( ) function , except that the argument handling is even more complicated . The `request` parameter is limited to values that can fit in 32-bits . The parameter `arg` can be one of an integer , an object supporting the read-only buffer interface ( like bytes ) or an object supporting the read-write buffer interface ( like bytearray ) . With arguments `fd`.", "question_id": 3743}
{"snippet": "fcntl.ioctl(fd, request, mutate_flag=True)", "intent": "This function is identical to the fcntl ( ) function , except that the argument handling is even more complicated . The `request` parameter is limited to values that can fit in 32-bits . If a mutable buffer is passed , then the behaviour is determined by the value of the `mutate_flag` parameter . With arguments `fd`.", "question_id": 3744}
{"snippet": "fcntl.ioctl(fd, request, arg=0, mutate_flag=True)", "intent": "This function is identical to the fcntl ( ) function , except that the argument handling is even more complicated . The `request` parameter is limited to values that can fit in 32-bits . The parameter `arg` can be one of an integer , an object supporting the read-only buffer interface ( like bytes ) or an object supporting the read-write buffer interface ( like bytearray ) . If a mutable buffer is passed , then the behaviour is determined by the value of the `mutate_flag` parameter . With arguments `fd`.", "question_id": 3745}
{"snippet": "fcntl.flock(fd, operation)", "intent": "Perform the lock `operation` operation on file descriptor `fd` ( file objects providing a fileno ( ) method are accepted as well ) .", "question_id": 3746}
{"snippet": "fcntl.lockf(fd, cmd)", "intent": "This is essentially a wrapper around the fcntl ( ) locking calls . `fd` is the file descriptor of the file to lock or unlock , and `cmd` is one of the following values :", "question_id": 3747}
{"snippet": "fcntl.lockf(fd, cmd, len=0)", "intent": "This is essentially a wrapper around the fcntl ( ) locking calls . `fd` is the file descriptor of the file to lock or unlock , and `cmd` is one of the following values : `len` is the number of bytes to lock , `start` is the byte offset at which the lock starts , relative to `whence` , and whence is as with io.IOBase.seek ( ) , specifically :", "question_id": 3748}
{"snippet": "fcntl.lockf(fd, cmd, start=0)", "intent": "This is essentially a wrapper around the fcntl ( ) locking calls . `fd` is the file descriptor of the file to lock or unlock , and `cmd` is one of the following values : `len` is the number of bytes to lock , `start` is the byte offset at which the lock starts , relative to `whence` , and whence is as with io.IOBase.seek ( ) , specifically :", "question_id": 3749}
{"snippet": "fcntl.lockf(fd, cmd, whence=0)", "intent": "This is essentially a wrapper around the fcntl ( ) locking calls . `fd` is the file descriptor of the file to lock or unlock , and `cmd` is one of the following values : `len` is the number of bytes to lock , `start` is the byte offset at which the lock starts , relative to `whence` , and whence is as with io.IOBase.seek ( ) , specifically :", "question_id": 3750}
{"snippet": "fcntl.lockf(fd, cmd, len=0, start=0)", "intent": "This is essentially a wrapper around the fcntl ( ) locking calls . `fd` is the file descriptor of the file to lock or unlock , and `cmd` is one of the following values : `len` is the number of bytes to lock , `start` is the byte offset at which the lock starts , relative to `whence` , and whence is as with io.IOBase.seek ( ) , specifically :", "question_id": 3751}
{"snippet": "fcntl.lockf(fd, cmd, len=0, whence=0)", "intent": "This is essentially a wrapper around the fcntl ( ) locking calls . `fd` is the file descriptor of the file to lock or unlock , and `cmd` is one of the following values : `len` is the number of bytes to lock , `start` is the byte offset at which the lock starts , relative to `whence` , and whence is as with io.IOBase.seek ( ) , specifically :", "question_id": 3752}
{"snippet": "fcntl.lockf(fd, cmd, start=0, whence=0)", "intent": "This is essentially a wrapper around the fcntl ( ) locking calls . `fd` is the file descriptor of the file to lock or unlock , and `cmd` is one of the following values : `len` is the number of bytes to lock , `start` is the byte offset at which the lock starts , relative to `whence` , and whence is as with io.IOBase.seek ( ) , specifically :", "question_id": 3753}
{"snippet": "fcntl.lockf(fd, cmd, len=0, start=0, whence=0)", "intent": "This is essentially a wrapper around the fcntl ( ) locking calls . `fd` is the file descriptor of the file to lock or unlock , and `cmd` is one of the following values : `len` is the number of bytes to lock , `start` is the byte offset at which the lock starts , relative to `whence` , and whence is as with io.IOBase.seek ( ) , specifically :", "question_id": 3754}
{"snippet": "filecmp.cmp(f1, f2)", "intent": "Compare the files named `f1` and `f2` , returning True if they seem equal , False otherwise .", "question_id": 3755}
{"snippet": "filecmp.cmp(f1, f2, shallow=True)", "intent": "Compare the files named `f1` and `f2` , returning True if they seem equal , False otherwise . If `shallow` is true , files with identical os.stat ( ) signatures are taken to be equal .", "question_id": 3756}
{"snippet": "filecmp.cmpfiles(dir1, dir2, common)", "intent": "Compare the files in the two directories `dir1` and `dir2` whose names are given by `common` .", "question_id": 3757}
{"snippet": "filecmp.cmpfiles(dir1, dir2, common, shallow=True)", "intent": "Compare the files in the two directories `dir1` and `dir2` whose names are given by `common` . The `shallow` parameter has the same meaning and default value as for filecmp.cmp ( ) .", "question_id": 3758}
{"snippet": "filecmp.clear_cache()", "intent": "Clear the filecmp cache .", "question_id": 3759}
{"snippet": "filecmp.dircmp(a, b)", "intent": "Construct `a` new directory comparison object , to compare the directories a and b. `ignore` is a list of names to ignore , and defaults to filecmp.DEFAULT_IGNORES . With arguments `b`.", "question_id": 3760}
{"snippet": "filecmp.dircmp(a, b, ignore=None)", "intent": "Construct `a` new directory comparison object , to compare the directories a and b. `ignore` is a list of names to ignore , and defaults to filecmp.DEFAULT_IGNORES . With arguments `b`.", "question_id": 3761}
{"snippet": "filecmp.dircmp(a, b, hide=None)", "intent": "Construct `a` new directory comparison object , to compare the directories a and b. `ignore` is a list of names to ignore , and defaults to filecmp.DEFAULT_IGNORES . `hide` is a list of names to hide , and defaults to [ os.curdir , os.pardir ] . With arguments `b`.", "question_id": 3762}
{"snippet": "filecmp.dircmp(a, b, ignore=None, hide=None)", "intent": "Construct `a` new directory comparison object , to compare the directories a and b. `ignore` is a list of names to ignore , and defaults to filecmp.DEFAULT_IGNORES . `hide` is a list of names to hide , and defaults to [ os.curdir , os.pardir ] . With arguments `b`.", "question_id": 3763}
{"snippet": "dircmp.report()", "intent": "Print ( to sys.stdout ) a comparison between a and b .", "question_id": 3764}
{"snippet": "dircmp.report_partial_closure()", "intent": "Print a comparison between a and b and common immediate subdirectories .", "question_id": 3765}
{"snippet": "dircmp.report_full_closure()", "intent": "Print a comparison between a and b and common subdirectories ( recursively ) .", "question_id": 3766}
{"snippet": "dircmp.left", "intent": "The directory a.", "question_id": 3767}
{"snippet": "dircmp.right", "intent": "The directory b.", "question_id": 3768}
{"snippet": "dircmp.left_list", "intent": "Files and subdirectories in a, filtered by hide and ignore.", "question_id": 3769}
{"snippet": "dircmp.right_list", "intent": "Files and subdirectories in b, filtered by hide and ignore.", "question_id": 3770}
{"snippet": "dircmp.common", "intent": "Files and subdirectories in both a and b.", "question_id": 3771}
{"snippet": "dircmp.left_only", "intent": "Files and subdirectories only in a.", "question_id": 3772}
{"snippet": "dircmp.right_only", "intent": "Files and subdirectories only in b.", "question_id": 3773}
{"snippet": "dircmp.common_dirs", "intent": "Subdirectories in both a and b.", "question_id": 3774}
{"snippet": "dircmp.common_files", "intent": "Files in both a and b.", "question_id": 3775}
{"snippet": "dircmp.common_funny", "intent": "Names in both a and b, such that the type differs between the directories, or names for which os.stat() reports an error.", "question_id": 3776}
{"snippet": "dircmp.same_files", "intent": "Files which are identical in both a and b, using the class\u2019s file comparison operator.", "question_id": 3777}
{"snippet": "dircmp.diff_files", "intent": "Files which are in both a and b, whose contents differ according to the class\u2019s file comparison operator.", "question_id": 3778}
{"snippet": "dircmp.funny_files", "intent": "Files which are in both a and b, but could not be compared.", "question_id": 3779}
{"snippet": "dircmp.subdirs", "intent": "A dictionary mapping names in common_dirs to dircmp objects.", "question_id": 3780}
{"snippet": "filecmp.DEFAULT_IGNORES", "intent": "List of directories ignored by dircmp by default.", "question_id": 3781}
{"snippet": "fileinput.input()", "intent": "Create an instance of the FileInput class .", "question_id": 3782}
{"snippet": "fileinput.input(files=None)", "intent": "Create an instance of the FileInput class . With arguments `files`.", "question_id": 3783}
{"snippet": "fileinput.input(inplace=False)", "intent": "Create an instance of the FileInput class . With arguments `inplace`.", "question_id": 3784}
{"snippet": "fileinput.input(backup='')", "intent": "Create an instance of the FileInput class . With arguments `backup`.", "question_id": 3785}
{"snippet": "fileinput.input(bufsize=0)", "intent": "Create an instance of the FileInput class . With arguments `bufsize`.", "question_id": 3786}
{"snippet": "fileinput.input(mode='r')", "intent": "Create an instance of the FileInput class . With arguments `mode`.", "question_id": 3787}
{"snippet": "fileinput.input(openhook=None)", "intent": "Create an instance of the FileInput class . With arguments `openhook`.", "question_id": 3788}
{"snippet": "fileinput.input(files=None, inplace=False)", "intent": "Create an instance of the FileInput class . With arguments `files`, `inplace`.", "question_id": 3789}
{"snippet": "fileinput.input(files=None, backup='')", "intent": "Create an instance of the FileInput class . With arguments `files`, `backup`.", "question_id": 3790}
{"snippet": "fileinput.input(files=None, bufsize=0)", "intent": "Create an instance of the FileInput class . With arguments `files`, `bufsize`.", "question_id": 3791}
{"snippet": "fileinput.filename()", "intent": "Return the name of the file currently being read .", "question_id": 3792}
{"snippet": "fileinput.fileno()", "intent": "Return the integer \u201c file descriptor \u201d for the current file .", "question_id": 3793}
{"snippet": "fileinput.lineno()", "intent": "Return the cumulative line number of the line that has just been read .", "question_id": 3794}
{"snippet": "fileinput.filelineno()", "intent": "Return the line number in the current file .", "question_id": 3795}
{"snippet": "fileinput.isfirstline()", "intent": "Returns true if the line just read is the first line of its file , otherwise returns false .", "question_id": 3796}
{"snippet": "fileinput.isstdin()", "intent": "Returns true if the last line was read from sys.stdin , otherwise returns false .", "question_id": 3797}
{"snippet": "fileinput.nextfile()", "intent": "Close the current file so that the next iteration will read the first line from the next file ( if any ) ; lines not read from the file will not count towards the cumulative line count .", "question_id": 3798}
{"snippet": "fileinput.close()", "intent": "Close the sequence .", "question_id": 3799}
{"snippet": "fileinput.FileInput()", "intent": "Class FileInput is the implementation ; its methods filename ( ) , fileno ( ) , lineno ( ) , filelineno ( ) , isfirstline ( ) , isstdin ( ) , nextfile ( ) and close ( ) correspond to the functions of the same name in the module .", "question_id": 3800}
{"snippet": "fileinput.FileInput(files=None)", "intent": "Class FileInput is the implementation ; its methods filename ( ) , fileno ( ) , lineno ( ) , filelineno ( ) , isfirstline ( ) , isstdin ( ) , nextfile ( ) and close ( ) correspond to the functions of the same name in the module . With arguments `files`.", "question_id": 3801}
{"snippet": "fileinput.FileInput(inplace=False)", "intent": "Class FileInput is the implementation ; its methods filename ( ) , fileno ( ) , lineno ( ) , filelineno ( ) , isfirstline ( ) , isstdin ( ) , nextfile ( ) and close ( ) correspond to the functions of the same name in the module . You can not use `inplace` and openhook together .", "question_id": 3802}
{"snippet": "fileinput.FileInput(backup='')", "intent": "Class FileInput is the implementation ; its methods filename ( ) , fileno ( ) , lineno ( ) , filelineno ( ) , isfirstline ( ) , isstdin ( ) , nextfile ( ) and close ( ) correspond to the functions of the same name in the module . With arguments `backup`.", "question_id": 3803}
{"snippet": "fileinput.FileInput(bufsize=0)", "intent": "Class FileInput is the implementation ; its methods filename ( ) , fileno ( ) , lineno ( ) , filelineno ( ) , isfirstline ( ) , isstdin ( ) , nextfile ( ) and close ( ) correspond to the functions of the same name in the module . With arguments `bufsize`.", "question_id": 3804}
{"snippet": "fileinput.FileInput(mode='r')", "intent": "Class FileInput is the implementation ; its methods filename ( ) , fileno ( ) , lineno ( ) , filelineno ( ) , isfirstline ( ) , isstdin ( ) , nextfile ( ) and close ( ) correspond to the functions of the same name in the module . With `mode` you can specify which file mode will be passed to open ( ) .", "question_id": 3805}
{"snippet": "fileinput.FileInput(openhook=None)", "intent": "Class FileInput is the implementation ; its methods filename ( ) , fileno ( ) , lineno ( ) , filelineno ( ) , isfirstline ( ) , isstdin ( ) , nextfile ( ) and close ( ) correspond to the functions of the same name in the module . The `openhook` , when given , must be a function that takes two arguments , filename and mode , and returns an accordingly opened file-like object .", "question_id": 3806}
{"snippet": "fileinput.FileInput(files=None, inplace=False)", "intent": "Class FileInput is the implementation ; its methods filename ( ) , fileno ( ) , lineno ( ) , filelineno ( ) , isfirstline ( ) , isstdin ( ) , nextfile ( ) and close ( ) correspond to the functions of the same name in the module . You can not use `inplace` and openhook together . With arguments `files`.", "question_id": 3807}
{"snippet": "fileinput.FileInput(files=None, backup='')", "intent": "Class FileInput is the implementation ; its methods filename ( ) , fileno ( ) , lineno ( ) , filelineno ( ) , isfirstline ( ) , isstdin ( ) , nextfile ( ) and close ( ) correspond to the functions of the same name in the module . With arguments `files`, `backup`.", "question_id": 3808}
{"snippet": "fileinput.FileInput(files=None, bufsize=0)", "intent": "Class FileInput is the implementation ; its methods filename ( ) , fileno ( ) , lineno ( ) , filelineno ( ) , isfirstline ( ) , isstdin ( ) , nextfile ( ) and close ( ) correspond to the functions of the same name in the module . With arguments `files`, `bufsize`.", "question_id": 3809}
{"snippet": "fileinput.hook_compressed(filename, mode)", "intent": "Transparently opens files compressed with gzip and bzip2 ( recognized by the extensions '.gz ' and '.bz2 ' ) using the gzip and bz2 modules . If the `filename` extension is not '.gz ' or '.bz2 ' , the file is opened normally ( ie , using open ( ) without any decompression ) . With arguments `mode`.", "question_id": 3810}
{"snippet": "fileinput.hook_encoded(encoding)", "intent": "Returns a hook which opens each file with open ( ) , using the given `encoding` and `errors` to read the file .", "question_id": 3811}
{"snippet": "fileinput.hook_encoded(encoding, errors=None)", "intent": "Returns a hook which opens each file with open ( ) , using the given `encoding` and `errors` to read the file .", "question_id": 3812}
{"snippet": "fnmatch.fnmatch(filename, pattern)", "intent": "Test whether the `filename` string matches the `pattern` string , returning True or False .", "question_id": 3813}
{"snippet": "fnmatch.fnmatchcase(filename, pattern)", "intent": "Test whether `filename` matches `pattern` , returning True or False ; the comparison is case-sensitive and does not apply os.path.normcase ( ) .", "question_id": 3814}
{"snippet": "fnmatch.filter(names, pattern)", "intent": "Return the subset of the list of `names` that match `pattern` .", "question_id": 3815}
{"snippet": "fnmatch.translate(pattern)", "intent": "Return the shell-style `pattern` converted to a regular expression for using with re.match ( ) .", "question_id": 3816}
{"snippet": "formatter.AS_IS", "intent": "Value which can be used in the font specification passed to the push_font() method described below, or as the new value to any other push_property() method.", "question_id": 3817}
{"snippet": "formatter.writer", "intent": "The writer instance with which the formatter interacts.", "question_id": 3818}
{"snippet": "formatter.end_paragraph(blanklines)", "intent": "Close any open paragraphs and insert at least `blanklines` before the next paragraph .", "question_id": 3819}
{"snippet": "formatter.add_line_break()", "intent": "Add a hard line break if one does not already exist .", "question_id": 3820}
{"snippet": "formatter.add_hor_rule(*args, **kw)", "intent": "Insert a horizontal rule in the output . With arguments `*args`, `**kw`.", "question_id": 3821}
{"snippet": "formatter.add_flowing_data(data)", "intent": "Provide `data` which should be formatted with collapsed whitespace .", "question_id": 3822}
{"snippet": "formatter.add_literal_data(data)", "intent": "Provide `data` which should be passed to the writer unchanged .", "question_id": 3823}
{"snippet": "formatter.add_label_data(format, counter)", "intent": "Insert a label which should be placed to the left of the current left margin . If the `format` value is a string , it is interpreted as a format specification for `counter` , which should be an integer .", "question_id": 3824}
{"snippet": "formatter.flush_softspace()", "intent": "Send any pending whitespace buffered from a previous call to add_flowing_data ( ) to the associated writer object .", "question_id": 3825}
{"snippet": "formatter.push_alignment(align)", "intent": "Push a new alignment setting onto the alignment stack . If the alignment value is changed from the previous setting , the writer \u2019 s new_alignment ( ) method is called with the `align` value .", "question_id": 3826}
{"snippet": "formatter.pop_alignment()", "intent": "Restore the previous alignment .", "question_id": 3827}
{"snippet": "formatter.push_font((size, italic, bold, teletype))", "intent": "Change some or all font properties of the writer object . With arguments `(size`, `italic`, `bold`, `teletype)`.", "question_id": 3828}
{"snippet": "formatter.pop_font()", "intent": "Restore the previous font .", "question_id": 3829}
{"snippet": "formatter.push_margin(margin)", "intent": "Increase the number of left `margin` indentations by one , associating the logical tag margin with the new indentation .", "question_id": 3830}
{"snippet": "formatter.pop_margin()", "intent": "Restore the previous margin .", "question_id": 3831}
{"snippet": "formatter.push_style(*styles)", "intent": "Push any number of arbitrary style specifications . With arguments `*styles`.", "question_id": 3832}
{"snippet": "formatter.pop_style()", "intent": "Pop the last `n` style specifications passed to push_style ( ) .", "question_id": 3833}
{"snippet": "formatter.pop_style(n=1)", "intent": "Pop the last `n` style specifications passed to push_style ( ) .", "question_id": 3834}
{"snippet": "formatter.set_spacing(spacing)", "intent": "Set the `spacing` style for the writer .", "question_id": 3835}
{"snippet": "formatter.assert_line_data()", "intent": "Inform the formatter that data has been added to the current paragraph out-of-band .", "question_id": 3836}
{"snippet": "formatter.assert_line_data(flag=1)", "intent": "Inform the formatter that data has been added to the current paragraph out-of-band . The optional `flag` argument can be set to false if the writer manipulations produced a hard line break at the end of the output .", "question_id": 3837}
{"snippet": "formatter.NullFormatter()", "intent": "A formatter which does nothing .", "question_id": 3838}
{"snippet": "formatter.NullFormatter(writer=None)", "intent": "A formatter which does nothing . If `writer` is omitted , a NullWriter instance is created .", "question_id": 3839}
{"snippet": "formatter.AbstractFormatter(writer)", "intent": "The standard formatter . With arguments `writer`.", "question_id": 3840}
{"snippet": "writer.flush()", "intent": "Flush any buffered output or device control events .", "question_id": 3841}
{"snippet": "writer.new_alignment(align)", "intent": "Set the alignment style . The `align` value can be any object , but by convention is a string or None , where None indicates that the writer \u2019 s \u201c preferred \u201d alignment should be used .", "question_id": 3842}
{"snippet": "writer.new_font(font)", "intent": "Set the `font` style .", "question_id": 3843}
{"snippet": "writer.new_margin(margin, level)", "intent": "Set the `margin` `level` to the integer level and the logical tag to margin .", "question_id": 3844}
{"snippet": "writer.new_spacing(spacing)", "intent": "Set the `spacing` style to spacing .", "question_id": 3845}
{"snippet": "writer.new_styles(styles)", "intent": "Set additional `styles` .", "question_id": 3846}
{"snippet": "writer.send_line_break()", "intent": "Break the current line .", "question_id": 3847}
{"snippet": "writer.send_paragraph(blankline)", "intent": "Produce a paragraph separation of at least `blankline` blank lines , or the equivalent .", "question_id": 3848}
{"snippet": "writer.send_hor_rule(*args, **kw)", "intent": "Display a horizontal rule on the output device . With arguments `*args`, `**kw`.", "question_id": 3849}
{"snippet": "writer.send_flowing_data(data)", "intent": "Output character `data` which may be word-wrapped and re-flowed as needed .", "question_id": 3850}
{"snippet": "writer.send_literal_data(data)", "intent": "Output character `data` which has already been formatted for display .", "question_id": 3851}
{"snippet": "writer.send_label_data(data)", "intent": "Set `data` to the left of the current left margin , if possible .", "question_id": 3852}
{"snippet": "formatter.NullWriter", "intent": "A writer which only provides the interface definition; no actions are taken on any methods.", "question_id": 3853}
{"snippet": "formatter.AbstractWriter", "intent": "A writer which can be used in debugging formatters, but not much else.", "question_id": 3854}
{"snippet": "formatter.DumbWriter()", "intent": "Simple writer class which writes output on the `file` object passed in as file or , if file is omitted , on standard output .", "question_id": 3855}
{"snippet": "formatter.DumbWriter(file=None)", "intent": "Simple writer class which writes output on the `file` object passed in as file or , if file is omitted , on standard output .", "question_id": 3856}
{"snippet": "formatter.DumbWriter(maxcol=72)", "intent": "Simple writer class which writes output on the `file` object passed in as file or , if file is omitted , on standard output . The output is simply word-wrapped to the number of columns specified by `maxcol` .", "question_id": 3857}
{"snippet": "formatter.DumbWriter(file=None, maxcol=72)", "intent": "Simple writer class which writes output on the `file` object passed in as file or , if file is omitted , on standard output . The output is simply word-wrapped to the number of columns specified by `maxcol` .", "question_id": 3858}
{"snippet": "fractions.Fraction()", "intent": "The first version requires that `numerator` and `denominator` are instances of numbers.Rational and returns a new Fraction instance with value numerator/denominator .", "question_id": 3859}
{"snippet": "fractions.Fraction(numerator=0)", "intent": "The first version requires that `numerator` and `denominator` are instances of numbers.Rational and returns a new Fraction instance with value numerator/denominator .", "question_id": 3860}
{"snippet": "fractions.Fraction(denominator=1)", "intent": "The first version requires that `numerator` and `denominator` are instances of numbers.Rational and returns a new Fraction instance with value numerator/denominator .", "question_id": 3861}
{"snippet": "fractions.Fraction(numerator=0, denominator=1)", "intent": "The first version requires that `numerator` and `denominator` are instances of numbers.Rational and returns a new Fraction instance with value numerator/denominator .", "question_id": 3862}
{"snippet": "fractions.Fraction(other_fraction)", "intent": "The first version requires that numerator and denominator are instances of numbers.Rational and returns a new Fraction instance with value numerator/denominator . The second version requires that `other_fraction` is an instance of numbers.Rational and returns a Fraction instance with the same value .", "question_id": 3863}
{"snippet": "fractions.Fraction(float)", "intent": "The first version requires that numerator and denominator are instances of numbers.Rational and returns a new Fraction instance with value numerator/denominator . The next two versions accept either a `float` or a decimal.Decimal instance , and return a Fraction instance with exactly the same value .", "question_id": 3864}
{"snippet": "fractions.Fraction(decimal)", "intent": "The first version requires that numerator and denominator are instances of numbers.Rational and returns a new Fraction instance with value numerator/denominator . where the optional sign may be either \u2018 + \u2019 or \u2018 - \u2018 and numerator and denominator ( if present ) are strings of `decimal` digits .", "question_id": 3865}
{"snippet": "fractions.Fraction(string)", "intent": "The first version requires that numerator and denominator are instances of numbers.Rational and returns a new Fraction instance with value numerator/denominator . The last version of the constructor expects a `string` or unicode instance .", "question_id": 3866}
{"snippet": "fraction.numerator", "intent": "Numerator of the Fraction in lowest term.", "question_id": 3867}
{"snippet": "fraction.denominator", "intent": "Denominator of the Fraction in lowest term.", "question_id": 3868}
{"snippet": "fraction.from_float(flt)", "intent": "This class method constructs a Fraction representing the exact value of `flt` , which must be a float .", "question_id": 3869}
{"snippet": "fraction.from_decimal(dec)", "intent": "This class method constructs a Fraction representing the exact value of `dec` , which must be a decimal.Decimal instance .", "question_id": 3870}
{"snippet": "fraction.limit_denominator()", "intent": "Finds and returns the closest Fraction to self that has denominator at most `max_denominator` .", "question_id": 3871}
{"snippet": "fraction.limit_denominator(max_denominator=1000000)", "intent": "Finds and returns the closest Fraction to self that has denominator at most `max_denominator` .", "question_id": 3872}
{"snippet": "fraction.__floor__()", "intent": "Returns the greatest int < = self .", "question_id": 3873}
{"snippet": "fraction.__ceil__()", "intent": "Returns the least int > = self .", "question_id": 3874}
{"snippet": "fraction.__round__()", "intent": "The first version returns the nearest int to self , rounding half to even .", "question_id": 3875}
{"snippet": "fraction.__round__(ndigits)", "intent": "The first version returns the nearest int to self , rounding half to even . The second version rounds self to the nearest multiple of Fraction ( 1 , 10**ndigits ) ( logically , if `ndigits` is negative ) , again rounding half toward even .", "question_id": 3876}
{"snippet": "fractions.gcd(a, b)", "intent": "Return the greatest common divisor of the integers `a` and `b` .", "question_id": 3877}
{"snippet": "ftplib.FTP()", "intent": "Return a new instance of the FTP class .", "question_id": 3878}
{"snippet": "ftplib.FTP(host='')", "intent": "Return a new instance of the FTP class . When `host` is given , the method call connect ( host ) is made .", "question_id": 3879}
{"snippet": "ftplib.FTP(user='')", "intent": "Return a new instance of the FTP class . When `user` is given , additionally the method call login ( user , `passwd` , `acct` ) is made ( where passwd and acct default to the empty string when not given ) .", "question_id": 3880}
{"snippet": "ftplib.FTP(passwd='')", "intent": "Return a new instance of the FTP class . When `user` is given , additionally the method call login ( user , `passwd` , `acct` ) is made ( where passwd and acct default to the empty string when not given ) .", "question_id": 3881}
{"snippet": "ftplib.FTP(acct='')", "intent": "Return a new instance of the FTP class . When `user` is given , additionally the method call login ( user , `passwd` , `acct` ) is made ( where passwd and acct default to the empty string when not given ) .", "question_id": 3882}
{"snippet": "ftplib.FTP(timeout=None)", "intent": "Return a new instance of the FTP class . The optional `timeout` parameter specifies a timeout in seconds for blocking operations like the connection attempt ( if is not specified , the global default timeout setting will be used ) .", "question_id": 3883}
{"snippet": "ftplib.FTP(source_address=None)", "intent": "Return a new instance of the FTP class . `source_address` is a 2-tuple ( host , port ) for the socket to bind to as its source address before connecting .", "question_id": 3884}
{"snippet": "ftplib.FTP(host='', user='')", "intent": "Return a new instance of the FTP class . When `host` is given , the method call connect ( host ) is made . When `user` is given , additionally the method call login ( user , `passwd` , `acct` ) is made ( where passwd and acct default to the empty string when not given ) .", "question_id": 3885}
{"snippet": "ftplib.FTP(host='', passwd='')", "intent": "Return a new instance of the FTP class . When `host` is given , the method call connect ( host ) is made . When `user` is given , additionally the method call login ( user , `passwd` , `acct` ) is made ( where passwd and acct default to the empty string when not given ) .", "question_id": 3886}
{"snippet": "ftplib.FTP(host='', acct='')", "intent": "Return a new instance of the FTP class . When `host` is given , the method call connect ( host ) is made . When `user` is given , additionally the method call login ( user , `passwd` , `acct` ) is made ( where passwd and acct default to the empty string when not given ) .", "question_id": 3887}
{"snippet": "ftplib.FTP_TLS()", "intent": "A FTP subclass which adds TLS support to FTP as described in RFC 4217 .", "question_id": 3888}
{"snippet": "ftplib.FTP_TLS(host='')", "intent": "A FTP subclass which adds TLS support to FTP as described in RFC 4217 . With arguments `host`.", "question_id": 3889}
{"snippet": "ftplib.FTP_TLS(user='')", "intent": "A FTP subclass which adds TLS support to FTP as described in RFC 4217 . Securing the data connection requires the `user` to explicitly ask for it by calling the prot_p ( ) method .", "question_id": 3890}
{"snippet": "ftplib.FTP_TLS(passwd='')", "intent": "A FTP subclass which adds TLS support to FTP as described in RFC 4217 . With arguments `passwd`.", "question_id": 3891}
{"snippet": "ftplib.FTP_TLS(acct='')", "intent": "A FTP subclass which adds TLS support to FTP as described in RFC 4217 . With arguments `acct`.", "question_id": 3892}
{"snippet": "ftplib.FTP_TLS(keyfile=None)", "intent": "A FTP subclass which adds TLS support to FTP as described in RFC 4217 . `keyfile` and `certfile` are a legacy alternative to context \u2013 they can point to PEM-formatted private key and certificate chain files ( respectively ) for the SSL connection .", "question_id": 3893}
{"snippet": "ftplib.FTP_TLS(certfile=None)", "intent": "A FTP subclass which adds TLS support to FTP as described in RFC 4217 . `keyfile` and `certfile` are a legacy alternative to context \u2013 they can point to PEM-formatted private key and certificate chain files ( respectively ) for the SSL connection .", "question_id": 3894}
{"snippet": "ftplib.FTP_TLS(context=None)", "intent": "A FTP subclass which adds TLS support to FTP as described in RFC 4217 . `context` is a ssl.SSLContext object which allows bundling SSL configuration options , certificates and private keys into a single ( potentially long-lived ) structure .", "question_id": 3895}
{"snippet": "ftplib.FTP_TLS(timeout=None)", "intent": "A FTP subclass which adds TLS support to FTP as described in RFC 4217 . With arguments `timeout`.", "question_id": 3896}
{"snippet": "ftplib.FTP_TLS(source_address=None)", "intent": "A FTP subclass which adds TLS support to FTP as described in RFC 4217 . With arguments `source_address`.", "question_id": 3897}
{"snippet": "ftplib.error_reply", "intent": "Exception raised when an unexpected reply is received from the server.", "question_id": 3898}
{"snippet": "ftplib.error_temp", "intent": "Exception raised when an error code signifying a temporary error (response codes in the range 400\u2013499) is received.", "question_id": 3899}
{"snippet": "ftplib.error_perm", "intent": "Exception raised when an error code signifying a permanent error (response codes in the range 500\u2013599) is received.", "question_id": 3900}
{"snippet": "ftplib.error_proto", "intent": "Exception raised when a reply is received from the server that does not fit the response specifications of the File Transfer Protocol, i.e.", "question_id": 3901}
{"snippet": "ftplib.all_errors", "intent": "The set of all exceptions (as a tuple) that methods of FTP instances may raise as a result of problems with the FTP connection (as opposed to programming errors made by the caller).", "question_id": 3902}
{"snippet": "FTP.set_debuglevel(level)", "intent": "Set the instance \u2019 s debugging `level` .", "question_id": 3903}
{"snippet": "FTP.connect()", "intent": "Connect to the given `host` and `port` .", "question_id": 3904}
{"snippet": "FTP.connect(host='')", "intent": "Connect to the given `host` and `port` .", "question_id": 3905}
{"snippet": "FTP.connect(port=0)", "intent": "Connect to the given `host` and `port` .", "question_id": 3906}
{"snippet": "FTP.connect(timeout=None)", "intent": "Connect to the given `host` and `port` . The optional `timeout` parameter specifies a timeout in seconds for the connection attempt .", "question_id": 3907}
{"snippet": "FTP.connect(source_address=None)", "intent": "Connect to the given `host` and `port` . `source_address` is a 2-tuple ( host , port ) for the socket to bind to as its source address before connecting .", "question_id": 3908}
{"snippet": "FTP.connect(host='', port=0)", "intent": "Connect to the given `host` and `port` .", "question_id": 3909}
{"snippet": "FTP.connect(host='', timeout=None)", "intent": "Connect to the given `host` and `port` . The optional `timeout` parameter specifies a timeout in seconds for the connection attempt .", "question_id": 3910}
{"snippet": "FTP.connect(host='', source_address=None)", "intent": "Connect to the given `host` and `port` . `source_address` is a 2-tuple ( host , port ) for the socket to bind to as its source address before connecting .", "question_id": 3911}
{"snippet": "FTP.connect(port=0, timeout=None)", "intent": "Connect to the given `host` and `port` . The optional `timeout` parameter specifies a timeout in seconds for the connection attempt .", "question_id": 3912}
{"snippet": "FTP.connect(port=0, source_address=None)", "intent": "Connect to the given `host` and `port` . `source_address` is a 2-tuple ( host , port ) for the socket to bind to as its source address before connecting .", "question_id": 3913}
{"snippet": "FTP.getwelcome()", "intent": "Return the welcome message sent by the server in reply to the initial connection .", "question_id": 3914}
{"snippet": "FTP.login()", "intent": "Log in as the given `user` .", "question_id": 3915}
{"snippet": "FTP.login(user='anonymous')", "intent": "Log in as the given `user` .", "question_id": 3916}
{"snippet": "FTP.login(passwd='')", "intent": "Log in as the given `user` . The `passwd` and `acct` parameters are optional and default to the empty string .", "question_id": 3917}
{"snippet": "FTP.login(acct='')", "intent": "Log in as the given `user` . The `passwd` and `acct` parameters are optional and default to the empty string .", "question_id": 3918}
{"snippet": "FTP.login(user='anonymous', passwd='')", "intent": "Log in as the given `user` . The `passwd` and `acct` parameters are optional and default to the empty string .", "question_id": 3919}
{"snippet": "FTP.login(user='anonymous', acct='')", "intent": "Log in as the given `user` . The `passwd` and `acct` parameters are optional and default to the empty string .", "question_id": 3920}
{"snippet": "FTP.login(passwd='', acct='')", "intent": "Log in as the given `user` . The `passwd` and `acct` parameters are optional and default to the empty string .", "question_id": 3921}
{"snippet": "FTP.login(user='anonymous', passwd='', acct='')", "intent": "Log in as the given `user` . The `passwd` and `acct` parameters are optional and default to the empty string .", "question_id": 3922}
{"snippet": "FTP.abort()", "intent": "Abort a file transfer that is in progress .", "question_id": 3923}
{"snippet": "FTP.sendcmd(cmd)", "intent": "Send a simple command string to the server and return the response string . With arguments `cmd`.", "question_id": 3924}
{"snippet": "FTP.voidcmd(cmd)", "intent": "Send a simple command string to the server and handle the response . With arguments `cmd`.", "question_id": 3925}
{"snippet": "FTP.retrbinary(cmd, callback)", "intent": "Retrieve a file in binary transfer mode . `cmd` should be an appropriate RETR command : 'RETR filename ' . The `callback` function is called for each block of data received , with a single bytes argument giving the data block .", "question_id": 3926}
{"snippet": "FTP.retrbinary(cmd, callback, blocksize=8192)", "intent": "Retrieve a file in binary transfer mode . `cmd` should be an appropriate RETR command : 'RETR filename ' . The `callback` function is called for each block of data received , with a single bytes argument giving the data block . The optional `blocksize` argument specifies the maximum chunk size to read on the low-level socket object created to do the actual transfer ( which will also be the largest size of the data blocks passed to callback ) .", "question_id": 3927}
{"snippet": "FTP.retrbinary(cmd, callback, rest=None)", "intent": "Retrieve a file in binary transfer mode . `cmd` should be an appropriate RETR command : 'RETR filename ' . The `callback` function is called for each block of data received , with a single bytes argument giving the data block . `rest` means the same thing as in the transfercmd ( ) method .", "question_id": 3928}
{"snippet": "FTP.retrbinary(cmd, callback, blocksize=8192, rest=None)", "intent": "Retrieve a file in binary transfer mode . `cmd` should be an appropriate RETR command : 'RETR filename ' . The `callback` function is called for each block of data received , with a single bytes argument giving the data block . The optional `blocksize` argument specifies the maximum chunk size to read on the low-level socket object created to do the actual transfer ( which will also be the largest size of the data blocks passed to callback ) . `rest` means the same thing as in the transfercmd ( ) method .", "question_id": 3929}
{"snippet": "FTP.retrlines(cmd)", "intent": "Retrieve a file or directory listing in ASCII transfer mode . `cmd` should be an appropriate RETR command ( see retrbinary ( ) ) or a command such as LIST or NLST ( usually just the string 'LIST ' ) .", "question_id": 3930}
{"snippet": "FTP.retrlines(cmd, callback=None)", "intent": "Retrieve a file or directory listing in ASCII transfer mode . `cmd` should be an appropriate RETR command ( see retrbinary ( ) ) or a command such as LIST or NLST ( usually just the string 'LIST ' ) . The `callback` function is called for each line with a string argument containing the line with the trailing CRLF stripped .", "question_id": 3931}
{"snippet": "FTP.set_pasv(val)", "intent": "Enable \u201c passive \u201d mode if `val` is true , otherwise disable passive mode .", "question_id": 3932}
{"snippet": "FTP.storbinary(cmd, fp)", "intent": "Store a file in binary transfer mode . `cmd` should be an appropriate STOR command : `` STOR filename '' . `fp` is a file object ( opened in binary mode ) which is read until EOF using its read ( ) method in blocks of size `blocksize` to provide the data to be stored .", "question_id": 3933}
{"snippet": "FTP.storbinary(cmd, fp, blocksize=8192)", "intent": "Store a file in binary transfer mode . `cmd` should be an appropriate STOR command : `` STOR filename '' . `fp` is a file object ( opened in binary mode ) which is read until EOF using its read ( ) method in blocks of size `blocksize` to provide the data to be stored .", "question_id": 3934}
{"snippet": "FTP.storbinary(cmd, fp, callback=None)", "intent": "Store a file in binary transfer mode . `cmd` should be an appropriate STOR command : `` STOR filename '' . `fp` is a file object ( opened in binary mode ) which is read until EOF using its read ( ) method in blocks of size `blocksize` to provide the data to be stored . The blocksize argument defaults to 8192. `callback` is an optional single parameter callable that is called on each block of data after it is sent .", "question_id": 3935}
{"snippet": "FTP.storbinary(cmd, fp, rest=None)", "intent": "Store a file in binary transfer mode . `cmd` should be an appropriate STOR command : `` STOR filename '' . `fp` is a file object ( opened in binary mode ) which is read until EOF using its read ( ) method in blocks of size `blocksize` to provide the data to be stored . `rest` means the same thing as in the transfercmd ( ) method .", "question_id": 3936}
{"snippet": "FTP.storbinary(cmd, fp, blocksize=8192, callback=None)", "intent": "Store a file in binary transfer mode . `cmd` should be an appropriate STOR command : `` STOR filename '' . `fp` is a file object ( opened in binary mode ) which is read until EOF using its read ( ) method in blocks of size `blocksize` to provide the data to be stored . The blocksize argument defaults to 8192. `callback` is an optional single parameter callable that is called on each block of data after it is sent .", "question_id": 3937}
{"snippet": "FTP.storbinary(cmd, fp, blocksize=8192, rest=None)", "intent": "Store a file in binary transfer mode . `cmd` should be an appropriate STOR command : `` STOR filename '' . `fp` is a file object ( opened in binary mode ) which is read until EOF using its read ( ) method in blocks of size `blocksize` to provide the data to be stored . `rest` means the same thing as in the transfercmd ( ) method .", "question_id": 3938}
{"snippet": "FTP.storbinary(cmd, fp, callback=None, rest=None)", "intent": "Store a file in binary transfer mode . `cmd` should be an appropriate STOR command : `` STOR filename '' . `fp` is a file object ( opened in binary mode ) which is read until EOF using its read ( ) method in blocks of size `blocksize` to provide the data to be stored . The blocksize argument defaults to 8192. `callback` is an optional single parameter callable that is called on each block of data after it is sent . `rest` means the same thing as in the transfercmd ( ) method .", "question_id": 3939}
{"snippet": "FTP.storbinary(cmd, fp, blocksize=8192, callback=None, rest=None)", "intent": "Store a file in binary transfer mode . `cmd` should be an appropriate STOR command : `` STOR filename '' . `fp` is a file object ( opened in binary mode ) which is read until EOF using its read ( ) method in blocks of size `blocksize` to provide the data to be stored . The blocksize argument defaults to 8192. `callback` is an optional single parameter callable that is called on each block of data after it is sent . `rest` means the same thing as in the transfercmd ( ) method .", "question_id": 3940}
{"snippet": "FTP.storlines(cmd, fp)", "intent": "Store a file in ASCII transfer mode . `cmd` should be an appropriate STOR command ( see storbinary ( ) ) . Lines are read until EOF from the file object `fp` ( opened in binary mode ) using its readline ( ) method to provide the data to be stored .", "question_id": 3941}
{"snippet": "FTP.storlines(cmd, fp, callback=None)", "intent": "Store a file in ASCII transfer mode . `cmd` should be an appropriate STOR command ( see storbinary ( ) ) . Lines are read until EOF from the file object `fp` ( opened in binary mode ) using its readline ( ) method to provide the data to be stored . `callback` is an optional single parameter callable that is called on each line after it is sent .", "question_id": 3942}
{"snippet": "FTP.transfercmd(cmd)", "intent": "Initiate a transfer over the data connection . If the transfer is active , send an EPRT or PORT command and the transfer command specified by `cmd` , and accept the connection .", "question_id": 3943}
{"snippet": "FTP.transfercmd(cmd, rest=None)", "intent": "Initiate a transfer over the data connection . If the transfer is active , send an EPRT or PORT command and the transfer command specified by `cmd` , and accept the connection . If optional `rest` is given , a REST command is sent to the server , passing rest as an argument .", "question_id": 3944}
{"snippet": "FTP.ntransfercmd(cmd)", "intent": "Like transfercmd ( ) , but returns a tuple of the data connection and the expected size of the data . `cmd` and `rest` means the same thing as in transfercmd ( ) .", "question_id": 3945}
{"snippet": "FTP.ntransfercmd(cmd, rest=None)", "intent": "Like transfercmd ( ) , but returns a tuple of the data connection and the expected size of the data . `cmd` and `rest` means the same thing as in transfercmd ( ) .", "question_id": 3946}
{"snippet": "FTP.mlsd()", "intent": "List a directory in a standardized format by using MLSD command ( RFC 3659 ) .", "question_id": 3947}
{"snippet": "FTP.mlsd(path=\"\")", "intent": "List a directory in a standardized format by using MLSD command ( RFC 3659 ) . If `path` is omitted the current directory is assumed .", "question_id": 3948}
{"snippet": "FTP.mlsd(facts=)", "intent": "List a directory in a standardized format by using MLSD command ( RFC 3659 ) . `facts` is a list of strings representing the type of information desired ( e.g .", "question_id": 3949}
{"snippet": "FTP.mlsd(path=\"\", facts=)", "intent": "List a directory in a standardized format by using MLSD command ( RFC 3659 ) . If `path` is omitted the current directory is assumed . `facts` is a list of strings representing the type of information desired ( e.g .", "question_id": 3950}
{"snippet": "FTP.mlsd()", "intent": "List a directory in a standardized format by using MLSD command ( RFC 3659 ) .", "question_id": 3951}
{"snippet": "FTP.mlsd(path=\"\")", "intent": "List a directory in a standardized format by using MLSD command ( RFC 3659 ) . If `path` is omitted the current directory is assumed .", "question_id": 3952}
{"snippet": "FTP.mlsd(facts=)", "intent": "List a directory in a standardized format by using MLSD command ( RFC 3659 ) . `facts` is a list of strings representing the type of information desired ( e.g .", "question_id": 3953}
{"snippet": "FTP.mlsd(path=\"\", facts=)", "intent": "List a directory in a standardized format by using MLSD command ( RFC 3659 ) . If `path` is omitted the current directory is assumed . `facts` is a list of strings representing the type of information desired ( e.g .", "question_id": 3954}
{"snippet": "FTP.nlst(argument)", "intent": "Return a list of file names as returned by the NLST command . The optional `argument` is a directory to list ( default is the current server directory ) .", "question_id": 3955}
{"snippet": "FTP.nlst()", "intent": "Return a list of file names as returned by the NLST command .", "question_id": 3956}
{"snippet": "FTP.dir(argument)", "intent": "Produce a directory listing as returned by the LIST command , printing it to standard output . The optional `argument` is a directory to list ( default is the current server directory ) .", "question_id": 3957}
{"snippet": "FTP.dir()", "intent": "Produce a directory listing as returned by the LIST command , printing it to standard output .", "question_id": 3958}
{"snippet": "FTP.rename(fromname, toname)", "intent": "Rename file `fromname` on the server to `toname` .", "question_id": 3959}
{"snippet": "FTP.delete(filename)", "intent": "Remove the file named `filename` from the server .", "question_id": 3960}
{"snippet": "FTP.cwd(pathname)", "intent": "Set the current directory on the server . With arguments `pathname`.", "question_id": 3961}
{"snippet": "FTP.mkd(pathname)", "intent": "Create a new directory on the server . With arguments `pathname`.", "question_id": 3962}
{"snippet": "FTP.pwd()", "intent": "Return the pathname of the current directory on the server .", "question_id": 3963}
{"snippet": "FTP.rmd(dirname)", "intent": "Remove the directory named `dirname` on the server .", "question_id": 3964}
{"snippet": "FTP.size(filename)", "intent": "Request the size of the file named `filename` on the server .", "question_id": 3965}
{"snippet": "FTP.quit()", "intent": "Send a QUIT command to the server and close the connection .", "question_id": 3966}
{"snippet": "FTP.close()", "intent": "Close the connection unilaterally .", "question_id": 3967}
{"snippet": "FTP_TLS.ssl_version", "intent": "The SSL version to use (defaults to ssl.PROTOCOL_SSLv23).", "question_id": 3968}
{"snippet": "FTP_TLS.auth()", "intent": "Set up a secure control connection by using TLS or SSL , depending on what is specified in the ssl_version attribute .", "question_id": 3969}
{"snippet": "FTP_TLS.ccc()", "intent": "Revert control channel back to plaintext .", "question_id": 3970}
{"snippet": "FTP_TLS.prot_p()", "intent": "Set up secure data connection .", "question_id": 3971}
{"snippet": "FTP_TLS.prot_c()", "intent": "Set up clear text data connection .", "question_id": 3972}
{"snippet": "abs(x)", "intent": "Return the absolute value of a number . With arguments `x`.", "question_id": 3973}
{"snippet": "all(iterable)", "intent": "Return True if all elements of the `iterable` are true ( or if the iterable is empty ) .", "question_id": 3974}
{"snippet": "any(iterable)", "intent": "Return True if any element of the `iterable` is true .", "question_id": 3975}
{"snippet": "ascii(object)", "intent": "As repr ( ) , return a string containing a printable representation of an `object` , but escape the non-ASCII characters in the string returned by repr ( ) using \\x , \\u or \\U escapes .", "question_id": 3976}
{"snippet": "bin(x)", "intent": "Convert an integer number to a binary string prefixed with \u201c 0b \u201d . If `x` is not a Python int object , it has to define an __index__ ( ) method that returns an integer .", "question_id": 3977}
{"snippet": "bool(x)", "intent": "Return a Boolean value , i.e . `x` is converted using the standard truth testing procedure .", "question_id": 3978}
{"snippet": "bool()", "intent": "Return a Boolean value , i.e .", "question_id": 3979}
{"snippet": "breakpoint(*args, **kws)", "intent": "This function drops you into the debugger at the call site . With arguments `*args`, `**kws`.", "question_id": 3980}
{"snippet": "bytearray(source, encoding, errors)", "intent": "Return a new array of bytes . The optional `source` parameter can be used to initialize the array in a few different ways : With arguments `encoding`, `errors`.", "question_id": 3981}
{"snippet": "bytearray(source, encoding)", "intent": "Return a new array of bytes . The optional `source` parameter can be used to initialize the array in a few different ways : With arguments `encoding`.", "question_id": 3982}
{"snippet": "bytearray(source)", "intent": "Return a new array of bytes . The optional `source` parameter can be used to initialize the array in a few different ways :", "question_id": 3983}
{"snippet": "bytearray()", "intent": "Return a new array of bytes .", "question_id": 3984}
{"snippet": "bytes(source, encoding, errors)", "intent": "Return a new \u201c bytes \u201d object , which is an immutable sequence of integers in the range 0 < = x < 256. bytes is an immutable version of bytearray \u2013 it has the same non-mutating methods and the same indexing and slicing behavior . With arguments `source`, `encoding`, `errors`.", "question_id": 3985}
{"snippet": "bytes(source, encoding)", "intent": "Return a new \u201c bytes \u201d object , which is an immutable sequence of integers in the range 0 < = x < 256. bytes is an immutable version of bytearray \u2013 it has the same non-mutating methods and the same indexing and slicing behavior . With arguments `source`, `encoding`.", "question_id": 3986}
{"snippet": "bytes(source)", "intent": "Return a new \u201c bytes \u201d object , which is an immutable sequence of integers in the range 0 < = x < 256. bytes is an immutable version of bytearray \u2013 it has the same non-mutating methods and the same indexing and slicing behavior . With arguments `source`.", "question_id": 3987}
{"snippet": "bytes()", "intent": "Return a new \u201c bytes \u201d object , which is an immutable sequence of integers in the range 0 < = x < 256. bytes is an immutable version of bytearray \u2013 it has the same non-mutating methods and the same indexing and slicing behavior .", "question_id": 3988}
{"snippet": "callable(object)", "intent": "Return True if the `object` argument appears callable , False if not .", "question_id": 3989}
{"snippet": "chr(i)", "intent": "Return the string representing a character whose Unicode code point is the integer `i` .", "question_id": 3990}
{"snippet": "@classmethod", "intent": "Transform a method into a class method.", "question_id": 3991}
{"snippet": "compile(source, filename, mode)", "intent": "Compile the `source` into a code or AST object . The `filename` argument should give the file from which the code was read ; pass some recognizable value if it wasn \u2019 t read from a file ( ' < string > ' is commonly used ) . The `mode` argument specifies what kind of code must be compiled ; it can be 'exec ' if source consists of a sequence of statements , 'eval ' if it consists of a single expression , or 'single ' if it consists of a single interactive statement ( in the latter case , expression statements that evaluate to something other than None will be printed ) .", "question_id": 3992}
{"snippet": "compile(source, filename, mode, flags=0)", "intent": "Compile the `source` into a code or AST object . The `filename` argument should give the file from which the code was read ; pass some recognizable value if it wasn \u2019 t read from a file ( ' < string > ' is commonly used ) . The `mode` argument specifies what kind of code must be compiled ; it can be 'exec ' if source consists of a sequence of statements , 'eval ' if it consists of a single expression , or 'single ' if it consists of a single interactive statement ( in the latter case , expression statements that evaluate to something other than None will be printed ) . The optional arguments `flags` and `dont_inherit` control which future statements affect the compilation of source .", "question_id": 3993}
{"snippet": "compile(source, filename, mode, dont_inherit=False)", "intent": "Compile the `source` into a code or AST object . The `filename` argument should give the file from which the code was read ; pass some recognizable value if it wasn \u2019 t read from a file ( ' < string > ' is commonly used ) . The `mode` argument specifies what kind of code must be compiled ; it can be 'exec ' if source consists of a sequence of statements , 'eval ' if it consists of a single expression , or 'single ' if it consists of a single interactive statement ( in the latter case , expression statements that evaluate to something other than None will be printed ) . The optional arguments `flags` and `dont_inherit` control which future statements affect the compilation of source .", "question_id": 3994}
{"snippet": "compile(source, filename, mode, optimize=-1)", "intent": "Compile the `source` into a code or AST object . The `filename` argument should give the file from which the code was read ; pass some recognizable value if it wasn \u2019 t read from a file ( ' < string > ' is commonly used ) . The `mode` argument specifies what kind of code must be compiled ; it can be 'exec ' if source consists of a sequence of statements , 'eval ' if it consists of a single expression , or 'single ' if it consists of a single interactive statement ( in the latter case , expression statements that evaluate to something other than None will be printed ) . The argument `optimize` specifies the optimization level of the compiler ; the default value of -1 selects the optimization level of the interpreter as given by -O options .", "question_id": 3995}
{"snippet": "compile(source, filename, mode, flags=0, dont_inherit=False)", "intent": "Compile the `source` into a code or AST object . The `filename` argument should give the file from which the code was read ; pass some recognizable value if it wasn \u2019 t read from a file ( ' < string > ' is commonly used ) . The `mode` argument specifies what kind of code must be compiled ; it can be 'exec ' if source consists of a sequence of statements , 'eval ' if it consists of a single expression , or 'single ' if it consists of a single interactive statement ( in the latter case , expression statements that evaluate to something other than None will be printed ) . The optional arguments `flags` and `dont_inherit` control which future statements affect the compilation of source .", "question_id": 3996}
{"snippet": "compile(source, filename, mode, flags=0, optimize=-1)", "intent": "Compile the `source` into a code or AST object . The `filename` argument should give the file from which the code was read ; pass some recognizable value if it wasn \u2019 t read from a file ( ' < string > ' is commonly used ) . The `mode` argument specifies what kind of code must be compiled ; it can be 'exec ' if source consists of a sequence of statements , 'eval ' if it consists of a single expression , or 'single ' if it consists of a single interactive statement ( in the latter case , expression statements that evaluate to something other than None will be printed ) . The optional arguments `flags` and `dont_inherit` control which future statements affect the compilation of source . The argument `optimize` specifies the optimization level of the compiler ; the default value of -1 selects the optimization level of the interpreter as given by -O options .", "question_id": 3997}
{"snippet": "compile(source, filename, mode, dont_inherit=False, optimize=-1)", "intent": "Compile the `source` into a code or AST object . The `filename` argument should give the file from which the code was read ; pass some recognizable value if it wasn \u2019 t read from a file ( ' < string > ' is commonly used ) . The `mode` argument specifies what kind of code must be compiled ; it can be 'exec ' if source consists of a sequence of statements , 'eval ' if it consists of a single expression , or 'single ' if it consists of a single interactive statement ( in the latter case , expression statements that evaluate to something other than None will be printed ) . The optional arguments `flags` and `dont_inherit` control which future statements affect the compilation of source . The argument `optimize` specifies the optimization level of the compiler ; the default value of -1 selects the optimization level of the interpreter as given by -O options .", "question_id": 3998}
{"snippet": "compile(source, filename, mode, flags=0, dont_inherit=False, optimize=-1)", "intent": "Compile the `source` into a code or AST object . The `filename` argument should give the file from which the code was read ; pass some recognizable value if it wasn \u2019 t read from a file ( ' < string > ' is commonly used ) . The `mode` argument specifies what kind of code must be compiled ; it can be 'exec ' if source consists of a sequence of statements , 'eval ' if it consists of a single expression , or 'single ' if it consists of a single interactive statement ( in the latter case , expression statements that evaluate to something other than None will be printed ) . The optional arguments `flags` and `dont_inherit` control which future statements affect the compilation of source . The argument `optimize` specifies the optimization level of the compiler ; the default value of -1 selects the optimization level of the interpreter as given by -O options .", "question_id": 3999}
{"snippet": "complex(real, imag)", "intent": "Return a complex number with the value `real` + imag*1j or convert a string or number to a complex number . If `imag` is omitted , it defaults to zero and the constructor serves as a numeric conversion like int and float .", "question_id": 4000}
{"snippet": "complex(real)", "intent": "Return a complex number with the value `real` + imag*1j or convert a string or number to a complex number .", "question_id": 4001}
{"snippet": "complex()", "intent": "Return a complex number with the value `real` + imag*1j or convert a string or number to a complex number .", "question_id": 4002}
{"snippet": "delattr(object, name)", "intent": "This is a relative of setattr ( ) . The arguments are an `object` and a string . The string must be the `name` of one of the object \u2019 s attributes .", "question_id": 4003}
{"snippet": "dict(**kwarg)", "intent": "Create a new dictionary . With arguments `**kwarg`.", "question_id": 4004}
{"snippet": "dict(mapping, **kwarg)", "intent": "Create a new dictionary . With arguments `mapping`, `**kwarg`.", "question_id": 4005}
{"snippet": "dict(iterable, **kwarg)", "intent": "Create a new dictionary . With arguments `iterable`, `**kwarg`.", "question_id": 4006}
{"snippet": "dir(object)", "intent": "Without arguments , return the list of names in the current local scope . With an argument , attempt to return a list of valid attributes for that `object` .", "question_id": 4007}
{"snippet": "dir()", "intent": "Without arguments , return the list of names in the current local scope .", "question_id": 4008}
{"snippet": "divmod(a, b)", "intent": "Take two ( non complex ) numbers as arguments and return `a` pair of numbers consisting of their quotient and remainder when using integer division . For integers , the result is the same as ( a // `b` , a % b ) .", "question_id": 4009}
{"snippet": "enumerate(iterable)", "intent": "Return an enumerate object . `iterable` must be a sequence , an iterator , or some other object which supports iteration .", "question_id": 4010}
{"snippet": "enumerate(iterable, start=0)", "intent": "Return an enumerate object . `iterable` must be a sequence , an iterator , or some other object which supports iteration . The __next__ ( ) method of the iterator returned by enumerate ( ) returns a tuple containing a count ( from `start` which defaults to 0 ) and the values obtained from iterating over iterable .", "question_id": 4011}
{"snippet": "eval(expression, globals, locals)", "intent": "The arguments are a string and optional `globals` and `locals` . The `expression` argument is parsed and evaluated as a Python expression ( technically speaking , a condition list ) using the globals and locals dictionaries as global and local namespace .", "question_id": 4012}
{"snippet": "eval(expression, globals)", "intent": "The arguments are a string and optional `globals` and `locals` . The `expression` argument is parsed and evaluated as a Python expression ( technically speaking , a condition list ) using the globals and locals dictionaries as global and local namespace .", "question_id": 4013}
{"snippet": "eval(expression)", "intent": "The arguments are a string and optional `globals` and `locals` . The `expression` argument is parsed and evaluated as a Python expression ( technically speaking , a condition list ) using the globals and locals dictionaries as global and local namespace .", "question_id": 4014}
{"snippet": "exec(object, globals, locals)", "intent": "This function supports dynamic execution of Python code . `object` must be either a string or a code object . If only `globals` is provided , it must be a dictionary , which will be used for both the global and the local variables . If globals and `locals` are given , they are used for the global and local variables , respectively .", "question_id": 4015}
{"snippet": "exec(object, globals)", "intent": "This function supports dynamic execution of Python code . `object` must be either a string or a code object . If only `globals` is provided , it must be a dictionary , which will be used for both the global and the local variables .", "question_id": 4016}
{"snippet": "exec(object)", "intent": "This function supports dynamic execution of Python code . `object` must be either a string or a code object .", "question_id": 4017}
{"snippet": "filter(function, iterable)", "intent": "Construct an iterator from those elements of `iterable` for which `function` returns true .", "question_id": 4018}
{"snippet": "float(x)", "intent": "Return a floating point number constructed from a number or string `x` .", "question_id": 4019}
{"snippet": "float()", "intent": "Return a floating point number constructed from a number or string `x` .", "question_id": 4020}
{"snippet": "format(value, format_spec)", "intent": "Convert a `value` to a \u201c formatted \u201d representation , as controlled by `format_spec` .", "question_id": 4021}
{"snippet": "format(value)", "intent": "Convert a `value` to a \u201c formatted \u201d representation , as controlled by `format_spec` .", "question_id": 4022}
{"snippet": "frozenset(iterable)", "intent": "Return a new frozenset object , optionally with elements taken from `iterable` .", "question_id": 4023}
{"snippet": "frozenset()", "intent": "Return a new frozenset object , optionally with elements taken from `iterable` .", "question_id": 4024}
{"snippet": "getattr(object, name, default)", "intent": "Return the value of the named attribute of `object` . `name` must be a string . If the named attribute does not exist , `default` is returned if provided , otherwise AttributeError is raised .", "question_id": 4025}
{"snippet": "getattr(object, name)", "intent": "Return the value of the named attribute of `object` . `name` must be a string .", "question_id": 4026}
{"snippet": "globals()", "intent": "Return a dictionary representing the current global symbol table .", "question_id": 4027}
{"snippet": "hasattr(object, name)", "intent": "The arguments are an `object` and a string . The result is True if the string is the `name` of one of the object \u2019 s attributes , False if not .", "question_id": 4028}
{"snippet": "hash(object)", "intent": "Return the hash value of the `object` ( if it has one ) .", "question_id": 4029}
{"snippet": "help(object)", "intent": "Invoke the built-in help system . If the argument is any other kind of `object` , a help page on the object is generated .", "question_id": 4030}
{"snippet": "help()", "intent": "Invoke the built-in help system .", "question_id": 4031}
{"snippet": "hex(x)", "intent": "Convert an integer number to a lowercase hexadecimal string prefixed with \u201c 0x \u201d . If `x` is not a Python int object , it has to define an __index__ ( ) method that returns an integer .", "question_id": 4032}
{"snippet": "id(object)", "intent": "Return the \u201c identity \u201d of an `object` .", "question_id": 4033}
{"snippet": "input(prompt)", "intent": "If the `prompt` argument is present , it is written to standard output without a trailing newline .", "question_id": 4034}
{"snippet": "input()", "intent": "If the `prompt` argument is present , it is written to standard output without a trailing newline .", "question_id": 4035}
{"snippet": "int(x)", "intent": "Return an integer object constructed from a number or string `x` , or return 0 if no arguments are given .", "question_id": 4036}
{"snippet": "int()", "intent": "Return an integer object constructed from a number or string `x` , or return 0 if no arguments are given .", "question_id": 4037}
{"snippet": "int(x)", "intent": "Return an integer object constructed from a number or string `x` , or return 0 if no arguments are given .", "question_id": 4038}
{"snippet": "int(x, base=10)", "intent": "Return an integer object constructed from a number or string `x` , or return 0 if no arguments are given . If x is not a number or if `base` is given , then x must be a string , bytes , or bytearray instance representing an integer literal in radix base .", "question_id": 4039}
{"snippet": "isinstance(object, classinfo)", "intent": "Return true if the `object` argument is an instance of the `classinfo` argument , or of a ( direct , indirect or virtual ) subclass thereof .", "question_id": 4040}
{"snippet": "issubclass(class, classinfo)", "intent": "Return true if `class` is a subclass ( direct , indirect or virtual ) of `classinfo` .", "question_id": 4041}
{"snippet": "iter(object, sentinel)", "intent": "Return an iterator `object` . If the second argument , `sentinel` , is given , then object must be a callable object .", "question_id": 4042}
{"snippet": "iter(object)", "intent": "Return an iterator `object` .", "question_id": 4043}
{"snippet": "len(s)", "intent": "Return the length ( the number of items ) of an object . With arguments `s`.", "question_id": 4044}
{"snippet": "list(iterable)", "intent": "Rather than being a function , list is actually a mutable sequence type , as documented in Lists and Sequence Types \u2014 list , tuple , range . With arguments `iterable`.", "question_id": 4045}
{"snippet": "list()", "intent": "Rather than being a function , list is actually a mutable sequence type , as documented in Lists and Sequence Types \u2014 list , tuple , range .", "question_id": 4046}
{"snippet": "locals()", "intent": "Update and return a dictionary representing the current local symbol table .", "question_id": 4047}
{"snippet": "map(function, iterable)", "intent": "Return an iterator that applies `function` to every item of `iterable` , yielding the results .", "question_id": 4048}
{"snippet": "max(iterable, key, default)", "intent": "Return the largest item in an `iterable` or the largest of two or more arguments . The `key` argument specifies a one-argument ordering function like that used for list.sort ( ) . The `default` argument specifies an object to return if the provided iterable is empty .", "question_id": 4049}
{"snippet": "max(iterable, key)", "intent": "Return the largest item in an `iterable` or the largest of two or more arguments . The `key` argument specifies a one-argument ordering function like that used for list.sort ( ) .", "question_id": 4050}
{"snippet": "max(arg1, arg2, *args, key)", "intent": "Return the largest item in an iterable or the largest of two or more arguments . The `key` argument specifies a one-argument ordering function like that used for list.sort ( ) . With arguments `arg1`, `arg2`, `*args`.", "question_id": 4051}
{"snippet": "max(arg1, arg2, *args)", "intent": "Return the largest item in an iterable or the largest of two or more arguments . With arguments `arg1`, `arg2`, `*args`.", "question_id": 4052}
{"snippet": "memoryview(obj)", "intent": "Return a \u201c memory view \u201d object created from the given argument . With arguments `obj`.", "question_id": 4053}
{"snippet": "min(iterable, key, default)", "intent": "Return the smallest item in an `iterable` or the smallest of two or more arguments . The `key` argument specifies a one-argument ordering function like that used for list.sort ( ) . The `default` argument specifies an object to return if the provided iterable is empty .", "question_id": 4054}
{"snippet": "min(iterable, key)", "intent": "Return the smallest item in an `iterable` or the smallest of two or more arguments . The `key` argument specifies a one-argument ordering function like that used for list.sort ( ) .", "question_id": 4055}
{"snippet": "min(arg1, arg2, *args, key)", "intent": "Return the smallest item in an iterable or the smallest of two or more arguments . The `key` argument specifies a one-argument ordering function like that used for list.sort ( ) . With arguments `arg1`, `arg2`, `*args`.", "question_id": 4056}
{"snippet": "min(arg1, arg2, *args)", "intent": "Return the smallest item in an iterable or the smallest of two or more arguments . With arguments `arg1`, `arg2`, `*args`.", "question_id": 4057}
{"snippet": "next(iterator, default)", "intent": "Retrieve the next item from the `iterator` by calling its __next__ ( ) method . If `default` is given , it is returned if the iterator is exhausted , otherwise StopIteration is raised .", "question_id": 4058}
{"snippet": "next(iterator)", "intent": "Retrieve the next item from the `iterator` by calling its __next__ ( ) method .", "question_id": 4059}
{"snippet": "object", "intent": "Return a new featureless object.", "question_id": 4060}
{"snippet": "oct(x)", "intent": "Convert an integer number to an octal string prefixed with \u201c 0o \u201d . If `x` is not a Python int object , it has to define an __index__ ( ) method that returns an integer .", "question_id": 4061}
{"snippet": "open(file)", "intent": "Open `file` and return a corresponding file object .", "question_id": 4062}
{"snippet": "open(file, mode='r')", "intent": "Open `file` and return a corresponding file object . `mode` is an optional string that specifies the mode in which the file is opened .", "question_id": 4063}
{"snippet": "open(file, buffering=-1)", "intent": "Open `file` and return a corresponding file object . `buffering` is an optional integer used to set the buffering policy .", "question_id": 4064}
{"snippet": "open(file, encoding=None)", "intent": "Open `file` and return a corresponding file object . In text mode , if `encoding` is not specified the encoding used is platform dependent : locale.getpreferredencoding ( False ) is called to get the current locale encoding .", "question_id": 4065}
{"snippet": "open(file, errors=None)", "intent": "Open `file` and return a corresponding file object . `errors` is an optional string that specifies how encoding and decoding errors are to be handled\u2014this can not be used in binary mode .", "question_id": 4066}
{"snippet": "open(file, newline=None)", "intent": "Open `file` and return a corresponding file object . Refer to the documentation of the `newline` parameter for further details .", "question_id": 4067}
{"snippet": "open(file, closefd=True)", "intent": "Open `file` and return a corresponding file object . ( If a file descriptor is given , it is closed when the returned I/O object is closed , unless `closefd` is set to False . )", "question_id": 4068}
{"snippet": "open(file, opener=None)", "intent": "Open `file` and return a corresponding file object . A custom `opener` can be used by passing a callable as opener .", "question_id": 4069}
{"snippet": "open(file, mode='r', buffering=-1)", "intent": "Open `file` and return a corresponding file object . `mode` is an optional string that specifies the mode in which the file is opened . `buffering` is an optional integer used to set the buffering policy .", "question_id": 4070}
{"snippet": "open(file, mode='r', encoding=None)", "intent": "Open `file` and return a corresponding file object . `mode` is an optional string that specifies the mode in which the file is opened . In text mode , if `encoding` is not specified the encoding used is platform dependent : locale.getpreferredencoding ( False ) is called to get the current locale encoding .", "question_id": 4071}
{"snippet": "ord(c)", "intent": "Given a string representing one Unicode character , return an integer representing the Unicode code point of that character . With arguments `c`.", "question_id": 4072}
{"snippet": "pow(x, y, z)", "intent": "Return `x` to the power `y` ; if `z` is present , return x to the power y , modulo z ( computed more efficiently than pow ( x , y ) % z ) .", "question_id": 4073}
{"snippet": "pow(x, y)", "intent": "Return `x` to the power `y` ; if `z` is present , return x to the power y , modulo z ( computed more efficiently than pow ( x , y ) % z ) .", "question_id": 4074}
{"snippet": "print(*objects)", "intent": "Print objects to the text stream `file` , separated by `sep` and followed by `end` . With arguments `*objects`.", "question_id": 4075}
{"snippet": "print(*objects, sep=' ')", "intent": "Print objects to the text stream `file` , separated by `sep` and followed by `end` . With arguments `*objects`.", "question_id": 4076}
{"snippet": "print(*objects, end='\\n')", "intent": "Print objects to the text stream `file` , separated by `sep` and followed by `end` . With arguments `*objects`.", "question_id": 4077}
{"snippet": "print(*objects, file=sys.stdout)", "intent": "Print objects to the text stream `file` , separated by `sep` and followed by `end` . With arguments `*objects`.", "question_id": 4078}
{"snippet": "print(*objects, flush=False)", "intent": "Print objects to the text stream `file` , separated by `sep` and followed by `end` . sep , end , file and `flush` , if present , must be given as keyword arguments . With arguments `*objects`.", "question_id": 4079}
{"snippet": "print(*objects, sep=' ', end='\\n')", "intent": "Print objects to the text stream `file` , separated by `sep` and followed by `end` . With arguments `*objects`.", "question_id": 4080}
{"snippet": "print(*objects, sep=' ', file=sys.stdout)", "intent": "Print objects to the text stream `file` , separated by `sep` and followed by `end` . With arguments `*objects`.", "question_id": 4081}
{"snippet": "print(*objects, sep=' ', flush=False)", "intent": "Print objects to the text stream `file` , separated by `sep` and followed by `end` . sep , end , file and `flush` , if present , must be given as keyword arguments . With arguments `*objects`.", "question_id": 4082}
{"snippet": "print(*objects, end='\\n', file=sys.stdout)", "intent": "Print objects to the text stream `file` , separated by `sep` and followed by `end` . With arguments `*objects`.", "question_id": 4083}
{"snippet": "print(*objects, end='\\n', flush=False)", "intent": "Print objects to the text stream `file` , separated by `sep` and followed by `end` . sep , end , file and `flush` , if present , must be given as keyword arguments . With arguments `*objects`.", "question_id": 4084}
{"snippet": "property()", "intent": "Return a property attribute .", "question_id": 4085}
{"snippet": "property(fget=None)", "intent": "Return a property attribute . `fget` is a function for getting an attribute value .", "question_id": 4086}
{"snippet": "property(fset=None)", "intent": "Return a property attribute . `fset` is a function for setting an attribute value .", "question_id": 4087}
{"snippet": "property(fdel=None)", "intent": "Return a property attribute . `fdel` is a function for deleting an attribute value .", "question_id": 4088}
{"snippet": "property(doc=None)", "intent": "Return a property attribute . And `doc` creates a docstring for the attribute .", "question_id": 4089}
{"snippet": "property(fget=None, fset=None)", "intent": "Return a property attribute . `fget` is a function for getting an attribute value . `fset` is a function for setting an attribute value .", "question_id": 4090}
{"snippet": "property(fget=None, fdel=None)", "intent": "Return a property attribute . `fget` is a function for getting an attribute value . `fdel` is a function for deleting an attribute value .", "question_id": 4091}
{"snippet": "property(fget=None, doc=None)", "intent": "Return a property attribute . `fget` is a function for getting an attribute value . And `doc` creates a docstring for the attribute .", "question_id": 4092}
{"snippet": "property(fset=None, fdel=None)", "intent": "Return a property attribute . `fset` is a function for setting an attribute value . `fdel` is a function for deleting an attribute value .", "question_id": 4093}
{"snippet": "property(fset=None, doc=None)", "intent": "Return a property attribute . `fset` is a function for setting an attribute value . And `doc` creates a docstring for the attribute .", "question_id": 4094}
{"snippet": "range(stop)", "intent": "Rather than being a function , range is actually an immutable sequence type , as documented in Ranges and Sequence Types \u2014 list , tuple , range . With arguments `stop`.", "question_id": 4095}
{"snippet": "range(start, stop, step)", "intent": "Rather than being a function , range is actually an immutable sequence type , as documented in Ranges and Sequence Types \u2014 list , tuple , range . With arguments `start`, `stop`, `step`.", "question_id": 4096}
{"snippet": "range(start, stop)", "intent": "Rather than being a function , range is actually an immutable sequence type , as documented in Ranges and Sequence Types \u2014 list , tuple , range . With arguments `start`, `stop`.", "question_id": 4097}
{"snippet": "repr(object)", "intent": "Return a string containing a printable representation of an `object` .", "question_id": 4098}
{"snippet": "reversed(seq)", "intent": "Return a reverse iterator . `seq` must be an object which has a __reversed__ ( ) method or supports the sequence protocol ( the __len__ ( ) method and the __getitem__ ( ) method with integer arguments starting at 0 ) .", "question_id": 4099}
{"snippet": "round(number, ndigits)", "intent": "Return `number` rounded to `ndigits` precision after the decimal point .", "question_id": 4100}
{"snippet": "round(number)", "intent": "Return `number` rounded to `ndigits` precision after the decimal point .", "question_id": 4101}
{"snippet": "set(iterable)", "intent": "Return a new set object , optionally with elements taken from `iterable` .", "question_id": 4102}
{"snippet": "set()", "intent": "Return a new set object , optionally with elements taken from `iterable` .", "question_id": 4103}
{"snippet": "setattr(object, name, value)", "intent": "This is the counterpart of getattr ( ) . The arguments are an `object` , a string and an arbitrary `value` . The string may `name` an existing attribute or a new attribute .", "question_id": 4104}
{"snippet": "slice(stop)", "intent": "Return a slice object representing the set of indices specified by range ( start , `stop` , step ) .", "question_id": 4105}
{"snippet": "slice(start, stop, step)", "intent": "Return a slice object representing the set of indices specified by range ( `start` , `stop` , `step` ) .", "question_id": 4106}
{"snippet": "slice(start, stop)", "intent": "Return a slice object representing the set of indices specified by range ( `start` , `stop` , `step` ) .", "question_id": 4107}
{"snippet": "sorted(iterable)", "intent": "Return a new sorted list from the items in `iterable` .", "question_id": 4108}
{"snippet": "sorted(iterable, key=None)", "intent": "Return a new sorted list from the items in `iterable` . `key` specifies a function of one argument that is used to extract a comparison key from each element in iterable ( for example , key=str.lower ) .", "question_id": 4109}
{"snippet": "sorted(iterable, reverse=False)", "intent": "Return a new sorted list from the items in `iterable` . `reverse` is a boolean value .", "question_id": 4110}
{"snippet": "sorted(iterable, key=None, reverse=False)", "intent": "Return a new sorted list from the items in `iterable` . `key` specifies a function of one argument that is used to extract a comparison key from each element in iterable ( for example , key=str.lower ) . `reverse` is a boolean value .", "question_id": 4111}
{"snippet": "@staticmethod", "intent": "Transform a method into a static method.", "question_id": 4112}
{"snippet": "str()", "intent": "Return a str version of `object` .", "question_id": 4113}
{"snippet": "str(object='')", "intent": "Return a str version of `object` .", "question_id": 4114}
{"snippet": "str()", "intent": "Return a str version of `object` .", "question_id": 4115}
{"snippet": "str(object=b'')", "intent": "Return a str version of `object` .", "question_id": 4116}
{"snippet": "str(encoding='utf-8')", "intent": "Return a str version of `object` . With arguments `encoding`.", "question_id": 4117}
{"snippet": "str(errors='strict')", "intent": "Return a str version of `object` . With arguments `errors`.", "question_id": 4118}
{"snippet": "str(object=b'', encoding='utf-8')", "intent": "Return a str version of `object` . With arguments `encoding`.", "question_id": 4119}
{"snippet": "str(object=b'', errors='strict')", "intent": "Return a str version of `object` . With arguments `errors`.", "question_id": 4120}
{"snippet": "str(encoding='utf-8', errors='strict')", "intent": "Return a str version of `object` . With arguments `encoding`, `errors`.", "question_id": 4121}
{"snippet": "str(object=b'', encoding='utf-8', errors='strict')", "intent": "Return a str version of `object` . With arguments `encoding`, `errors`.", "question_id": 4122}
{"snippet": "sum(iterable, start)", "intent": "Sums `start` and the items of an `iterable` from left to right and returns the total .", "question_id": 4123}
{"snippet": "sum(iterable)", "intent": "Sums `start` and the items of an `iterable` from left to right and returns the total .", "question_id": 4124}
{"snippet": "super(type, object-or-type)", "intent": "Return a proxy object that delegates method calls to a parent or sibling class of `type` . With arguments `object-or-type`.", "question_id": 4125}
{"snippet": "super(type)", "intent": "Return a proxy object that delegates method calls to a parent or sibling class of `type` .", "question_id": 4126}
{"snippet": "super()", "intent": "Return a proxy object that delegates method calls to a parent or sibling class of `type` .", "question_id": 4127}
{"snippet": "tuple(iterable)", "intent": "Rather than being a function , tuple is actually an immutable sequence type , as documented in Tuples and Sequence Types \u2014 list , tuple , range . With arguments `iterable`.", "question_id": 4128}
{"snippet": "tuple()", "intent": "Rather than being a function , tuple is actually an immutable sequence type , as documented in Tuples and Sequence Types \u2014 list , tuple , range .", "question_id": 4129}
{"snippet": "type(object)", "intent": "With one argument , return the type of an `object` .", "question_id": 4130}
{"snippet": "type(name, bases, dict)", "intent": "With one argument , return the type of an object . The `name` string is the class name and becomes the __name__ attribute ; the `bases` tuple itemizes the base classes and becomes the __bases__ attribute ; and the `dict` dictionary is the namespace containing definitions for class body and is copied to a standard dictionary to become the __dict__ attribute .", "question_id": 4131}
{"snippet": "vars(object)", "intent": "Return the __dict__ attribute for a module , class , instance , or any other `object` with a __dict__ attribute .", "question_id": 4132}
{"snippet": "vars()", "intent": "Return the __dict__ attribute for a module , class , instance , or any other `object` with a __dict__ attribute .", "question_id": 4133}
{"snippet": "zip(*iterables)", "intent": "Make an iterator that aggregates elements from each of the iterables . With arguments `*iterables`.", "question_id": 4134}
{"snippet": "__import__(name)", "intent": "This function is invoked by the import statement . The function imports the module `name` , potentially using the given `globals` and `locals` to determine how to interpret the name in a package context .", "question_id": 4135}
{"snippet": "__import__(name, globals=None)", "intent": "This function is invoked by the import statement . The function imports the module `name` , potentially using the given `globals` and `locals` to determine how to interpret the name in a package context .", "question_id": 4136}
{"snippet": "__import__(name, locals=None)", "intent": "This function is invoked by the import statement . The function imports the module `name` , potentially using the given `globals` and `locals` to determine how to interpret the name in a package context .", "question_id": 4137}
{"snippet": "__import__(name, fromlist=())", "intent": "This function is invoked by the import statement . The function imports the module `name` , potentially using the given `globals` and `locals` to determine how to interpret the name in a package context . The `fromlist` gives the names of objects or submodules that should be imported from the module given by name .", "question_id": 4138}
{"snippet": "__import__(name, level=0)", "intent": "This function is invoked by the import statement . The function imports the module `name` , potentially using the given `globals` and `locals` to determine how to interpret the name in a package context . `level` specifies whether to use absolute or relative imports .", "question_id": 4139}
{"snippet": "__import__(name, globals=None, locals=None)", "intent": "This function is invoked by the import statement . The function imports the module `name` , potentially using the given `globals` and `locals` to determine how to interpret the name in a package context .", "question_id": 4140}
{"snippet": "__import__(name, globals=None, fromlist=())", "intent": "This function is invoked by the import statement . The function imports the module `name` , potentially using the given `globals` and `locals` to determine how to interpret the name in a package context . The `fromlist` gives the names of objects or submodules that should be imported from the module given by name .", "question_id": 4141}
{"snippet": "__import__(name, globals=None, level=0)", "intent": "This function is invoked by the import statement . The function imports the module `name` , potentially using the given `globals` and `locals` to determine how to interpret the name in a package context . `level` specifies whether to use absolute or relative imports .", "question_id": 4142}
{"snippet": "__import__(name, locals=None, fromlist=())", "intent": "This function is invoked by the import statement . The function imports the module `name` , potentially using the given `globals` and `locals` to determine how to interpret the name in a package context . The `fromlist` gives the names of objects or submodules that should be imported from the module given by name .", "question_id": 4143}
{"snippet": "__import__(name, locals=None, level=0)", "intent": "This function is invoked by the import statement . The function imports the module `name` , potentially using the given `globals` and `locals` to determine how to interpret the name in a package context . `level` specifies whether to use absolute or relative imports .", "question_id": 4144}
{"snippet": "functools.cmp_to_key(func)", "intent": "Transform an old-style comparison function to a key function . With arguments `func`.", "question_id": 4145}
{"snippet": "@functools.lru_cache()", "intent": "Decorator to wrap a function with a memoizing callable that saves up to the `maxsize` most recent calls .", "question_id": 4146}
{"snippet": "@functools.lru_cache(maxsize=128)", "intent": "Decorator to wrap a function with a memoizing callable that saves up to the `maxsize` most recent calls .", "question_id": 4147}
{"snippet": "@functools.lru_cache(typed=False)", "intent": "Decorator to wrap a function with a memoizing callable that saves up to the `maxsize` most recent calls . If `typed` is set to true , function arguments of different types will be cached separately .", "question_id": 4148}
{"snippet": "@functools.lru_cache(maxsize=128, typed=False)", "intent": "Decorator to wrap a function with a memoizing callable that saves up to the `maxsize` most recent calls . If `typed` is set to true , function arguments of different types will be cached separately .", "question_id": 4149}
{"snippet": "@functools.total_ordering", "intent": "Given a class defining one or more rich comparison ordering methods, this class decorator supplies the rest.", "question_id": 4150}
{"snippet": "functools.partial(func, *args, **keywords)", "intent": "Return a new partial object which when called will behave like `func` called with the positional arguments args and keyword arguments keywords . With arguments `*args`, `**keywords`.", "question_id": 4151}
{"snippet": "functools.partialmethod(func, *args, **keywords)", "intent": "Return a new partialmethod descriptor which behaves like partial except that it is designed to be used as a method definition rather than being directly callable . `func` must be a descriptor or a callable ( objects which are both , like normal functions , are handled as descriptors ) . With arguments `*args`, `**keywords`.", "question_id": 4152}
{"snippet": "functools.reduce(function, iterable, initializer)", "intent": "Apply `function` of two arguments cumulatively to the items of sequence , from left to right , so as to reduce the sequence to a single value . If the optional `initializer` is present , it is placed before the items of the sequence in the calculation , and serves as a default when the sequence is empty . With arguments `iterable`.", "question_id": 4153}
{"snippet": "functools.reduce(function, iterable)", "intent": "Apply `function` of two arguments cumulatively to the items of sequence , from left to right , so as to reduce the sequence to a single value . With arguments `iterable`.", "question_id": 4154}
{"snippet": "@functools.singledispatch", "intent": "Transform a function into a single-dispatch generic function.", "question_id": 4155}
{"snippet": "functools.update_wrapper(wrapper, wrapped)", "intent": "Update a `wrapper` function to look like the `wrapped` function .", "question_id": 4156}
{"snippet": "functools.update_wrapper(wrapper, wrapped, assigned=WRAPPER_ASSIGNMENTS)", "intent": "Update a `wrapper` function to look like the `wrapped` function . The optional arguments are tuples to specify which attributes of the original function are `assigned` directly to the matching attributes on the wrapper function and which attributes of the wrapper function are `updated` with the corresponding attributes from the original function .", "question_id": 4157}
{"snippet": "functools.update_wrapper(wrapper, wrapped, updated=WRAPPER_UPDATES)", "intent": "Update a `wrapper` function to look like the `wrapped` function . The optional arguments are tuples to specify which attributes of the original function are `assigned` directly to the matching attributes on the wrapper function and which attributes of the wrapper function are `updated` with the corresponding attributes from the original function .", "question_id": 4158}
{"snippet": "functools.update_wrapper(wrapper, wrapped, assigned=WRAPPER_ASSIGNMENTS, updated=WRAPPER_UPDATES)", "intent": "Update a `wrapper` function to look like the `wrapped` function . The optional arguments are tuples to specify which attributes of the original function are `assigned` directly to the matching attributes on the wrapper function and which attributes of the wrapper function are `updated` with the corresponding attributes from the original function .", "question_id": 4159}
{"snippet": "@functools.wraps(wrapped)", "intent": "This is a convenience function for invoking update_wrapper ( ) as a function decorator when defining a wrapper function . With arguments `wrapped`.", "question_id": 4160}
{"snippet": "@functools.wraps(wrapped, assigned=WRAPPER_ASSIGNMENTS)", "intent": "This is a convenience function for invoking update_wrapper ( ) as a function decorator when defining a wrapper function . With arguments `wrapped`, `assigned`.", "question_id": 4161}
{"snippet": "@functools.wraps(wrapped, updated=WRAPPER_UPDATES)", "intent": "This is a convenience function for invoking update_wrapper ( ) as a function decorator when defining a wrapper function . With arguments `wrapped`, `updated`.", "question_id": 4162}
{"snippet": "@functools.wraps(wrapped, assigned=WRAPPER_ASSIGNMENTS, updated=WRAPPER_UPDATES)", "intent": "This is a convenience function for invoking update_wrapper ( ) as a function decorator when defining a wrapper function . With arguments `wrapped`, `assigned`, `updated`.", "question_id": 4163}
{"snippet": "partial.func", "intent": "A callable object or function.", "question_id": 4164}
{"snippet": "partial.args", "intent": "The leftmost positional arguments that will be prepended to the positional arguments provided to a partial object call.", "question_id": 4165}
{"snippet": "partial.keywords", "intent": "The keyword arguments that will be supplied when the partial object is called.", "question_id": 4166}
{"snippet": "gc.enable()", "intent": "Enable automatic garbage collection .", "question_id": 4167}
{"snippet": "gc.disable()", "intent": "Disable automatic garbage collection .", "question_id": 4168}
{"snippet": "gc.isenabled()", "intent": "Returns true if automatic collection is enabled .", "question_id": 4169}
{"snippet": "gc.collect()", "intent": "With no arguments , run a full collection .", "question_id": 4170}
{"snippet": "gc.collect(generation=2)", "intent": "With no arguments , run a full collection . The optional argument `generation` may be an integer specifying which generation to collect ( from 0 to 2 ) .", "question_id": 4171}
{"snippet": "gc.set_debug(flags)", "intent": "Set the garbage collection debugging `flags` .", "question_id": 4172}
{"snippet": "gc.get_debug()", "intent": "Return the debugging flags currently set .", "question_id": 4173}
{"snippet": "gc.get_objects()", "intent": "Returns a list of all objects tracked by the collector , excluding the list returned .", "question_id": 4174}
{"snippet": "gc.get_stats()", "intent": "Return a list of three per-generation dictionaries containing collection statistics since interpreter start .", "question_id": 4175}
{"snippet": "gc.set_threshold(threshold0, threshold1, threshold2)", "intent": "Set the garbage collection thresholds ( the collection frequency ) . Setting `threshold0` to zero disables collection . If generation 0 has been examined more than `threshold1` times since generation 1 has been examined , then generation 1 is examined as well . Similarly , `threshold2` controls the number of collections of generation 1 before collecting generation 2 .", "question_id": 4176}
{"snippet": "gc.set_threshold(threshold0, threshold1)", "intent": "Set the garbage collection thresholds ( the collection frequency ) . Setting `threshold0` to zero disables collection . If generation 0 has been examined more than `threshold1` times since generation 1 has been examined , then generation 1 is examined as well .", "question_id": 4177}
{"snippet": "gc.set_threshold(threshold0)", "intent": "Set the garbage collection thresholds ( the collection frequency ) . Setting `threshold0` to zero disables collection .", "question_id": 4178}
{"snippet": "gc.get_count()", "intent": "Return the current collection counts as a tuple of ( count0 , count1 , count2 ) .", "question_id": 4179}
{"snippet": "gc.get_threshold()", "intent": "Return the current collection thresholds as a tuple of ( threshold0 , threshold1 , threshold2 ) .", "question_id": 4180}
{"snippet": "gc.get_referrers(*objs)", "intent": "Return the list of objects that directly refer to any of objs . With arguments `*objs`.", "question_id": 4181}
{"snippet": "gc.get_referents(*objs)", "intent": "Return a list of objects directly referred to by any of the arguments . With arguments `*objs`.", "question_id": 4182}
{"snippet": "gc.is_tracked(obj)", "intent": "Returns True if the object is currently tracked by the garbage collector , False otherwise . With arguments `obj`.", "question_id": 4183}
{"snippet": "gc.freeze()", "intent": "Freeze all the objects tracked by gc - move them to a permanent generation and ignore all the future collections .", "question_id": 4184}
{"snippet": "gc.unfreeze()", "intent": "Unfreeze the objects in the permanent generation , put them back into the oldest generation .", "question_id": 4185}
{"snippet": "gc.get_freeze_count()", "intent": "Return the number of objects in the permanent generation .", "question_id": 4186}
{"snippet": "gc.garbage", "intent": "A list of objects which the collector found to be unreachable but could not be freed (uncollectable objects).", "question_id": 4187}
{"snippet": "gc.callbacks", "intent": "A list of callbacks that will be invoked by the garbage collector before and after collection.", "question_id": 4188}
{"snippet": "gc.DEBUG_STATS", "intent": "Print statistics during collection.", "question_id": 4189}
{"snippet": "gc.DEBUG_COLLECTABLE", "intent": "Print information on collectable objects found.", "question_id": 4190}
{"snippet": "gc.DEBUG_UNCOLLECTABLE", "intent": "Print information of uncollectable objects found (objects which are not reachable but cannot be freed by the collector).", "question_id": 4191}
{"snippet": "gc.DEBUG_SAVEALL", "intent": "When set, all unreachable objects found will be appended to garbage rather than being freed.", "question_id": 4192}
{"snippet": "gc.DEBUG_LEAK", "intent": "The debugging flags necessary for the collector to print information about a leaking program (equal to DEBUG_COLLECTABLE | DEBUG_UNCOLLECTABLE | DEBUG_SAVEALL).", "question_id": 4193}
{"snippet": "getopt.getopt(args, shortopts)", "intent": "Parses command line options and parameter list . `args` is the argument list to be parsed , without the leading reference to the running program . `shortopts` is the string of option letters that the script wants to recognize , with options that require an argument followed by a colon ( ' : ' ; i.e. , the same format that Unix getopt ( ) uses ) .", "question_id": 4194}
{"snippet": "getopt.getopt(args, shortopts, longopts=)", "intent": "Parses command line options and parameter list . `args` is the argument list to be parsed , without the leading reference to the running program . `shortopts` is the string of option letters that the script wants to recognize , with options that require an argument followed by a colon ( ' : ' ; i.e. , the same format that Unix getopt ( ) uses ) . `longopts` , if specified , must be a list of strings with the names of the long options which should be supported .", "question_id": 4195}
{"snippet": "getopt.getopt(args)", "intent": "Parses command line options and parameter list . `args` is the argument list to be parsed , without the leading reference to the running program .", "question_id": 4196}
{"snippet": "getopt.getopt(args, longopts=)", "intent": "Parses command line options and parameter list . `args` is the argument list to be parsed , without the leading reference to the running program . `longopts` , if specified , must be a list of strings with the names of the long options which should be supported .", "question_id": 4197}
{"snippet": "getopt.gnu_getopt(args, shortopts)", "intent": "This function works like getopt ( ) , except that GNU style scanning mode is used by default . With arguments `args`, `shortopts`.", "question_id": 4198}
{"snippet": "getopt.gnu_getopt(args, shortopts, longopts=)", "intent": "This function works like getopt ( ) , except that GNU style scanning mode is used by default . With arguments `args`, `shortopts`, `longopts`.", "question_id": 4199}
{"snippet": "getopt.gnu_getopt(args)", "intent": "This function works like getopt ( ) , except that GNU style scanning mode is used by default . With arguments `args`.", "question_id": 4200}
{"snippet": "getopt.gnu_getopt(args, longopts=)", "intent": "This function works like getopt ( ) , except that GNU style scanning mode is used by default . With arguments `args`, `longopts`.", "question_id": 4201}
{"snippet": "getopt.GetoptError", "intent": "This is raised when an unrecognized option is found in the argument list or when an option requiring an argument is given none.", "question_id": 4202}
{"snippet": "getopt.error", "intent": "Alias for GetoptError; for backward compatibility.", "question_id": 4203}
{"snippet": "getpass.getpass()", "intent": "Prompt the user for a password without echoing .", "question_id": 4204}
{"snippet": "getpass.getpass(prompt='Password: ')", "intent": "Prompt the user for a password without echoing . The user is prompted using the string `prompt` , which defaults to 'Password : ' .", "question_id": 4205}
{"snippet": "getpass.getpass(stream=None)", "intent": "Prompt the user for a password without echoing . On Unix , the prompt is written to the file-like object `stream` using the replace error handler if needed .", "question_id": 4206}
{"snippet": "getpass.getpass(prompt='Password: ', stream=None)", "intent": "Prompt the user for a password without echoing . The user is prompted using the string `prompt` , which defaults to 'Password : ' . On Unix , the prompt is written to the file-like object `stream` using the replace error handler if needed .", "question_id": 4207}
{"snippet": "getpass.GetPassWarning", "intent": "A UserWarning subclass issued when password input may be echoed.", "question_id": 4208}
{"snippet": "getpass.getuser()", "intent": "Return the \u201c login name \u201d of the user .", "question_id": 4209}
{"snippet": "gettext.bindtextdomain(domain)", "intent": "Bind the `domain` to the locale directory `localedir` .", "question_id": 4210}
{"snippet": "gettext.bindtextdomain(domain, localedir=None)", "intent": "Bind the `domain` to the locale directory `localedir` .", "question_id": 4211}
{"snippet": "gettext.bind_textdomain_codeset(domain)", "intent": "Bind the `domain` to `codeset` , changing the encoding of byte strings returned by the lgettext ( ) , ldgettext ( ) , lngettext ( ) and ldngettext ( ) functions .", "question_id": 4212}
{"snippet": "gettext.bind_textdomain_codeset(domain, codeset=None)", "intent": "Bind the `domain` to `codeset` , changing the encoding of byte strings returned by the lgettext ( ) , ldgettext ( ) , lngettext ( ) and ldngettext ( ) functions .", "question_id": 4213}
{"snippet": "gettext.textdomain()", "intent": "Change or query the current global `domain` .", "question_id": 4214}
{"snippet": "gettext.textdomain(domain=None)", "intent": "Change or query the current global `domain` .", "question_id": 4215}
{"snippet": "gettext.gettext(message)", "intent": "Return the localized translation of `message` , based on the current global domain , language , and locale directory .", "question_id": 4216}
{"snippet": "gettext.dgettext(domain, message)", "intent": "Like gettext ( ) , but look the `message` up in the specified `domain` .", "question_id": 4217}
{"snippet": "gettext.ngettext(singular, plural, n)", "intent": "Like gettext ( ) , but consider `plural` forms . If no translation is found , return `singular` if n is 1 ; return plural otherwise . If a translation is found , apply the plural formula to `n` , and return the resulting message ( some languages have more than two plural forms ) .", "question_id": 4218}
{"snippet": "gettext.dngettext(domain, singular, plural, n)", "intent": "Like ngettext ( ) , but look the message up in the specified `domain` . With arguments `singular`, `plural`, `n`.", "question_id": 4219}
{"snippet": "gettext.ldngettext(domain, singular, plural, n)", "intent": "Equivalent to the corresponding functions without the l prefix ( gettext ( ) , dgettext ( ) , ngettext ( ) and dngettext ( ) ) , but the translation is returned as a byte string encoded in the preferred system encoding if no other encoding was explicitly set with bind_textdomain_codeset ( ) . With arguments `domain`, `singular`, `plural`, `n`.", "question_id": 4220}
{"snippet": "gettext.find(domain)", "intent": "This function implements the standard .mo file search algorithm . It takes a `domain` , identical to what textdomain ( ) takes .", "question_id": 4221}
{"snippet": "gettext.find(domain, localedir=None)", "intent": "This function implements the standard .mo file search algorithm . It takes a `domain` , identical to what textdomain ( ) takes . Optional `localedir` is as in bindtextdomain ( ) .", "question_id": 4222}
{"snippet": "gettext.find(domain, languages=None)", "intent": "This function implements the standard .mo file search algorithm . It takes a `domain` , identical to what textdomain ( ) takes . Optional `languages` is a list of strings , where each string is a language code .", "question_id": 4223}
{"snippet": "gettext.find(domain, all=False)", "intent": "This function implements the standard .mo file search algorithm . It takes a `domain` , identical to what textdomain ( ) takes . If `all` is given , it returns a list of all file names , in the order in which they appear in the languages list or the environment variables .", "question_id": 4224}
{"snippet": "gettext.find(domain, localedir=None, languages=None)", "intent": "This function implements the standard .mo file search algorithm . It takes a `domain` , identical to what textdomain ( ) takes . Optional `localedir` is as in bindtextdomain ( ) . Optional `languages` is a list of strings , where each string is a language code .", "question_id": 4225}
{"snippet": "gettext.find(domain, localedir=None, all=False)", "intent": "This function implements the standard .mo file search algorithm . It takes a `domain` , identical to what textdomain ( ) takes . Optional `localedir` is as in bindtextdomain ( ) . If `all` is given , it returns a list of all file names , in the order in which they appear in the languages list or the environment variables .", "question_id": 4226}
{"snippet": "gettext.find(domain, languages=None, all=False)", "intent": "This function implements the standard .mo file search algorithm . It takes a `domain` , identical to what textdomain ( ) takes . Optional `languages` is a list of strings , where each string is a language code . If `all` is given , it returns a list of all file names , in the order in which they appear in the languages list or the environment variables .", "question_id": 4227}
{"snippet": "gettext.find(domain, localedir=None, languages=None, all=False)", "intent": "This function implements the standard .mo file search algorithm . It takes a `domain` , identical to what textdomain ( ) takes . Optional `localedir` is as in bindtextdomain ( ) . Optional `languages` is a list of strings , where each string is a language code . If `all` is given , it returns a list of all file names , in the order in which they appear in the languages list or the environment variables .", "question_id": 4228}
{"snippet": "gettext.translation(domain)", "intent": "Return a *Translations instance based on the `domain` , `localedir` , and `languages` , which are first passed to find ( ) to get a list of the associated .mo file paths .", "question_id": 4229}
{"snippet": "gettext.translation(domain, localedir=None)", "intent": "Return a *Translations instance based on the `domain` , `localedir` , and `languages` , which are first passed to find ( ) to get a list of the associated .mo file paths .", "question_id": 4230}
{"snippet": "gettext.translation(domain, languages=None)", "intent": "Return a *Translations instance based on the `domain` , `localedir` , and `languages` , which are first passed to find ( ) to get a list of the associated .mo file paths .", "question_id": 4231}
{"snippet": "gettext.translation(domain, class_=None)", "intent": "Return a *Translations instance based on the `domain` , `localedir` , and `languages` , which are first passed to find ( ) to get a list of the associated .mo file paths . The actual class instantiated is `class_` if provided , otherwise GNUTranslations .", "question_id": 4232}
{"snippet": "gettext.translation(domain, fallback=False)", "intent": "Return a *Translations instance based on the `domain` , `localedir` , and `languages` , which are first passed to find ( ) to get a list of the associated .mo file paths . To allow setting the `fallback` , copy.copy ( ) is used to clone each translation object from the cache ; the actual instance data is still shared with the cache .", "question_id": 4233}
{"snippet": "gettext.translation(domain, codeset=None)", "intent": "Return a *Translations instance based on the `domain` , `localedir` , and `languages` , which are first passed to find ( ) to get a list of the associated .mo file paths . If provided , `codeset` will change the charset used to encode translated strings in the lgettext ( ) and lngettext ( ) methods .", "question_id": 4234}
{"snippet": "gettext.translation(domain, localedir=None, languages=None)", "intent": "Return a *Translations instance based on the `domain` , `localedir` , and `languages` , which are first passed to find ( ) to get a list of the associated .mo file paths .", "question_id": 4235}
{"snippet": "gettext.translation(domain, localedir=None, class_=None)", "intent": "Return a *Translations instance based on the `domain` , `localedir` , and `languages` , which are first passed to find ( ) to get a list of the associated .mo file paths . The actual class instantiated is `class_` if provided , otherwise GNUTranslations .", "question_id": 4236}
{"snippet": "gettext.translation(domain, localedir=None, fallback=False)", "intent": "Return a *Translations instance based on the `domain` , `localedir` , and `languages` , which are first passed to find ( ) to get a list of the associated .mo file paths . To allow setting the `fallback` , copy.copy ( ) is used to clone each translation object from the cache ; the actual instance data is still shared with the cache .", "question_id": 4237}
{"snippet": "gettext.translation(domain, localedir=None, codeset=None)", "intent": "Return a *Translations instance based on the `domain` , `localedir` , and `languages` , which are first passed to find ( ) to get a list of the associated .mo file paths . If provided , `codeset` will change the charset used to encode translated strings in the lgettext ( ) and lngettext ( ) methods .", "question_id": 4238}
{"snippet": "gettext.install(domain)", "intent": "This installs the function _ ( ) in Python \u2019 s builtins namespace , based on `domain` , `localedir` , and `codeset` which are passed to the function translation ( ) .", "question_id": 4239}
{"snippet": "gettext.install(domain, localedir=None)", "intent": "This installs the function _ ( ) in Python \u2019 s builtins namespace , based on `domain` , `localedir` , and `codeset` which are passed to the function translation ( ) .", "question_id": 4240}
{"snippet": "gettext.install(domain, codeset=None)", "intent": "This installs the function _ ( ) in Python \u2019 s builtins namespace , based on `domain` , `localedir` , and `codeset` which are passed to the function translation ( ) .", "question_id": 4241}
{"snippet": "gettext.install(domain, names=None)", "intent": "This installs the function _ ( ) in Python \u2019 s builtins namespace , based on `domain` , `localedir` , and `codeset` which are passed to the function translation ( ) . For the `names` parameter , please see the description of the translation object \u2019 s install ( ) method .", "question_id": 4242}
{"snippet": "gettext.install(domain, localedir=None, codeset=None)", "intent": "This installs the function _ ( ) in Python \u2019 s builtins namespace , based on `domain` , `localedir` , and `codeset` which are passed to the function translation ( ) .", "question_id": 4243}
{"snippet": "gettext.install(domain, localedir=None, names=None)", "intent": "This installs the function _ ( ) in Python \u2019 s builtins namespace , based on `domain` , `localedir` , and `codeset` which are passed to the function translation ( ) . For the `names` parameter , please see the description of the translation object \u2019 s install ( ) method .", "question_id": 4244}
{"snippet": "gettext.install(domain, codeset=None, names=None)", "intent": "This installs the function _ ( ) in Python \u2019 s builtins namespace , based on `domain` , `localedir` , and `codeset` which are passed to the function translation ( ) . For the `names` parameter , please see the description of the translation object \u2019 s install ( ) method .", "question_id": 4245}
{"snippet": "gettext.install(domain, localedir=None, codeset=None, names=None)", "intent": "This installs the function _ ( ) in Python \u2019 s builtins namespace , based on `domain` , `localedir` , and `codeset` which are passed to the function translation ( ) . For the `names` parameter , please see the description of the translation object \u2019 s install ( ) method .", "question_id": 4246}
{"snippet": "gettext.NullTranslations()", "intent": "Takes an optional file object `fp` , which is ignored by the base class .", "question_id": 4247}
{"snippet": "gettext.NullTranslations(fp=None)", "intent": "Takes an optional file object `fp` , which is ignored by the base class .", "question_id": 4248}
{"snippet": "null_translations._parse(fp)", "intent": "No-op in the base class , this method takes file object `fp` , and reads the data from the file , initializing its message catalog .", "question_id": 4249}
{"snippet": "null_translations.add_fallback(fallback)", "intent": "Add `fallback` as the fallback object for the current translation object .", "question_id": 4250}
{"snippet": "null_translations.gettext(message)", "intent": "If a fallback has been set , forward gettext ( ) to the fallback . Otherwise , return `message` .", "question_id": 4251}
{"snippet": "null_translations.ngettext(singular, plural, n)", "intent": "If a fallback has been set , forward ngettext ( ) to the fallback . Otherwise , return `singular` if `n` is 1 ; return `plural` otherwise .", "question_id": 4252}
{"snippet": "null_translations.lngettext(singular, plural, n)", "intent": "Equivalent to gettext ( ) and ngettext ( ) , but the translation is returned as a byte string encoded in the preferred system encoding if no encoding was explicitly set with set_output_charset ( ) . With arguments `singular`, `plural`, `n`.", "question_id": 4253}
{"snippet": "null_translations.info()", "intent": "Return the \u201c protected \u201d _info variable , a dictionary containing the metadata found in the message catalog file .", "question_id": 4254}
{"snippet": "null_translations.charset()", "intent": "Return the encoding of the message catalog file .", "question_id": 4255}
{"snippet": "null_translations.output_charset()", "intent": "Return the encoding used to return translated messages in lgettext ( ) and lngettext ( ) .", "question_id": 4256}
{"snippet": "null_translations.set_output_charset(charset)", "intent": "Change the encoding used to return translated messages . With arguments `charset`.", "question_id": 4257}
{"snippet": "null_translations.install()", "intent": "This method installs gettext ( ) into the built-in namespace , binding it to _ .", "question_id": 4258}
{"snippet": "null_translations.install(names=None)", "intent": "This method installs gettext ( ) into the built-in namespace , binding it to _ . If the `names` parameter is given , it must be a sequence containing the names of functions you want to install in the builtins namespace in addition to _ ( ) .", "question_id": 4259}
{"snippet": "gettext.GNUTranslations", "intent": "The following methods are overridden from the base class implementation:", "question_id": 4260}
{"snippet": "gnu_translations.gettext(message)", "intent": "Look up the `message` id in the catalog and return the corresponding message string , as a Unicode string .", "question_id": 4261}
{"snippet": "gnu_translations.ngettext(singular, plural, n)", "intent": "Do a plural-forms lookup of a message id . `singular` is used as the message id for purposes of lookup in the catalog , while `n` is used to determine which `plural` form to use .", "question_id": 4262}
{"snippet": "gnu_translations.lngettext(singular, plural, n)", "intent": "Equivalent to gettext ( ) and ngettext ( ) , but the translation is returned as a byte string encoded in the preferred system encoding if no encoding was explicitly set with set_output_charset ( ) . With arguments `singular`, `plural`, `n`.", "question_id": 4263}
{"snippet": "glob.glob(pathname)", "intent": "Return a possibly-empty list of path names that match `pathname` , which must be a string containing a path specification .", "question_id": 4264}
{"snippet": "glob.glob(pathname, recursive=False)", "intent": "Return a possibly-empty list of path names that match `pathname` , which must be a string containing a path specification . If `recursive` is true , the pattern \u201c ** \u201d will match any files and zero or more directories , subdirectories and symbolic links to directories .", "question_id": 4265}
{"snippet": "glob.iglob(pathname)", "intent": "Return an iterator which yields the same values as glob ( ) without actually storing them all simultaneously . With arguments `pathname`.", "question_id": 4266}
{"snippet": "glob.iglob(pathname, recursive=False)", "intent": "Return an iterator which yields the same values as glob ( ) without actually storing them all simultaneously . With arguments `pathname`, `recursive`.", "question_id": 4267}
{"snippet": "glob.escape(pathname)", "intent": "Escape all special characters ( ' ? With arguments `pathname`.", "question_id": 4268}
{"snippet": "grp.getgrgid(gid)", "intent": "Return the group database entry for the given numeric group ID . With arguments `gid`.", "question_id": 4269}
{"snippet": "grp.getgrnam(name)", "intent": "Return the group database entry for the given group `name` .", "question_id": 4270}
{"snippet": "grp.getgrall()", "intent": "Return a list of all available group entries , in arbitrary order .", "question_id": 4271}
{"snippet": "gzip.open(filename)", "intent": "Open a gzip-compressed file in binary or text `mode` , returning a file object . The `filename` argument can be an actual filename ( a str or bytes object ) , or an existing file object to read from or write to .", "question_id": 4272}
{"snippet": "gzip.open(filename, mode='rb')", "intent": "Open a gzip-compressed file in binary or text `mode` , returning a file object . The `filename` argument can be an actual filename ( a str or bytes object ) , or an existing file object to read from or write to .", "question_id": 4273}
{"snippet": "gzip.open(filename, compresslevel=9)", "intent": "Open a gzip-compressed file in binary or text `mode` , returning a file object . The `filename` argument can be an actual filename ( a str or bytes object ) , or an existing file object to read from or write to . The `compresslevel` argument is an integer from 0 to 9 , as for the GzipFile constructor .", "question_id": 4274}
{"snippet": "gzip.open(filename, encoding=None)", "intent": "Open a gzip-compressed file in binary or text `mode` , returning a file object . The `filename` argument can be an actual filename ( a str or bytes object ) , or an existing file object to read from or write to . In this case , the `encoding` , `errors` and `newline` arguments must not be provided .", "question_id": 4275}
{"snippet": "gzip.open(filename, errors=None)", "intent": "Open a gzip-compressed file in binary or text `mode` , returning a file object . The `filename` argument can be an actual filename ( a str or bytes object ) , or an existing file object to read from or write to . In this case , the `encoding` , `errors` and `newline` arguments must not be provided .", "question_id": 4276}
{"snippet": "gzip.open(filename, newline=None)", "intent": "Open a gzip-compressed file in binary or text `mode` , returning a file object . The `filename` argument can be an actual filename ( a str or bytes object ) , or an existing file object to read from or write to . In this case , the `encoding` , `errors` and `newline` arguments must not be provided .", "question_id": 4277}
{"snippet": "gzip.open(filename, mode='rb', compresslevel=9)", "intent": "Open a gzip-compressed file in binary or text `mode` , returning a file object . The `filename` argument can be an actual filename ( a str or bytes object ) , or an existing file object to read from or write to . The `compresslevel` argument is an integer from 0 to 9 , as for the GzipFile constructor .", "question_id": 4278}
{"snippet": "gzip.open(filename, mode='rb', encoding=None)", "intent": "Open a gzip-compressed file in binary or text `mode` , returning a file object . The `filename` argument can be an actual filename ( a str or bytes object ) , or an existing file object to read from or write to . In this case , the `encoding` , `errors` and `newline` arguments must not be provided .", "question_id": 4279}
{"snippet": "gzip.open(filename, mode='rb', errors=None)", "intent": "Open a gzip-compressed file in binary or text `mode` , returning a file object . The `filename` argument can be an actual filename ( a str or bytes object ) , or an existing file object to read from or write to . In this case , the `encoding` , `errors` and `newline` arguments must not be provided .", "question_id": 4280}
{"snippet": "gzip.open(filename, mode='rb', newline=None)", "intent": "Open a gzip-compressed file in binary or text `mode` , returning a file object . The `filename` argument can be an actual filename ( a str or bytes object ) , or an existing file object to read from or write to . In this case , the `encoding` , `errors` and `newline` arguments must not be provided .", "question_id": 4281}
{"snippet": "gzip.GzipFile()", "intent": "Constructor for the GzipFile class , which simulates most of the methods of a file object , with the exception of the truncate ( ) method .", "question_id": 4282}
{"snippet": "gzip.GzipFile(filename=None)", "intent": "Constructor for the GzipFile class , which simulates most of the methods of a file object , with the exception of the truncate ( ) method . At least one of `fileobj` and `filename` must be given a non-trivial value .", "question_id": 4283}
{"snippet": "gzip.GzipFile(mode=None)", "intent": "Constructor for the GzipFile class , which simulates most of the methods of a file object , with the exception of the truncate ( ) method . The `mode` argument can be any of ' r ' , 'rb ' , ' a ' , 'ab ' , ' w ' , 'wb ' , ' x ' , or 'xb ' , depending on whether the file will be read or written .", "question_id": 4284}
{"snippet": "gzip.GzipFile(compresslevel=9)", "intent": "Constructor for the GzipFile class , which simulates most of the methods of a file object , with the exception of the truncate ( ) method . The `compresslevel` argument is an integer from 0 to 9 controlling the level of compression ; 1 is fastest and produces the least compression , and 9 is slowest and produces the most compression .", "question_id": 4285}
{"snippet": "gzip.GzipFile(fileobj=None)", "intent": "Constructor for the GzipFile class , which simulates most of the methods of a file object , with the exception of the truncate ( ) method . At least one of `fileobj` and `filename` must be given a non-trivial value .", "question_id": 4286}
{"snippet": "gzip.GzipFile(mtime=None)", "intent": "Constructor for the GzipFile class , which simulates most of the methods of a file object , with the exception of the truncate ( ) method . The `mtime` argument is an optional numeric timestamp to be written to the last modification time field in the stream when compressing .", "question_id": 4287}
{"snippet": "gzip.GzipFile(filename=None, mode=None)", "intent": "Constructor for the GzipFile class , which simulates most of the methods of a file object , with the exception of the truncate ( ) method . At least one of `fileobj` and `filename` must be given a non-trivial value . The `mode` argument can be any of ' r ' , 'rb ' , ' a ' , 'ab ' , ' w ' , 'wb ' , ' x ' , or 'xb ' , depending on whether the file will be read or written .", "question_id": 4288}
{"snippet": "gzip.GzipFile(filename=None, compresslevel=9)", "intent": "Constructor for the GzipFile class , which simulates most of the methods of a file object , with the exception of the truncate ( ) method . At least one of `fileobj` and `filename` must be given a non-trivial value . The `compresslevel` argument is an integer from 0 to 9 controlling the level of compression ; 1 is fastest and produces the least compression , and 9 is slowest and produces the most compression .", "question_id": 4289}
{"snippet": "gzip.GzipFile(filename=None, fileobj=None)", "intent": "Constructor for the GzipFile class , which simulates most of the methods of a file object , with the exception of the truncate ( ) method . At least one of `fileobj` and `filename` must be given a non-trivial value .", "question_id": 4290}
{"snippet": "gzip.GzipFile(filename=None, mtime=None)", "intent": "Constructor for the GzipFile class , which simulates most of the methods of a file object , with the exception of the truncate ( ) method . At least one of `fileobj` and `filename` must be given a non-trivial value . The `mtime` argument is an optional numeric timestamp to be written to the last modification time field in the stream when compressing .", "question_id": 4291}
{"snippet": "gzip_file.peek(n)", "intent": "Read `n` uncompressed bytes without advancing the file position .", "question_id": 4292}
{"snippet": "gzip_file.mtime", "intent": "When decompressing, the value of the last modification time field in the most recently read header may be read from this attribute, as an integer.", "question_id": 4293}
{"snippet": "gzip.compress(data)", "intent": "Compress the `data` , returning a bytes object containing the compressed data .", "question_id": 4294}
{"snippet": "gzip.compress(data, compresslevel=9)", "intent": "Compress the `data` , returning a bytes object containing the compressed data . `compresslevel` has the same meaning as in the GzipFile constructor above .", "question_id": 4295}
{"snippet": "gzip.decompress(data)", "intent": "Decompress the `data` , returning a bytes object containing the uncompressed data .", "question_id": 4296}
{"snippet": "hashlib.new(name, data)", "intent": "Is a generic constructor that takes the string `name` of the desired algorithm as its first parameter . With arguments `data`.", "question_id": 4297}
{"snippet": "hashlib.new(name)", "intent": "Is a generic constructor that takes the string `name` of the desired algorithm as its first parameter .", "question_id": 4298}
{"snippet": "hashlib.algorithms_guaranteed", "intent": "A set containing the names of the hash algorithms guaranteed to be supported by this module on all platforms.", "question_id": 4299}
{"snippet": "hashlib.algorithms_available", "intent": "A set containing the names of the hash algorithms that are available in the running Python interpreter.", "question_id": 4300}
{"snippet": "hash.digest_size", "intent": "The size of the resulting hash in bytes.", "question_id": 4301}
{"snippet": "hash.block_size", "intent": "The internal block size of the hash algorithm in bytes.", "question_id": 4302}
{"snippet": "hash.name", "intent": "The canonical name of this hash, always lowercase and always suitable as a parameter to new() to create another hash of this type.", "question_id": 4303}
{"snippet": "hash.update(data)", "intent": "Update the hash object with the bytes-like object . With arguments `data`.", "question_id": 4304}
{"snippet": "hash.digest()", "intent": "Return the digest of the data passed to the update ( ) method so far .", "question_id": 4305}
{"snippet": "hash.hexdigest()", "intent": "Like digest ( ) except the digest is returned as a string object of double length , containing only hexadecimal digits .", "question_id": 4306}
{"snippet": "hash.copy()", "intent": "Return a copy ( \u201c clone \u201d ) of the hash object .", "question_id": 4307}
{"snippet": "shake.digest(length)", "intent": "Return the digest of the data passed to the update ( ) method so far . This is a bytes object of size `length` which may contain bytes in the whole range from 0 to 255 .", "question_id": 4308}
{"snippet": "shake.hexdigest(length)", "intent": "Like digest ( ) except the digest is returned as a string object of double `length` , containing only hexadecimal digits .", "question_id": 4309}
{"snippet": "hashlib.pbkdf2_hmac(hash_name, password, salt, iterations)", "intent": "The function provides PKCS # 5 password-based key derivation function 2 . The string `hash_name` is the desired name of the hash digest algorithm for HMAC , e.g . `password` and `salt` are interpreted as buffers of bytes . The number of `iterations` should be chosen based on the hash algorithm and computing power .", "question_id": 4310}
{"snippet": "hashlib.pbkdf2_hmac(hash_name, password, salt, iterations, dklen=None)", "intent": "The function provides PKCS # 5 password-based key derivation function 2 . The string `hash_name` is the desired name of the hash digest algorithm for HMAC , e.g . `password` and `salt` are interpreted as buffers of bytes . The number of `iterations` should be chosen based on the hash algorithm and computing power . `dklen` is the length of the derived key .", "question_id": 4311}
{"snippet": "hashlib.scrypt(password, salt, n, r, p)", "intent": "The function provides scrypt password-based key derivation function as defined in RFC 7914 . `password` and `salt` must be bytes-like objects . `n` is the CPU/Memory cost factor , `r` the block size , `p` parallelization factor and `maxmem` limits memory ( OpenSSL 1.1.0 defaults to 32 MiB ) .", "question_id": 4312}
{"snippet": "hashlib.scrypt(password, salt, n, r, p, maxmem=0)", "intent": "The function provides scrypt password-based key derivation function as defined in RFC 7914 . `password` and `salt` must be bytes-like objects . `n` is the CPU/Memory cost factor , `r` the block size , `p` parallelization factor and `maxmem` limits memory ( OpenSSL 1.1.0 defaults to 32 MiB ) .", "question_id": 4313}
{"snippet": "hashlib.scrypt(password, salt, n, r, p, dklen=64)", "intent": "The function provides scrypt password-based key derivation function as defined in RFC 7914 . `password` and `salt` must be bytes-like objects . `n` is the CPU/Memory cost factor , `r` the block size , `p` parallelization factor and `maxmem` limits memory ( OpenSSL 1.1.0 defaults to 32 MiB ) . `dklen` is the length of the derived key .", "question_id": 4314}
{"snippet": "hashlib.scrypt(password, salt, n, r, p, maxmem=0, dklen=64)", "intent": "The function provides scrypt password-based key derivation function as defined in RFC 7914 . `password` and `salt` must be bytes-like objects . `n` is the CPU/Memory cost factor , `r` the block size , `p` parallelization factor and `maxmem` limits memory ( OpenSSL 1.1.0 defaults to 32 MiB ) . `dklen` is the length of the derived key .", "question_id": 4315}
{"snippet": "heapq.heappush(heap, item)", "intent": "Push the value `item` onto the `heap` , maintaining the heap invariant .", "question_id": 4316}
{"snippet": "heapq.heappop(heap)", "intent": "Pop and return the smallest item from the `heap` , maintaining the heap invariant .", "question_id": 4317}
{"snippet": "heapq.heappushpop(heap, item)", "intent": "Push `item` on the `heap` , then pop and return the smallest item from the heap .", "question_id": 4318}
{"snippet": "heapq.heapify(x)", "intent": "Transform list `x` into a heap , in-place , in linear time .", "question_id": 4319}
{"snippet": "heapq.heapreplace(heap, item)", "intent": "Pop and return the smallest `item` from the `heap` , and also push the new item .", "question_id": 4320}
{"snippet": "heapq.merge(*iterables)", "intent": "Merge multiple sorted inputs into a single sorted output ( for example , merge timestamped entries from multiple log files ) . Similar to sorted ( itertools.chain ( `*iterables` ) ) but returns an iterable , does not pull the data into memory all at once , and assumes that each of the input streams is already sorted ( smallest to largest ) .", "question_id": 4321}
{"snippet": "heapq.merge(*iterables, key=None)", "intent": "Merge multiple sorted inputs into a single sorted output ( for example , merge timestamped entries from multiple log files ) . Similar to sorted ( itertools.chain ( `*iterables` ) ) but returns an iterable , does not pull the data into memory all at once , and assumes that each of the input streams is already sorted ( smallest to largest ) . `key` specifies a key function of one argument that is used to extract a comparison key from each input element .", "question_id": 4322}
{"snippet": "heapq.merge(*iterables, reverse=False)", "intent": "Merge multiple sorted inputs into a single sorted output ( for example , merge timestamped entries from multiple log files ) . Similar to sorted ( itertools.chain ( `*iterables` ) ) but returns an iterable , does not pull the data into memory all at once , and assumes that each of the input streams is already sorted ( smallest to largest ) . `reverse` is a boolean value .", "question_id": 4323}
{"snippet": "heapq.merge(*iterables, key=None, reverse=False)", "intent": "Merge multiple sorted inputs into a single sorted output ( for example , merge timestamped entries from multiple log files ) . Similar to sorted ( itertools.chain ( `*iterables` ) ) but returns an iterable , does not pull the data into memory all at once , and assumes that each of the input streams is already sorted ( smallest to largest ) . `key` specifies a key function of one argument that is used to extract a comparison key from each input element . `reverse` is a boolean value .", "question_id": 4324}
{"snippet": "heapq.nlargest(n, iterable)", "intent": "Return a list with the `n` largest elements from the dataset defined by `iterable` .", "question_id": 4325}
{"snippet": "heapq.nlargest(n, iterable, key=None)", "intent": "Return a list with the `n` largest elements from the dataset defined by `iterable` . `key` , if provided , specifies a function of one argument that is used to extract a comparison key from each element in iterable ( for example , key=str.lower ) .", "question_id": 4326}
{"snippet": "heapq.nsmallest(n, iterable)", "intent": "Return a list with the `n` smallest elements from the dataset defined by `iterable` .", "question_id": 4327}
{"snippet": "heapq.nsmallest(n, iterable, key=None)", "intent": "Return a list with the `n` smallest elements from the dataset defined by `iterable` . `key` , if provided , specifies a function of one argument that is used to extract a comparison key from each element in iterable ( for example , key=str.lower ) .", "question_id": 4328}
{"snippet": "hmac.new(key)", "intent": "Return a new hmac object . `key` is a bytes or bytearray object giving the secret key .", "question_id": 4329}
{"snippet": "hmac.new(key, msg=None)", "intent": "Return a new hmac object . `key` is a bytes or bytearray object giving the secret key . If `msg` is present , the method call update ( msg ) is made .", "question_id": 4330}
{"snippet": "hmac.new(key, digestmod=None)", "intent": "Return a new hmac object . `key` is a bytes or bytearray object giving the secret key . `digestmod` is the digest name , digest constructor or module for the HMAC object to use .", "question_id": 4331}
{"snippet": "hmac.new(key, msg=None, digestmod=None)", "intent": "Return a new hmac object . `key` is a bytes or bytearray object giving the secret key . If `msg` is present , the method call update ( msg ) is made . `digestmod` is the digest name , digest constructor or module for the HMAC object to use .", "question_id": 4332}
{"snippet": "hmac.digest(key, msg, digest)", "intent": "Return `digest` of `msg` for given secret `key` and digest .", "question_id": 4333}
{"snippet": "HMAC.update(msg)", "intent": "Update the hmac object with `msg` .", "question_id": 4334}
{"snippet": "HMAC.digest()", "intent": "Return the digest of the bytes passed to the update ( ) method so far .", "question_id": 4335}
{"snippet": "HMAC.hexdigest()", "intent": "Like digest ( ) except the digest is returned as a string twice the length containing only hexadecimal digits .", "question_id": 4336}
{"snippet": "HMAC.copy()", "intent": "Return a copy ( \u201c clone \u201d ) of the hmac object .", "question_id": 4337}
{"snippet": "HMAC.digest_size", "intent": "The size of the resulting HMAC digest in bytes.", "question_id": 4338}
{"snippet": "HMAC.block_size", "intent": "The internal block size of the hash algorithm in bytes.", "question_id": 4339}
{"snippet": "HMAC.name", "intent": "The canonical name of this HMAC, always lowercase, e.g.", "question_id": 4340}
{"snippet": "hmac.compare_digest(a, b)", "intent": "Return `a` == `b` .", "question_id": 4341}
{"snippet": "html.entities.html5", "intent": "A dictionary that maps HTML5 named character references 1 to the equivalent Unicode character(s), e.g.", "question_id": 4342}
{"snippet": "html.entities.entitydefs", "intent": "A dictionary mapping XHTML 1.0 entity definitions to their replacement text in ISO Latin-1.", "question_id": 4343}
{"snippet": "html.entities.name2codepoint", "intent": "A dictionary that maps HTML entity names to the Unicode code points.", "question_id": 4344}
{"snippet": "html.entities.codepoint2name", "intent": "A dictionary that maps Unicode code points to HTML entity names.", "question_id": 4345}
{"snippet": "html.escape(s)", "intent": "Convert the characters & , < and > in string `s` to HTML-safe sequences .", "question_id": 4346}
{"snippet": "html.escape(s, quote=True)", "intent": "Convert the characters & , < and > in string `s` to HTML-safe sequences . If the optional flag `quote` is true , the characters ( `` ) and ( ' ) are also translated ; this helps for inclusion in an HTML attribute value delimited by quotes , as in < a href= '' ... '' > .", "question_id": 4347}
{"snippet": "html.unescape(s)", "intent": "Convert all named and numeric character references ( e.g . & gt ; , & # 62 ; , & # x3e ; ) in the string `s` to the corresponding Unicode characters .", "question_id": 4348}
{"snippet": "html.parser.HTMLParser()", "intent": "Create a parser instance able to parse invalid markup .", "question_id": 4349}
{"snippet": "html.parser.HTMLParser(convert_charrefs=True)", "intent": "Create a parser instance able to parse invalid markup . If `convert_charrefs` is True ( the default ) , all character references ( except the ones in script/style elements ) are automatically converted to the corresponding Unicode characters .", "question_id": 4350}
{"snippet": "HTMLParser.feed(data)", "intent": "Feed some text to the parser . It is processed insofar as it consists of complete elements ; incomplete `data` is buffered until more data is fed or close ( ) is called .", "question_id": 4351}
{"snippet": "HTMLParser.close()", "intent": "Force processing of all buffered data as if it were followed by an end-of-file mark .", "question_id": 4352}
{"snippet": "HTMLParser.reset()", "intent": "Reset the instance .", "question_id": 4353}
{"snippet": "HTMLParser.getpos()", "intent": "Return current line number and offset .", "question_id": 4354}
{"snippet": "HTMLParser.get_starttag_text()", "intent": "Return the text of the most recently opened start tag .", "question_id": 4355}
{"snippet": "HTMLParser.handle_starttag(tag, attrs)", "intent": "This method is called to handle the start of a `tag` ( e.g . The `attrs` argument is a list of ( name , value ) pairs containing the attributes found inside the tag \u2019 s < > brackets .", "question_id": 4356}
{"snippet": "HTMLParser.handle_endtag(tag)", "intent": "This method is called to handle the end `tag` of an element ( e.g .", "question_id": 4357}
{"snippet": "HTMLParser.handle_startendtag(tag, attrs)", "intent": "Similar to handle_starttag ( ) , but called when the parser encounters an XHTML-style empty `tag` ( < img ... / > ) . With arguments `attrs`.", "question_id": 4358}
{"snippet": "HTMLParser.handle_data(data)", "intent": "This method is called to process arbitrary `data` ( e.g .", "question_id": 4359}
{"snippet": "HTMLParser.handle_entityref(name)", "intent": "This method is called to process a named character reference of the form & `name` ; ( e.g .", "question_id": 4360}
{"snippet": "HTMLParser.handle_charref(name)", "intent": "This method is called to process decimal and hexadecimal numeric character references of the form & # NNN ; and & # xNNN ; . With arguments `name`.", "question_id": 4361}
{"snippet": "HTMLParser.handle_comment(data)", "intent": "This method is called when a comment is encountered ( e.g . With arguments `data`.", "question_id": 4362}
{"snippet": "HTMLParser.handle_decl(decl)", "intent": "This method is called to handle an HTML doctype declaration ( e.g . The `decl` parameter will be the entire contents of the declaration inside the < ! ... > markup ( e.g .", "question_id": 4363}
{"snippet": "HTMLParser.handle_pi(data)", "intent": "Method called when a processing instruction is encountered . The `data` parameter will contain the entire processing instruction .", "question_id": 4364}
{"snippet": "HTMLParser.unknown_decl(data)", "intent": "This method is called when an unrecognized declaration is read by the parser . The `data` parameter will be the entire contents of the declaration inside the < ! [ ...", "question_id": 4365}
{"snippet": "http.client.HTTPConnection(host, timeout)", "intent": "An HTTPConnection instance represents one transaction with an HTTP server . It should be instantiated passing it a `host` and optional `port` number . If the optional `timeout` parameter is given , blocking operations ( like connection attempts ) will timeout after that many seconds ( if it is not given , the global default timeout setting is used ) .", "question_id": 4366}
{"snippet": "http.client.HTTPConnection(host, timeout, port=None)", "intent": "An HTTPConnection instance represents one transaction with an HTTP server . It should be instantiated passing it a `host` and optional `port` number . If the optional `timeout` parameter is given , blocking operations ( like connection attempts ) will timeout after that many seconds ( if it is not given , the global default timeout setting is used ) .", "question_id": 4367}
{"snippet": "http.client.HTTPConnection(host, timeout, source_address=None)", "intent": "An HTTPConnection instance represents one transaction with an HTTP server . It should be instantiated passing it a `host` and optional `port` number . If the optional `timeout` parameter is given , blocking operations ( like connection attempts ) will timeout after that many seconds ( if it is not given , the global default timeout setting is used ) . The optional `source_address` parameter may be a tuple of a ( host , port ) to use as the source address the HTTP connection is made from .", "question_id": 4368}
{"snippet": "http.client.HTTPConnection(host, timeout, blocksize=8192)", "intent": "An HTTPConnection instance represents one transaction with an HTTP server . It should be instantiated passing it a `host` and optional `port` number . If the optional `timeout` parameter is given , blocking operations ( like connection attempts ) will timeout after that many seconds ( if it is not given , the global default timeout setting is used ) . The optional `blocksize` parameter sets the buffer size in bytes for sending a file-like message body .", "question_id": 4369}
{"snippet": "http.client.HTTPConnection(host, timeout, port=None, source_address=None)", "intent": "An HTTPConnection instance represents one transaction with an HTTP server . It should be instantiated passing it a `host` and optional `port` number . If the optional `timeout` parameter is given , blocking operations ( like connection attempts ) will timeout after that many seconds ( if it is not given , the global default timeout setting is used ) . The optional `source_address` parameter may be a tuple of a ( host , port ) to use as the source address the HTTP connection is made from .", "question_id": 4370}
{"snippet": "http.client.HTTPConnection(host, timeout, port=None, blocksize=8192)", "intent": "An HTTPConnection instance represents one transaction with an HTTP server . It should be instantiated passing it a `host` and optional `port` number . If the optional `timeout` parameter is given , blocking operations ( like connection attempts ) will timeout after that many seconds ( if it is not given , the global default timeout setting is used ) . The optional `blocksize` parameter sets the buffer size in bytes for sending a file-like message body .", "question_id": 4371}
{"snippet": "http.client.HTTPConnection(host, timeout, source_address=None, blocksize=8192)", "intent": "An HTTPConnection instance represents one transaction with an HTTP server . It should be instantiated passing it a `host` and optional `port` number . If the optional `timeout` parameter is given , blocking operations ( like connection attempts ) will timeout after that many seconds ( if it is not given , the global default timeout setting is used ) . The optional `source_address` parameter may be a tuple of a ( host , port ) to use as the source address the HTTP connection is made from . The optional `blocksize` parameter sets the buffer size in bytes for sending a file-like message body .", "question_id": 4372}
{"snippet": "http.client.HTTPConnection(host, timeout, port=None, source_address=None, blocksize=8192)", "intent": "An HTTPConnection instance represents one transaction with an HTTP server . It should be instantiated passing it a `host` and optional `port` number . If the optional `timeout` parameter is given , blocking operations ( like connection attempts ) will timeout after that many seconds ( if it is not given , the global default timeout setting is used ) . The optional `source_address` parameter may be a tuple of a ( host , port ) to use as the source address the HTTP connection is made from . The optional `blocksize` parameter sets the buffer size in bytes for sending a file-like message body .", "question_id": 4373}
{"snippet": "http.client.HTTPConnection(host)", "intent": "An HTTPConnection instance represents one transaction with an HTTP server . It should be instantiated passing it a `host` and optional `port` number .", "question_id": 4374}
{"snippet": "http.client.HTTPConnection(host, port=None)", "intent": "An HTTPConnection instance represents one transaction with an HTTP server . It should be instantiated passing it a `host` and optional `port` number .", "question_id": 4375}
{"snippet": "http.client.HTTPConnection(host, source_address=None)", "intent": "An HTTPConnection instance represents one transaction with an HTTP server . It should be instantiated passing it a `host` and optional `port` number . The optional `source_address` parameter may be a tuple of a ( host , port ) to use as the source address the HTTP connection is made from .", "question_id": 4376}
{"snippet": "http.client.HTTPConnection(host, blocksize=8192)", "intent": "An HTTPConnection instance represents one transaction with an HTTP server . It should be instantiated passing it a `host` and optional `port` number . The optional `blocksize` parameter sets the buffer size in bytes for sending a file-like message body .", "question_id": 4377}
{"snippet": "http.client.HTTPConnection(host, port=None, source_address=None)", "intent": "An HTTPConnection instance represents one transaction with an HTTP server . It should be instantiated passing it a `host` and optional `port` number . The optional `source_address` parameter may be a tuple of a ( host , port ) to use as the source address the HTTP connection is made from .", "question_id": 4378}
{"snippet": "http.client.HTTPConnection(host, port=None, blocksize=8192)", "intent": "An HTTPConnection instance represents one transaction with an HTTP server . It should be instantiated passing it a `host` and optional `port` number . The optional `blocksize` parameter sets the buffer size in bytes for sending a file-like message body .", "question_id": 4379}
{"snippet": "http.client.HTTPConnection(host, source_address=None, blocksize=8192)", "intent": "An HTTPConnection instance represents one transaction with an HTTP server . It should be instantiated passing it a `host` and optional `port` number . The optional `source_address` parameter may be a tuple of a ( host , port ) to use as the source address the HTTP connection is made from . The optional `blocksize` parameter sets the buffer size in bytes for sending a file-like message body .", "question_id": 4380}
{"snippet": "http.client.HTTPConnection(host, port=None, source_address=None, blocksize=8192)", "intent": "An HTTPConnection instance represents one transaction with an HTTP server . It should be instantiated passing it a `host` and optional `port` number . The optional `source_address` parameter may be a tuple of a ( host , port ) to use as the source address the HTTP connection is made from . The optional `blocksize` parameter sets the buffer size in bytes for sending a file-like message body .", "question_id": 4381}
{"snippet": "http.client.HTTPSConnection(host, timeout)", "intent": "A subclass of HTTPConnection that uses SSL for communication with secure servers . With arguments `host`, `timeout`.", "question_id": 4382}
{"snippet": "http.client.HTTPSConnection(host, timeout, port=None)", "intent": "A subclass of HTTPConnection that uses SSL for communication with secure servers . Default `port` is 443 . With arguments `host`, `timeout`.", "question_id": 4383}
{"snippet": "http.client.HTTPSConnection(host, timeout, key_file=None)", "intent": "A subclass of HTTPConnection that uses SSL for communication with secure servers . With arguments `host`, `timeout`, `key_file`.", "question_id": 4384}
{"snippet": "http.client.HTTPSConnection(host, timeout, cert_file=None)", "intent": "A subclass of HTTPConnection that uses SSL for communication with secure servers . With arguments `host`, `timeout`, `cert_file`.", "question_id": 4385}
{"snippet": "http.client.HTTPSConnection(host, timeout, source_address=None)", "intent": "A subclass of HTTPConnection that uses SSL for communication with secure servers . With arguments `host`, `timeout`, `source_address`.", "question_id": 4386}
{"snippet": "http.client.HTTPSConnection(host, timeout, context=None)", "intent": "A subclass of HTTPConnection that uses SSL for communication with secure servers . If `context` is specified , it must be a ssl.SSLContext instance describing the various SSL options . With arguments `host`, `timeout`.", "question_id": 4387}
{"snippet": "http.client.HTTPSConnection(host, timeout, check_hostname=None)", "intent": "A subclass of HTTPConnection that uses SSL for communication with secure servers . With arguments `host`, `timeout`, `check_hostname`.", "question_id": 4388}
{"snippet": "http.client.HTTPSConnection(host, timeout, blocksize=8192)", "intent": "A subclass of HTTPConnection that uses SSL for communication with secure servers . With arguments `host`, `timeout`, `blocksize`.", "question_id": 4389}
{"snippet": "http.client.HTTPSConnection(host, timeout, port=None, key_file=None)", "intent": "A subclass of HTTPConnection that uses SSL for communication with secure servers . Default `port` is 443 . With arguments `host`, `timeout`, `key_file`.", "question_id": 4390}
{"snippet": "http.client.HTTPSConnection(host, timeout, port=None, cert_file=None)", "intent": "A subclass of HTTPConnection that uses SSL for communication with secure servers . Default `port` is 443 . With arguments `host`, `timeout`, `cert_file`.", "question_id": 4391}
{"snippet": "http.client.HTTPSConnection(host)", "intent": "A subclass of HTTPConnection that uses SSL for communication with secure servers . With arguments `host`.", "question_id": 4392}
{"snippet": "http.client.HTTPSConnection(host, port=None)", "intent": "A subclass of HTTPConnection that uses SSL for communication with secure servers . Default `port` is 443 . With arguments `host`.", "question_id": 4393}
{"snippet": "http.client.HTTPSConnection(host, key_file=None)", "intent": "A subclass of HTTPConnection that uses SSL for communication with secure servers . With arguments `host`, `key_file`.", "question_id": 4394}
{"snippet": "http.client.HTTPSConnection(host, cert_file=None)", "intent": "A subclass of HTTPConnection that uses SSL for communication with secure servers . With arguments `host`, `cert_file`.", "question_id": 4395}
{"snippet": "http.client.HTTPSConnection(host, source_address=None)", "intent": "A subclass of HTTPConnection that uses SSL for communication with secure servers . With arguments `host`, `source_address`.", "question_id": 4396}
{"snippet": "http.client.HTTPSConnection(host, context=None)", "intent": "A subclass of HTTPConnection that uses SSL for communication with secure servers . If `context` is specified , it must be a ssl.SSLContext instance describing the various SSL options . With arguments `host`.", "question_id": 4397}
{"snippet": "http.client.HTTPSConnection(host, check_hostname=None)", "intent": "A subclass of HTTPConnection that uses SSL for communication with secure servers . With arguments `host`, `check_hostname`.", "question_id": 4398}
{"snippet": "http.client.HTTPSConnection(host, blocksize=8192)", "intent": "A subclass of HTTPConnection that uses SSL for communication with secure servers . With arguments `host`, `blocksize`.", "question_id": 4399}
{"snippet": "http.client.HTTPSConnection(host, port=None, key_file=None)", "intent": "A subclass of HTTPConnection that uses SSL for communication with secure servers . Default `port` is 443 . With arguments `host`, `key_file`.", "question_id": 4400}
{"snippet": "http.client.HTTPSConnection(host, port=None, cert_file=None)", "intent": "A subclass of HTTPConnection that uses SSL for communication with secure servers . Default `port` is 443 . With arguments `host`, `cert_file`.", "question_id": 4401}
{"snippet": "http.client.HTTPResponse(sock)", "intent": "Class whose instances are returned upon successful connection . With arguments `sock`.", "question_id": 4402}
{"snippet": "http.client.HTTPResponse(sock, debuglevel=0)", "intent": "Class whose instances are returned upon successful connection . With arguments `sock`, `debuglevel`.", "question_id": 4403}
{"snippet": "http.client.HTTPResponse(sock, method=None)", "intent": "Class whose instances are returned upon successful connection . With arguments `sock`, `method`.", "question_id": 4404}
{"snippet": "http.client.HTTPResponse(sock, url=None)", "intent": "Class whose instances are returned upon successful connection . With arguments `sock`, `url`.", "question_id": 4405}
{"snippet": "http.client.HTTPResponse(sock, debuglevel=0, method=None)", "intent": "Class whose instances are returned upon successful connection . With arguments `sock`, `debuglevel`, `method`.", "question_id": 4406}
{"snippet": "http.client.HTTPResponse(sock, debuglevel=0, url=None)", "intent": "Class whose instances are returned upon successful connection . With arguments `sock`, `debuglevel`, `url`.", "question_id": 4407}
{"snippet": "http.client.HTTPResponse(sock, method=None, url=None)", "intent": "Class whose instances are returned upon successful connection . With arguments `sock`, `method`, `url`.", "question_id": 4408}
{"snippet": "http.client.HTTPResponse(sock, debuglevel=0, method=None, url=None)", "intent": "Class whose instances are returned upon successful connection . With arguments `sock`, `debuglevel`, `method`, `url`.", "question_id": 4409}
{"snippet": "http.client.HTTPException", "intent": "The base class of the other exceptions in this module.", "question_id": 4410}
{"snippet": "http.client.NotConnected", "intent": "A subclass of HTTPException.", "question_id": 4411}
{"snippet": "http.client.InvalidURL", "intent": "A subclass of HTTPException, raised if a port is given and is either non-numeric or empty.", "question_id": 4412}
{"snippet": "http.client.UnknownProtocol", "intent": "A subclass of HTTPException.", "question_id": 4413}
{"snippet": "http.client.UnknownTransferEncoding", "intent": "A subclass of HTTPException.", "question_id": 4414}
{"snippet": "http.client.UnimplementedFileMode", "intent": "A subclass of HTTPException.", "question_id": 4415}
{"snippet": "http.client.IncompleteRead", "intent": "A subclass of HTTPException.", "question_id": 4416}
{"snippet": "http.client.ImproperConnectionState", "intent": "A subclass of HTTPException.", "question_id": 4417}
{"snippet": "http.client.CannotSendRequest", "intent": "A subclass of ImproperConnectionState.", "question_id": 4418}
{"snippet": "http.client.CannotSendHeader", "intent": "A subclass of ImproperConnectionState.", "question_id": 4419}
{"snippet": "http.client.ResponseNotReady", "intent": "A subclass of ImproperConnectionState.", "question_id": 4420}
{"snippet": "http.client.BadStatusLine", "intent": "A subclass of HTTPException.", "question_id": 4421}
{"snippet": "http.client.LineTooLong", "intent": "A subclass of HTTPException.", "question_id": 4422}
{"snippet": "http.client.RemoteDisconnected", "intent": "A subclass of ConnectionResetError and BadStatusLine.", "question_id": 4423}
{"snippet": "http.client.HTTP_PORT", "intent": "The default port for the HTTP protocol (always 80).", "question_id": 4424}
{"snippet": "http.client.HTTPS_PORT", "intent": "The default port for the HTTPS protocol (always 443).", "question_id": 4425}
{"snippet": "http.client.responses", "intent": "This dictionary maps the HTTP 1.1 status codes to the W3C names.", "question_id": 4426}
{"snippet": "HTTPConnection.request(method, url)", "intent": "This will send a request to the server using the HTTP request `method` method and the selector `url` .", "question_id": 4427}
{"snippet": "HTTPConnection.request(method, url, body=None)", "intent": "This will send a request to the server using the HTTP request `method` method and the selector `url` . If `body` is specified , the specified data is sent after the `headers` are finished .", "question_id": 4428}
{"snippet": "HTTPConnection.request(method, url, headers={})", "intent": "This will send a request to the server using the HTTP request `method` method and the selector `url` . If `body` is specified , the specified data is sent after the `headers` are finished .", "question_id": 4429}
{"snippet": "HTTPConnection.request(method, url, encode_chunked=False)", "intent": "This will send a request to the server using the HTTP request `method` method and the selector `url` . The `encode_chunked` argument is only relevant if Transfer-Encoding is specified in headers .", "question_id": 4430}
{"snippet": "HTTPConnection.request(method, url, body=None, headers={})", "intent": "This will send a request to the server using the HTTP request `method` method and the selector `url` . If `body` is specified , the specified data is sent after the `headers` are finished .", "question_id": 4431}
{"snippet": "HTTPConnection.request(method, url, body=None, encode_chunked=False)", "intent": "This will send a request to the server using the HTTP request `method` method and the selector `url` . If `body` is specified , the specified data is sent after the `headers` are finished . The `encode_chunked` argument is only relevant if Transfer-Encoding is specified in headers .", "question_id": 4432}
{"snippet": "HTTPConnection.request(method, url, headers={}, encode_chunked=False)", "intent": "This will send a request to the server using the HTTP request `method` method and the selector `url` . If `body` is specified , the specified data is sent after the `headers` are finished . The `encode_chunked` argument is only relevant if Transfer-Encoding is specified in headers .", "question_id": 4433}
{"snippet": "HTTPConnection.request(method, url, body=None, headers={}, encode_chunked=False)", "intent": "This will send a request to the server using the HTTP request `method` method and the selector `url` . If `body` is specified , the specified data is sent after the `headers` are finished . The `encode_chunked` argument is only relevant if Transfer-Encoding is specified in headers .", "question_id": 4434}
{"snippet": "HTTPConnection.getresponse()", "intent": "Should be called after a request is sent to get the response from the server .", "question_id": 4435}
{"snippet": "HTTPConnection.set_debuglevel(level)", "intent": "Set the debugging `level` .", "question_id": 4436}
{"snippet": "HTTPConnection.set_tunnel(host)", "intent": "Set the `host` and the `port` for HTTP Connect Tunnelling .", "question_id": 4437}
{"snippet": "HTTPConnection.set_tunnel(host, port=None)", "intent": "Set the `host` and the `port` for HTTP Connect Tunnelling .", "question_id": 4438}
{"snippet": "HTTPConnection.set_tunnel(host, headers=None)", "intent": "Set the `host` and the `port` for HTTP Connect Tunnelling . The `headers` argument should be a mapping of extra HTTP headers to send with the CONNECT request .", "question_id": 4439}
{"snippet": "HTTPConnection.set_tunnel(host, port=None, headers=None)", "intent": "Set the `host` and the `port` for HTTP Connect Tunnelling . The `headers` argument should be a mapping of extra HTTP headers to send with the CONNECT request .", "question_id": 4440}
{"snippet": "HTTPConnection.connect()", "intent": "Connect to the server specified when the object was created .", "question_id": 4441}
{"snippet": "HTTPConnection.close()", "intent": "Close the connection to the server .", "question_id": 4442}
{"snippet": "HTTPConnection.blocksize", "intent": "Buffer size in bytes for sending a file-like message body.", "question_id": 4443}
{"snippet": "HTTPConnection.putrequest(method, url)", "intent": "This should be the first call after the connection to the server has been made . It sends a line to the server consisting of the `method` string , the `url` string , and the HTTP version ( HTTP/1.1 ) .", "question_id": 4444}
{"snippet": "HTTPConnection.putrequest(method, url, skip_host=False)", "intent": "This should be the first call after the connection to the server has been made . It sends a line to the server consisting of the `method` string , the `url` string , and the HTTP version ( HTTP/1.1 ) . To disable automatic sending of Host : or Accept-Encoding : headers ( for example to accept additional content encodings ) , specify `skip_host` or `skip_accept_encoding` with non-False values .", "question_id": 4445}
{"snippet": "HTTPConnection.putrequest(method, url, skip_accept_encoding=False)", "intent": "This should be the first call after the connection to the server has been made . It sends a line to the server consisting of the `method` string , the `url` string , and the HTTP version ( HTTP/1.1 ) . To disable automatic sending of Host : or Accept-Encoding : headers ( for example to accept additional content encodings ) , specify `skip_host` or `skip_accept_encoding` with non-False values .", "question_id": 4446}
{"snippet": "HTTPConnection.putrequest(method, url, skip_host=False, skip_accept_encoding=False)", "intent": "This should be the first call after the connection to the server has been made . It sends a line to the server consisting of the `method` string , the `url` string , and the HTTP version ( HTTP/1.1 ) . To disable automatic sending of Host : or Accept-Encoding : headers ( for example to accept additional content encodings ) , specify `skip_host` or `skip_accept_encoding` with non-False values .", "question_id": 4447}
{"snippet": "HTTPConnection.putheader(header, argument)", "intent": "Send an RFC 822-style `header` to the server . It sends a line to the server consisting of the header , a colon and a space , and the first `argument` .", "question_id": 4448}
{"snippet": "HTTPConnection.putheader(header)", "intent": "Send an RFC 822-style `header` to the server .", "question_id": 4449}
{"snippet": "HTTPConnection.endheaders()", "intent": "Send a blank line to the server , signalling the end of the headers .", "question_id": 4450}
{"snippet": "HTTPConnection.endheaders(message_body=None)", "intent": "Send a blank line to the server , signalling the end of the headers . The optional `message_body` argument can be used to pass a message body associated with the request .", "question_id": 4451}
{"snippet": "HTTPConnection.endheaders(encode_chunked=False)", "intent": "Send a blank line to the server , signalling the end of the headers . If `encode_chunked` is True , the result of each iteration of message_body will be chunk-encoded as specified in RFC 7230 , Section 3.3.1 .", "question_id": 4452}
{"snippet": "HTTPConnection.endheaders(message_body=None, encode_chunked=False)", "intent": "Send a blank line to the server , signalling the end of the headers . The optional `message_body` argument can be used to pass a message body associated with the request . If `encode_chunked` is True , the result of each iteration of message_body will be chunk-encoded as specified in RFC 7230 , Section 3.3.1 .", "question_id": 4453}
{"snippet": "HTTPConnection.send(data)", "intent": "Send `data` to the server .", "question_id": 4454}
{"snippet": "HTTPResponse.read(amt)", "intent": "Reads and returns the response body , or up to the next `amt` bytes .", "question_id": 4455}
{"snippet": "HTTPResponse.read()", "intent": "Reads and returns the response body , or up to the next `amt` bytes .", "question_id": 4456}
{"snippet": "HTTPResponse.readinto(b)", "intent": "Reads up to the next len ( `b` ) bytes of the response body into the buffer b .", "question_id": 4457}
{"snippet": "HTTPResponse.getheader(name)", "intent": "Return the value of the header `name` , or `default` if there is no header matching name .", "question_id": 4458}
{"snippet": "HTTPResponse.getheader(name, default=None)", "intent": "Return the value of the header `name` , or `default` if there is no header matching name .", "question_id": 4459}
{"snippet": "HTTPResponse.getheaders()", "intent": "Return a list of ( header , value ) tuples .", "question_id": 4460}
{"snippet": "HTTPResponse.fileno()", "intent": "Return the fileno of the underlying socket .", "question_id": 4461}
{"snippet": "HTTPResponse.msg", "intent": "A http.client.HTTPMessage instance containing the response headers.", "question_id": 4462}
{"snippet": "HTTPResponse.version", "intent": "HTTP protocol version used by server.", "question_id": 4463}
{"snippet": "HTTPResponse.status", "intent": "Status code returned by server.", "question_id": 4464}
{"snippet": "HTTPResponse.reason", "intent": "Reason phrase returned by server.", "question_id": 4465}
{"snippet": "HTTPResponse.debuglevel", "intent": "A debugging hook.", "question_id": 4466}
{"snippet": "HTTPResponse.closed", "intent": "Is True if the stream is closed.", "question_id": 4467}
{"snippet": "http.cookiejar.LoadError", "intent": "Instances of FileCookieJar raise this exception on failure to load cookies from a file.", "question_id": 4468}
{"snippet": "http.cookiejar.CookieJar()", "intent": "`policy` is an object implementing the CookiePolicy interface .", "question_id": 4469}
{"snippet": "http.cookiejar.CookieJar(policy=None)", "intent": "`policy` is an object implementing the CookiePolicy interface .", "question_id": 4470}
{"snippet": "http.cookiejar.FileCookieJar(filename)", "intent": "`policy` is an object implementing the CookiePolicy interface . With arguments `filename`.", "question_id": 4471}
{"snippet": "http.cookiejar.FileCookieJar(filename, delayload=None)", "intent": "`policy` is an object implementing the CookiePolicy interface . With arguments `filename`, `delayload`.", "question_id": 4472}
{"snippet": "http.cookiejar.FileCookieJar(filename, policy=None)", "intent": "`policy` is an object implementing the CookiePolicy interface . With arguments `filename`.", "question_id": 4473}
{"snippet": "http.cookiejar.FileCookieJar(filename, delayload=None, policy=None)", "intent": "`policy` is an object implementing the CookiePolicy interface . With arguments `filename`, `delayload`.", "question_id": 4474}
{"snippet": "http.cookiejar.CookiePolicy", "intent": "This class is responsible for deciding whether each cookie should be accepted from / returned to the server.", "question_id": 4475}
{"snippet": "http.cookiejar.DefaultCookiePolicy()", "intent": "Constructor arguments should be passed as keyword arguments only .", "question_id": 4476}
{"snippet": "http.cookiejar.DefaultCookiePolicy(blocked_domains=None)", "intent": "Constructor arguments should be passed as keyword arguments only . `blocked_domains` is a sequence of domain names that we never accept cookies from , nor return cookies to .", "question_id": 4477}
{"snippet": "http.cookiejar.DefaultCookiePolicy(allowed_domains=None)", "intent": "Constructor arguments should be passed as keyword arguments only . `allowed_domains` if not None , this is a sequence of the only domains for which we accept and return cookies .", "question_id": 4478}
{"snippet": "http.cookiejar.DefaultCookiePolicy(netscape=True)", "intent": "Constructor arguments should be passed as keyword arguments only . With arguments `netscape`.", "question_id": 4479}
{"snippet": "http.cookiejar.DefaultCookiePolicy(rfc2965=False)", "intent": "Constructor arguments should be passed as keyword arguments only . With arguments `rfc2965`.", "question_id": 4480}
{"snippet": "http.cookiejar.DefaultCookiePolicy(rfc2109_as_netscape=None)", "intent": "Constructor arguments should be passed as keyword arguments only . However , if RFC 2965 handling is turned off or `rfc2109_as_netscape` is True , RFC 2109 cookies are \u2018 downgraded \u2019 by the CookieJar instance to Netscape cookies , by setting the version attribute of the Cookie instance to 0 .", "question_id": 4481}
{"snippet": "http.cookiejar.DefaultCookiePolicy(hide_cookie2=False)", "intent": "Constructor arguments should be passed as keyword arguments only . With arguments `hide_cookie2`.", "question_id": 4482}
{"snippet": "http.cookiejar.DefaultCookiePolicy(strict_domain=False)", "intent": "Constructor arguments should be passed as keyword arguments only . With arguments `strict_domain`.", "question_id": 4483}
{"snippet": "http.cookiejar.DefaultCookiePolicy(strict_rfc2965_unverifiable=True)", "intent": "Constructor arguments should be passed as keyword arguments only . With arguments `strict_rfc2965_unverifiable`.", "question_id": 4484}
{"snippet": "http.cookiejar.DefaultCookiePolicy(strict_ns_unverifiable=False)", "intent": "Constructor arguments should be passed as keyword arguments only . With arguments `strict_ns_unverifiable`.", "question_id": 4485}
{"snippet": "http.cookiejar.Cookie", "intent": "This class represents Netscape, RFC 2109 and RFC 2965 cookies.", "question_id": 4486}
{"snippet": "CookieJar.add_cookie_header(request)", "intent": "Add correct Cookie header to `request` .", "question_id": 4487}
{"snippet": "CookieJar.extract_cookies(response, request)", "intent": "Extract cookies from HTTP `response` and store them in the CookieJar , where allowed by policy . The `request` object ( usually a urllib.request.Request instance ) must support the methods get_full_url ( ) , get_host ( ) , unverifiable ( ) , and origin_req_host attribute , as documented by urllib.request .", "question_id": 4488}
{"snippet": "CookieJar.set_policy(policy)", "intent": "Set the CookiePolicy instance to be used . With arguments `policy`.", "question_id": 4489}
{"snippet": "CookieJar.make_cookies(response, request)", "intent": "Return sequence of Cookie objects extracted from `response` object . See the documentation for extract_cookies ( ) for the interfaces required of the response and `request` arguments .", "question_id": 4490}
{"snippet": "CookieJar.set_cookie_if_ok(cookie, request)", "intent": "Set a Cookie if policy says it \u2019 s OK to do so . With arguments `cookie`, `request`.", "question_id": 4491}
{"snippet": "CookieJar.set_cookie(cookie)", "intent": "Set a Cookie , without checking with policy to see whether or not it should be set . With arguments `cookie`.", "question_id": 4492}
{"snippet": "CookieJar.clear(domain, path, name)", "intent": "Clear some cookies . If given a single argument , only cookies belonging to that `domain` will be removed . If given two arguments , cookies belonging to the specified domain and URL `path` are removed . If given three arguments , then the cookie with the specified domain , path and `name` is removed .", "question_id": 4493}
{"snippet": "CookieJar.clear(domain, path)", "intent": "Clear some cookies . If given a single argument , only cookies belonging to that `domain` will be removed . If given two arguments , cookies belonging to the specified domain and URL `path` are removed .", "question_id": 4494}
{"snippet": "CookieJar.clear(domain)", "intent": "Clear some cookies . If given a single argument , only cookies belonging to that `domain` will be removed .", "question_id": 4495}
{"snippet": "CookieJar.clear()", "intent": "Clear some cookies .", "question_id": 4496}
{"snippet": "CookieJar.clear_session_cookies()", "intent": "Discard all session cookies .", "question_id": 4497}
{"snippet": "FileCookieJar.save()", "intent": "Save cookies to a file .", "question_id": 4498}
{"snippet": "FileCookieJar.save(filename=None)", "intent": "Save cookies to a file . `filename` is the name of file in which to save cookies .", "question_id": 4499}
{"snippet": "FileCookieJar.save(ignore_discard=False)", "intent": "Save cookies to a file . `ignore_discard` : save even cookies set to be discarded .", "question_id": 4500}
{"snippet": "FileCookieJar.save(ignore_expires=False)", "intent": "Save cookies to a file . `ignore_expires` : save even cookies that have expired", "question_id": 4501}
{"snippet": "FileCookieJar.save(filename=None, ignore_discard=False)", "intent": "Save cookies to a file . `filename` is the name of file in which to save cookies . `ignore_discard` : save even cookies set to be discarded .", "question_id": 4502}
{"snippet": "FileCookieJar.save(filename=None, ignore_expires=False)", "intent": "Save cookies to a file . `filename` is the name of file in which to save cookies . `ignore_expires` : save even cookies that have expired", "question_id": 4503}
{"snippet": "FileCookieJar.save(ignore_discard=False, ignore_expires=False)", "intent": "Save cookies to a file . `ignore_discard` : save even cookies set to be discarded . `ignore_expires` : save even cookies that have expired", "question_id": 4504}
{"snippet": "FileCookieJar.save(filename=None, ignore_discard=False, ignore_expires=False)", "intent": "Save cookies to a file . `filename` is the name of file in which to save cookies . `ignore_discard` : save even cookies set to be discarded . `ignore_expires` : save even cookies that have expired", "question_id": 4505}
{"snippet": "FileCookieJar.load()", "intent": "Load cookies from a file .", "question_id": 4506}
{"snippet": "FileCookieJar.load(filename=None)", "intent": "Load cookies from a file . With arguments `filename`.", "question_id": 4507}
{"snippet": "FileCookieJar.load(ignore_discard=False)", "intent": "Load cookies from a file . With arguments `ignore_discard`.", "question_id": 4508}
{"snippet": "FileCookieJar.load(ignore_expires=False)", "intent": "Load cookies from a file . With arguments `ignore_expires`.", "question_id": 4509}
{"snippet": "FileCookieJar.load(filename=None, ignore_discard=False)", "intent": "Load cookies from a file . With arguments `filename`, `ignore_discard`.", "question_id": 4510}
{"snippet": "FileCookieJar.load(filename=None, ignore_expires=False)", "intent": "Load cookies from a file . With arguments `filename`, `ignore_expires`.", "question_id": 4511}
{"snippet": "FileCookieJar.load(ignore_discard=False, ignore_expires=False)", "intent": "Load cookies from a file . With arguments `ignore_discard`, `ignore_expires`.", "question_id": 4512}
{"snippet": "FileCookieJar.load(filename=None, ignore_discard=False, ignore_expires=False)", "intent": "Load cookies from a file . With arguments `filename`, `ignore_discard`, `ignore_expires`.", "question_id": 4513}
{"snippet": "FileCookieJar.revert()", "intent": "Clear all cookies and reload cookies from a saved file .", "question_id": 4514}
{"snippet": "FileCookieJar.revert(filename=None)", "intent": "Clear all cookies and reload cookies from a saved file . With arguments `filename`.", "question_id": 4515}
{"snippet": "FileCookieJar.revert(ignore_discard=False)", "intent": "Clear all cookies and reload cookies from a saved file . With arguments `ignore_discard`.", "question_id": 4516}
{"snippet": "FileCookieJar.revert(ignore_expires=False)", "intent": "Clear all cookies and reload cookies from a saved file . With arguments `ignore_expires`.", "question_id": 4517}
{"snippet": "FileCookieJar.revert(filename=None, ignore_discard=False)", "intent": "Clear all cookies and reload cookies from a saved file . With arguments `filename`, `ignore_discard`.", "question_id": 4518}
{"snippet": "FileCookieJar.revert(filename=None, ignore_expires=False)", "intent": "Clear all cookies and reload cookies from a saved file . With arguments `filename`, `ignore_expires`.", "question_id": 4519}
{"snippet": "FileCookieJar.revert(ignore_discard=False, ignore_expires=False)", "intent": "Clear all cookies and reload cookies from a saved file . With arguments `ignore_discard`, `ignore_expires`.", "question_id": 4520}
{"snippet": "FileCookieJar.revert(filename=None, ignore_discard=False, ignore_expires=False)", "intent": "Clear all cookies and reload cookies from a saved file . With arguments `filename`, `ignore_discard`, `ignore_expires`.", "question_id": 4521}
{"snippet": "FileCookieJar.filename", "intent": "Filename of default file in which to keep cookies.", "question_id": 4522}
{"snippet": "FileCookieJar.delayload", "intent": "If true, load cookies lazily from disk.", "question_id": 4523}
{"snippet": "http.cookiejar.MozillaCookieJar(filename)", "intent": "A FileCookieJar that can load from and save cookies to disk in the Mozilla cookies.txt file format ( which is also used by the Lynx and Netscape browsers ) . With arguments `filename`.", "question_id": 4524}
{"snippet": "http.cookiejar.MozillaCookieJar(filename, delayload=None)", "intent": "A FileCookieJar that can load from and save cookies to disk in the Mozilla cookies.txt file format ( which is also used by the Lynx and Netscape browsers ) . With arguments `filename`, `delayload`.", "question_id": 4525}
{"snippet": "http.cookiejar.MozillaCookieJar(filename, policy=None)", "intent": "A FileCookieJar that can load from and save cookies to disk in the Mozilla cookies.txt file format ( which is also used by the Lynx and Netscape browsers ) . With arguments `filename`, `policy`.", "question_id": 4526}
{"snippet": "http.cookiejar.MozillaCookieJar(filename, delayload=None, policy=None)", "intent": "A FileCookieJar that can load from and save cookies to disk in the Mozilla cookies.txt file format ( which is also used by the Lynx and Netscape browsers ) . With arguments `filename`, `delayload`, `policy`.", "question_id": 4527}
{"snippet": "http.cookiejar.LWPCookieJar(filename)", "intent": "A FileCookieJar that can load from and save cookies to disk in format compatible with the libwww-perl library \u2019 s Set-Cookie3 file format . With arguments `filename`.", "question_id": 4528}
{"snippet": "http.cookiejar.LWPCookieJar(filename, delayload=None)", "intent": "A FileCookieJar that can load from and save cookies to disk in format compatible with the libwww-perl library \u2019 s Set-Cookie3 file format . With arguments `filename`, `delayload`.", "question_id": 4529}
{"snippet": "http.cookiejar.LWPCookieJar(filename, policy=None)", "intent": "A FileCookieJar that can load from and save cookies to disk in format compatible with the libwww-perl library \u2019 s Set-Cookie3 file format . With arguments `filename`, `policy`.", "question_id": 4530}
{"snippet": "http.cookiejar.LWPCookieJar(filename, delayload=None, policy=None)", "intent": "A FileCookieJar that can load from and save cookies to disk in format compatible with the libwww-perl library \u2019 s Set-Cookie3 file format . With arguments `filename`, `delayload`, `policy`.", "question_id": 4531}
{"snippet": "CookiePolicy.set_ok(cookie, request)", "intent": "Return boolean value indicating whether `cookie` should be accepted from server . `request` is an object implementing the interface defined by the documentation for CookieJar.extract_cookies ( ) .", "question_id": 4532}
{"snippet": "CookiePolicy.return_ok(cookie, request)", "intent": "Return boolean value indicating whether `cookie` should be returned to server . `request` is an object implementing the interface defined by the documentation for CookieJar.add_cookie_header ( ) .", "question_id": 4533}
{"snippet": "CookiePolicy.domain_return_ok(domain, request)", "intent": "Return false if cookies should not be returned , given cookie `domain` . Note that domain_return_ok ( ) is called for every cookie domain , not just for the `request` domain .", "question_id": 4534}
{"snippet": "CookiePolicy.path_return_ok(path, request)", "intent": "Return false if cookies should not be returned , given cookie `path` . With arguments `request`.", "question_id": 4535}
{"snippet": "CookiePolicy.netscape", "intent": "Implement Netscape protocol.", "question_id": 4536}
{"snippet": "CookiePolicy.rfc2965", "intent": "Implement RFC 2965 protocol.", "question_id": 4537}
{"snippet": "CookiePolicy.hide_cookie2", "intent": "Don\u2019t add Cookie2 header to requests (the presence of this header indicates to the server that we understand RFC 2965 cookies).", "question_id": 4538}
{"snippet": "DefaultCookiePolicy.blocked_domains()", "intent": "Return the sequence of blocked domains ( as a tuple ) .", "question_id": 4539}
{"snippet": "DefaultCookiePolicy.set_blocked_domains(blocked_domains)", "intent": "Set the sequence of blocked domains . With arguments `blocked_domains`.", "question_id": 4540}
{"snippet": "DefaultCookiePolicy.is_blocked(domain)", "intent": "Return whether `domain` is on the blacklist for setting or receiving cookies .", "question_id": 4541}
{"snippet": "DefaultCookiePolicy.allowed_domains()", "intent": "Return None , or the sequence of allowed domains ( as a tuple ) .", "question_id": 4542}
{"snippet": "DefaultCookiePolicy.set_allowed_domains(allowed_domains)", "intent": "Set the sequence of allowed domains , or None . With arguments `allowed_domains`.", "question_id": 4543}
{"snippet": "DefaultCookiePolicy.is_not_allowed(domain)", "intent": "Return whether `domain` is not on the whitelist for setting or receiving cookies .", "question_id": 4544}
{"snippet": "DefaultCookiePolicy.rfc2109_as_netscape", "intent": "If true, request that the CookieJar instance downgrade RFC 2109 cookies (ie.", "question_id": 4545}
{"snippet": "DefaultCookiePolicy.strict_domain", "intent": "Don\u2019t allow sites to set two-component domains with country-code top-level domains like .co.uk, .gov.uk, .co.nz.etc.", "question_id": 4546}
{"snippet": "DefaultCookiePolicy.strict_rfc2965_unverifiable", "intent": "Follow RFC 2965 rules on unverifiable transactions (usually, an unverifiable transaction is one resulting from a redirect or a request for an image hosted on another site).", "question_id": 4547}
{"snippet": "DefaultCookiePolicy.strict_ns_unverifiable", "intent": "Apply RFC 2965 rules on unverifiable transactions even to Netscape cookies.", "question_id": 4548}
{"snippet": "DefaultCookiePolicy.strict_ns_domain", "intent": "Flags indicating how strict to be with domain-matching rules for Netscape cookies.", "question_id": 4549}
{"snippet": "DefaultCookiePolicy.strict_ns_set_initial_dollar", "intent": "Ignore cookies in Set-Cookie: headers that have names starting with '$'.", "question_id": 4550}
{"snippet": "DefaultCookiePolicy.strict_ns_set_path", "intent": "Don\u2019t allow setting cookies whose path doesn\u2019t path-match request URI.", "question_id": 4551}
{"snippet": "DefaultCookiePolicy.DomainStrictNoDots", "intent": "When setting cookies, the \u2018host prefix\u2019 must not contain a dot (eg.", "question_id": 4552}
{"snippet": "DefaultCookiePolicy.DomainStrictNonDomain", "intent": "Cookies that did not explicitly specify a domain cookie-attribute can only be returned to a domain equal to the domain that set the cookie (eg.", "question_id": 4553}
{"snippet": "DefaultCookiePolicy.DomainRFC2965Match", "intent": "When setting cookies, require a full RFC 2965 domain-match.", "question_id": 4554}
{"snippet": "DefaultCookiePolicy.DomainLiberal", "intent": "Equivalent to 0 (ie.", "question_id": 4555}
{"snippet": "DefaultCookiePolicy.DomainStrict", "intent": "Equivalent to DomainStrictNoDots|DomainStrictNonDomain.", "question_id": 4556}
{"snippet": "Cookie.version", "intent": "Integer or None.", "question_id": 4557}
{"snippet": "Cookie.name", "intent": "Cookie name (a string).", "question_id": 4558}
{"snippet": "Cookie.value", "intent": "Cookie value (a string), or None.", "question_id": 4559}
{"snippet": "Cookie.port", "intent": "String representing a port or a set of ports (eg.", "question_id": 4560}
{"snippet": "Cookie.path", "intent": "Cookie path (a string, eg.", "question_id": 4561}
{"snippet": "Cookie.secure", "intent": "True if cookie should only be returned over a secure connection.", "question_id": 4562}
{"snippet": "Cookie.expires", "intent": "Integer expiry date in seconds since epoch, or None.", "question_id": 4563}
{"snippet": "Cookie.discard", "intent": "True if this is a session cookie.", "question_id": 4564}
{"snippet": "Cookie.comment", "intent": "String comment from the server explaining the function of this cookie, or None.", "question_id": 4565}
{"snippet": "Cookie.comment_url", "intent": "URL linking to a comment from the server explaining the function of this cookie, or None.", "question_id": 4566}
{"snippet": "Cookie.rfc2109", "intent": "True if this cookie was received as an RFC 2109 cookie (ie.", "question_id": 4567}
{"snippet": "Cookie.port_specified", "intent": "True if a port or set of ports was explicitly specified by the server (in the Set-Cookie / Set-Cookie2 header).", "question_id": 4568}
{"snippet": "Cookie.domain_specified", "intent": "True if a domain was explicitly specified by the server.", "question_id": 4569}
{"snippet": "Cookie.domain_initial_dot", "intent": "True if the domain explicitly specified by the server began with a dot ('.", "question_id": 4570}
{"snippet": "Cookie.has_nonstandard_attr(name)", "intent": "Return true if cookie has the named cookie-attribute . With arguments `name`.", "question_id": 4571}
{"snippet": "Cookie.get_nonstandard_attr(name)", "intent": "If cookie has the named cookie-attribute , return its value . With arguments `name`.", "question_id": 4572}
{"snippet": "Cookie.get_nonstandard_attr(name, default=None)", "intent": "If cookie has the named cookie-attribute , return its value . Otherwise , return `default` . With arguments `name`.", "question_id": 4573}
{"snippet": "Cookie.set_nonstandard_attr(name, value)", "intent": "Set the `value` of the named cookie-attribute . With arguments `name`.", "question_id": 4574}
{"snippet": "Cookie.is_expired()", "intent": "True if cookie has passed the time at which the server requested it should expire .", "question_id": 4575}
{"snippet": "Cookie.is_expired(now=None)", "intent": "True if cookie has passed the time at which the server requested it should expire . If `now` is given ( in seconds since the epoch ) , return whether the cookie has expired at the specified time .", "question_id": 4576}
{"snippet": "http.cookies.CookieError", "intent": "Exception failing because of RFC 2109 invalidity: incorrect attributes, incorrect Set-Cookie header, etc.", "question_id": 4577}
{"snippet": "http.cookies.BaseCookie(input)", "intent": "This class is a dictionary-like object whose keys are strings and whose values are Morsel instances . If `input` is given , it is passed to the load ( ) method .", "question_id": 4578}
{"snippet": "http.cookies.BaseCookie()", "intent": "This class is a dictionary-like object whose keys are strings and whose values are Morsel instances .", "question_id": 4579}
{"snippet": "http.cookies.SimpleCookie(input)", "intent": "This class derives from BaseCookie and overrides value_decode ( ) and value_encode ( ) . With arguments `input`.", "question_id": 4580}
{"snippet": "http.cookies.SimpleCookie()", "intent": "This class derives from BaseCookie and overrides value_decode ( ) and value_encode ( ) .", "question_id": 4581}
{"snippet": "BaseCookie.value_decode(val)", "intent": "Return a tuple ( real_value , coded_value ) from a string representation . With arguments `val`.", "question_id": 4582}
{"snippet": "BaseCookie.value_encode(val)", "intent": "Return a tuple ( real_value , coded_value ) . `val` can be any type , but coded_value will always be converted to a string .", "question_id": 4583}
{"snippet": "BaseCookie.output()", "intent": "Return a string representation suitable to be sent as HTTP headers .", "question_id": 4584}
{"snippet": "BaseCookie.output(attrs=None)", "intent": "Return a string representation suitable to be sent as HTTP headers . `attrs` and `header` are sent to each Morsel \u2019 s output ( ) method .", "question_id": 4585}
{"snippet": "BaseCookie.output(header='Set-Cookie:')", "intent": "Return a string representation suitable to be sent as HTTP headers . `attrs` and `header` are sent to each Morsel \u2019 s output ( ) method .", "question_id": 4586}
{"snippet": "BaseCookie.output(sep='\\r\\n')", "intent": "Return a string representation suitable to be sent as HTTP headers . `sep` is used to join the headers together , and is by default the combination '\\r\\n ' ( CRLF ) .", "question_id": 4587}
{"snippet": "BaseCookie.output(attrs=None, header='Set-Cookie:')", "intent": "Return a string representation suitable to be sent as HTTP headers . `attrs` and `header` are sent to each Morsel \u2019 s output ( ) method .", "question_id": 4588}
{"snippet": "BaseCookie.output(attrs=None, sep='\\r\\n')", "intent": "Return a string representation suitable to be sent as HTTP headers . `attrs` and `header` are sent to each Morsel \u2019 s output ( ) method . `sep` is used to join the headers together , and is by default the combination '\\r\\n ' ( CRLF ) .", "question_id": 4589}
{"snippet": "BaseCookie.output(header='Set-Cookie:', sep='\\r\\n')", "intent": "Return a string representation suitable to be sent as HTTP headers . `attrs` and `header` are sent to each Morsel \u2019 s output ( ) method . `sep` is used to join the headers together , and is by default the combination '\\r\\n ' ( CRLF ) .", "question_id": 4590}
{"snippet": "BaseCookie.output(attrs=None, header='Set-Cookie:', sep='\\r\\n')", "intent": "Return a string representation suitable to be sent as HTTP headers . `attrs` and `header` are sent to each Morsel \u2019 s output ( ) method . `sep` is used to join the headers together , and is by default the combination '\\r\\n ' ( CRLF ) .", "question_id": 4591}
{"snippet": "BaseCookie.js_output()", "intent": "Return an embeddable JavaScript snippet , which , if run on a browser which supports JavaScript , will act the same as if the HTTP headers was sent .", "question_id": 4592}
{"snippet": "BaseCookie.js_output(attrs=None)", "intent": "Return an embeddable JavaScript snippet , which , if run on a browser which supports JavaScript , will act the same as if the HTTP headers was sent . The meaning for `attrs` is the same as in output ( ) .", "question_id": 4593}
{"snippet": "BaseCookie.load(rawdata)", "intent": "If `rawdata` is a string , parse it as an HTTP_COOKIE and add the values found there as Morsels .", "question_id": 4594}
{"snippet": "http.cookies.Morsel", "intent": "Abstract a key/value pair, which has some RFC 2109 attributes.", "question_id": 4595}
{"snippet": "Morsel.value", "intent": "The value of the cookie.", "question_id": 4596}
{"snippet": "Morsel.coded_value", "intent": "The encoded value of the cookie \u2014 this is what should be sent.", "question_id": 4597}
{"snippet": "Morsel.key", "intent": "The name of the cookie.", "question_id": 4598}
{"snippet": "Morsel.set(key, value, coded_value)", "intent": "Set the `key` , `value` and `coded_value` attributes .", "question_id": 4599}
{"snippet": "Morsel.isReservedKey(K)", "intent": "Whether `K` is a member of the set of keys of a Morsel .", "question_id": 4600}
{"snippet": "Morsel.output()", "intent": "Return a string representation of the Morsel , suitable to be sent as an HTTP `header` .", "question_id": 4601}
{"snippet": "Morsel.output(attrs=None)", "intent": "Return a string representation of the Morsel , suitable to be sent as an HTTP `header` . By default , all the attributes are included , unless `attrs` is given , in which case it should be a list of attributes to use .", "question_id": 4602}
{"snippet": "Morsel.output(header='Set-Cookie:')", "intent": "Return a string representation of the Morsel , suitable to be sent as an HTTP `header` .", "question_id": 4603}
{"snippet": "Morsel.output(attrs=None, header='Set-Cookie:')", "intent": "Return a string representation of the Morsel , suitable to be sent as an HTTP `header` . By default , all the attributes are included , unless `attrs` is given , in which case it should be a list of attributes to use .", "question_id": 4604}
{"snippet": "Morsel.js_output()", "intent": "Return an embeddable JavaScript snippet , which , if run on a browser which supports JavaScript , will act the same as if the HTTP header was sent .", "question_id": 4605}
{"snippet": "Morsel.js_output(attrs=None)", "intent": "Return an embeddable JavaScript snippet , which , if run on a browser which supports JavaScript , will act the same as if the HTTP header was sent . The meaning for `attrs` is the same as in output ( ) .", "question_id": 4606}
{"snippet": "Morsel.OutputString()", "intent": "Return a string representing the Morsel , without any surrounding HTTP or JavaScript .", "question_id": 4607}
{"snippet": "Morsel.OutputString(attrs=None)", "intent": "Return a string representing the Morsel , without any surrounding HTTP or JavaScript . The meaning for `attrs` is the same as in output ( ) .", "question_id": 4608}
{"snippet": "Morsel.update(values)", "intent": "Update the `values` in the Morsel dictionary with the values in the dictionary values .", "question_id": 4609}
{"snippet": "Morsel.copy(value)", "intent": "Return a shallow copy of the Morsel object . With arguments `value`.", "question_id": 4610}
{"snippet": "Morsel.setdefault(key)", "intent": "Raise an error if `key` is not a valid RFC 2109 attribute , otherwise behave the same as dict.setdefault ( ) .", "question_id": 4611}
{"snippet": "Morsel.setdefault(key, value=None)", "intent": "Raise an error if `key` is not a valid RFC 2109 attribute , otherwise behave the same as dict.setdefault ( ) . With arguments `value`.", "question_id": 4612}
{"snippet": "http.HTTPStatus", "intent": "A subclass of enum.IntEnum that defines a set of HTTP status codes, reason phrases and long descriptions written in English.", "question_id": 4613}
{"snippet": "http.server.HTTPServer(server_address, RequestHandlerClass)", "intent": "This class builds on the TCPServer class by storing the server address as instance variables named server_name and server_port . With arguments `server_address`, `RequestHandlerClass`.", "question_id": 4614}
{"snippet": "http.server.ThreadingHTTPServer(server_address, RequestHandlerClass)", "intent": "This class is identical to HTTPServer but uses threads to handle requests by using the ThreadingMixIn . With arguments `server_address`, `RequestHandlerClass`.", "question_id": 4615}
{"snippet": "http.server.BaseHTTPRequestHandler(request, client_address, server)", "intent": "This class is used to handle the HTTP requests that arrive at the `server` . By itself , it can not respond to any actual HTTP requests ; it must be subclassed to handle each `request` method ( e.g . With arguments `client_address`.", "question_id": 4616}
{"snippet": "base_http_request_handler.client_address", "intent": "Contains a tuple of the form (host, port) referring to the client\u2019s address.", "question_id": 4617}
{"snippet": "base_http_request_handler.server", "intent": "Contains the server instance.", "question_id": 4618}
{"snippet": "base_http_request_handler.close_connection", "intent": "Boolean that should be set before handle_one_request() returns, indicating if another request may be expected, or if the connection should be shut down.", "question_id": 4619}
{"snippet": "base_http_request_handler.requestline", "intent": "Contains the string representation of the HTTP request line.", "question_id": 4620}
{"snippet": "base_http_request_handler.command", "intent": "Contains the command (request type).", "question_id": 4621}
{"snippet": "base_http_request_handler.path", "intent": "Contains the request path.", "question_id": 4622}
{"snippet": "base_http_request_handler.request_version", "intent": "Contains the version string from the request.", "question_id": 4623}
{"snippet": "base_http_request_handler.headers", "intent": "Holds an instance of the class specified by the MessageClass class variable.", "question_id": 4624}
{"snippet": "base_http_request_handler.rfile", "intent": "An io.BufferedIOBase input stream, ready to read from the start of the optional input data.", "question_id": 4625}
{"snippet": "base_http_request_handler.wfile", "intent": "Contains the output stream for writing a response back to the client.", "question_id": 4626}
{"snippet": "base_http_request_handler.server_version", "intent": "Specifies the server software version.", "question_id": 4627}
{"snippet": "base_http_request_handler.sys_version", "intent": "Contains the Python system version, in a form usable by the version_string method and the server_version class variable.", "question_id": 4628}
{"snippet": "base_http_request_handler.error_message_format", "intent": "Specifies a format string that should be used by send_error() method for building an error response to the client.", "question_id": 4629}
{"snippet": "base_http_request_handler.error_content_type", "intent": "Specifies the Content-Type HTTP header of error responses sent to the client.", "question_id": 4630}
{"snippet": "base_http_request_handler.protocol_version", "intent": "This specifies the HTTP protocol version used in responses.", "question_id": 4631}
{"snippet": "base_http_request_handler.MessageClass", "intent": "Specifies an email.message.Message-like class to parse HTTP headers.", "question_id": 4632}
{"snippet": "base_http_request_handler.responses", "intent": "This attribute contains a mapping of error code integers to two-element tuples containing a short and long message.", "question_id": 4633}
{"snippet": "base_http_request_handler.handle()", "intent": "Calls handle_one_request ( ) once ( or , if persistent connections are enabled , multiple times ) to handle incoming HTTP requests .", "question_id": 4634}
{"snippet": "base_http_request_handler.handle_one_request()", "intent": "This method will parse and dispatch the request to the appropriate do_* ( ) method .", "question_id": 4635}
{"snippet": "base_http_request_handler.handle_expect_100()", "intent": "When a HTTP/1.1 compliant server receives an Expect : 100-continue request header it responds back with a 100 Continue followed by 200 OK headers .", "question_id": 4636}
{"snippet": "base_http_request_handler.send_error(code)", "intent": "Sends and logs a complete error reply to the client . The numeric `code` specifies the HTTP error code , with `message` as an optional , short , human readable description of the error .", "question_id": 4637}
{"snippet": "base_http_request_handler.send_error(code, message=None)", "intent": "Sends and logs a complete error reply to the client . The numeric `code` specifies the HTTP error code , with `message` as an optional , short , human readable description of the error .", "question_id": 4638}
{"snippet": "base_http_request_handler.send_error(code, explain=None)", "intent": "Sends and logs a complete error reply to the client . The numeric `code` specifies the HTTP error code , with `message` as an optional , short , human readable description of the error . The `explain` argument can be used to provide more detailed information about the error ; it will be formatted using the error_message_format attribute and emitted , after a complete set of headers , as the response body .", "question_id": 4639}
{"snippet": "base_http_request_handler.send_error(code, message=None, explain=None)", "intent": "Sends and logs a complete error reply to the client . The numeric `code` specifies the HTTP error code , with `message` as an optional , short , human readable description of the error . The `explain` argument can be used to provide more detailed information about the error ; it will be formatted using the error_message_format attribute and emitted , after a complete set of headers , as the response body .", "question_id": 4640}
{"snippet": "base_http_request_handler.send_response(code)", "intent": "Adds a response header to the headers buffer and logs the accepted request . With arguments `code`.", "question_id": 4641}
{"snippet": "base_http_request_handler.send_response(code, message=None)", "intent": "Adds a response header to the headers buffer and logs the accepted request . With arguments `code`, `message`.", "question_id": 4642}
{"snippet": "base_http_request_handler.send_header(keyword, value)", "intent": "Adds the HTTP header to an internal buffer which will be written to the output stream when either end_headers ( ) or flush_headers ( ) is invoked . `keyword` should specify the header keyword , with `value` specifying its value .", "question_id": 4643}
{"snippet": "base_http_request_handler.send_response_only(code)", "intent": "Sends the response header only , used for the purposes when 100 Continue response is sent by the server to the client . The headers not buffered and sent directly the output stream.If the `message` is not specified , the HTTP message corresponding the response `code` is sent .", "question_id": 4644}
{"snippet": "base_http_request_handler.send_response_only(code, message=None)", "intent": "Sends the response header only , used for the purposes when 100 Continue response is sent by the server to the client . The headers not buffered and sent directly the output stream.If the `message` is not specified , the HTTP message corresponding the response `code` is sent .", "question_id": 4645}
{"snippet": "base_http_request_handler.end_headers()", "intent": "Adds a blank line ( indicating the end of the HTTP headers in the response ) to the headers buffer and calls flush_headers ( ) .", "question_id": 4646}
{"snippet": "base_http_request_handler.flush_headers()", "intent": "Finally send the headers to the output stream and flush the internal headers buffer .", "question_id": 4647}
{"snippet": "base_http_request_handler.log_request()", "intent": "Logs an accepted ( successful ) request .", "question_id": 4648}
{"snippet": "base_http_request_handler.log_request(code='-')", "intent": "Logs an accepted ( successful ) request . `code` should specify the numeric HTTP code associated with the response .", "question_id": 4649}
{"snippet": "base_http_request_handler.log_request(size='-')", "intent": "Logs an accepted ( successful ) request . If a `size` of the response is available , then it should be passed as the size parameter .", "question_id": 4650}
{"snippet": "base_http_request_handler.log_request(code='-', size='-')", "intent": "Logs an accepted ( successful ) request . `code` should specify the numeric HTTP code associated with the response . If a `size` of the response is available , then it should be passed as the size parameter .", "question_id": 4651}
{"snippet": "base_http_request_handler.log_error()", "intent": "Logs an error when a request can not be fulfilled .", "question_id": 4652}
{"snippet": "base_http_request_handler.log_message(format)", "intent": "Logs an arbitrary message to sys.stderr . The `format` argument is a standard printf-style format string , where the additional arguments to log_message ( ) are applied as inputs to the formatting .", "question_id": 4653}
{"snippet": "base_http_request_handler.version_string()", "intent": "Returns the server software \u2019 s version string .", "question_id": 4654}
{"snippet": "base_http_request_handler.date_time_string()", "intent": "Returns the date and time given by `timestamp` ( which must be None or in the format returned by time.time ( ) ) , formatted for a message header .", "question_id": 4655}
{"snippet": "base_http_request_handler.date_time_string(timestamp=None)", "intent": "Returns the date and time given by `timestamp` ( which must be None or in the format returned by time.time ( ) ) , formatted for a message header .", "question_id": 4656}
{"snippet": "base_http_request_handler.log_date_time_string()", "intent": "Returns the current date and time , formatted for logging .", "question_id": 4657}
{"snippet": "base_http_request_handler.address_string()", "intent": "Returns the client address .", "question_id": 4658}
{"snippet": "http.server.SimpleHTTPRequestHandler(request, client_address, server)", "intent": "This class serves files from the current `directory` and below , directly mapping the directory structure to HTTP requests . A lot of the work , such as parsing the `request` , is done by the base class BaseHTTPRequestHandler . With arguments `client_address`, `server`.", "question_id": 4659}
{"snippet": "http.server.SimpleHTTPRequestHandler(request, client_address, server, directory=None)", "intent": "This class serves files from the current `directory` and below , directly mapping the directory structure to HTTP requests . A lot of the work , such as parsing the `request` , is done by the base class BaseHTTPRequestHandler . With arguments `client_address`, `server`.", "question_id": 4660}
{"snippet": "simple_http_request_handler.server_version", "intent": "This will be \"SimpleHTTP/\" + __version__, where __version__ is defined at the module level.", "question_id": 4661}
{"snippet": "simple_http_request_handler.extensions_map", "intent": "A dictionary mapping suffixes into MIME types.", "question_id": 4662}
{"snippet": "simple_http_request_handler.directory", "intent": "If not specified, the directory to serve is the current working directory.", "question_id": 4663}
{"snippet": "simple_http_request_handler.do_HEAD()", "intent": "This method serves the 'HEAD ' request type : it sends the headers it would send for the equivalent GET request .", "question_id": 4664}
{"snippet": "simple_http_request_handler.do_GET()", "intent": "The request is mapped to a local file by interpreting the request as a path relative to the current working directory .", "question_id": 4665}
{"snippet": "http.server.CGIHTTPRequestHandler(request, client_address, server)", "intent": "This class is used to serve either files or output of CGI scripts from the current directory and below . The do_GET ( ) and do_HEAD ( ) functions are modified to run CGI scripts and serve the output , instead of serving files , if the `request` leads to somewhere below the cgi_directories path . Only directory-based CGI are used \u2014 the other common `server` configuration is to treat special extensions as denoting CGI scripts . With arguments `client_address`.", "question_id": 4666}
{"snippet": "cgihttp_request_handler.cgi_directories", "intent": "This defaults to ['/cgi-bin', '/htbin'] and describes directories to treat as containing CGI scripts.", "question_id": 4667}
{"snippet": "cgihttp_request_handler.do_POST()", "intent": "This method serves the 'POST ' request type , only allowed for CGI scripts .", "question_id": 4668}
{"snippet": "imaplib.IMAP4()", "intent": "This class implements the actual IMAP4 protocol .", "question_id": 4669}
{"snippet": "imaplib.IMAP4(host='')", "intent": "This class implements the actual IMAP4 protocol . If `host` is not specified , `` ( the local host ) is used .", "question_id": 4670}
{"snippet": "imaplib.IMAP4(port=IMAP4_PORT)", "intent": "This class implements the actual IMAP4 protocol . If `port` is omitted , the standard IMAP4 port ( 143 ) is used .", "question_id": 4671}
{"snippet": "imaplib.IMAP4(host='', port=IMAP4_PORT)", "intent": "This class implements the actual IMAP4 protocol . If `host` is not specified , `` ( the local host ) is used . If `port` is omitted , the standard IMAP4 port ( 143 ) is used .", "question_id": 4672}
{"snippet": "IMAP4.error", "intent": "Exception raised on any errors.", "question_id": 4673}
{"snippet": "IMAP4.abort", "intent": "IMAP4 server errors cause this exception to be raised.", "question_id": 4674}
{"snippet": "IMAP4.readonly", "intent": "This exception is raised when a writable mailbox has its status changed by the server.", "question_id": 4675}
{"snippet": "imaplib.IMAP4_SSL()", "intent": "This is a subclass derived from IMAP4 that connects over an SSL encrypted socket ( to use this class you need a socket module that was compiled with SSL support ) .", "question_id": 4676}
{"snippet": "imaplib.IMAP4_SSL(host='')", "intent": "This is a subclass derived from IMAP4 that connects over an SSL encrypted socket ( to use this class you need a socket module that was compiled with SSL support ) . If `host` is not specified , `` ( the local host ) is used .", "question_id": 4677}
{"snippet": "imaplib.IMAP4_SSL(port=IMAP4_SSL_PORT)", "intent": "This is a subclass derived from IMAP4 that connects over an SSL encrypted socket ( to use this class you need a socket module that was compiled with SSL support ) . If `port` is omitted , the standard IMAP4-over-SSL port ( 993 ) is used .", "question_id": 4678}
{"snippet": "imaplib.IMAP4_SSL(keyfile=None)", "intent": "This is a subclass derived from IMAP4 that connects over an SSL encrypted socket ( to use this class you need a socket module that was compiled with SSL support ) . `keyfile` and `certfile` are a legacy alternative to ssl_context - they can point to PEM-formatted private key and certificate chain files for the SSL connection .", "question_id": 4679}
{"snippet": "imaplib.IMAP4_SSL(certfile=None)", "intent": "This is a subclass derived from IMAP4 that connects over an SSL encrypted socket ( to use this class you need a socket module that was compiled with SSL support ) . `keyfile` and `certfile` are a legacy alternative to ssl_context - they can point to PEM-formatted private key and certificate chain files for the SSL connection .", "question_id": 4680}
{"snippet": "imaplib.IMAP4_SSL(ssl_context=None)", "intent": "This is a subclass derived from IMAP4 that connects over an SSL encrypted socket ( to use this class you need a socket module that was compiled with SSL support ) . `ssl_context` is a ssl.SSLContext object which allows bundling SSL configuration options , certificates and private keys into a single ( potentially long-lived ) structure .", "question_id": 4681}
{"snippet": "imaplib.IMAP4_SSL(host='', port=IMAP4_SSL_PORT)", "intent": "This is a subclass derived from IMAP4 that connects over an SSL encrypted socket ( to use this class you need a socket module that was compiled with SSL support ) . If `host` is not specified , `` ( the local host ) is used . If `port` is omitted , the standard IMAP4-over-SSL port ( 993 ) is used .", "question_id": 4682}
{"snippet": "imaplib.IMAP4_SSL(host='', keyfile=None)", "intent": "This is a subclass derived from IMAP4 that connects over an SSL encrypted socket ( to use this class you need a socket module that was compiled with SSL support ) . If `host` is not specified , `` ( the local host ) is used . `keyfile` and `certfile` are a legacy alternative to ssl_context - they can point to PEM-formatted private key and certificate chain files for the SSL connection .", "question_id": 4683}
{"snippet": "imaplib.IMAP4_SSL(host='', certfile=None)", "intent": "This is a subclass derived from IMAP4 that connects over an SSL encrypted socket ( to use this class you need a socket module that was compiled with SSL support ) . If `host` is not specified , `` ( the local host ) is used . `keyfile` and `certfile` are a legacy alternative to ssl_context - they can point to PEM-formatted private key and certificate chain files for the SSL connection .", "question_id": 4684}
{"snippet": "imaplib.IMAP4_SSL(host='', ssl_context=None)", "intent": "This is a subclass derived from IMAP4 that connects over an SSL encrypted socket ( to use this class you need a socket module that was compiled with SSL support ) . If `host` is not specified , `` ( the local host ) is used . `ssl_context` is a ssl.SSLContext object which allows bundling SSL configuration options , certificates and private keys into a single ( potentially long-lived ) structure .", "question_id": 4685}
{"snippet": "imaplib.IMAP4_stream(command)", "intent": "This is a subclass derived from IMAP4 that connects to the stdin/stdout file descriptors created by passing `command` to subprocess.Popen ( ) .", "question_id": 4686}
{"snippet": "imaplib.Internaldate2tuple(datestr)", "intent": "Parse an IMAP4 INTERNALDATE string and return corresponding local time . With arguments `datestr`.", "question_id": 4687}
{"snippet": "imaplib.Int2AP(num)", "intent": "Converts an integer into a string representation using characters from the set [ A .. P ] . With arguments `num`.", "question_id": 4688}
{"snippet": "imaplib.ParseFlags(flagstr)", "intent": "Converts an IMAP4 FLAGS response to a tuple of individual flags . With arguments `flagstr`.", "question_id": 4689}
{"snippet": "imaplib.Time2Internaldate(date_time)", "intent": "Convert `date_time` to an IMAP4 INTERNALDATE representation .", "question_id": 4690}
{"snippet": "IMAP4.append(mailbox, flags, date_time, message)", "intent": "Append `message` to named `mailbox` . With arguments `flags`, `date_time`.", "question_id": 4691}
{"snippet": "IMAP4.authenticate(mechanism, authobject)", "intent": "Authenticate command \u2014 requires response processing . `mechanism` specifies which authentication mechanism is to be used - it should appear in the instance variable capabilities in the form AUTH=mechanism . `authobject` must be a callable object :", "question_id": 4692}
{"snippet": "IMAP4.check()", "intent": "Checkpoint mailbox on server .", "question_id": 4693}
{"snippet": "IMAP4.close()", "intent": "Close currently selected mailbox .", "question_id": 4694}
{"snippet": "IMAP4.copy(message_set, new_mailbox)", "intent": "Copy `message_set` messages onto end of `new_mailbox` .", "question_id": 4695}
{"snippet": "IMAP4.create(mailbox)", "intent": "Create new `mailbox` named mailbox .", "question_id": 4696}
{"snippet": "IMAP4.delete(mailbox)", "intent": "Delete old `mailbox` named mailbox .", "question_id": 4697}
{"snippet": "IMAP4.deleteacl(mailbox, who)", "intent": "Delete the ACLs ( remove any rights ) set for `who` on `mailbox` .", "question_id": 4698}
{"snippet": "IMAP4.enable(capability)", "intent": "Enable `capability` ( see RFC 5161 ) .", "question_id": 4699}
{"snippet": "IMAP4.expunge()", "intent": "Permanently remove deleted items from selected mailbox .", "question_id": 4700}
{"snippet": "IMAP4.fetch(message_set, message_parts)", "intent": "Fetch ( parts of ) messages . `message_parts` should be a string of message part names enclosed within parentheses , eg : `` ( UID BODY [ TEXT ] ) '' . With arguments `message_set`.", "question_id": 4701}
{"snippet": "IMAP4.getacl(mailbox)", "intent": "Get the ACLs for `mailbox` .", "question_id": 4702}
{"snippet": "IMAP4.getannotation(mailbox, entry, attribute)", "intent": "Retrieve the specified ANNOTATIONs for `mailbox` . With arguments `entry`, `attribute`.", "question_id": 4703}
{"snippet": "IMAP4.getquota(root)", "intent": "Get the quota `root` \u2019 s resource usage and limits .", "question_id": 4704}
{"snippet": "IMAP4.getquotaroot(mailbox)", "intent": "Get the list of quota roots for the named `mailbox` .", "question_id": 4705}
{"snippet": "IMAP4.list(directory, pattern)", "intent": "List mailbox names in `directory` matching `pattern` .", "question_id": 4706}
{"snippet": "IMAP4.list(directory)", "intent": "List mailbox names in `directory` matching `pattern` .", "question_id": 4707}
{"snippet": "IMAP4.list()", "intent": "List mailbox names in `directory` matching `pattern` .", "question_id": 4708}
{"snippet": "IMAP4.login(user, password)", "intent": "Identify the client using a plaintext `password` . With arguments `user`.", "question_id": 4709}
{"snippet": "IMAP4.login_cram_md5(user, password)", "intent": "Force use of CRAM-MD5 authentication when identifying the client to protect the `password` . With arguments `user`.", "question_id": 4710}
{"snippet": "IMAP4.logout()", "intent": "Shutdown connection to server .", "question_id": 4711}
{"snippet": "IMAP4.lsub()", "intent": "List subscribed mailbox names in `directory` matching `pattern` .", "question_id": 4712}
{"snippet": "IMAP4.lsub(directory='\"\"')", "intent": "List subscribed mailbox names in `directory` matching `pattern` .", "question_id": 4713}
{"snippet": "IMAP4.lsub(pattern='*')", "intent": "List subscribed mailbox names in `directory` matching `pattern` .", "question_id": 4714}
{"snippet": "IMAP4.lsub(directory='\"\"', pattern='*')", "intent": "List subscribed mailbox names in `directory` matching `pattern` .", "question_id": 4715}
{"snippet": "IMAP4.myrights(mailbox)", "intent": "Show my ACLs for a `mailbox` ( i.e .", "question_id": 4716}
{"snippet": "IMAP4.namespace()", "intent": "Returns IMAP namespaces as defined in RFC 2342 .", "question_id": 4717}
{"snippet": "IMAP4.noop()", "intent": "Send NOOP to server .", "question_id": 4718}
{"snippet": "IMAP4.open(host, port)", "intent": "Opens socket to `port` at `host` .", "question_id": 4719}
{"snippet": "IMAP4.partial(message_num, message_part, start, length)", "intent": "Fetch truncated part of a message . With arguments `message_num`, `message_part`, `start`, `length`.", "question_id": 4720}
{"snippet": "IMAP4.proxyauth(user)", "intent": "Assume authentication as `user` .", "question_id": 4721}
{"snippet": "IMAP4.read(size)", "intent": "Reads `size` bytes from the remote server .", "question_id": 4722}
{"snippet": "IMAP4.readline()", "intent": "Reads one line from the remote server .", "question_id": 4723}
{"snippet": "IMAP4.recent()", "intent": "Prompt server for an update .", "question_id": 4724}
{"snippet": "IMAP4.rename(oldmailbox, newmailbox)", "intent": "Rename mailbox named `oldmailbox` to `newmailbox` .", "question_id": 4725}
{"snippet": "IMAP4.response(code)", "intent": "Return data for response `code` if received , or None .", "question_id": 4726}
{"snippet": "IMAP4.search(charset, criterion)", "intent": "Search mailbox for matching messages . `charset` may be None , in which case no CHARSET will be specified in the request to the server . The IMAP protocol requires that at least one `criterion` be specified ; an exception will be raised when the server returns an error .", "question_id": 4727}
{"snippet": "IMAP4.search(charset)", "intent": "Search mailbox for matching messages . `charset` may be None , in which case no CHARSET will be specified in the request to the server .", "question_id": 4728}
{"snippet": "IMAP4.select()", "intent": "Select a `mailbox` .", "question_id": 4729}
{"snippet": "IMAP4.select(mailbox='INBOX')", "intent": "Select a `mailbox` .", "question_id": 4730}
{"snippet": "IMAP4.select(readonly=False)", "intent": "Select a `mailbox` . If the `readonly` flag is set , modifications to the mailbox are not allowed .", "question_id": 4731}
{"snippet": "IMAP4.select(mailbox='INBOX', readonly=False)", "intent": "Select a `mailbox` . If the `readonly` flag is set , modifications to the mailbox are not allowed .", "question_id": 4732}
{"snippet": "IMAP4.send(data)", "intent": "Sends `data` to the remote server .", "question_id": 4733}
{"snippet": "IMAP4.setacl(mailbox, who, what)", "intent": "Set an ACL for `mailbox` . With arguments `who`, `what`.", "question_id": 4734}
{"snippet": "IMAP4.setannotation(mailbox, entry, attribute)", "intent": "Set ANNOTATIONs for `mailbox` . With arguments `entry`, `attribute`.", "question_id": 4735}
{"snippet": "IMAP4.setannotation(mailbox, entry)", "intent": "Set ANNOTATIONs for `mailbox` . With arguments `entry`.", "question_id": 4736}
{"snippet": "IMAP4.setquota(root, limits)", "intent": "Set the quota `root` \u2019 s resource `limits` .", "question_id": 4737}
{"snippet": "IMAP4.shutdown()", "intent": "Close connection established in open .", "question_id": 4738}
{"snippet": "IMAP4.socket()", "intent": "Returns socket instance used to connect to server .", "question_id": 4739}
{"snippet": "IMAP4.sort(sort_criteria, charset, search_criterion)", "intent": "The sort command is a variant of search with sorting semantics for the results . Sort has two arguments before the `search_criterion` argument ( s ) ; a parenthesized list of `sort_criteria` , and the searching `charset` .", "question_id": 4740}
{"snippet": "IMAP4.sort(sort_criteria, charset)", "intent": "The sort command is a variant of search with sorting semantics for the results . Sort has two arguments before the `search_criterion` argument ( s ) ; a parenthesized list of `sort_criteria` , and the searching `charset` .", "question_id": 4741}
{"snippet": "IMAP4.starttls()", "intent": "Send a STARTTLS command .", "question_id": 4742}
{"snippet": "IMAP4.starttls(ssl_context=None)", "intent": "Send a STARTTLS command . The `ssl_context` argument is optional and should be a ssl.SSLContext object .", "question_id": 4743}
{"snippet": "IMAP4.status(mailbox, names)", "intent": "Request named status conditions for `mailbox` . With arguments `names`.", "question_id": 4744}
{"snippet": "IMAP4.store(message_set, command, flag_list)", "intent": "Alters flag dispositions for messages in mailbox . `command` is specified by section 6.4.6 of RFC 2060 as being one of \u201c FLAGS \u201d , \u201c +FLAGS \u201d , or \u201c -FLAGS \u201d , optionally with a suffix of \u201c .SILENT \u201d . With arguments `message_set`, `flag_list`.", "question_id": 4745}
{"snippet": "IMAP4.subscribe(mailbox)", "intent": "Subscribe to new `mailbox` .", "question_id": 4746}
{"snippet": "IMAP4.thread(threading_algorithm, charset, search_criterion)", "intent": "The thread command is a variant of search with threading semantics for the results . Thread has two arguments before the `search_criterion` argument ( s ) ; a `threading_algorithm` , and the searching `charset` .", "question_id": 4747}
{"snippet": "IMAP4.thread(threading_algorithm, charset)", "intent": "The thread command is a variant of search with threading semantics for the results . Thread has two arguments before the `search_criterion` argument ( s ) ; a `threading_algorithm` , and the searching `charset` .", "question_id": 4748}
{"snippet": "IMAP4.uid(command, arg)", "intent": "Execute `command` args with messages identified by UID , rather than message number . With arguments `arg`.", "question_id": 4749}
{"snippet": "IMAP4.uid(command)", "intent": "Execute `command` args with messages identified by UID , rather than message number .", "question_id": 4750}
{"snippet": "IMAP4.unsubscribe(mailbox)", "intent": "Unsubscribe from old `mailbox` .", "question_id": 4751}
{"snippet": "IMAP4.xatom(name)", "intent": "Allow simple extension commands notified by server in CAPABILITY response . With arguments `name`.", "question_id": 4752}
{"snippet": "IMAP4.xatom()", "intent": "Allow simple extension commands notified by server in CAPABILITY response .", "question_id": 4753}
{"snippet": "IMAP4.PROTOCOL_VERSION", "intent": "The most recent supported protocol in the CAPABILITY response from the server.", "question_id": 4754}
{"snippet": "IMAP4.debug", "intent": "Integer value to control debugging output.", "question_id": 4755}
{"snippet": "IMAP4.utf8_enabled", "intent": "Boolean value that is normally False, but is set to True if an enable() command is successfully issued for the UTF8=ACCEPT capability.", "question_id": 4756}
{"snippet": "imghdr.what(filename)", "intent": "Tests the image data contained in the file named by `filename` , and returns a string describing the image type .", "question_id": 4757}
{"snippet": "imghdr.what(filename, h=None)", "intent": "Tests the image data contained in the file named by `filename` , and returns a string describing the image type . If optional `h` is provided , the filename is ignored and h is assumed to contain the byte stream to test .", "question_id": 4758}
{"snippet": "imghdr.tests", "intent": "A list of functions performing the individual tests.", "question_id": 4759}
{"snippet": "imp.get_magic()", "intent": "Return the magic string value used to recognize byte-compiled code files ( .pyc files ) .", "question_id": 4760}
{"snippet": "imp.get_suffixes()", "intent": "Return a list of 3-element tuples , each describing a particular type of module .", "question_id": 4761}
{"snippet": "imp.find_module(name, path)", "intent": "Try to find the module `name` . If `path` is omitted or None , the list of directory names given by sys.path is searched , but first a few special places are searched : the function tries to find a built-in module with the given name ( C_BUILTIN ) , then a frozen module ( PY_FROZEN ) , and on some systems some other places are looked in as well ( on Windows , it looks in the registry which may point to a specific file ) .", "question_id": 4762}
{"snippet": "imp.find_module(name)", "intent": "Try to find the module `name` .", "question_id": 4763}
{"snippet": "imp.load_module(name, file, pathname, description)", "intent": "Load a module that was previously found by find_module ( ) ( or by an otherwise conducted search yielding compatible results ) . The `name` argument indicates the full module name ( including the package name , if this is a submodule of a package ) . The `file` argument is an open file , and `pathname` is the corresponding file name ; these can be None and `` , respectively , when the module is a package or not being loaded from a file . The `description` argument is a tuple , as would be returned by get_suffixes ( ) , describing what kind of module must be loaded .", "question_id": 4764}
{"snippet": "imp.new_module(name)", "intent": "Return a new empty module object called `name` .", "question_id": 4765}
{"snippet": "imp.reload(module)", "intent": "Reload a previously imported `module` .", "question_id": 4766}
{"snippet": "imp.cache_from_source(path)", "intent": "Return the PEP 3147 `path` to the byte-compiled file associated with the source path .", "question_id": 4767}
{"snippet": "imp.cache_from_source(path, debug_override=None)", "intent": "Return the PEP 3147 `path` to the byte-compiled file associated with the source path . By passing in True or False for `debug_override` you can override the system \u2019 s value for __debug__ , leading to optimized bytecode .", "question_id": 4768}
{"snippet": "imp.source_from_cache(path)", "intent": "Given the `path` to a PEP 3147 file name , return the associated source code file path .", "question_id": 4769}
{"snippet": "imp.get_tag()", "intent": "Return the PEP 3147 magic tag string matching this version of Python \u2019 s magic number , as returned by get_magic ( ) .", "question_id": 4770}
{"snippet": "imp.lock_held()", "intent": "Return True if the global import lock is currently held , else False .", "question_id": 4771}
{"snippet": "imp.acquire_lock()", "intent": "Acquire the interpreter \u2019 s global import lock for the current thread .", "question_id": 4772}
{"snippet": "imp.release_lock()", "intent": "Release the interpreter \u2019 s global import lock .", "question_id": 4773}
{"snippet": "imp.PY_SOURCE", "intent": "The module was found as a source file.", "question_id": 4774}
{"snippet": "imp.PY_COMPILED", "intent": "The module was found as a compiled code object file.", "question_id": 4775}
{"snippet": "imp.C_EXTENSION", "intent": "The module was found as dynamically loadable shared library.", "question_id": 4776}
{"snippet": "imp.PKG_DIRECTORY", "intent": "The module was found as a package directory.", "question_id": 4777}
{"snippet": "imp.C_BUILTIN", "intent": "The module was found as a built-in module.", "question_id": 4778}
{"snippet": "imp.PY_FROZEN", "intent": "The module was found as a frozen module.", "question_id": 4779}
{"snippet": "imp.NullImporter(path_string)", "intent": "The NullImporter type is a PEP 302 import hook that handles non-directory path strings by failing to find any modules . With arguments `path_string`.", "question_id": 4780}
{"snippet": "null_importer.find_module(fullname, path)", "intent": "This method always returns None , indicating that the requested module could not be found . With arguments `fullname`, `path`.", "question_id": 4781}
{"snippet": "null_importer.find_module(fullname)", "intent": "This method always returns None , indicating that the requested module could not be found . With arguments `fullname`.", "question_id": 4782}
{"snippet": "importlib.__import__(name)", "intent": "An implementation of the built-in __import__ ( ) function . With arguments `name`.", "question_id": 4783}
{"snippet": "importlib.__import__(name, globals=None)", "intent": "An implementation of the built-in __import__ ( ) function . With arguments `name`, `globals`.", "question_id": 4784}
{"snippet": "importlib.__import__(name, locals=None)", "intent": "An implementation of the built-in __import__ ( ) function . With arguments `name`, `locals`.", "question_id": 4785}
{"snippet": "importlib.__import__(name, fromlist=())", "intent": "An implementation of the built-in __import__ ( ) function . With arguments `name`, `fromlist`.", "question_id": 4786}
{"snippet": "importlib.__import__(name, level=0)", "intent": "An implementation of the built-in __import__ ( ) function . With arguments `name`, `level`.", "question_id": 4787}
{"snippet": "importlib.__import__(name, globals=None, locals=None)", "intent": "An implementation of the built-in __import__ ( ) function . With arguments `name`, `globals`, `locals`.", "question_id": 4788}
{"snippet": "importlib.__import__(name, globals=None, fromlist=())", "intent": "An implementation of the built-in __import__ ( ) function . With arguments `name`, `globals`, `fromlist`.", "question_id": 4789}
{"snippet": "importlib.__import__(name, globals=None, level=0)", "intent": "An implementation of the built-in __import__ ( ) function . With arguments `name`, `globals`, `level`.", "question_id": 4790}
{"snippet": "importlib.__import__(name, locals=None, fromlist=())", "intent": "An implementation of the built-in __import__ ( ) function . With arguments `name`, `locals`, `fromlist`.", "question_id": 4791}
{"snippet": "importlib.__import__(name, locals=None, level=0)", "intent": "An implementation of the built-in __import__ ( ) function . With arguments `name`, `locals`, `level`.", "question_id": 4792}
{"snippet": "importlib.import_module(name)", "intent": "Import a module . The `name` argument specifies what module to import in absolute or relative terms ( e.g .", "question_id": 4793}
{"snippet": "importlib.import_module(name, package=None)", "intent": "Import a module . The `name` argument specifies what module to import in absolute or relative terms ( e.g . If the name is specified in relative terms , then the `package` argument must be set to the name of the package which is to act as the anchor for resolving the package name ( e.g .", "question_id": 4794}
{"snippet": "importlib.find_loader(name)", "intent": "Find the loader for a module , optionally within the specified `path` . If the module is in sys.modules , then sys.modules [ `name` ] .__loader__ is returned ( unless the loader would be None or is not set , in which case ValueError is raised ) .", "question_id": 4795}
{"snippet": "importlib.find_loader(name, path=None)", "intent": "Find the loader for a module , optionally within the specified `path` . If the module is in sys.modules , then sys.modules [ `name` ] .__loader__ is returned ( unless the loader would be None or is not set , in which case ValueError is raised ) .", "question_id": 4796}
{"snippet": "importlib.invalidate_caches()", "intent": "Invalidate the internal caches of finders stored at sys.meta_path .", "question_id": 4797}
{"snippet": "importlib.reload(module)", "intent": "Reload a previously imported `module` .", "question_id": 4798}
{"snippet": "importlib.abc.Finder", "intent": "An abstract base class representing a finder.", "question_id": 4799}
{"snippet": "finder.find_module(fullname)", "intent": "An abstract method for finding a loader for the specified module . With arguments `fullname`.", "question_id": 4800}
{"snippet": "finder.find_module(fullname, path=None)", "intent": "An abstract method for finding a loader for the specified module . With arguments `fullname`, `path`.", "question_id": 4801}
{"snippet": "importlib.abc.MetaPathFinder", "intent": "An abstract base class representing a meta path finder.", "question_id": 4802}
{"snippet": "meta_path_finder.find_spec(fullname, path)", "intent": "An abstract method for finding a spec for the specified module . If this is a top-level import , `path` will be None . With arguments `fullname`.", "question_id": 4803}
{"snippet": "meta_path_finder.find_spec(fullname, path, target=None)", "intent": "An abstract method for finding a spec for the specified module . If this is a top-level import , `path` will be None . When passed in , `target` is a module object that the finder may use to make a more educated guess about what spec to return . With arguments `fullname`.", "question_id": 4804}
{"snippet": "meta_path_finder.find_module(fullname, path)", "intent": "A legacy method for finding a loader for the specified module . If this is a top-level import , `path` will be None . With arguments `fullname`.", "question_id": 4805}
{"snippet": "meta_path_finder.invalidate_caches()", "intent": "An optional method which , when called , should invalidate any internal cache used by the finder .", "question_id": 4806}
{"snippet": "importlib.abc.PathEntryFinder", "intent": "An abstract base class representing a path entry finder.", "question_id": 4807}
{"snippet": "path_entry_finder.find_spec(fullname)", "intent": "An abstract method for finding a spec for the specified module . With arguments `fullname`.", "question_id": 4808}
{"snippet": "path_entry_finder.find_spec(fullname, target=None)", "intent": "An abstract method for finding a spec for the specified module . When passed in , `target` is a module object that the finder may use to make a more educated guess about what spec to return . With arguments `fullname`.", "question_id": 4809}
{"snippet": "path_entry_finder.find_loader(fullname)", "intent": "A legacy method for finding a loader for the specified module . With arguments `fullname`.", "question_id": 4810}
{"snippet": "path_entry_finder.find_module(fullname)", "intent": "A concrete implementation of Finder.find_module ( ) which is equivalent to self.find_loader ( `fullname` ) [ 0 ] .", "question_id": 4811}
{"snippet": "path_entry_finder.invalidate_caches()", "intent": "An optional method which , when called , should invalidate any internal cache used by the finder .", "question_id": 4812}
{"snippet": "importlib.abc.Loader", "intent": "An abstract base class for a loader.", "question_id": 4813}
{"snippet": "loader.create_module(spec)", "intent": "A method that returns the module object to use when importing a module . With arguments `spec`.", "question_id": 4814}
{"snippet": "loader.exec_module(module)", "intent": "An abstract method that executes the `module` in its own namespace when a module is imported or reloaded .", "question_id": 4815}
{"snippet": "loader.load_module(fullname)", "intent": "A legacy method for loading a module . With arguments `fullname`.", "question_id": 4816}
{"snippet": "loader.module_repr(module)", "intent": "A legacy method which when implemented calculates and returns the given `module` \u2019 s repr , as a string .", "question_id": 4817}
{"snippet": "importlib.abc.ResourceReader", "intent": "An abstract base class to provide the ability to read resources.", "question_id": 4818}
{"snippet": "resource_reader.open_resource(resource)", "intent": "Returns an opened , file-like object for binary reading of the `resource` .", "question_id": 4819}
{"snippet": "resource_reader.resource_path(resource)", "intent": "Returns the file system path to the `resource` .", "question_id": 4820}
{"snippet": "resource_reader.is_resource(name)", "intent": "Returns True if the named `name` is considered a resource .", "question_id": 4821}
{"snippet": "resource_reader.contents()", "intent": "Returns an iterable of strings over the contents of the package .", "question_id": 4822}
{"snippet": "importlib.abc.ResourceLoader", "intent": "An abstract base class for a loader which implements the optional PEP 302 protocol for loading arbitrary resources from the storage back-end.", "question_id": 4823}
{"snippet": "resource_loader.get_data(path)", "intent": "An abstract method to return the bytes for the data located at `path` .", "question_id": 4824}
{"snippet": "importlib.abc.InspectLoader", "intent": "An abstract base class for a loader which implements the optional PEP 302 protocol for loaders that inspect modules.", "question_id": 4825}
{"snippet": "inspect_loader.get_code(fullname)", "intent": "Return the code object for a module , or None if the module does not have a code object ( as would be the case , for example , for a built-in module ) . With arguments `fullname`.", "question_id": 4826}
{"snippet": "inspect_loader.get_source(fullname)", "intent": "An abstract method to return the source of a module . With arguments `fullname`.", "question_id": 4827}
{"snippet": "inspect_loader.is_package(fullname)", "intent": "An abstract method to return a true value if the module is a package , a false value otherwise . With arguments `fullname`.", "question_id": 4828}
{"snippet": "inspect_loader.source_to_code(data)", "intent": "Create a code object from Python source . The `data` argument can be whatever the compile ( ) function supports ( i.e .", "question_id": 4829}
{"snippet": "inspect_loader.source_to_code(data, path='<string>')", "intent": "Create a code object from Python source . The `data` argument can be whatever the compile ( ) function supports ( i.e . The `path` argument should be the \u201c path \u201d to where the source code originated from , which can be an abstract concept ( e.g .", "question_id": 4830}
{"snippet": "inspect_loader.exec_module(module)", "intent": "Implementation of Loader.exec_module ( ) . With arguments `module`.", "question_id": 4831}
{"snippet": "inspect_loader.load_module(fullname)", "intent": "Implementation of Loader.load_module ( ) . With arguments `fullname`.", "question_id": 4832}
{"snippet": "importlib.abc.ExecutionLoader", "intent": "An abstract base class which inherits from InspectLoader that, when implemented, helps a module to be executed as a script.", "question_id": 4833}
{"snippet": "execution_loader.get_filename(fullname)", "intent": "An abstract method that is to return the value of __file__ for the specified module . With arguments `fullname`.", "question_id": 4834}
{"snippet": "importlib.abc.FileLoader(fullname, path)", "intent": "An abstract base class which inherits from ResourceLoader and ExecutionLoader , providing concrete implementations of ResourceLoader.get_data ( ) and ExecutionLoader.get_filename ( ) . The `fullname` argument is a fully resolved name of the module the loader is to handle . The `path` argument is the path to the file for the module .", "question_id": 4835}
{"snippet": "file_loader.name", "intent": "The name of the module the loader can handle.", "question_id": 4836}
{"snippet": "file_loader.path", "intent": "Path to the file of the module.", "question_id": 4837}
{"snippet": "file_loader.load_module(fullname)", "intent": "Calls super \u2019 s load_module ( ) . With arguments `fullname`.", "question_id": 4838}
{"snippet": "file_loader.get_filename(fullname)", "intent": "Returns path . With arguments `fullname`.", "question_id": 4839}
{"snippet": "file_loader.get_data(path)", "intent": "Reads `path` as a binary file and returns the bytes from it .", "question_id": 4840}
{"snippet": "importlib.abc.SourceLoader", "intent": "An abstract base class for implementing source (and optionally bytecode) file loading.", "question_id": 4841}
{"snippet": "source_loader.path_stats(path)", "intent": "Optional abstract method which returns a dict containing metadata about the specified `path` .", "question_id": 4842}
{"snippet": "source_loader.path_mtime(path)", "intent": "Optional abstract method which returns the modification time for the specified `path` .", "question_id": 4843}
{"snippet": "source_loader.set_data(path, data)", "intent": "Optional abstract method which writes the specified bytes to a file `path` . With arguments `data`.", "question_id": 4844}
{"snippet": "source_loader.get_code(fullname)", "intent": "Concrete implementation of InspectLoader.get_code ( ) . With arguments `fullname`.", "question_id": 4845}
{"snippet": "source_loader.exec_module(module)", "intent": "Concrete implementation of Loader.exec_module ( ) . With arguments `module`.", "question_id": 4846}
{"snippet": "source_loader.load_module(fullname)", "intent": "Concrete implementation of Loader.load_module ( ) . With arguments `fullname`.", "question_id": 4847}
{"snippet": "source_loader.get_source(fullname)", "intent": "Concrete implementation of InspectLoader.get_source ( ) . With arguments `fullname`.", "question_id": 4848}
{"snippet": "source_loader.is_package(fullname)", "intent": "Concrete implementation of InspectLoader.is_package ( ) . With arguments `fullname`.", "question_id": 4849}
{"snippet": "importlib.resources.Package", "intent": "The Package type is defined as Union[str, ModuleType].", "question_id": 4850}
{"snippet": "importlib.resources.Resource", "intent": "This type describes the resource names passed into the various functions in this package.", "question_id": 4851}
{"snippet": "importlib.resources.open_binary(package, resource)", "intent": "Open for binary reading the `resource` within `package` .", "question_id": 4852}
{"snippet": "importlib.resources.open_text(package, resource)", "intent": "Open for text reading the `resource` within `package` .", "question_id": 4853}
{"snippet": "importlib.resources.open_text(package, resource, encoding='utf-8')", "intent": "Open for text reading the `resource` within `package` . `encoding` and `errors` have the same meaning as with built-in open ( ) .", "question_id": 4854}
{"snippet": "importlib.resources.open_text(package, resource, errors='strict')", "intent": "Open for text reading the `resource` within `package` . `encoding` and `errors` have the same meaning as with built-in open ( ) .", "question_id": 4855}
{"snippet": "importlib.resources.open_text(package, resource, encoding='utf-8', errors='strict')", "intent": "Open for text reading the `resource` within `package` . `encoding` and `errors` have the same meaning as with built-in open ( ) .", "question_id": 4856}
{"snippet": "importlib.resources.read_binary(package, resource)", "intent": "Read and return the contents of the `resource` within `package` as bytes .", "question_id": 4857}
{"snippet": "importlib.resources.read_text(package, resource)", "intent": "Read and return the contents of `resource` within `package` as a str .", "question_id": 4858}
{"snippet": "importlib.resources.read_text(package, resource, encoding='utf-8')", "intent": "Read and return the contents of `resource` within `package` as a str . `encoding` and `errors` have the same meaning as with built-in open ( ) .", "question_id": 4859}
{"snippet": "importlib.resources.read_text(package, resource, errors='strict')", "intent": "Read and return the contents of `resource` within `package` as a str . `encoding` and `errors` have the same meaning as with built-in open ( ) .", "question_id": 4860}
{"snippet": "importlib.resources.read_text(package, resource, encoding='utf-8', errors='strict')", "intent": "Read and return the contents of `resource` within `package` as a str . `encoding` and `errors` have the same meaning as with built-in open ( ) .", "question_id": 4861}
{"snippet": "importlib.resources.path(package, resource)", "intent": "Return the path to the `resource` as an actual file system path . `package` is either a name or a module object which conforms to the Package requirements .", "question_id": 4862}
{"snippet": "importlib.resources.is_resource(package, name)", "intent": "Return True if there is a resource named `name` in the `package` , otherwise False .", "question_id": 4863}
{"snippet": "importlib.resources.contents(package)", "intent": "Return an iterable over the named items within the `package` .", "question_id": 4864}
{"snippet": "importlib.machinery.SOURCE_SUFFIXES", "intent": "A list of strings representing the recognized file suffixes for source modules.", "question_id": 4865}
{"snippet": "importlib.machinery.DEBUG_BYTECODE_SUFFIXES", "intent": "A list of strings representing the file suffixes for non-optimized bytecode modules.", "question_id": 4866}
{"snippet": "importlib.machinery.OPTIMIZED_BYTECODE_SUFFIXES", "intent": "A list of strings representing the file suffixes for optimized bytecode modules.", "question_id": 4867}
{"snippet": "importlib.machinery.BYTECODE_SUFFIXES", "intent": "A list of strings representing the recognized file suffixes for bytecode modules (including the leading dot).", "question_id": 4868}
{"snippet": "importlib.machinery.EXTENSION_SUFFIXES", "intent": "A list of strings representing the recognized file suffixes for extension modules.", "question_id": 4869}
{"snippet": "importlib.machinery.all_suffixes()", "intent": "Returns a combined list of strings representing all file suffixes for modules recognized by the standard import machinery .", "question_id": 4870}
{"snippet": "importlib.machinery.BuiltinImporter", "intent": "An importer for built-in modules.", "question_id": 4871}
{"snippet": "importlib.machinery.FrozenImporter", "intent": "An importer for frozen modules.", "question_id": 4872}
{"snippet": "importlib.machinery.WindowsRegistryFinder", "intent": "Finder for modules declared in the Windows registry.", "question_id": 4873}
{"snippet": "importlib.machinery.PathFinder", "intent": "A Finder for sys.path and package __path__ attributes.", "question_id": 4874}
{"snippet": "path_finder.find_spec(fullname)", "intent": "Class method that attempts to find a spec for the module specified by `fullname` on sys.path or , if defined , on `path` .", "question_id": 4875}
{"snippet": "path_finder.find_spec(fullname, path=None)", "intent": "Class method that attempts to find a spec for the module specified by `fullname` on sys.path or , if defined , on `path` .", "question_id": 4876}
{"snippet": "path_finder.find_spec(fullname, target=None)", "intent": "Class method that attempts to find a spec for the module specified by `fullname` on sys.path or , if defined , on `path` . With arguments `target`.", "question_id": 4877}
{"snippet": "path_finder.find_spec(fullname, path=None, target=None)", "intent": "Class method that attempts to find a spec for the module specified by `fullname` on sys.path or , if defined , on `path` . With arguments `target`.", "question_id": 4878}
{"snippet": "path_finder.find_module(fullname)", "intent": "A legacy wrapper around find_spec ( ) . With arguments `fullname`.", "question_id": 4879}
{"snippet": "path_finder.find_module(fullname, path=None)", "intent": "A legacy wrapper around find_spec ( ) . With arguments `fullname`, `path`.", "question_id": 4880}
{"snippet": "path_finder.invalidate_caches()", "intent": "Calls importlib.abc.PathEntryFinder.invalidate_caches ( ) on all finders stored in sys.path_importer_cache that define the method .", "question_id": 4881}
{"snippet": "importlib.machinery.FileFinder(path, *loader_details)", "intent": "A concrete implementation of importlib.abc.PathEntryFinder which caches results from the file system . The `path` argument is the directory for which the finder is in charge of searching . With arguments `*loader_details`.", "question_id": 4882}
{"snippet": "file_finder.path", "intent": "The path the finder will search in.", "question_id": 4883}
{"snippet": "file_finder.find_spec(fullname)", "intent": "Attempt to find the spec to handle `fullname` within path .", "question_id": 4884}
{"snippet": "file_finder.find_spec(fullname, target=None)", "intent": "Attempt to find the spec to handle `fullname` within path . With arguments `target`.", "question_id": 4885}
{"snippet": "file_finder.find_loader(fullname)", "intent": "Attempt to find the loader to handle `fullname` within path .", "question_id": 4886}
{"snippet": "file_finder.invalidate_caches()", "intent": "Clear out the internal cache .", "question_id": 4887}
{"snippet": "file_finder.path_hook(*loader_details)", "intent": "A class method which returns a closure for use on sys.path_hooks . With arguments `*loader_details`.", "question_id": 4888}
{"snippet": "importlib.machinery.SourceFileLoader(fullname, path)", "intent": "A concrete implementation of importlib.abc.SourceLoader by subclassing importlib.abc.FileLoader and providing some concrete implementations of other methods . With arguments `fullname`, `path`.", "question_id": 4889}
{"snippet": "source_file_loader.name", "intent": "The name of the module that this loader will handle.", "question_id": 4890}
{"snippet": "source_file_loader.path", "intent": "The path to the source file.", "question_id": 4891}
{"snippet": "source_file_loader.is_package(fullname)", "intent": "Return true if path appears to be for a package . With arguments `fullname`.", "question_id": 4892}
{"snippet": "source_file_loader.path_stats(path)", "intent": "Concrete implementation of importlib.abc.SourceLoader.path_stats ( ) . With arguments `path`.", "question_id": 4893}
{"snippet": "source_file_loader.set_data(path, data)", "intent": "Concrete implementation of importlib.abc.SourceLoader.set_data ( ) . With arguments `path`, `data`.", "question_id": 4894}
{"snippet": "source_file_loader.load_module()", "intent": "Concrete implementation of importlib.abc.Loader.load_module ( ) where specifying the `name` of the module to load is optional .", "question_id": 4895}
{"snippet": "source_file_loader.load_module(name=None)", "intent": "Concrete implementation of importlib.abc.Loader.load_module ( ) where specifying the `name` of the module to load is optional .", "question_id": 4896}
{"snippet": "importlib.machinery.SourcelessFileLoader(fullname, path)", "intent": "A concrete implementation of importlib.abc.FileLoader which can import bytecode files ( i.e . With arguments `fullname`, `path`.", "question_id": 4897}
{"snippet": "sourceless_file_loader.name", "intent": "The name of the module the loader will handle.", "question_id": 4898}
{"snippet": "sourceless_file_loader.path", "intent": "The path to the bytecode file.", "question_id": 4899}
{"snippet": "sourceless_file_loader.is_package(fullname)", "intent": "Determines if the module is a package based on path . With arguments `fullname`.", "question_id": 4900}
{"snippet": "sourceless_file_loader.get_code(fullname)", "intent": "Returns the code object for name created from path . With arguments `fullname`.", "question_id": 4901}
{"snippet": "sourceless_file_loader.get_source(fullname)", "intent": "Returns None as bytecode files have no source when this loader is used . With arguments `fullname`.", "question_id": 4902}
{"snippet": "importlib.machinery.ExtensionFileLoader(fullname, path)", "intent": "A concrete implementation of importlib.abc.ExecutionLoader for extension modules . The `fullname` argument specifies the name of the module the loader is to support . The `path` argument is the path to the extension module \u2019 s file .", "question_id": 4903}
{"snippet": "extension_file_loader.name", "intent": "Name of the module the loader supports.", "question_id": 4904}
{"snippet": "extension_file_loader.path", "intent": "Path to the extension module.", "question_id": 4905}
{"snippet": "extension_file_loader.create_module(spec)", "intent": "Creates the module object from the given specification in accordance with PEP 489 . With arguments `spec`.", "question_id": 4906}
{"snippet": "extension_file_loader.exec_module(module)", "intent": "Initializes the given `module` object in accordance with PEP 489 .", "question_id": 4907}
{"snippet": "extension_file_loader.is_package(fullname)", "intent": "Returns True if the file path points to a package \u2019 s __init__ module based on EXTENSION_SUFFIXES . With arguments `fullname`.", "question_id": 4908}
{"snippet": "extension_file_loader.get_code(fullname)", "intent": "Returns None as extension modules lack a code object . With arguments `fullname`.", "question_id": 4909}
{"snippet": "extension_file_loader.get_source(fullname)", "intent": "Returns None as extension modules do not have source code . With arguments `fullname`.", "question_id": 4910}
{"snippet": "extension_file_loader.get_filename(fullname)", "intent": "Returns path . With arguments `fullname`.", "question_id": 4911}
{"snippet": "importlib.machinery.ModuleSpec(name, loader)", "intent": "A specification for a module \u2019 s import-system-related state . A string for the fully-qualified `name` of the module . The `loader` to use for loading .", "question_id": 4912}
{"snippet": "importlib.machinery.ModuleSpec(name, loader, origin=None)", "intent": "A specification for a module \u2019 s import-system-related state . A string for the fully-qualified `name` of the module . The `loader` to use for loading . Normally \u201c `origin` \u201d should be set , but it may be None ( the default ) which indicates it is unspecified ( e.g .", "question_id": 4913}
{"snippet": "importlib.machinery.ModuleSpec(name, loader, loader_state=None)", "intent": "A specification for a module \u2019 s import-system-related state . A string for the fully-qualified `name` of the module . The `loader` to use for loading . With arguments `loader_state`.", "question_id": 4914}
{"snippet": "importlib.machinery.ModuleSpec(name, loader, is_package=None)", "intent": "A specification for a module \u2019 s import-system-related state . A string for the fully-qualified `name` of the module . The `loader` to use for loading . With arguments `is_package`.", "question_id": 4915}
{"snippet": "importlib.machinery.ModuleSpec(name, loader, origin=None, loader_state=None)", "intent": "A specification for a module \u2019 s import-system-related state . A string for the fully-qualified `name` of the module . The `loader` to use for loading . Normally \u201c `origin` \u201d should be set , but it may be None ( the default ) which indicates it is unspecified ( e.g . With arguments `loader_state`.", "question_id": 4916}
{"snippet": "importlib.machinery.ModuleSpec(name, loader, origin=None, is_package=None)", "intent": "A specification for a module \u2019 s import-system-related state . A string for the fully-qualified `name` of the module . The `loader` to use for loading . Normally \u201c `origin` \u201d should be set , but it may be None ( the default ) which indicates it is unspecified ( e.g . With arguments `is_package`.", "question_id": 4917}
{"snippet": "importlib.machinery.ModuleSpec(name, loader, loader_state=None, is_package=None)", "intent": "A specification for a module \u2019 s import-system-related state . A string for the fully-qualified `name` of the module . The `loader` to use for loading . With arguments `loader_state`, `is_package`.", "question_id": 4918}
{"snippet": "importlib.machinery.ModuleSpec(name, loader, origin=None, loader_state=None, is_package=None)", "intent": "A specification for a module \u2019 s import-system-related state . A string for the fully-qualified `name` of the module . The `loader` to use for loading . Normally \u201c `origin` \u201d should be set , but it may be None ( the default ) which indicates it is unspecified ( e.g . With arguments `loader_state`, `is_package`.", "question_id": 4919}
{"snippet": "importlib.util.MAGIC_NUMBER", "intent": "The bytes which represent the bytecode version number.", "question_id": 4920}
{"snippet": "importlib.util.cache_from_source(path)", "intent": "Return the PEP 3147/PEP 488 `path` to the byte-compiled file associated with the source path .", "question_id": 4921}
{"snippet": "importlib.util.cache_from_source(path, debug_override=None)", "intent": "Return the PEP 3147/PEP 488 `path` to the byte-compiled file associated with the source path . The `debug_override` parameter is deprecated and can be used to override the system \u2019 s value for __debug__ .", "question_id": 4922}
{"snippet": "importlib.util.cache_from_source(path, optimization=None)", "intent": "Return the PEP 3147/PEP 488 `path` to the byte-compiled file associated with the source path . The `optimization` parameter is used to specify the optimization level of the bytecode file .", "question_id": 4923}
{"snippet": "importlib.util.cache_from_source(path, debug_override=None, optimization=None)", "intent": "Return the PEP 3147/PEP 488 `path` to the byte-compiled file associated with the source path . The `debug_override` parameter is deprecated and can be used to override the system \u2019 s value for __debug__ . The `optimization` parameter is used to specify the optimization level of the bytecode file .", "question_id": 4924}
{"snippet": "importlib.util.source_from_cache(path)", "intent": "Given the `path` to a PEP 3147 file name , return the associated source code file path .", "question_id": 4925}
{"snippet": "importlib.util.decode_source(source_bytes)", "intent": "Decode the given bytes representing source code and return it as a string with universal newlines ( as required by importlib.abc.InspectLoader.get_source ( ) ) . With arguments `source_bytes`.", "question_id": 4926}
{"snippet": "importlib.util.resolve_name(name, package)", "intent": "Resolve a relative module `name` to an absolute one . This allows for usage such as importlib.util.resolve_name ( 'sys ' , __package__ ) without doing a check to see if the `package` argument is needed .", "question_id": 4927}
{"snippet": "importlib.util.find_spec(name)", "intent": "Find the spec for a module , optionally relative to the specified `package` `name` .", "question_id": 4928}
{"snippet": "importlib.util.find_spec(name, package=None)", "intent": "Find the spec for a module , optionally relative to the specified `package` `name` .", "question_id": 4929}
{"snippet": "importlib.util.module_from_spec(spec)", "intent": "Create a new module based on `spec` and spec.loader.create_module .", "question_id": 4930}
{"snippet": "@importlib.util.module_for_loader", "intent": "A decorator for importlib.abc.Loader.load_module() to handle selecting the proper module object to load with.", "question_id": 4931}
{"snippet": "@importlib.util.set_loader", "intent": "A decorator for importlib.abc.Loader.load_module() to set the __loader__ attribute on the returned module.", "question_id": 4932}
{"snippet": "@importlib.util.set_package", "intent": "A decorator for importlib.abc.Loader.load_module() to set the __package__ attribute on the returned module.", "question_id": 4933}
{"snippet": "importlib.util.spec_from_loader(name, loader)", "intent": "A factory function for creating a ModuleSpec instance based on a `loader` . With arguments `name`.", "question_id": 4934}
{"snippet": "importlib.util.spec_from_loader(name, loader, origin=None)", "intent": "A factory function for creating a ModuleSpec instance based on a `loader` . With arguments `name`, `origin`.", "question_id": 4935}
{"snippet": "importlib.util.spec_from_loader(name, loader, is_package=None)", "intent": "A factory function for creating a ModuleSpec instance based on a `loader` . With arguments `name`, `is_package`.", "question_id": 4936}
{"snippet": "importlib.util.spec_from_loader(name, loader, origin=None, is_package=None)", "intent": "A factory function for creating a ModuleSpec instance based on a `loader` . With arguments `name`, `origin`, `is_package`.", "question_id": 4937}
{"snippet": "importlib.util.spec_from_file_location(name, location)", "intent": "A factory function for creating a ModuleSpec instance based on the path to a file . With arguments `name`, `location`.", "question_id": 4938}
{"snippet": "importlib.util.spec_from_file_location(name, location, loader=None)", "intent": "A factory function for creating a ModuleSpec instance based on the path to a file . Missing information will be filled in on the spec by making use of `loader` APIs and by the implication that the module will be file-based . With arguments `name`, `location`.", "question_id": 4939}
{"snippet": "importlib.util.spec_from_file_location(name, location, submodule_search_locations=None)", "intent": "A factory function for creating a ModuleSpec instance based on the path to a file . With arguments `name`, `location`, `submodule_search_locations`.", "question_id": 4940}
{"snippet": "importlib.util.spec_from_file_location(name, location, loader=None, submodule_search_locations=None)", "intent": "A factory function for creating a ModuleSpec instance based on the path to a file . Missing information will be filled in on the spec by making use of `loader` APIs and by the implication that the module will be file-based . With arguments `name`, `location`, `submodule_search_locations`.", "question_id": 4941}
{"snippet": "importlib.util.source_hash(source_bytes)", "intent": "Return the hash of `source_bytes` as bytes .", "question_id": 4942}
{"snippet": "importlib.util.LazyLoader(loader)", "intent": "A class which postpones the execution of the `loader` of a module until the module has an attribute accessed .", "question_id": 4943}
{"snippet": "lazy_loader.factory(loader)", "intent": "A static method which returns a callable that creates a lazy `loader` .", "question_id": 4944}
{"snippet": "inspect.getmembers(object, predicate)", "intent": "Return all the members of an `object` in a list of ( name , value ) pairs sorted by name . If the optional `predicate` argument is supplied , only members for which the predicate returns a true value are included .", "question_id": 4945}
{"snippet": "inspect.getmembers(object)", "intent": "Return all the members of an `object` in a list of ( name , value ) pairs sorted by name .", "question_id": 4946}
{"snippet": "inspect.getmodulename(path)", "intent": "Return the name of the module named by the file `path` , without including the names of enclosing packages .", "question_id": 4947}
{"snippet": "inspect.ismodule(object)", "intent": "Return true if the `object` is a module .", "question_id": 4948}
{"snippet": "inspect.isclass(object)", "intent": "Return true if the `object` is a class , whether built-in or created in Python code .", "question_id": 4949}
{"snippet": "inspect.ismethod(object)", "intent": "Return true if the `object` is a bound method written in Python .", "question_id": 4950}
{"snippet": "inspect.isfunction(object)", "intent": "Return true if the `object` is a Python function , which includes functions created by a lambda expression .", "question_id": 4951}
{"snippet": "inspect.isgeneratorfunction(object)", "intent": "Return true if the `object` is a Python generator function .", "question_id": 4952}
{"snippet": "inspect.isgenerator(object)", "intent": "Return true if the `object` is a generator .", "question_id": 4953}
{"snippet": "inspect.iscoroutinefunction(object)", "intent": "Return true if the `object` is a coroutine function ( a function defined with an async def syntax ) .", "question_id": 4954}
{"snippet": "inspect.iscoroutine(object)", "intent": "Return true if the `object` is a coroutine created by an async def function .", "question_id": 4955}
{"snippet": "inspect.isawaitable(object)", "intent": "Return true if the `object` can be used in await expression .", "question_id": 4956}
{"snippet": "inspect.isasyncgenfunction(object)", "intent": "Return true if the `object` is an asynchronous generator function , for example :", "question_id": 4957}
{"snippet": "inspect.isasyncgen(object)", "intent": "Return true if the `object` is an asynchronous generator iterator created by an asynchronous generator function .", "question_id": 4958}
{"snippet": "inspect.istraceback(object)", "intent": "Return true if the `object` is a traceback .", "question_id": 4959}
{"snippet": "inspect.isframe(object)", "intent": "Return true if the `object` is a frame .", "question_id": 4960}
{"snippet": "inspect.iscode(object)", "intent": "Return true if the `object` is a code .", "question_id": 4961}
{"snippet": "inspect.isbuiltin(object)", "intent": "Return true if the `object` is a built-in function or a bound built-in method .", "question_id": 4962}
{"snippet": "inspect.isroutine(object)", "intent": "Return true if the `object` is a user-defined or built-in function or method .", "question_id": 4963}
{"snippet": "inspect.isabstract(object)", "intent": "Return true if the `object` is an abstract base class .", "question_id": 4964}
{"snippet": "inspect.ismethoddescriptor(object)", "intent": "Return true if the `object` is a method descriptor , but not if ismethod ( ) , isclass ( ) , isfunction ( ) or isbuiltin ( ) are true .", "question_id": 4965}
{"snippet": "inspect.isdatadescriptor(object)", "intent": "Return true if the `object` is a data descriptor .", "question_id": 4966}
{"snippet": "inspect.isgetsetdescriptor(object)", "intent": "Return true if the `object` is a getset descriptor .", "question_id": 4967}
{"snippet": "inspect.ismemberdescriptor(object)", "intent": "Return true if the `object` is a member descriptor .", "question_id": 4968}
{"snippet": "inspect.getdoc(object)", "intent": "Get the documentation string for an `object` , cleaned up with cleandoc ( ) .", "question_id": 4969}
{"snippet": "inspect.getcomments(object)", "intent": "Return in a single string any lines of comments immediately preceding the `object` \u2019 s source code ( for a class , function , or method ) , or at the top of the Python source file ( if the object is a module ) .", "question_id": 4970}
{"snippet": "inspect.getfile(object)", "intent": "Return the name of the ( text or binary ) file in which an `object` was defined .", "question_id": 4971}
{"snippet": "inspect.getmodule(object)", "intent": "Try to guess which module an `object` was defined in .", "question_id": 4972}
{"snippet": "inspect.getsourcefile(object)", "intent": "Return the name of the Python source file in which an `object` was defined .", "question_id": 4973}
{"snippet": "inspect.getsourcelines(object)", "intent": "Return a list of source lines and starting line number for an `object` .", "question_id": 4974}
{"snippet": "inspect.getsource(object)", "intent": "Return the text of the source code for an `object` .", "question_id": 4975}
{"snippet": "inspect.cleandoc(doc)", "intent": "Clean up indentation from docstrings that are indented to line up with blocks of code . With arguments `doc`.", "question_id": 4976}
{"snippet": "inspect.signature(callable)", "intent": "Return a Signature object for the given `callable` :", "question_id": 4977}
{"snippet": "inspect.signature(callable, follow_wrapped=True)", "intent": "Return a Signature object for the given `callable` : With arguments `follow_wrapped`.", "question_id": 4978}
{"snippet": "inspect.Signature()", "intent": "A Signature object represents the call signature of a function and its return annotation .", "question_id": 4979}
{"snippet": "inspect.Signature(parameters=None)", "intent": "A Signature object represents the call signature of a function and its return annotation . For each parameter accepted by the function it stores a Parameter object in its `parameters` collection .", "question_id": 4980}
{"snippet": "inspect.Signature(return_annotation=Signature.empty)", "intent": "A Signature object represents the call signature of a function and its return annotation . The optional `return_annotation` argument , can be an arbitrary Python object , is the \u201c return \u201d annotation of the callable .", "question_id": 4981}
{"snippet": "inspect.Signature(parameters=None, return_annotation=Signature.empty)", "intent": "A Signature object represents the call signature of a function and its return annotation . For each parameter accepted by the function it stores a Parameter object in its `parameters` collection . The optional `return_annotation` argument , can be an arbitrary Python object , is the \u201c return \u201d annotation of the callable .", "question_id": 4982}
{"snippet": "signature.empty", "intent": "A special class-level marker to specify absence of a return annotation.", "question_id": 4983}
{"snippet": "signature.parameters", "intent": "An ordered mapping of parameters\u2019 names to the corresponding Parameter objects.", "question_id": 4984}
{"snippet": "signature.return_annotation", "intent": "The \u201creturn\u201d annotation for the callable.", "question_id": 4985}
{"snippet": "signature.bind(*args, **kwargs)", "intent": "Create a mapping from positional and keyword arguments to parameters . Returns BoundArguments if `*args` and `**kwargs` match the signature , or raises a TypeError .", "question_id": 4986}
{"snippet": "signature.bind_partial(*args, **kwargs)", "intent": "Works the same way as Signature.bind ( ) , but allows the omission of some required arguments ( mimics functools.partial ( ) behavior . ) With arguments `*args`, `**kwargs`.", "question_id": 4987}
{"snippet": "signature.replace(parameters, return_annotation)", "intent": "Create a new Signature instance based on the instance replace was invoked on . It is possible to pass different `parameters` and/or `return_annotation` to override the corresponding properties of the base signature .", "question_id": 4988}
{"snippet": "signature.replace(parameters)", "intent": "Create a new Signature instance based on the instance replace was invoked on . It is possible to pass different `parameters` and/or `return_annotation` to override the corresponding properties of the base signature .", "question_id": 4989}
{"snippet": "signature.replace()", "intent": "Create a new Signature instance based on the instance replace was invoked on .", "question_id": 4990}
{"snippet": "signature.from_callable(obj)", "intent": "Return a Signature ( or its subclass ) object for a given callable `obj` .", "question_id": 4991}
{"snippet": "signature.from_callable(obj, follow_wrapped=True)", "intent": "Return a Signature ( or its subclass ) object for a given callable `obj` . With arguments `follow_wrapped`.", "question_id": 4992}
{"snippet": "inspect.Parameter(name, kind)", "intent": "Parameter objects are immutable . With arguments `name`, `kind`.", "question_id": 4993}
{"snippet": "inspect.Parameter(name, kind, default=Parameter.empty)", "intent": "Parameter objects are immutable . With arguments `name`, `kind`, `default`.", "question_id": 4994}
{"snippet": "inspect.Parameter(name, kind, annotation=Parameter.empty)", "intent": "Parameter objects are immutable . With arguments `name`, `kind`, `annotation`.", "question_id": 4995}
{"snippet": "inspect.Parameter(name, kind, default=Parameter.empty, annotation=Parameter.empty)", "intent": "Parameter objects are immutable . With arguments `name`, `kind`, `default`, `annotation`.", "question_id": 4996}
{"snippet": "parameter.empty", "intent": "A special class-level marker to specify absence of default values and annotations.", "question_id": 4997}
{"snippet": "parameter.name", "intent": "The name of the parameter as a string.", "question_id": 4998}
{"snippet": "parameter.default", "intent": "The default value for the parameter.", "question_id": 4999}
{"snippet": "parameter.annotation", "intent": "The annotation for the parameter.", "question_id": 5000}
{"snippet": "parameter.kind", "intent": "Describes how argument values are bound to the parameter.", "question_id": 5001}
{"snippet": "inspect.BoundArguments", "intent": "Result of a Signature.bind() or Signature.bind_partial() call.", "question_id": 5002}
{"snippet": "bound_arguments.arguments", "intent": "An ordered, mutable mapping (collections.OrderedDict) of parameters\u2019 names to arguments\u2019 values.", "question_id": 5003}
{"snippet": "bound_arguments.args", "intent": "A tuple of positional arguments values.", "question_id": 5004}
{"snippet": "bound_arguments.kwargs", "intent": "A dict of keyword arguments values.", "question_id": 5005}
{"snippet": "bound_arguments.signature", "intent": "A reference to the parent Signature object.", "question_id": 5006}
{"snippet": "bound_arguments.apply_defaults()", "intent": "Set default values for missing arguments .", "question_id": 5007}
{"snippet": "inspect.getclasstree(classes)", "intent": "Arrange the given list of `classes` into a hierarchy of nested lists .", "question_id": 5008}
{"snippet": "inspect.getclasstree(classes, unique=False)", "intent": "Arrange the given list of `classes` into a hierarchy of nested lists . If the `unique` argument is true , exactly one entry appears in the returned structure for each class in the given list .", "question_id": 5009}
{"snippet": "inspect.getargspec(func)", "intent": "Get the names and default values of a Python function \u2019 s parameters . With arguments `func`.", "question_id": 5010}
{"snippet": "inspect.getfullargspec(func)", "intent": "Get the names and default values of a Python function \u2019 s parameters . With arguments `func`.", "question_id": 5011}
{"snippet": "inspect.getargvalues(frame)", "intent": "Get information about arguments passed into a particular `frame` .", "question_id": 5012}
{"snippet": "inspect.formatargspec(args, varargs, varkw, defaults, kwonlyargs, kwonlydefaults, annotations, formatarg, formatvarargs, formatvarkw, formatvalue, formatreturns, formatannotations)", "intent": "Format a pretty argument spec from the values returned by getfullargspec ( ) . The first seven arguments are ( `args` , `varargs` , `varkw` , `defaults` , `kwonlyargs` , `kwonlydefaults` , `annotations` ) . With arguments `formatarg`, `formatvarargs`, `formatvarkw`, `formatvalue`, `formatreturns`, `formatannotations`.", "question_id": 5013}
{"snippet": "inspect.formatargspec(args, varargs, varkw, defaults, kwonlyargs, kwonlydefaults, annotations, formatarg, formatvarargs, formatvarkw, formatvalue, formatreturns)", "intent": "Format a pretty argument spec from the values returned by getfullargspec ( ) . The first seven arguments are ( `args` , `varargs` , `varkw` , `defaults` , `kwonlyargs` , `kwonlydefaults` , `annotations` ) . With arguments `formatarg`, `formatvarargs`, `formatvarkw`, `formatvalue`, `formatreturns`.", "question_id": 5014}
{"snippet": "inspect.formatargspec(args, varargs, varkw, defaults, kwonlyargs, kwonlydefaults, annotations, formatarg, formatvarargs, formatvarkw, formatvalue)", "intent": "Format a pretty argument spec from the values returned by getfullargspec ( ) . The first seven arguments are ( `args` , `varargs` , `varkw` , `defaults` , `kwonlyargs` , `kwonlydefaults` , `annotations` ) . With arguments `formatarg`, `formatvarargs`, `formatvarkw`, `formatvalue`.", "question_id": 5015}
{"snippet": "inspect.formatargvalues(args, varargs, varkw, locals, formatarg, formatvarargs, formatvarkw, formatvalue)", "intent": "Format a pretty argument spec from the four values returned by getargvalues ( ) . With arguments `args`, `varargs`, `varkw`, `locals`, `formatarg`, `formatvarargs`, `formatvarkw`, `formatvalue`.", "question_id": 5016}
{"snippet": "inspect.formatargvalues(args, varargs, varkw, locals, formatarg, formatvarargs, formatvarkw)", "intent": "Format a pretty argument spec from the four values returned by getargvalues ( ) . With arguments `args`, `varargs`, `varkw`, `locals`, `formatarg`, `formatvarargs`, `formatvarkw`.", "question_id": 5017}
{"snippet": "inspect.getmro(cls)", "intent": "Return a tuple of class `cls` \u2019 s base classes , including cls , in method resolution order .", "question_id": 5018}
{"snippet": "inspect.getcallargs(func, *args, **kwds)", "intent": "Bind the args and kwds to the argument names of the Python function or method `func` , as if it was called with them . whenever func ( `*args` , `**kwds` ) would raise an exception because of incompatible signature , an exception of the same type and the same or similar message is raised .", "question_id": 5019}
{"snippet": "inspect.getclosurevars(func)", "intent": "Get the mapping of external name references in a Python function or method `func` to their current values .", "question_id": 5020}
{"snippet": "inspect.unwrap(func)", "intent": "Get the object wrapped by `func` .", "question_id": 5021}
{"snippet": "inspect.unwrap(func, stop=None)", "intent": "Get the object wrapped by `func` . `stop` is an optional callback accepting an object in the wrapper chain as its sole argument that allows the unwrapping to be terminated early if the callback returns a true value .", "question_id": 5022}
{"snippet": "inspect.getframeinfo(frame)", "intent": "Get information about a `frame` or traceback object .", "question_id": 5023}
{"snippet": "inspect.getframeinfo(frame, context=1)", "intent": "Get information about a `frame` or traceback object . With arguments `context`.", "question_id": 5024}
{"snippet": "inspect.getouterframes(frame)", "intent": "Get a list of `frame` records for a frame and all outer frames .", "question_id": 5025}
{"snippet": "inspect.getouterframes(frame, context=1)", "intent": "Get a list of `frame` records for a frame and all outer frames . With arguments `context`.", "question_id": 5026}
{"snippet": "inspect.getinnerframes(traceback)", "intent": "Get a list of frame records for a `traceback` \u2019 s frame and all inner frames .", "question_id": 5027}
{"snippet": "inspect.getinnerframes(traceback, context=1)", "intent": "Get a list of frame records for a `traceback` \u2019 s frame and all inner frames . With arguments `context`.", "question_id": 5028}
{"snippet": "inspect.currentframe()", "intent": "Return the frame object for the caller \u2019 s stack frame .", "question_id": 5029}
{"snippet": "inspect.stack()", "intent": "Return a list of frame records for the caller \u2019 s stack .", "question_id": 5030}
{"snippet": "inspect.stack(context=1)", "intent": "Return a list of frame records for the caller \u2019 s stack . With arguments `context`.", "question_id": 5031}
{"snippet": "inspect.trace()", "intent": "Return a list of frame records for the stack between the current frame and the frame in which an exception currently being handled was raised in .", "question_id": 5032}
{"snippet": "inspect.trace(context=1)", "intent": "Return a list of frame records for the stack between the current frame and the frame in which an exception currently being handled was raised in . With arguments `context`.", "question_id": 5033}
{"snippet": "inspect.getattr_static(obj, attr)", "intent": "Retrieve attributes without triggering dynamic lookup via the descriptor protocol , __getattr__ ( ) or __getattribute__ ( ) . With arguments `obj`, `attr`.", "question_id": 5034}
{"snippet": "inspect.getattr_static(obj, attr, default=None)", "intent": "Retrieve attributes without triggering dynamic lookup via the descriptor protocol , __getattr__ ( ) or __getattribute__ ( ) . With arguments `obj`, `attr`, `default`.", "question_id": 5035}
{"snippet": "inspect.getgeneratorstate(generator)", "intent": "Get current state of a generator-iterator . With arguments `generator`.", "question_id": 5036}
{"snippet": "inspect.getcoroutinestate(coroutine)", "intent": "Get current state of a `coroutine` object .", "question_id": 5037}
{"snippet": "inspect.getgeneratorlocals(generator)", "intent": "Get the mapping of live local variables in `generator` to their current values .", "question_id": 5038}
{"snippet": "inspect.getcoroutinelocals(coroutine)", "intent": "This function is analogous to getgeneratorlocals ( ) , but works for `coroutine` objects created by async def functions .", "question_id": 5039}
{"snippet": "inspect.CO_OPTIMIZED", "intent": "The code object is optimized, using fast locals.", "question_id": 5040}
{"snippet": "inspect.CO_NEWLOCALS", "intent": "If set, a new dict will be created for the frame\u2019s f_locals when the code object is executed.", "question_id": 5041}
{"snippet": "inspect.CO_VARARGS", "intent": "The code object has a variable positional parameter (*args-like).", "question_id": 5042}
{"snippet": "inspect.CO_VARKEYWORDS", "intent": "The code object has a variable keyword parameter (**kwargs-like).", "question_id": 5043}
{"snippet": "inspect.CO_NESTED", "intent": "The flag is set when the code object is a nested function.", "question_id": 5044}
{"snippet": "inspect.CO_GENERATOR", "intent": "The flag is set when the code object is a generator function, i.e.", "question_id": 5045}
{"snippet": "inspect.CO_NOFREE", "intent": "The flag is set if there are no free or cell variables.", "question_id": 5046}
{"snippet": "inspect.CO_COROUTINE", "intent": "The flag is set when the code object is a coroutine function.", "question_id": 5047}
{"snippet": "inspect.CO_ITERABLE_COROUTINE", "intent": "The flag is used to transform generators into generator-based coroutines.", "question_id": 5048}
{"snippet": "inspect.CO_ASYNC_GENERATOR", "intent": "The flag is set when the code object is an asynchronous generator function.", "question_id": 5049}
{"snippet": "io.DEFAULT_BUFFER_SIZE", "intent": "An int containing the default buffer size used by the module\u2019s buffered I/O classes.", "question_id": 5050}
{"snippet": "io.open(file)", "intent": "This is an alias for the builtin open ( ) function . With arguments `file`.", "question_id": 5051}
{"snippet": "io.open(file, mode='r')", "intent": "This is an alias for the builtin open ( ) function . With arguments `file`, `mode`.", "question_id": 5052}
{"snippet": "io.open(file, buffering=-1)", "intent": "This is an alias for the builtin open ( ) function . With arguments `file`, `buffering`.", "question_id": 5053}
{"snippet": "io.open(file, encoding=None)", "intent": "This is an alias for the builtin open ( ) function . With arguments `file`, `encoding`.", "question_id": 5054}
{"snippet": "io.open(file, errors=None)", "intent": "This is an alias for the builtin open ( ) function . With arguments `file`, `errors`.", "question_id": 5055}
{"snippet": "io.open(file, newline=None)", "intent": "This is an alias for the builtin open ( ) function . With arguments `file`, `newline`.", "question_id": 5056}
{"snippet": "io.open(file, closefd=True)", "intent": "This is an alias for the builtin open ( ) function . With arguments `file`, `closefd`.", "question_id": 5057}
{"snippet": "io.open(file, opener=None)", "intent": "This is an alias for the builtin open ( ) function . With arguments `file`, `opener`.", "question_id": 5058}
{"snippet": "io.open(file, mode='r', buffering=-1)", "intent": "This is an alias for the builtin open ( ) function . With arguments `file`, `mode`, `buffering`.", "question_id": 5059}
{"snippet": "io.open(file, mode='r', encoding=None)", "intent": "This is an alias for the builtin open ( ) function . With arguments `file`, `mode`, `encoding`.", "question_id": 5060}
{"snippet": "io.BlockingIOError", "intent": "This is a compatibility alias for the builtin BlockingIOError exception.", "question_id": 5061}
{"snippet": "io.UnsupportedOperation", "intent": "An exception inheriting OSError and ValueError that is raised when an unsupported operation is called on a stream.", "question_id": 5062}
{"snippet": "io.IOBase", "intent": "The abstract base class for all I/O classes, acting on streams of bytes.", "question_id": 5063}
{"snippet": "io_base.close()", "intent": "Flush and close this stream .", "question_id": 5064}
{"snippet": "io_base.closed", "intent": "True if the stream is closed.", "question_id": 5065}
{"snippet": "io_base.fileno()", "intent": "Return the underlying file descriptor ( an integer ) of the stream if it exists .", "question_id": 5066}
{"snippet": "io_base.flush()", "intent": "Flush the write buffers of the stream if applicable .", "question_id": 5067}
{"snippet": "io_base.isatty()", "intent": "Return True if the stream is interactive ( i.e. , connected to a terminal/tty device ) .", "question_id": 5068}
{"snippet": "io_base.readable()", "intent": "Return True if the stream can be read from .", "question_id": 5069}
{"snippet": "io_base.readline()", "intent": "Read and return one line from the stream .", "question_id": 5070}
{"snippet": "io_base.readline(size=-1)", "intent": "Read and return one line from the stream . If `size` is specified , at most size bytes will be read .", "question_id": 5071}
{"snippet": "io_base.readlines()", "intent": "Read and return a list of lines from the stream .", "question_id": 5072}
{"snippet": "io_base.readlines(hint=-1)", "intent": "Read and return a list of lines from the stream . `hint` can be specified to control the number of lines read : no more lines will be read if the total size ( in bytes/characters ) of all lines so far exceeds hint .", "question_id": 5073}
{"snippet": "io_base.seek(offset)", "intent": "Change the stream position to the given byte `offset` .", "question_id": 5074}
{"snippet": "io_base.seek(offset, whence=SEEK_SET)", "intent": "Change the stream position to the given byte `offset` . offset is interpreted relative to the position indicated by `whence` .", "question_id": 5075}
{"snippet": "io_base.seekable()", "intent": "Return True if the stream supports random access .", "question_id": 5076}
{"snippet": "io_base.tell()", "intent": "Return the current stream position .", "question_id": 5077}
{"snippet": "io_base.truncate()", "intent": "Resize the stream to the given `size` in bytes ( or the current position if size is not specified ) .", "question_id": 5078}
{"snippet": "io_base.truncate(size=None)", "intent": "Resize the stream to the given `size` in bytes ( or the current position if size is not specified ) .", "question_id": 5079}
{"snippet": "io_base.writable()", "intent": "Return True if the stream supports writing .", "question_id": 5080}
{"snippet": "io_base.writelines(lines)", "intent": "Write a list of `lines` to the stream .", "question_id": 5081}
{"snippet": "io_base.__del__()", "intent": "Prepare for object destruction .", "question_id": 5082}
{"snippet": "io.RawIOBase", "intent": "Base class for raw binary I/O.", "question_id": 5083}
{"snippet": "raw_io_base.read()", "intent": "Read up to `size` bytes from the object and return them .", "question_id": 5084}
{"snippet": "raw_io_base.read(size=-1)", "intent": "Read up to `size` bytes from the object and return them .", "question_id": 5085}
{"snippet": "raw_io_base.readall()", "intent": "Read and return all the bytes from the stream until EOF , using multiple calls to the stream if necessary .", "question_id": 5086}
{"snippet": "raw_io_base.readinto(b)", "intent": "Read bytes into a pre-allocated , writable bytes-like object `b` , and return the number of bytes read .", "question_id": 5087}
{"snippet": "raw_io_base.write(b)", "intent": "Write the given bytes-like object , `b` , to the underlying raw stream , and return the number of bytes written .", "question_id": 5088}
{"snippet": "io.BufferedIOBase", "intent": "Base class for binary streams that support some kind of buffering.", "question_id": 5089}
{"snippet": "buffered_io_base.raw", "intent": "The underlying raw stream (a RawIOBase instance) that BufferedIOBase deals with.", "question_id": 5090}
{"snippet": "buffered_io_base.detach()", "intent": "Separate the underlying raw stream from the buffer and return it .", "question_id": 5091}
{"snippet": "buffered_io_base.read()", "intent": "Read and return up to `size` bytes .", "question_id": 5092}
{"snippet": "buffered_io_base.read(size=-1)", "intent": "Read and return up to `size` bytes .", "question_id": 5093}
{"snippet": "buffered_io_base.read1(size)", "intent": "Read and return up to `size` bytes , with at most one call to the underlying raw stream \u2019 s read ( ) ( or readinto ( ) ) method .", "question_id": 5094}
{"snippet": "buffered_io_base.read1()", "intent": "Read and return up to `size` bytes , with at most one call to the underlying raw stream \u2019 s read ( ) ( or readinto ( ) ) method .", "question_id": 5095}
{"snippet": "buffered_io_base.readinto(b)", "intent": "Read bytes into a pre-allocated , writable bytes-like object `b` and return the number of bytes read .", "question_id": 5096}
{"snippet": "buffered_io_base.readinto1(b)", "intent": "Read bytes into a pre-allocated , writable bytes-like object `b` , using at most one call to the underlying raw stream \u2019 s read ( ) ( or readinto ( ) ) method .", "question_id": 5097}
{"snippet": "buffered_io_base.write(b)", "intent": "Write the given bytes-like object , `b` , and return the number of bytes written ( always equal to the length of b in bytes , since if the write fails an OSError will be raised ) .", "question_id": 5098}
{"snippet": "io.FileIO(name)", "intent": "FileIO represents an OS-level file containing bytes data . The `name` can be one of two things :", "question_id": 5099}
{"snippet": "io.FileIO(name, mode='r')", "intent": "FileIO represents an OS-level file containing bytes data . The `name` can be one of two things : The `mode` can be ' r ' , ' w ' , ' x ' or ' a ' for reading ( default ) , writing , exclusive creation or appending .", "question_id": 5100}
{"snippet": "io.FileIO(name, closefd=True)", "intent": "FileIO represents an OS-level file containing bytes data . The `name` can be one of two things : With arguments `closefd`.", "question_id": 5101}
{"snippet": "io.FileIO(name, opener=None)", "intent": "FileIO represents an OS-level file containing bytes data . The `name` can be one of two things : A custom `opener` can be used by passing a callable as opener .", "question_id": 5102}
{"snippet": "io.FileIO(name, mode='r', closefd=True)", "intent": "FileIO represents an OS-level file containing bytes data . The `name` can be one of two things : The `mode` can be ' r ' , ' w ' , ' x ' or ' a ' for reading ( default ) , writing , exclusive creation or appending . With arguments `closefd`.", "question_id": 5103}
{"snippet": "io.FileIO(name, mode='r', opener=None)", "intent": "FileIO represents an OS-level file containing bytes data . The `name` can be one of two things : The `mode` can be ' r ' , ' w ' , ' x ' or ' a ' for reading ( default ) , writing , exclusive creation or appending . A custom `opener` can be used by passing a callable as opener .", "question_id": 5104}
{"snippet": "io.FileIO(name, closefd=True, opener=None)", "intent": "FileIO represents an OS-level file containing bytes data . The `name` can be one of two things : A custom `opener` can be used by passing a callable as opener . With arguments `closefd`.", "question_id": 5105}
{"snippet": "io.FileIO(name, mode='r', closefd=True, opener=None)", "intent": "FileIO represents an OS-level file containing bytes data . The `name` can be one of two things : The `mode` can be ' r ' , ' w ' , ' x ' or ' a ' for reading ( default ) , writing , exclusive creation or appending . A custom `opener` can be used by passing a callable as opener . With arguments `closefd`.", "question_id": 5106}
{"snippet": "file_io.mode", "intent": "The mode as given in the constructor.", "question_id": 5107}
{"snippet": "file_io.name", "intent": "The file name.", "question_id": 5108}
{"snippet": "io.BytesIO(initial_bytes)", "intent": "A stream implementation using an in-memory bytes buffer . The optional argument `initial_bytes` is a bytes-like object that contains initial data .", "question_id": 5109}
{"snippet": "io.BytesIO()", "intent": "A stream implementation using an in-memory bytes buffer .", "question_id": 5110}
{"snippet": "bytes_io.getbuffer()", "intent": "Return a readable and writable view over the contents of the buffer without copying them .", "question_id": 5111}
{"snippet": "bytes_io.getvalue()", "intent": "Return bytes containing the entire contents of the buffer .", "question_id": 5112}
{"snippet": "bytes_io.read1(size)", "intent": "In BytesIO , this is the same as read ( ) . With arguments `size`.", "question_id": 5113}
{"snippet": "bytes_io.read1()", "intent": "In BytesIO , this is the same as read ( ) .", "question_id": 5114}
{"snippet": "bytes_io.readinto1(b)", "intent": "In BytesIO , this is the same as readinto ( ) . With arguments `b`.", "question_id": 5115}
{"snippet": "io.BufferedReader(raw)", "intent": "A buffer providing higher-level access to a readable , sequential RawIOBase object . When reading data from this object , a larger amount of data may be requested from the underlying `raw` stream , and kept in an internal buffer .", "question_id": 5116}
{"snippet": "io.BufferedReader(raw, buffer_size=DEFAULT_BUFFER_SIZE)", "intent": "A buffer providing higher-level access to a readable , sequential RawIOBase object . When reading data from this object , a larger amount of data may be requested from the underlying `raw` stream , and kept in an internal buffer . The constructor creates a BufferedReader for the given readable raw stream and `buffer_size` .", "question_id": 5117}
{"snippet": "buffered_reader.peek(size)", "intent": "Return bytes from the stream without advancing the position . With arguments `size`.", "question_id": 5118}
{"snippet": "buffered_reader.peek()", "intent": "Return bytes from the stream without advancing the position .", "question_id": 5119}
{"snippet": "buffered_reader.read(size)", "intent": "Read and return `size` bytes , or if size is not given or negative , until EOF or if the read call would block in non-blocking mode .", "question_id": 5120}
{"snippet": "buffered_reader.read()", "intent": "Read and return `size` bytes , or if size is not given or negative , until EOF or if the read call would block in non-blocking mode .", "question_id": 5121}
{"snippet": "buffered_reader.read1(size)", "intent": "Read and return up to `size` bytes with only one call on the raw stream .", "question_id": 5122}
{"snippet": "buffered_reader.read1()", "intent": "Read and return up to `size` bytes with only one call on the raw stream .", "question_id": 5123}
{"snippet": "io.BufferedWriter(raw)", "intent": "A buffer providing higher-level access to a writeable , sequential RawIOBase object . The constructor creates a BufferedWriter for the given writeable `raw` stream .", "question_id": 5124}
{"snippet": "io.BufferedWriter(raw, buffer_size=DEFAULT_BUFFER_SIZE)", "intent": "A buffer providing higher-level access to a writeable , sequential RawIOBase object . The constructor creates a BufferedWriter for the given writeable `raw` stream . If the `buffer_size` is not given , it defaults to DEFAULT_BUFFER_SIZE .", "question_id": 5125}
{"snippet": "buffered_writer.flush()", "intent": "Force bytes held in the buffer into the raw stream .", "question_id": 5126}
{"snippet": "buffered_writer.write(b)", "intent": "Write the bytes-like object , `b` , and return the number of bytes written .", "question_id": 5127}
{"snippet": "io.BufferedRandom(raw)", "intent": "A buffered interface to random access streams . The constructor creates a reader and writer for a seekable `raw` stream , given in the first argument .", "question_id": 5128}
{"snippet": "io.BufferedRandom(raw, buffer_size=DEFAULT_BUFFER_SIZE)", "intent": "A buffered interface to random access streams . The constructor creates a reader and writer for a seekable `raw` stream , given in the first argument . If the `buffer_size` is omitted it defaults to DEFAULT_BUFFER_SIZE .", "question_id": 5129}
{"snippet": "io.BufferedRWPair(reader, writer)", "intent": "A buffered I/O object combining two unidirectional RawIOBase objects \u2013 one readable , the other writeable \u2013 into a single bidirectional endpoint . `reader` and `writer` are RawIOBase objects that are readable and writeable respectively .", "question_id": 5130}
{"snippet": "io.BufferedRWPair(reader, writer, buffer_size=DEFAULT_BUFFER_SIZE)", "intent": "A buffered I/O object combining two unidirectional RawIOBase objects \u2013 one readable , the other writeable \u2013 into a single bidirectional endpoint . `reader` and `writer` are RawIOBase objects that are readable and writeable respectively . If the `buffer_size` is omitted it defaults to DEFAULT_BUFFER_SIZE .", "question_id": 5131}
{"snippet": "io.TextIOBase", "intent": "Base class for text streams.", "question_id": 5132}
{"snippet": "text_io_base.encoding", "intent": "The name of the encoding used to decode the stream\u2019s bytes into strings, and to encode strings into bytes.", "question_id": 5133}
{"snippet": "text_io_base.errors", "intent": "The error setting of the decoder or encoder.", "question_id": 5134}
{"snippet": "text_io_base.newlines", "intent": "A string, a tuple of strings, or None, indicating the newlines translated so far.", "question_id": 5135}
{"snippet": "text_io_base.buffer", "intent": "The underlying binary buffer (a BufferedIOBase instance) that TextIOBase deals with.", "question_id": 5136}
{"snippet": "text_io_base.detach()", "intent": "Separate the underlying binary buffer from the TextIOBase and return it .", "question_id": 5137}
{"snippet": "text_io_base.read()", "intent": "Read and return at most `size` characters from the stream as a single str .", "question_id": 5138}
{"snippet": "text_io_base.read(size=-1)", "intent": "Read and return at most `size` characters from the stream as a single str .", "question_id": 5139}
{"snippet": "text_io_base.readline()", "intent": "Read until newline or EOF and return a single str .", "question_id": 5140}
{"snippet": "text_io_base.readline(size=-1)", "intent": "Read until newline or EOF and return a single str . If `size` is specified , at most size characters will be read .", "question_id": 5141}
{"snippet": "text_io_base.seek(offset)", "intent": "Change the stream position to the given `offset` .", "question_id": 5142}
{"snippet": "text_io_base.seek(offset, whence=SEEK_SET)", "intent": "Change the stream position to the given `offset` . Behaviour depends on the `whence` parameter .", "question_id": 5143}
{"snippet": "text_io_base.tell()", "intent": "Return the current stream position as an opaque number .", "question_id": 5144}
{"snippet": "text_io_base.write(s)", "intent": "Write the string `s` to the stream and return the number of characters written .", "question_id": 5145}
{"snippet": "io.TextIOWrapper(buffer)", "intent": "A buffered text stream over a BufferedIOBase binary stream . If `write_through` is True , calls to write ( ) are guaranteed not to be buffered : any data written on the TextIOWrapper object is immediately handled to its underlying binary `buffer` .", "question_id": 5146}
{"snippet": "io.TextIOWrapper(buffer, encoding=None)", "intent": "A buffered text stream over a BufferedIOBase binary stream . If `write_through` is True , calls to write ( ) are guaranteed not to be buffered : any data written on the TextIOWrapper object is immediately handled to its underlying binary `buffer` . `encoding` gives the name of the encoding that the stream will be decoded or encoded with .", "question_id": 5147}
{"snippet": "io.TextIOWrapper(buffer, errors=None)", "intent": "A buffered text stream over a BufferedIOBase binary stream . If `write_through` is True , calls to write ( ) are guaranteed not to be buffered : any data written on the TextIOWrapper object is immediately handled to its underlying binary `buffer` . `errors` is an optional string that specifies how encoding and decoding errors are to be handled .", "question_id": 5148}
{"snippet": "io.TextIOWrapper(buffer, newline=None)", "intent": "A buffered text stream over a BufferedIOBase binary stream . If `write_through` is True , calls to write ( ) are guaranteed not to be buffered : any data written on the TextIOWrapper object is immediately handled to its underlying binary `buffer` . `newline` controls how line endings are handled .", "question_id": 5149}
{"snippet": "io.TextIOWrapper(buffer, line_buffering=False)", "intent": "A buffered text stream over a BufferedIOBase binary stream . If `write_through` is True , calls to write ( ) are guaranteed not to be buffered : any data written on the TextIOWrapper object is immediately handled to its underlying binary `buffer` . If `line_buffering` is True , flush ( ) is implied when a call to write contains a newline character or a carriage return .", "question_id": 5150}
{"snippet": "io.TextIOWrapper(buffer, write_through=False)", "intent": "A buffered text stream over a BufferedIOBase binary stream . If `write_through` is True , calls to write ( ) are guaranteed not to be buffered : any data written on the TextIOWrapper object is immediately handled to its underlying binary `buffer` .", "question_id": 5151}
{"snippet": "io.TextIOWrapper(buffer, encoding=None, errors=None)", "intent": "A buffered text stream over a BufferedIOBase binary stream . If `write_through` is True , calls to write ( ) are guaranteed not to be buffered : any data written on the TextIOWrapper object is immediately handled to its underlying binary `buffer` . `encoding` gives the name of the encoding that the stream will be decoded or encoded with . `errors` is an optional string that specifies how encoding and decoding errors are to be handled .", "question_id": 5152}
{"snippet": "io.TextIOWrapper(buffer, encoding=None, newline=None)", "intent": "A buffered text stream over a BufferedIOBase binary stream . If `write_through` is True , calls to write ( ) are guaranteed not to be buffered : any data written on the TextIOWrapper object is immediately handled to its underlying binary `buffer` . `encoding` gives the name of the encoding that the stream will be decoded or encoded with . `newline` controls how line endings are handled .", "question_id": 5153}
{"snippet": "io.TextIOWrapper(buffer, encoding=None, line_buffering=False)", "intent": "A buffered text stream over a BufferedIOBase binary stream . If `write_through` is True , calls to write ( ) are guaranteed not to be buffered : any data written on the TextIOWrapper object is immediately handled to its underlying binary `buffer` . `encoding` gives the name of the encoding that the stream will be decoded or encoded with . If `line_buffering` is True , flush ( ) is implied when a call to write contains a newline character or a carriage return .", "question_id": 5154}
{"snippet": "io.TextIOWrapper(buffer, encoding=None, write_through=False)", "intent": "A buffered text stream over a BufferedIOBase binary stream . If `write_through` is True , calls to write ( ) are guaranteed not to be buffered : any data written on the TextIOWrapper object is immediately handled to its underlying binary `buffer` . `encoding` gives the name of the encoding that the stream will be decoded or encoded with .", "question_id": 5155}
{"snippet": "text_io_wrapper.line_buffering", "intent": "Whether line buffering is enabled.", "question_id": 5156}
{"snippet": "text_io_wrapper.write_through", "intent": "Whether writes are passed immediately to the underlying binary buffer.", "question_id": 5157}
{"snippet": "text_io_wrapper.reconfigure(encoding, errors, newline,                      line_buffering, write_through)", "intent": "Reconfigure this text stream using new settings for `encoding` , `errors` , `newline` , line_buffering and `write_through` . With arguments `                     line_buffering`.", "question_id": 5158}
{"snippet": "text_io_wrapper.reconfigure(encoding, errors, newline,                      line_buffering)", "intent": "Reconfigure this text stream using new settings for `encoding` , `errors` , `newline` , line_buffering and `write_through` . With arguments `                     line_buffering`.", "question_id": 5159}
{"snippet": "text_io_wrapper.reconfigure(encoding, errors, newline)", "intent": "Reconfigure this text stream using new settings for `encoding` , `errors` , `newline` , line_buffering and `write_through` .", "question_id": 5160}
{"snippet": "text_io_wrapper.reconfigure(encoding, errors)", "intent": "Reconfigure this text stream using new settings for `encoding` , `errors` , `newline` , line_buffering and `write_through` .", "question_id": 5161}
{"snippet": "text_io_wrapper.reconfigure(encoding)", "intent": "Reconfigure this text stream using new settings for `encoding` , `errors` , `newline` , line_buffering and `write_through` .", "question_id": 5162}
{"snippet": "text_io_wrapper.reconfigure()", "intent": "Reconfigure this text stream using new settings for `encoding` , `errors` , `newline` , line_buffering and `write_through` .", "question_id": 5163}
{"snippet": "io.StringIO()", "intent": "An in-memory stream for text I/O .", "question_id": 5164}
{"snippet": "io.StringIO(initial_value='')", "intent": "An in-memory stream for text I/O . The initial value of the buffer can be set by providing `initial_value` .", "question_id": 5165}
{"snippet": "io.StringIO(newline='\\n')", "intent": "An in-memory stream for text I/O . If `newline` translation is enabled , newlines will be encoded as if by write ( ) .", "question_id": 5166}
{"snippet": "io.StringIO(initial_value='', newline='\\n')", "intent": "An in-memory stream for text I/O . The initial value of the buffer can be set by providing `initial_value` . If `newline` translation is enabled , newlines will be encoded as if by write ( ) .", "question_id": 5167}
{"snippet": "string_io.getvalue()", "intent": "Return a str containing the entire contents of the buffer .", "question_id": 5168}
{"snippet": "io.IncrementalNewlineDecoder", "intent": "A helper codec that decodes newlines for universal newlines mode.", "question_id": 5169}
{"snippet": "ipaddress.ip_address(address)", "intent": "Return an IPv4Address or IPv6Address object depending on the IP `address` passed as argument .", "question_id": 5170}
{"snippet": "ipaddress.ip_network(address)", "intent": "Return an IPv4Network or IPv6Network object depending on the IP `address` passed as argument .", "question_id": 5171}
{"snippet": "ipaddress.ip_network(address, strict=True)", "intent": "Return an IPv4Network or IPv6Network object depending on the IP `address` passed as argument . `strict` is passed to IPv4Network or IPv6Network constructor .", "question_id": 5172}
{"snippet": "ipaddress.ip_interface(address)", "intent": "Return an IPv4Interface or IPv6Interface object depending on the IP `address` passed as argument .", "question_id": 5173}
{"snippet": "ipaddress.IPv4Address(address)", "intent": "Construct an IPv4 `address` .", "question_id": 5174}
{"snippet": "i_pv4_address.version", "intent": "The appropriate version number: 4 for IPv4, 6 for IPv6.", "question_id": 5175}
{"snippet": "i_pv4_address.max_prefixlen", "intent": "The total number of bits in the address representation for this version: 32 for IPv4, 128 for IPv6.", "question_id": 5176}
{"snippet": "i_pv4_address.exploded", "intent": "The string representation in dotted decimal notation.", "question_id": 5177}
{"snippet": "i_pv4_address.packed", "intent": "The binary representation of this address - a bytes object of the appropriate length (most significant octet first).", "question_id": 5178}
{"snippet": "i_pv4_address.reverse_pointer", "intent": "The name of the reverse DNS PTR record for the IP address, e.g.", "question_id": 5179}
{"snippet": "i_pv4_address.is_multicast", "intent": "True if the address is reserved for multicast use.", "question_id": 5180}
{"snippet": "i_pv4_address.is_private", "intent": "True if the address is allocated for private networks.", "question_id": 5181}
{"snippet": "i_pv4_address.is_global", "intent": "True if the address is allocated for public networks.", "question_id": 5182}
{"snippet": "i_pv4_address.is_unspecified", "intent": "True if the address is unspecified.", "question_id": 5183}
{"snippet": "i_pv4_address.is_reserved", "intent": "True if the address is otherwise IETF reserved.", "question_id": 5184}
{"snippet": "i_pv4_address.is_loopback", "intent": "True if this is a loopback address.", "question_id": 5185}
{"snippet": "i_pv4_address.is_link_local", "intent": "True if the address is reserved for link-local usage.", "question_id": 5186}
{"snippet": "ipaddress.IPv6Address(address)", "intent": "Construct an IPv6 `address` .", "question_id": 5187}
{"snippet": "i_pv6_address.is_site_local", "intent": "True if the address is reserved for site-local usage.", "question_id": 5188}
{"snippet": "i_pv6_address.ipv4_mapped", "intent": "For addresses that appear to be IPv4 mapped addresses (starting with ::FFFF/96), this property will report the embedded IPv4 address.", "question_id": 5189}
{"snippet": "i_pv6_address.sixtofour", "intent": "For addresses that appear to be 6to4 addresses  (starting with 2002::/16) as defined by RFC 3056, this property will report the embedded IPv4 address.", "question_id": 5190}
{"snippet": "i_pv6_address.teredo", "intent": "For addresses that appear to be Teredo addresses (starting with 2001::/32) as defined by RFC 4380, this property will report the embedded (server, client) IP address pair.", "question_id": 5191}
{"snippet": "ipaddress.IPv4Network(address)", "intent": "Construct an IPv4 network definition . `address` can be one of the following :", "question_id": 5192}
{"snippet": "ipaddress.IPv4Network(address, strict=True)", "intent": "Construct an IPv4 network definition . `address` can be one of the following : If `strict` is True and host bits are set in the supplied address , then ValueError is raised .", "question_id": 5193}
{"snippet": "i_pv4_network.max_prefixlen", "intent": "Refer to the corresponding attribute documentation in IPv4Address.", "question_id": 5194}
{"snippet": "i_pv4_network.is_link_local", "intent": "These attributes are true for the network as a whole if they are true for both the network address and the broadcast address.", "question_id": 5195}
{"snippet": "i_pv4_network.network_address", "intent": "The network address for the network.", "question_id": 5196}
{"snippet": "i_pv4_network.broadcast_address", "intent": "The broadcast address for the network.", "question_id": 5197}
{"snippet": "i_pv4_network.hostmask", "intent": "The host mask, as an IPv4Address object.", "question_id": 5198}
{"snippet": "i_pv4_network.netmask", "intent": "The net mask, as an IPv4Address object.", "question_id": 5199}
{"snippet": "i_pv4_network.exploded", "intent": "A string representation of the network, with the mask in prefix notation.", "question_id": 5200}
{"snippet": "i_pv4_network.with_netmask", "intent": "A string representation of the network, with the mask in net mask notation.", "question_id": 5201}
{"snippet": "i_pv4_network.with_hostmask", "intent": "A string representation of the network, with the mask in host mask notation.", "question_id": 5202}
{"snippet": "i_pv4_network.num_addresses", "intent": "The total number of addresses in the network.", "question_id": 5203}
{"snippet": "i_pv4_network.prefixlen", "intent": "Length of the network prefix, in bits.", "question_id": 5204}
{"snippet": "i_pv4_network.hosts()", "intent": "Returns an iterator over the usable hosts in the network .", "question_id": 5205}
{"snippet": "i_pv4_network.overlaps(other)", "intent": "True if this network is partly or wholly contained in `other` or other is wholly contained in this network .", "question_id": 5206}
{"snippet": "i_pv4_network.address_exclude(network)", "intent": "Computes the `network` definitions resulting from removing the given network from this one .", "question_id": 5207}
{"snippet": "i_pv4_network.subnets()", "intent": "The subnets that join to make the current network definition , depending on the argument values .", "question_id": 5208}
{"snippet": "i_pv4_network.subnets(prefixlen_diff=1)", "intent": "The subnets that join to make the current network definition , depending on the argument values . `prefixlen_diff` is the amount our prefix length should be increased by .", "question_id": 5209}
{"snippet": "i_pv4_network.subnets(new_prefix=None)", "intent": "The subnets that join to make the current network definition , depending on the argument values . `new_prefix` is the desired new prefix of the subnets ; it must be larger than our prefix .", "question_id": 5210}
{"snippet": "i_pv4_network.subnets(prefixlen_diff=1, new_prefix=None)", "intent": "The subnets that join to make the current network definition , depending on the argument values . `prefixlen_diff` is the amount our prefix length should be increased by . `new_prefix` is the desired new prefix of the subnets ; it must be larger than our prefix .", "question_id": 5211}
{"snippet": "i_pv4_network.supernet()", "intent": "The supernet containing this network definition , depending on the argument values .", "question_id": 5212}
{"snippet": "i_pv4_network.supernet(prefixlen_diff=1)", "intent": "The supernet containing this network definition , depending on the argument values . `prefixlen_diff` is the amount our prefix length should be decreased by .", "question_id": 5213}
{"snippet": "i_pv4_network.supernet(new_prefix=None)", "intent": "The supernet containing this network definition , depending on the argument values . `new_prefix` is the desired new prefix of the supernet ; it must be smaller than our prefix .", "question_id": 5214}
{"snippet": "i_pv4_network.supernet(prefixlen_diff=1, new_prefix=None)", "intent": "The supernet containing this network definition , depending on the argument values . `prefixlen_diff` is the amount our prefix length should be decreased by . `new_prefix` is the desired new prefix of the supernet ; it must be smaller than our prefix .", "question_id": 5215}
{"snippet": "i_pv4_network.subnet_of(other)", "intent": "Returns True if this network is a subnet of `other` .", "question_id": 5216}
{"snippet": "i_pv4_network.supernet_of(other)", "intent": "Returns True if this network is a supernet of `other` .", "question_id": 5217}
{"snippet": "i_pv4_network.compare_networks(other)", "intent": "Compare this network to `other` .", "question_id": 5218}
{"snippet": "ipaddress.IPv6Network(address)", "intent": "Construct an IPv6 network definition . `address` can be one of the following :", "question_id": 5219}
{"snippet": "ipaddress.IPv6Network(address, strict=True)", "intent": "Construct an IPv6 network definition . `address` can be one of the following : If `strict` is True and host bits are set in the supplied address , then ValueError is raised .", "question_id": 5220}
{"snippet": "i_pv6_network.hosts()", "intent": "Returns an iterator over the usable hosts in the network .", "question_id": 5221}
{"snippet": "i_pv6_network.compare_networks(other)", "intent": "Refer to the corresponding attribute documentation in IPv4Network . With arguments `other`.", "question_id": 5222}
{"snippet": "i_pv6_network.is_site_local", "intent": "These attribute is true for the network as a whole if it is true for both the network address and the broadcast address.", "question_id": 5223}
{"snippet": "ipaddress.IPv4Interface(address)", "intent": "Construct an IPv4 interface . The meaning of `address` is as in the constructor of IPv4Network , except that arbitrary host addresses are always accepted .", "question_id": 5224}
{"snippet": "i_pv4_interface.ip", "intent": "The address (IPv4Address) without network information.", "question_id": 5225}
{"snippet": "i_pv4_interface.network", "intent": "The network (IPv4Network) this interface belongs to.", "question_id": 5226}
{"snippet": "i_pv4_interface.with_prefixlen", "intent": "A string representation of the interface with the mask in prefix notation.", "question_id": 5227}
{"snippet": "i_pv4_interface.with_netmask", "intent": "A string representation of the interface with the network as a net mask.", "question_id": 5228}
{"snippet": "i_pv4_interface.with_hostmask", "intent": "A string representation of the interface with the network as a host mask.", "question_id": 5229}
{"snippet": "ipaddress.IPv6Interface(address)", "intent": "Construct an IPv6 interface . The meaning of `address` is as in the constructor of IPv6Network , except that arbitrary host addresses are always accepted .", "question_id": 5230}
{"snippet": "i_pv6_interface.with_hostmask", "intent": "Refer to the corresponding attribute documentation in IPv4Interface.", "question_id": 5231}
{"snippet": "ipaddress.v4_int_to_packed(address)", "intent": "Represent an `address` as 4 packed bytes in network ( big-endian ) order .", "question_id": 5232}
{"snippet": "ipaddress.v6_int_to_packed(address)", "intent": "Represent an `address` as 16 packed bytes in network ( big-endian ) order .", "question_id": 5233}
{"snippet": "ipaddress.summarize_address_range(first, last)", "intent": "Return an iterator of the summarized network range given the `first` and `last` IP addresses .", "question_id": 5234}
{"snippet": "ipaddress.collapse_addresses(addresses)", "intent": "Return an iterator of the collapsed IPv4Network or IPv6Network objects . `addresses` is an iterator of IPv4Network or IPv6Network objects .", "question_id": 5235}
{"snippet": "ipaddress.get_mixed_type_key(obj)", "intent": "Return a key suitable for sorting between networks and addresses . `obj` is either a network or address object .", "question_id": 5236}
{"snippet": "ipaddress.AddressValueError(ValueError)", "intent": "Any value error related to the address . With arguments `ValueError`.", "question_id": 5237}
{"snippet": "ipaddress.NetmaskValueError(ValueError)", "intent": "Any value error related to the net mask . With arguments `ValueError`.", "question_id": 5238}
{"snippet": "itertools.accumulate(iterable, func)", "intent": "Make an iterator that returns accumulated sums , or accumulated results of other binary functions ( specified via the optional `func` argument ) . Elements of the input `iterable` may be any type that can be accepted as arguments to func .", "question_id": 5239}
{"snippet": "itertools.accumulate(iterable)", "intent": "Make an iterator that returns accumulated sums , or accumulated results of other binary functions ( specified via the optional `func` argument ) . Elements of the input `iterable` may be any type that can be accepted as arguments to func .", "question_id": 5240}
{"snippet": "itertools.chain(*iterables)", "intent": "Make an iterator that returns elements from the first iterable until it is exhausted , then proceeds to the next iterable , until all of the iterables are exhausted . With arguments `*iterables`.", "question_id": 5241}
{"snippet": "chain.from_iterable(iterable)", "intent": "Alternate constructor for chain ( ) . Gets chained inputs from a single `iterable` argument that is evaluated lazily .", "question_id": 5242}
{"snippet": "itertools.combinations(iterable, r)", "intent": "Return `r` length subsequences of elements from the input `iterable` .", "question_id": 5243}
{"snippet": "itertools.combinations_with_replacement(iterable, r)", "intent": "Return `r` length subsequences of elements from the input `iterable` allowing individual elements to be repeated more than once .", "question_id": 5244}
{"snippet": "itertools.compress(data, selectors)", "intent": "Make an iterator that filters elements from `data` returning only those that have a corresponding element in `selectors` that evaluates to True .", "question_id": 5245}
{"snippet": "itertools.count()", "intent": "Make an iterator that returns evenly spaced values starting with number `start` .", "question_id": 5246}
{"snippet": "itertools.count(start=0)", "intent": "Make an iterator that returns evenly spaced values starting with number `start` .", "question_id": 5247}
{"snippet": "itertools.count(step=1)", "intent": "Make an iterator that returns evenly spaced values starting with number `start` . When counting with floating point numbers , better accuracy can sometimes be achieved by substituting multiplicative code such as : ( start + `step` * i for i in count ( ) ) .", "question_id": 5248}
{"snippet": "itertools.count(start=0, step=1)", "intent": "Make an iterator that returns evenly spaced values starting with number `start` . When counting with floating point numbers , better accuracy can sometimes be achieved by substituting multiplicative code such as : ( start + `step` * i for i in count ( ) ) .", "question_id": 5249}
{"snippet": "itertools.cycle(iterable)", "intent": "Make an iterator returning elements from the `iterable` and saving a copy of each .", "question_id": 5250}
{"snippet": "itertools.dropwhile(predicate, iterable)", "intent": "Make an iterator that drops elements from the `iterable` as long as the `predicate` is true ; afterwards , returns every element .", "question_id": 5251}
{"snippet": "itertools.filterfalse(predicate, iterable)", "intent": "Make an iterator that filters elements from `iterable` returning only those for which the `predicate` is False .", "question_id": 5252}
{"snippet": "itertools.groupby(iterable)", "intent": "Make an iterator that returns consecutive keys and groups from the `iterable` .", "question_id": 5253}
{"snippet": "itertools.groupby(iterable, key=None)", "intent": "Make an iterator that returns consecutive keys and groups from the `iterable` . The `key` is a function computing a key value for each element .", "question_id": 5254}
{"snippet": "itertools.islice(iterable, stop)", "intent": "Make an iterator that returns selected elements from the `iterable` . If `stop` is None , then iteration continues until the iterator is exhausted , if at all ; otherwise , it stops at the specified position .", "question_id": 5255}
{"snippet": "itertools.islice(iterable, start, stop, step)", "intent": "Make an iterator that returns selected elements from the `iterable` . If `start` is non-zero , then elements from the iterable are skipped until start is reached . If `stop` is None , then iteration continues until the iterator is exhausted , if at all ; otherwise , it stops at the specified position . Afterward , elements are returned consecutively unless `step` is set higher than one which results in items being skipped .", "question_id": 5256}
{"snippet": "itertools.islice(iterable, start, stop)", "intent": "Make an iterator that returns selected elements from the `iterable` . If `start` is non-zero , then elements from the iterable are skipped until start is reached . If `stop` is None , then iteration continues until the iterator is exhausted , if at all ; otherwise , it stops at the specified position .", "question_id": 5257}
{"snippet": "itertools.permutations(iterable)", "intent": "Return successive `r` length permutations of elements in the `iterable` .", "question_id": 5258}
{"snippet": "itertools.permutations(iterable, r=None)", "intent": "Return successive `r` length permutations of elements in the `iterable` .", "question_id": 5259}
{"snippet": "itertools.product(*iterables)", "intent": "Cartesian product of input iterables . With arguments `*iterables`.", "question_id": 5260}
{"snippet": "itertools.product(*iterables, repeat=1)", "intent": "Cartesian product of input iterables . To compute the product of an iterable with itself , specify the number of repetitions with the optional `repeat` keyword argument . With arguments `*iterables`.", "question_id": 5261}
{"snippet": "itertools.repeat(object, times)", "intent": "Make an iterator that returns `object` over and over again . Runs indefinitely unless the `times` argument is specified .", "question_id": 5262}
{"snippet": "itertools.repeat(object)", "intent": "Make an iterator that returns `object` over and over again .", "question_id": 5263}
{"snippet": "itertools.starmap(function, iterable)", "intent": "Make an iterator that computes the `function` using arguments obtained from the `iterable` .", "question_id": 5264}
{"snippet": "itertools.takewhile(predicate, iterable)", "intent": "Make an iterator that returns elements from the `iterable` as long as the `predicate` is true .", "question_id": 5265}
{"snippet": "itertools.tee(iterable)", "intent": "Return `n` independent iterators from a single `iterable` .", "question_id": 5266}
{"snippet": "itertools.tee(iterable, n=2)", "intent": "Return `n` independent iterators from a single `iterable` .", "question_id": 5267}
{"snippet": "itertools.zip_longest(*iterables)", "intent": "Make an iterator that aggregates elements from each of the iterables . With arguments `*iterables`.", "question_id": 5268}
{"snippet": "itertools.zip_longest(*iterables, fillvalue=None)", "intent": "Make an iterator that aggregates elements from each of the iterables . If the iterables are of uneven length , missing values are filled-in with `fillvalue` . With arguments `*iterables`.", "question_id": 5269}
{"snippet": "json.dump(obj, fp, **kw)", "intent": "Serialize `obj` as a JSON formatted stream to `fp` ( a .write ( ) -supporting file-like object ) using this conversion table . With arguments `**kw`.", "question_id": 5270}
{"snippet": "json.dump(obj, fp, **kw, skipkeys=False)", "intent": "Serialize `obj` as a JSON formatted stream to `fp` ( a .write ( ) -supporting file-like object ) using this conversion table . If `skipkeys` is true ( `default` : False ) , then dict keys that are not of a basic type ( str , int , float , bool , None ) will be skipped instead of raising a TypeError . With arguments `**kw`.", "question_id": 5271}
{"snippet": "json.dump(obj, fp, **kw, ensure_ascii=True)", "intent": "Serialize `obj` as a JSON formatted stream to `fp` ( a .write ( ) -supporting file-like object ) using this conversion table . If `ensure_ascii` is true ( the default ) , the output is guaranteed to have all incoming non-ASCII characters escaped . With arguments `**kw`.", "question_id": 5272}
{"snippet": "json.dump(obj, fp, **kw, check_circular=True)", "intent": "Serialize `obj` as a JSON formatted stream to `fp` ( a .write ( ) -supporting file-like object ) using this conversion table . If `check_circular` is false ( default : True ) , then the circular reference check for container types will be skipped and a circular reference will result in an OverflowError ( or worse ) . With arguments `**kw`.", "question_id": 5273}
{"snippet": "json.dump(obj, fp, **kw, allow_nan=True)", "intent": "Serialize `obj` as a JSON formatted stream to `fp` ( a .write ( ) -supporting file-like object ) using this conversion table . If `allow_nan` is false ( default : True ) , then it will be a ValueError to serialize out of range float values ( nan , inf , -inf ) in strict compliance of the JSON specification . With arguments `**kw`.", "question_id": 5274}
{"snippet": "json.dump(obj, fp, **kw, cls=None)", "intent": "Serialize `obj` as a JSON formatted stream to `fp` ( a .write ( ) -supporting file-like object ) using this conversion table . one that overrides the default ( ) method to serialize additional types ) , specify it with the `cls` kwarg ; otherwise JSONEncoder is used . With arguments `**kw`.", "question_id": 5275}
{"snippet": "json.dump(obj, fp, **kw, indent=None)", "intent": "Serialize `obj` as a JSON formatted stream to `fp` ( a .write ( ) -supporting file-like object ) using this conversion table . If `indent` is a non-negative integer or string , then JSON array elements and object members will be pretty-printed with that indent level . With arguments `**kw`.", "question_id": 5276}
{"snippet": "json.dump(obj, fp, **kw, separators=None)", "intent": "Serialize `obj` as a JSON formatted stream to `fp` ( a .write ( ) -supporting file-like object ) using this conversion table . If specified , `separators` should be an ( item_separator , key_separator ) tuple . With arguments `**kw`.", "question_id": 5277}
{"snippet": "json.dump(obj, fp, **kw, default=None)", "intent": "Serialize `obj` as a JSON formatted stream to `fp` ( a .write ( ) -supporting file-like object ) using this conversion table . If `skipkeys` is true ( `default` : False ) , then dict keys that are not of a basic type ( str , int , float , bool , None ) will be skipped instead of raising a TypeError . With arguments `**kw`.", "question_id": 5278}
{"snippet": "json.dump(obj, fp, **kw, sort_keys=False)", "intent": "Serialize `obj` as a JSON formatted stream to `fp` ( a .write ( ) -supporting file-like object ) using this conversion table . If `sort_keys` is true ( default : False ) , then the output of dictionaries will be sorted by key . With arguments `**kw`.", "question_id": 5279}
{"snippet": "json.dumps(obj, **kw)", "intent": "Serialize `obj` to a JSON formatted str using this conversion table . With arguments `**kw`.", "question_id": 5280}
{"snippet": "json.dumps(obj, **kw, skipkeys=False)", "intent": "Serialize `obj` to a JSON formatted str using this conversion table . With arguments `**kw`, `skipkeys`.", "question_id": 5281}
{"snippet": "json.dumps(obj, **kw, ensure_ascii=True)", "intent": "Serialize `obj` to a JSON formatted str using this conversion table . With arguments `**kw`, `ensure_ascii`.", "question_id": 5282}
{"snippet": "json.dumps(obj, **kw, check_circular=True)", "intent": "Serialize `obj` to a JSON formatted str using this conversion table . With arguments `**kw`, `check_circular`.", "question_id": 5283}
{"snippet": "json.dumps(obj, **kw, allow_nan=True)", "intent": "Serialize `obj` to a JSON formatted str using this conversion table . With arguments `**kw`, `allow_nan`.", "question_id": 5284}
{"snippet": "json.dumps(obj, **kw, cls=None)", "intent": "Serialize `obj` to a JSON formatted str using this conversion table . With arguments `**kw`, `cls`.", "question_id": 5285}
{"snippet": "json.dumps(obj, **kw, indent=None)", "intent": "Serialize `obj` to a JSON formatted str using this conversion table . With arguments `**kw`, `indent`.", "question_id": 5286}
{"snippet": "json.dumps(obj, **kw, separators=None)", "intent": "Serialize `obj` to a JSON formatted str using this conversion table . With arguments `**kw`, `separators`.", "question_id": 5287}
{"snippet": "json.dumps(obj, **kw, default=None)", "intent": "Serialize `obj` to a JSON formatted str using this conversion table . With arguments `**kw`, `default`.", "question_id": 5288}
{"snippet": "json.dumps(obj, **kw, sort_keys=False)", "intent": "Serialize `obj` to a JSON formatted str using this conversion table . With arguments `**kw`, `sort_keys`.", "question_id": 5289}
{"snippet": "json.load(fp, **kw)", "intent": "Deserialize `fp` ( a .read ( ) -supporting text file or binary file containing a JSON document ) to a Python object using this conversion table . With arguments `**kw`.", "question_id": 5290}
{"snippet": "json.load(fp, **kw, cls=None)", "intent": "Deserialize `fp` ( a .read ( ) -supporting text file or binary file containing a JSON document ) to a Python object using this conversion table . To use a custom JSONDecoder subclass , specify it with the `cls` kwarg ; otherwise JSONDecoder is used . With arguments `**kw`.", "question_id": 5291}
{"snippet": "json.load(fp, **kw, object_hook=None)", "intent": "Deserialize `fp` ( a .read ( ) -supporting text file or binary file containing a JSON document ) to a Python object using this conversion table . `object_hook` is an optional function that will be called with the result of any object literal decoded ( a dict ) . With arguments `**kw`.", "question_id": 5292}
{"snippet": "json.load(fp, **kw, parse_float=None)", "intent": "Deserialize `fp` ( a .read ( ) -supporting text file or binary file containing a JSON document ) to a Python object using this conversion table . `parse_float` , if specified , will be called with the string of every JSON float to be decoded . With arguments `**kw`.", "question_id": 5293}
{"snippet": "json.load(fp, **kw, parse_int=None)", "intent": "Deserialize `fp` ( a .read ( ) -supporting text file or binary file containing a JSON document ) to a Python object using this conversion table . `parse_int` , if specified , will be called with the string of every JSON int to be decoded . With arguments `**kw`.", "question_id": 5294}
{"snippet": "json.load(fp, **kw, parse_constant=None)", "intent": "Deserialize `fp` ( a .read ( ) -supporting text file or binary file containing a JSON document ) to a Python object using this conversion table . `parse_constant` , if specified , will be called with one of the following strings : '-Infinity ' , 'Infinity ' , 'NaN ' . With arguments `**kw`.", "question_id": 5295}
{"snippet": "json.load(fp, **kw, object_pairs_hook=None)", "intent": "Deserialize `fp` ( a .read ( ) -supporting text file or binary file containing a JSON document ) to a Python object using this conversion table . `object_pairs_hook` is an optional function that will be called with the result of any object literal decoded with an ordered list of pairs . With arguments `**kw`.", "question_id": 5296}
{"snippet": "json.load(fp, **kw, cls=None, object_hook=None)", "intent": "Deserialize `fp` ( a .read ( ) -supporting text file or binary file containing a JSON document ) to a Python object using this conversion table . To use a custom JSONDecoder subclass , specify it with the `cls` kwarg ; otherwise JSONDecoder is used . `object_hook` is an optional function that will be called with the result of any object literal decoded ( a dict ) . With arguments `**kw`.", "question_id": 5297}
{"snippet": "json.load(fp, **kw, cls=None, parse_float=None)", "intent": "Deserialize `fp` ( a .read ( ) -supporting text file or binary file containing a JSON document ) to a Python object using this conversion table . To use a custom JSONDecoder subclass , specify it with the `cls` kwarg ; otherwise JSONDecoder is used . `parse_float` , if specified , will be called with the string of every JSON float to be decoded . With arguments `**kw`.", "question_id": 5298}
{"snippet": "json.load(fp, **kw, cls=None, parse_int=None)", "intent": "Deserialize `fp` ( a .read ( ) -supporting text file or binary file containing a JSON document ) to a Python object using this conversion table . To use a custom JSONDecoder subclass , specify it with the `cls` kwarg ; otherwise JSONDecoder is used . `parse_int` , if specified , will be called with the string of every JSON int to be decoded . With arguments `**kw`.", "question_id": 5299}
{"snippet": "json.loads(s, **kw)", "intent": "Deserialize `s` ( a str , bytes or bytearray instance containing a JSON document ) to a Python object using this conversion table . With arguments `**kw`.", "question_id": 5300}
{"snippet": "json.loads(s, **kw, encoding=None)", "intent": "Deserialize `s` ( a str , bytes or bytearray instance containing a JSON document ) to a Python object using this conversion table . The other arguments have the same meaning as in load ( ) , except `encoding` which is ignored and deprecated . With arguments `**kw`.", "question_id": 5301}
{"snippet": "json.loads(s, **kw, cls=None)", "intent": "Deserialize `s` ( a str , bytes or bytearray instance containing a JSON document ) to a Python object using this conversion table . With arguments `**kw`, `cls`.", "question_id": 5302}
{"snippet": "json.loads(s, **kw, object_hook=None)", "intent": "Deserialize `s` ( a str , bytes or bytearray instance containing a JSON document ) to a Python object using this conversion table . With arguments `**kw`, `object_hook`.", "question_id": 5303}
{"snippet": "json.loads(s, **kw, parse_float=None)", "intent": "Deserialize `s` ( a str , bytes or bytearray instance containing a JSON document ) to a Python object using this conversion table . With arguments `**kw`, `parse_float`.", "question_id": 5304}
{"snippet": "json.loads(s, **kw, parse_int=None)", "intent": "Deserialize `s` ( a str , bytes or bytearray instance containing a JSON document ) to a Python object using this conversion table . With arguments `**kw`, `parse_int`.", "question_id": 5305}
{"snippet": "json.loads(s, **kw, parse_constant=None)", "intent": "Deserialize `s` ( a str , bytes or bytearray instance containing a JSON document ) to a Python object using this conversion table . With arguments `**kw`, `parse_constant`.", "question_id": 5306}
{"snippet": "json.loads(s, **kw, object_pairs_hook=None)", "intent": "Deserialize `s` ( a str , bytes or bytearray instance containing a JSON document ) to a Python object using this conversion table . With arguments `**kw`, `object_pairs_hook`.", "question_id": 5307}
{"snippet": "json.loads(s, **kw, encoding=None, cls=None)", "intent": "Deserialize `s` ( a str , bytes or bytearray instance containing a JSON document ) to a Python object using this conversion table . The other arguments have the same meaning as in load ( ) , except `encoding` which is ignored and deprecated . With arguments `**kw`, `cls`.", "question_id": 5308}
{"snippet": "json.loads(s, **kw, encoding=None, object_hook=None)", "intent": "Deserialize `s` ( a str , bytes or bytearray instance containing a JSON document ) to a Python object using this conversion table . The other arguments have the same meaning as in load ( ) , except `encoding` which is ignored and deprecated . With arguments `**kw`, `object_hook`.", "question_id": 5309}
{"snippet": "json.JSONDecoder()", "intent": "Simple JSON decoder .", "question_id": 5310}
{"snippet": "json.JSONDecoder(object_hook=None)", "intent": "Simple JSON decoder . `object_hook` , if specified , will be called with the result of every JSON object decoded and its return value will be used in place of the given dict .", "question_id": 5311}
{"snippet": "json.JSONDecoder(parse_float=None)", "intent": "Simple JSON decoder . `parse_float` , if specified , will be called with the string of every JSON float to be decoded .", "question_id": 5312}
{"snippet": "json.JSONDecoder(parse_int=None)", "intent": "Simple JSON decoder . `parse_int` , if specified , will be called with the string of every JSON int to be decoded .", "question_id": 5313}
{"snippet": "json.JSONDecoder(parse_constant=None)", "intent": "Simple JSON decoder . `parse_constant` , if specified , will be called with one of the following strings : '-Infinity ' , 'Infinity ' , 'NaN ' .", "question_id": 5314}
{"snippet": "json.JSONDecoder(strict=True)", "intent": "Simple JSON decoder . If `strict` is false ( True is the default ) , then control characters will be allowed inside strings .", "question_id": 5315}
{"snippet": "json.JSONDecoder(object_pairs_hook=None)", "intent": "Simple JSON decoder . `object_pairs_hook` , if specified will be called with the result of every JSON object decoded with an ordered list of pairs .", "question_id": 5316}
{"snippet": "json.JSONDecoder(object_hook=None, parse_float=None)", "intent": "Simple JSON decoder . `object_hook` , if specified , will be called with the result of every JSON object decoded and its return value will be used in place of the given dict . `parse_float` , if specified , will be called with the string of every JSON float to be decoded .", "question_id": 5317}
{"snippet": "json.JSONDecoder(object_hook=None, parse_int=None)", "intent": "Simple JSON decoder . `object_hook` , if specified , will be called with the result of every JSON object decoded and its return value will be used in place of the given dict . `parse_int` , if specified , will be called with the string of every JSON int to be decoded .", "question_id": 5318}
{"snippet": "json.JSONDecoder(object_hook=None, parse_constant=None)", "intent": "Simple JSON decoder . `object_hook` , if specified , will be called with the result of every JSON object decoded and its return value will be used in place of the given dict . `parse_constant` , if specified , will be called with one of the following strings : '-Infinity ' , 'Infinity ' , 'NaN ' .", "question_id": 5319}
{"snippet": "json_decoder.decode(s)", "intent": "Return the Python representation of `s` ( a str instance containing a JSON document ) .", "question_id": 5320}
{"snippet": "json_decoder.raw_decode(s)", "intent": "Decode a JSON document from `s` ( a str beginning with a JSON document ) and return a 2-tuple of the Python representation and the index in s where the document ended .", "question_id": 5321}
{"snippet": "json.JSONEncoder()", "intent": "Extensible JSON encoder for Python data structures .", "question_id": 5322}
{"snippet": "json.JSONEncoder(skipkeys=False)", "intent": "Extensible JSON encoder for Python data structures . If `skipkeys` is false ( the default ) , then it is a TypeError to attempt encoding of keys that are not str , int , float or None .", "question_id": 5323}
{"snippet": "json.JSONEncoder(ensure_ascii=True)", "intent": "Extensible JSON encoder for Python data structures . If `ensure_ascii` is true ( the default ) , the output is guaranteed to have all incoming non-ASCII characters escaped .", "question_id": 5324}
{"snippet": "json.JSONEncoder(check_circular=True)", "intent": "Extensible JSON encoder for Python data structures . If `check_circular` is true ( the default ) , then lists , dicts , and custom encoded objects will be checked for circular references during encoding to prevent an infinite recursion ( which would cause an OverflowError ) .", "question_id": 5325}
{"snippet": "json.JSONEncoder(allow_nan=True)", "intent": "Extensible JSON encoder for Python data structures . If `allow_nan` is true ( the default ) , then NaN , Infinity , and -Infinity will be encoded as such .", "question_id": 5326}
{"snippet": "json.JSONEncoder(sort_keys=False)", "intent": "Extensible JSON encoder for Python data structures . If `sort_keys` is true ( default : False ) , then the output of dictionaries will be sorted by key ; this is useful for regression tests to ensure that JSON serializations can be compared on a day-to-day basis .", "question_id": 5327}
{"snippet": "json.JSONEncoder(indent=None)", "intent": "Extensible JSON encoder for Python data structures . If `indent` is a non-negative integer or string , then JSON array elements and object members will be pretty-printed with that indent level .", "question_id": 5328}
{"snippet": "json.JSONEncoder(separators=None)", "intent": "Extensible JSON encoder for Python data structures . If specified , `separators` should be an ( item_separator , key_separator ) tuple .", "question_id": 5329}
{"snippet": "json.JSONEncoder(default=None)", "intent": "Extensible JSON encoder for Python data structures . Supports the following objects and types by `default` :", "question_id": 5330}
{"snippet": "json.JSONEncoder(skipkeys=False, ensure_ascii=True)", "intent": "Extensible JSON encoder for Python data structures . If `skipkeys` is false ( the default ) , then it is a TypeError to attempt encoding of keys that are not str , int , float or None . If `ensure_ascii` is true ( the default ) , the output is guaranteed to have all incoming non-ASCII characters escaped .", "question_id": 5331}
{"snippet": "json_encoder.default(o)", "intent": "Implement this method in a subclass such that it returns a serializable object for `o` , or calls the base implementation ( to raise a TypeError ) .", "question_id": 5332}
{"snippet": "json_encoder.encode(o)", "intent": "Return a JSON string representation of a Python data structure , `o` .", "question_id": 5333}
{"snippet": "json_encoder.iterencode(o)", "intent": "Encode the given object , `o` , and yield each string representation as available .", "question_id": 5334}
{"snippet": "json.JSONDecodeError(msg, doc, pos)", "intent": "Subclass of ValueError with the following additional attributes : With arguments `msg`, `doc`, `pos`.", "question_id": 5335}
{"snippet": "json_encoder.msg", "intent": "The unformatted error message.", "question_id": 5336}
{"snippet": "json_encoder.doc", "intent": "The JSON document being parsed.", "question_id": 5337}
{"snippet": "json_encoder.pos", "intent": "The start index of doc where parsing failed.", "question_id": 5338}
{"snippet": "json_encoder.lineno", "intent": "The line corresponding to pos.", "question_id": 5339}
{"snippet": "json_encoder.colno", "intent": "The column corresponding to pos.", "question_id": 5340}
{"snippet": "keyword.iskeyword(s)", "intent": "Return true if `s` is a Python keyword .", "question_id": 5341}
{"snippet": "keyword.kwlist", "intent": "Sequence containing all the keywords defined for the interpreter.", "question_id": 5342}
{"snippet": "linecache.getline(filename, lineno)", "intent": "Get line `lineno` from file named `filename` .", "question_id": 5343}
{"snippet": "linecache.getline(filename, lineno, module_globals=None)", "intent": "Get line `lineno` from file named `filename` . If a file named filename is not found , the function will look for it in the module search path , sys.path , after first checking for a PEP 302 __loader__ in `module_globals` , in case the module was imported from a zipfile or other non-filesystem import source .", "question_id": 5344}
{"snippet": "linecache.clearcache()", "intent": "Clear the cache .", "question_id": 5345}
{"snippet": "linecache.checkcache()", "intent": "Check the cache for validity .", "question_id": 5346}
{"snippet": "linecache.checkcache(filename=None)", "intent": "Check the cache for validity . If `filename` is omitted , it will check all the entries in the cache .", "question_id": 5347}
{"snippet": "linecache.lazycache(filename, module_globals)", "intent": "Capture enough detail about a non-file-based module to permit getting its lines later via getline ( ) even if `module_globals` is None in the later call . With arguments `filename`.", "question_id": 5348}
{"snippet": "locale.Error", "intent": "Exception raised when the locale passed to setlocale() is not recognized.", "question_id": 5349}
{"snippet": "locale.setlocale(category)", "intent": "If `locale` is given and not None , setlocale ( ) modifies the locale setting for the `category` .", "question_id": 5350}
{"snippet": "locale.setlocale(category, locale=None)", "intent": "If `locale` is given and not None , setlocale ( ) modifies the locale setting for the `category` .", "question_id": 5351}
{"snippet": "locale.localeconv()", "intent": "Returns the database of the local conventions as a dictionary .", "question_id": 5352}
{"snippet": "locale.nl_langinfo(option)", "intent": "Return some locale-specific information as a string . With arguments `option`.", "question_id": 5353}
{"snippet": "locale.CODESET", "intent": "Get a string with the name of the character encoding used in the selected locale.", "question_id": 5354}
{"snippet": "locale.D_T_FMT", "intent": "Get a string that can be used as a format string for time.strftime() to represent date and time in a locale-specific way.", "question_id": 5355}
{"snippet": "locale.D_FMT", "intent": "Get a string that can be used as a format string for time.strftime() to represent a date in a locale-specific way.", "question_id": 5356}
{"snippet": "locale.T_FMT", "intent": "Get a string that can be used as a format string for time.strftime() to represent a time in a locale-specific way.", "question_id": 5357}
{"snippet": "locale.T_FMT_AMPM", "intent": "Get a format string for time.strftime() to represent time in the am/pm format.", "question_id": 5358}
{"snippet": "DAY_1 ... DAY_7", "intent": "Get the name of the n-th day of the week.", "question_id": 5359}
{"snippet": "ABDAY_1 ... ABDAY_7", "intent": "Get the abbreviated name of the n-th day of the week.", "question_id": 5360}
{"snippet": "MON_1 ... MON_12", "intent": "Get the name of the n-th month.", "question_id": 5361}
{"snippet": "ABMON_1 ... ABMON_12", "intent": "Get the abbreviated name of the n-th month.", "question_id": 5362}
{"snippet": "locale.RADIXCHAR", "intent": "Get the radix character (decimal dot, decimal comma, etc.", "question_id": 5363}
{"snippet": "locale.THOUSEP", "intent": "Get the separator character for thousands (groups of three digits).", "question_id": 5364}
{"snippet": "locale.YESEXPR", "intent": "Get a regular expression that can be used with the regex function to recognize a positive response to a yes/no question.", "question_id": 5365}
{"snippet": "locale.NOEXPR", "intent": "Get a regular expression that can be used with the regex(3) function to recognize a negative response to a yes/no question.", "question_id": 5366}
{"snippet": "locale.CRNCYSTR", "intent": "Get the currency symbol, preceded by \u201c-\u201d if the symbol should appear before the value, \u201c+\u201d if the symbol should appear after the value, or \u201c.\u201d if the symbol should replace the radix character.", "question_id": 5367}
{"snippet": "locale.ERA", "intent": "Get a string that represents the era used in the current locale.", "question_id": 5368}
{"snippet": "locale.ERA_D_T_FMT", "intent": "Get a format string for time.strftime() to represent date and time in a locale-specific era-based way.", "question_id": 5369}
{"snippet": "locale.ERA_D_FMT", "intent": "Get a format string for time.strftime() to represent a date in a locale-specific era-based way.", "question_id": 5370}
{"snippet": "locale.ERA_T_FMT", "intent": "Get a format string for time.strftime() to represent a time in a locale-specific era-based way.", "question_id": 5371}
{"snippet": "locale.ALT_DIGITS", "intent": "Get a representation of up to 100 values used to represent the values 0 to 99.", "question_id": 5372}
{"snippet": "locale.getdefaultlocale(envvars)", "intent": "Tries to determine the default locale settings and returns them as a tuple of the form ( language code , encoding ) . To maintain compatibility with other platforms , not only the LANG variable is tested , but a list of variables given as `envvars` parameter .", "question_id": 5373}
{"snippet": "locale.getdefaultlocale()", "intent": "Tries to determine the default locale settings and returns them as a tuple of the form ( language code , encoding ) .", "question_id": 5374}
{"snippet": "locale.getlocale()", "intent": "Returns the current setting for the given locale `category` as sequence containing language code , encoding .", "question_id": 5375}
{"snippet": "locale.getlocale(category=LC_CTYPE)", "intent": "Returns the current setting for the given locale `category` as sequence containing language code , encoding .", "question_id": 5376}
{"snippet": "locale.getpreferredencoding()", "intent": "Return the encoding used for text data , according to user preferences .", "question_id": 5377}
{"snippet": "locale.getpreferredencoding(do_setlocale=True)", "intent": "Return the encoding used for text data , according to user preferences . If invoking setlocale is not necessary or desired , `do_setlocale` should be set to False .", "question_id": 5378}
{"snippet": "locale.normalize(localename)", "intent": "Returns a normalized locale code for the given locale name . With arguments `localename`.", "question_id": 5379}
{"snippet": "locale.resetlocale()", "intent": "Sets the locale for `category` to the default setting .", "question_id": 5380}
{"snippet": "locale.resetlocale(category=LC_ALL)", "intent": "Sets the locale for `category` to the default setting .", "question_id": 5381}
{"snippet": "locale.strcoll(string1, string2)", "intent": "Compares two strings according to the current LC_COLLATE setting . As any other compare function , returns a negative , or a positive value , or 0 , depending on whether `string1` collates before or after `string2` or is equal to it .", "question_id": 5382}
{"snippet": "locale.strxfrm(string)", "intent": "Transforms a `string` to one that can be used in locale-aware comparisons .", "question_id": 5383}
{"snippet": "locale.format_string(format, val)", "intent": "Formats a number `val` according to the current LC_NUMERIC setting . The `format` follows the conventions of the % operator .", "question_id": 5384}
{"snippet": "locale.format_string(format, val, grouping=False)", "intent": "Formats a number `val` according to the current LC_NUMERIC setting . The `format` follows the conventions of the % operator . If `grouping` is true , also takes the grouping into account .", "question_id": 5385}
{"snippet": "locale.format_string(format, val, monetary=False)", "intent": "Formats a number `val` according to the current LC_NUMERIC setting . The `format` follows the conventions of the % operator . If `monetary` is true , the conversion uses monetary thousands separator and grouping strings .", "question_id": 5386}
{"snippet": "locale.format_string(format, val, grouping=False, monetary=False)", "intent": "Formats a number `val` according to the current LC_NUMERIC setting . The `format` follows the conventions of the % operator . If `grouping` is true , also takes the grouping into account . If `monetary` is true , the conversion uses monetary thousands separator and grouping strings .", "question_id": 5387}
{"snippet": "locale.format(format, val)", "intent": "Please note that this function works like format_string ( ) but will only work for exactly one % char specifier . For whole `format` strings , use format_string ( ) . With arguments `val`.", "question_id": 5388}
{"snippet": "locale.format(format, val, grouping=False)", "intent": "Please note that this function works like format_string ( ) but will only work for exactly one % char specifier . For whole `format` strings , use format_string ( ) . With arguments `val`, `grouping`.", "question_id": 5389}
{"snippet": "locale.format(format, val, monetary=False)", "intent": "Please note that this function works like format_string ( ) but will only work for exactly one % char specifier . For whole `format` strings , use format_string ( ) . With arguments `val`, `monetary`.", "question_id": 5390}
{"snippet": "locale.format(format, val, grouping=False, monetary=False)", "intent": "Please note that this function works like format_string ( ) but will only work for exactly one % char specifier . For whole `format` strings , use format_string ( ) . With arguments `val`, `grouping`, `monetary`.", "question_id": 5391}
{"snippet": "locale.currency(val)", "intent": "Formats a number `val` according to the current LC_MONETARY settings .", "question_id": 5392}
{"snippet": "locale.currency(val, symbol=True)", "intent": "Formats a number `val` according to the current LC_MONETARY settings . The returned string includes the currency `symbol` if symbol is true , which is the default .", "question_id": 5393}
{"snippet": "locale.currency(val, grouping=False)", "intent": "Formats a number `val` according to the current LC_MONETARY settings . If `grouping` is true ( which is not the default ) , grouping is done with the value .", "question_id": 5394}
{"snippet": "locale.currency(val, international=False)", "intent": "Formats a number `val` according to the current LC_MONETARY settings . If `international` is true ( which is not the default ) , the international currency symbol is used .", "question_id": 5395}
{"snippet": "locale.currency(val, symbol=True, grouping=False)", "intent": "Formats a number `val` according to the current LC_MONETARY settings . The returned string includes the currency `symbol` if symbol is true , which is the default . If `grouping` is true ( which is not the default ) , grouping is done with the value .", "question_id": 5396}
{"snippet": "locale.currency(val, symbol=True, international=False)", "intent": "Formats a number `val` according to the current LC_MONETARY settings . The returned string includes the currency `symbol` if symbol is true , which is the default . If `international` is true ( which is not the default ) , the international currency symbol is used .", "question_id": 5397}
{"snippet": "locale.currency(val, grouping=False, international=False)", "intent": "Formats a number `val` according to the current LC_MONETARY settings . If `grouping` is true ( which is not the default ) , grouping is done with the value . If `international` is true ( which is not the default ) , the international currency symbol is used .", "question_id": 5398}
{"snippet": "locale.currency(val, symbol=True, grouping=False, international=False)", "intent": "Formats a number `val` according to the current LC_MONETARY settings . The returned string includes the currency `symbol` if symbol is true , which is the default . If `grouping` is true ( which is not the default ) , grouping is done with the value . If `international` is true ( which is not the default ) , the international currency symbol is used .", "question_id": 5399}
{"snippet": "locale.str(float)", "intent": "Formats a floating point number using the same format as the built-in function str ( `float` ) , but takes the decimal point into account .", "question_id": 5400}
{"snippet": "locale.delocalize(string)", "intent": "Converts a `string` into a normalized number string , following the LC_NUMERIC settings .", "question_id": 5401}
{"snippet": "locale.atof(string)", "intent": "Converts a `string` to a floating point number , following the LC_NUMERIC settings .", "question_id": 5402}
{"snippet": "locale.atoi(string)", "intent": "Converts a `string` to an integer , following the LC_NUMERIC conventions .", "question_id": 5403}
{"snippet": "locale.LC_CTYPE", "intent": "Locale category for the character type functions.", "question_id": 5404}
{"snippet": "locale.LC_COLLATE", "intent": "Locale category for sorting strings.", "question_id": 5405}
{"snippet": "locale.LC_TIME", "intent": "Locale category for the formatting of time.", "question_id": 5406}
{"snippet": "locale.LC_MONETARY", "intent": "Locale category for formatting of monetary values.", "question_id": 5407}
{"snippet": "locale.LC_MESSAGES", "intent": "Locale category for message display.", "question_id": 5408}
{"snippet": "locale.LC_NUMERIC", "intent": "Locale category for formatting numbers.", "question_id": 5409}
{"snippet": "locale.LC_ALL", "intent": "Combination of all locale settings.", "question_id": 5410}
{"snippet": "locale.CHAR_MAX", "intent": "This is a symbolic constant used for different values returned by localeconv().", "question_id": 5411}
{"snippet": "logging.config.fileConfig(fname)", "intent": "Reads the logging configuration from a configparser-format file . With arguments `fname`.", "question_id": 5412}
{"snippet": "logging.config.fileConfig(fname, defaults=None)", "intent": "Reads the logging configuration from a configparser-format file . With arguments `fname`, `defaults`.", "question_id": 5413}
{"snippet": "logging.config.fileConfig(fname, disable_existing_loggers=True)", "intent": "Reads the logging configuration from a configparser-format file . With arguments `fname`, `disable_existing_loggers`.", "question_id": 5414}
{"snippet": "logging.config.fileConfig(fname, defaults=None, disable_existing_loggers=True)", "intent": "Reads the logging configuration from a configparser-format file . With arguments `fname`, `defaults`, `disable_existing_loggers`.", "question_id": 5415}
{"snippet": "logging.config.listen()", "intent": "Starts up a socket server on the specified `port` , and listens for new configurations .", "question_id": 5416}
{"snippet": "logging.config.listen(port=DEFAULT_LOGGING_CONFIG_PORT)", "intent": "Starts up a socket server on the specified `port` , and listens for new configurations .", "question_id": 5417}
{"snippet": "logging.config.listen(verify=None)", "intent": "Starts up a socket server on the specified `port` , and listens for new configurations . The `verify` argument , if specified , should be a callable which should verify whether bytes received across the socket are valid and should be processed .", "question_id": 5418}
{"snippet": "logging.config.listen(port=DEFAULT_LOGGING_CONFIG_PORT, verify=None)", "intent": "Starts up a socket server on the specified `port` , and listens for new configurations . The `verify` argument , if specified , should be a callable which should verify whether bytes received across the socket are valid and should be processed .", "question_id": 5419}
{"snippet": "logging.config.stopListening()", "intent": "Stops the listening server which was created with a call to listen ( ) .", "question_id": 5420}
{"snippet": "logging.StreamHandler()", "intent": "Returns a new instance of the StreamHandler class .", "question_id": 5421}
{"snippet": "logging.StreamHandler(stream=None)", "intent": "Returns a new instance of the StreamHandler class . If `stream` is specified , the instance will use it for logging output ; otherwise , sys.stderr will be used .", "question_id": 5422}
{"snippet": "stream_handler.emit(record)", "intent": "If a formatter is specified , it is used to format the `record` .", "question_id": 5423}
{"snippet": "stream_handler.flush()", "intent": "Flushes the stream by calling its flush ( ) method .", "question_id": 5424}
{"snippet": "stream_handler.setStream(stream)", "intent": "Sets the instance \u2019 s `stream` to the specified value , if it is different .", "question_id": 5425}
{"snippet": "logging.FileHandler(filename)", "intent": "Returns a new instance of the FileHandler class . With arguments `filename`.", "question_id": 5426}
{"snippet": "logging.FileHandler(filename, mode='a')", "intent": "Returns a new instance of the FileHandler class . If `mode` is not specified , ' a ' is used . With arguments `filename`.", "question_id": 5427}
{"snippet": "logging.FileHandler(filename, encoding=None)", "intent": "Returns a new instance of the FileHandler class . If `encoding` is not None , it is used to open the file with that encoding . With arguments `filename`.", "question_id": 5428}
{"snippet": "logging.FileHandler(filename, delay=False)", "intent": "Returns a new instance of the FileHandler class . If `delay` is true , then file opening is deferred until the first call to emit ( ) . With arguments `filename`.", "question_id": 5429}
{"snippet": "logging.FileHandler(filename, mode='a', encoding=None)", "intent": "Returns a new instance of the FileHandler class . If `mode` is not specified , ' a ' is used . If `encoding` is not None , it is used to open the file with that encoding . With arguments `filename`.", "question_id": 5430}
{"snippet": "logging.FileHandler(filename, mode='a', delay=False)", "intent": "Returns a new instance of the FileHandler class . If `mode` is not specified , ' a ' is used . If `delay` is true , then file opening is deferred until the first call to emit ( ) . With arguments `filename`.", "question_id": 5431}
{"snippet": "logging.FileHandler(filename, encoding=None, delay=False)", "intent": "Returns a new instance of the FileHandler class . If `encoding` is not None , it is used to open the file with that encoding . If `delay` is true , then file opening is deferred until the first call to emit ( ) . With arguments `filename`.", "question_id": 5432}
{"snippet": "logging.FileHandler(filename, mode='a', encoding=None, delay=False)", "intent": "Returns a new instance of the FileHandler class . If `mode` is not specified , ' a ' is used . If `encoding` is not None , it is used to open the file with that encoding . If `delay` is true , then file opening is deferred until the first call to emit ( ) . With arguments `filename`.", "question_id": 5433}
{"snippet": "file_handler.close()", "intent": "Closes the file .", "question_id": 5434}
{"snippet": "file_handler.emit(record)", "intent": "Outputs the `record` to the file .", "question_id": 5435}
{"snippet": "logging.NullHandler", "intent": "Returns a new instance of the NullHandler class.", "question_id": 5436}
{"snippet": "null_handler.emit(record)", "intent": "This method does nothing . With arguments `record`.", "question_id": 5437}
{"snippet": "null_handler.handle(record)", "intent": "This method does nothing . With arguments `record`.", "question_id": 5438}
{"snippet": "null_handler.createLock()", "intent": "This method returns None for the lock , since there is no underlying I/O to which access needs to be serialized .", "question_id": 5439}
{"snippet": "logging.handlers.WatchedFileHandler(filename)", "intent": "Returns a new instance of the WatchedFileHandler class . With arguments `filename`.", "question_id": 5440}
{"snippet": "logging.handlers.WatchedFileHandler(filename, mode='a')", "intent": "Returns a new instance of the WatchedFileHandler class . If `mode` is not specified , ' a ' is used . With arguments `filename`.", "question_id": 5441}
{"snippet": "logging.handlers.WatchedFileHandler(filename, encoding=None)", "intent": "Returns a new instance of the WatchedFileHandler class . If `encoding` is not None , it is used to open the file with that encoding . With arguments `filename`.", "question_id": 5442}
{"snippet": "logging.handlers.WatchedFileHandler(filename, delay=False)", "intent": "Returns a new instance of the WatchedFileHandler class . If `delay` is true , then file opening is deferred until the first call to emit ( ) . With arguments `filename`.", "question_id": 5443}
{"snippet": "logging.handlers.WatchedFileHandler(filename, mode='a', encoding=None)", "intent": "Returns a new instance of the WatchedFileHandler class . If `mode` is not specified , ' a ' is used . If `encoding` is not None , it is used to open the file with that encoding . With arguments `filename`.", "question_id": 5444}
{"snippet": "logging.handlers.WatchedFileHandler(filename, mode='a', delay=False)", "intent": "Returns a new instance of the WatchedFileHandler class . If `mode` is not specified , ' a ' is used . If `delay` is true , then file opening is deferred until the first call to emit ( ) . With arguments `filename`.", "question_id": 5445}
{"snippet": "logging.handlers.WatchedFileHandler(filename, encoding=None, delay=False)", "intent": "Returns a new instance of the WatchedFileHandler class . If `encoding` is not None , it is used to open the file with that encoding . If `delay` is true , then file opening is deferred until the first call to emit ( ) . With arguments `filename`.", "question_id": 5446}
{"snippet": "logging.handlers.WatchedFileHandler(filename, mode='a', encoding=None, delay=False)", "intent": "Returns a new instance of the WatchedFileHandler class . If `mode` is not specified , ' a ' is used . If `encoding` is not None , it is used to open the file with that encoding . If `delay` is true , then file opening is deferred until the first call to emit ( ) . With arguments `filename`.", "question_id": 5447}
{"snippet": "watched_file_handler.reopenIfNeeded()", "intent": "Checks to see if the file has changed .", "question_id": 5448}
{"snippet": "watched_file_handler.emit(record)", "intent": "Outputs the `record` to the file , but first calls reopenIfNeeded ( ) to reopen the file if it has changed .", "question_id": 5449}
{"snippet": "logging.handlers.BaseRotatingHandler(filename, mode)", "intent": "The parameters are as for FileHandler . With arguments `filename`, `mode`.", "question_id": 5450}
{"snippet": "logging.handlers.BaseRotatingHandler(filename, mode, encoding=None)", "intent": "The parameters are as for FileHandler . With arguments `filename`, `mode`, `encoding`.", "question_id": 5451}
{"snippet": "logging.handlers.BaseRotatingHandler(filename, mode, delay=False)", "intent": "The parameters are as for FileHandler . With arguments `filename`, `mode`, `delay`.", "question_id": 5452}
{"snippet": "logging.handlers.BaseRotatingHandler(filename, mode, encoding=None, delay=False)", "intent": "The parameters are as for FileHandler . With arguments `filename`, `mode`, `encoding`, `delay`.", "question_id": 5453}
{"snippet": "base_rotating_handler.namer", "intent": "If this attribute is set to a callable, the rotation_filename() method delegates to this callable.", "question_id": 5454}
{"snippet": "base_rotating_handler.rotator", "intent": "If this attribute is set to a callable, the rotate() method delegates to this callable.", "question_id": 5455}
{"snippet": "base_rotating_handler.rotation_filename(default_name)", "intent": "Modify the filename of a log file when rotating . With arguments `default_name`.", "question_id": 5456}
{"snippet": "base_rotating_handler.rotate(source, dest)", "intent": "When rotating , rotate the current log . The default implementation calls the \u2018 rotator \u2019 attribute of the handler , if it \u2019 s callable , passing the `source` and `dest` arguments to it .", "question_id": 5457}
{"snippet": "logging.handlers.RotatingFileHandler(filename)", "intent": "Returns a new instance of the RotatingFileHandler class . When backupCount is non-zero , the system will save old log files by appending the extensions \u2018 .1 \u2019 , \u2018 .2 \u2019 etc. , to the `filename` .", "question_id": 5458}
{"snippet": "logging.handlers.RotatingFileHandler(filename, mode='a')", "intent": "Returns a new instance of the RotatingFileHandler class . When backupCount is non-zero , the system will save old log files by appending the extensions \u2018 .1 \u2019 , \u2018 .2 \u2019 etc. , to the `filename` . If `mode` is not specified , ' a ' is used .", "question_id": 5459}
{"snippet": "logging.handlers.RotatingFileHandler(filename, maxBytes=0)", "intent": "Returns a new instance of the RotatingFileHandler class . When backupCount is non-zero , the system will save old log files by appending the extensions \u2018 .1 \u2019 , \u2018 .2 \u2019 etc. , to the `filename` . You can use the `maxBytes` and `backupCount` values to allow the file to rollover at a predetermined size .", "question_id": 5460}
{"snippet": "logging.handlers.RotatingFileHandler(filename, backupCount=0)", "intent": "Returns a new instance of the RotatingFileHandler class . When backupCount is non-zero , the system will save old log files by appending the extensions \u2018 .1 \u2019 , \u2018 .2 \u2019 etc. , to the `filename` . You can use the `maxBytes` and `backupCount` values to allow the file to rollover at a predetermined size .", "question_id": 5461}
{"snippet": "logging.handlers.RotatingFileHandler(filename, encoding=None)", "intent": "Returns a new instance of the RotatingFileHandler class . When backupCount is non-zero , the system will save old log files by appending the extensions \u2018 .1 \u2019 , \u2018 .2 \u2019 etc. , to the `filename` . If `encoding` is not None , it is used to open the file with that encoding .", "question_id": 5462}
{"snippet": "logging.handlers.RotatingFileHandler(filename, delay=False)", "intent": "Returns a new instance of the RotatingFileHandler class . When backupCount is non-zero , the system will save old log files by appending the extensions \u2018 .1 \u2019 , \u2018 .2 \u2019 etc. , to the `filename` . If `delay` is true , then file opening is deferred until the first call to emit ( ) .", "question_id": 5463}
{"snippet": "logging.handlers.RotatingFileHandler(filename, mode='a', maxBytes=0)", "intent": "Returns a new instance of the RotatingFileHandler class . When backupCount is non-zero , the system will save old log files by appending the extensions \u2018 .1 \u2019 , \u2018 .2 \u2019 etc. , to the `filename` . If `mode` is not specified , ' a ' is used . You can use the `maxBytes` and `backupCount` values to allow the file to rollover at a predetermined size .", "question_id": 5464}
{"snippet": "logging.handlers.RotatingFileHandler(filename, mode='a', backupCount=0)", "intent": "Returns a new instance of the RotatingFileHandler class . When backupCount is non-zero , the system will save old log files by appending the extensions \u2018 .1 \u2019 , \u2018 .2 \u2019 etc. , to the `filename` . If `mode` is not specified , ' a ' is used . You can use the `maxBytes` and `backupCount` values to allow the file to rollover at a predetermined size .", "question_id": 5465}
{"snippet": "logging.handlers.RotatingFileHandler(filename, mode='a', encoding=None)", "intent": "Returns a new instance of the RotatingFileHandler class . When backupCount is non-zero , the system will save old log files by appending the extensions \u2018 .1 \u2019 , \u2018 .2 \u2019 etc. , to the `filename` . If `mode` is not specified , ' a ' is used . If `encoding` is not None , it is used to open the file with that encoding .", "question_id": 5466}
{"snippet": "logging.handlers.RotatingFileHandler(filename, mode='a', delay=False)", "intent": "Returns a new instance of the RotatingFileHandler class . When backupCount is non-zero , the system will save old log files by appending the extensions \u2018 .1 \u2019 , \u2018 .2 \u2019 etc. , to the `filename` . If `mode` is not specified , ' a ' is used . If `delay` is true , then file opening is deferred until the first call to emit ( ) .", "question_id": 5467}
{"snippet": "rotating_file_handler.doRollover()", "intent": "Does a rollover , as described above .", "question_id": 5468}
{"snippet": "rotating_file_handler.emit(record)", "intent": "Outputs the `record` to the file , catering for rollover as described previously .", "question_id": 5469}
{"snippet": "logging.handlers.TimedRotatingFileHandler(filename)", "intent": "Returns a new instance of the TimedRotatingFileHandler class . On rotating it also sets the `filename` suffix .", "question_id": 5470}
{"snippet": "logging.handlers.TimedRotatingFileHandler(filename, when='h')", "intent": "Returns a new instance of the TimedRotatingFileHandler class . On rotating it also sets the `filename` suffix . Rotating happens based on the product of `when` and `interval` .", "question_id": 5471}
{"snippet": "logging.handlers.TimedRotatingFileHandler(filename, interval=1)", "intent": "Returns a new instance of the TimedRotatingFileHandler class . On rotating it also sets the `filename` suffix . Rotating happens based on the product of `when` and `interval` .", "question_id": 5472}
{"snippet": "logging.handlers.TimedRotatingFileHandler(filename, backupCount=0)", "intent": "Returns a new instance of the TimedRotatingFileHandler class . On rotating it also sets the `filename` suffix . If `backupCount` is nonzero , at most backupCount files will be kept , and if more would be created when rollover occurs , the oldest one is deleted .", "question_id": 5473}
{"snippet": "logging.handlers.TimedRotatingFileHandler(filename, encoding=None)", "intent": "Returns a new instance of the TimedRotatingFileHandler class . On rotating it also sets the `filename` suffix . With arguments `encoding`.", "question_id": 5474}
{"snippet": "logging.handlers.TimedRotatingFileHandler(filename, delay=False)", "intent": "Returns a new instance of the TimedRotatingFileHandler class . On rotating it also sets the `filename` suffix . If `delay` is true , then file opening is deferred until the first call to emit ( ) .", "question_id": 5475}
{"snippet": "logging.handlers.TimedRotatingFileHandler(filename, utc=False)", "intent": "Returns a new instance of the TimedRotatingFileHandler class . On rotating it also sets the `filename` suffix . If the `utc` argument is true , times in UTC will be used ; otherwise local time is used .", "question_id": 5476}
{"snippet": "logging.handlers.TimedRotatingFileHandler(filename, atTime=None)", "intent": "Returns a new instance of the TimedRotatingFileHandler class . On rotating it also sets the `filename` suffix . If `atTime` is not None , it must be a datetime.time instance which specifies the time of day when rollover occurs , for the cases where rollover is set to happen \u201c at midnight \u201d or \u201c on a particular weekday \u201d .", "question_id": 5477}
{"snippet": "logging.handlers.TimedRotatingFileHandler(filename, when='h', interval=1)", "intent": "Returns a new instance of the TimedRotatingFileHandler class . On rotating it also sets the `filename` suffix . Rotating happens based on the product of `when` and `interval` .", "question_id": 5478}
{"snippet": "logging.handlers.TimedRotatingFileHandler(filename, when='h', backupCount=0)", "intent": "Returns a new instance of the TimedRotatingFileHandler class . On rotating it also sets the `filename` suffix . Rotating happens based on the product of `when` and `interval` . If `backupCount` is nonzero , at most backupCount files will be kept , and if more would be created when rollover occurs , the oldest one is deleted .", "question_id": 5479}
{"snippet": "timed_rotating_file_handler.doRollover()", "intent": "Does a rollover , as described above .", "question_id": 5480}
{"snippet": "timed_rotating_file_handler.emit(record)", "intent": "Outputs the `record` to the file , catering for rollover as described above .", "question_id": 5481}
{"snippet": "logging.handlers.SocketHandler(host, port)", "intent": "Returns a new instance of the SocketHandler class intended to communicate with a remote machine whose address is given by `host` and `port` .", "question_id": 5482}
{"snippet": "socket_handler.close()", "intent": "Closes the socket .", "question_id": 5483}
{"snippet": "socket_handler.emit()", "intent": "Pickles the record \u2019 s attribute dictionary and writes it to the socket in binary format .", "question_id": 5484}
{"snippet": "socket_handler.handleError()", "intent": "Handles an error which has occurred during emit ( ) .", "question_id": 5485}
{"snippet": "socket_handler.makeSocket()", "intent": "This is a factory method which allows subclasses to define the precise type of socket they want .", "question_id": 5486}
{"snippet": "socket_handler.makePickle(record)", "intent": "Pickles the `record` \u2019 s attribute dictionary in binary format with a length prefix , and returns it ready for transmission across the socket .", "question_id": 5487}
{"snippet": "socket_handler.send(packet)", "intent": "Send a pickled byte-string `packet` to the socket .", "question_id": 5488}
{"snippet": "socket_handler.createSocket()", "intent": "Tries to create a socket ; on failure , uses an exponential back-off algorithm .", "question_id": 5489}
{"snippet": "logging.handlers.DatagramHandler(host, port)", "intent": "Returns a new instance of the DatagramHandler class intended to communicate with a remote machine whose address is given by `host` and `port` .", "question_id": 5490}
{"snippet": "datagram_handler.emit()", "intent": "Pickles the record \u2019 s attribute dictionary and writes it to the socket in binary format .", "question_id": 5491}
{"snippet": "datagram_handler.makeSocket()", "intent": "The factory method of SocketHandler is here overridden to create a UDP socket ( socket.SOCK_DGRAM ) .", "question_id": 5492}
{"snippet": "datagram_handler.send(s)", "intent": "Send a pickled byte-string to a socket . With arguments `s`.", "question_id": 5493}
{"snippet": "logging.handlers.SysLogHandler(SYSLOG_UDP_PORT))", "intent": "Returns a new instance of the SysLogHandler class intended to communicate with a remote Unix machine whose `address` is given by address in the form of a ( host , port ) tuple . With arguments `SYSLOG_UDP_PORT)`.", "question_id": 5494}
{"snippet": "logging.handlers.SysLogHandler(SYSLOG_UDP_PORT), address=('localhost')", "intent": "Returns a new instance of the SysLogHandler class intended to communicate with a remote Unix machine whose `address` is given by address in the form of a ( host , port ) tuple . With arguments `SYSLOG_UDP_PORT)`.", "question_id": 5495}
{"snippet": "logging.handlers.SysLogHandler(SYSLOG_UDP_PORT), facility=LOG_USER)", "intent": "Returns a new instance of the SysLogHandler class intended to communicate with a remote Unix machine whose `address` is given by address in the form of a ( host , port ) tuple . If `facility` is not specified , LOG_USER is used . With arguments `SYSLOG_UDP_PORT)`.", "question_id": 5496}
{"snippet": "logging.handlers.SysLogHandler(SYSLOG_UDP_PORT), socktype=socket.SOCK_DGRAM)", "intent": "Returns a new instance of the SysLogHandler class intended to communicate with a remote Unix machine whose `address` is given by address in the form of a ( host , port ) tuple . The type of socket opened depends on the `socktype` argument , which defaults to socket.SOCK_DGRAM and thus opens a UDP socket . With arguments `SYSLOG_UDP_PORT)`.", "question_id": 5497}
{"snippet": "logging.handlers.SysLogHandler(SYSLOG_UDP_PORT), address=('localhost', facility=LOG_USER)", "intent": "Returns a new instance of the SysLogHandler class intended to communicate with a remote Unix machine whose `address` is given by address in the form of a ( host , port ) tuple . If `facility` is not specified , LOG_USER is used . With arguments `SYSLOG_UDP_PORT)`.", "question_id": 5498}
{"snippet": "logging.handlers.SysLogHandler(SYSLOG_UDP_PORT), address=('localhost', socktype=socket.SOCK_DGRAM)", "intent": "Returns a new instance of the SysLogHandler class intended to communicate with a remote Unix machine whose `address` is given by address in the form of a ( host , port ) tuple . The type of socket opened depends on the `socktype` argument , which defaults to socket.SOCK_DGRAM and thus opens a UDP socket . With arguments `SYSLOG_UDP_PORT)`.", "question_id": 5499}
{"snippet": "logging.handlers.SysLogHandler(SYSLOG_UDP_PORT), facility=LOG_USER, socktype=socket.SOCK_DGRAM)", "intent": "Returns a new instance of the SysLogHandler class intended to communicate with a remote Unix machine whose `address` is given by address in the form of a ( host , port ) tuple . If `facility` is not specified , LOG_USER is used . The type of socket opened depends on the `socktype` argument , which defaults to socket.SOCK_DGRAM and thus opens a UDP socket . With arguments `SYSLOG_UDP_PORT)`.", "question_id": 5500}
{"snippet": "logging.handlers.SysLogHandler(SYSLOG_UDP_PORT), address=('localhost', facility=LOG_USER, socktype=socket.SOCK_DGRAM)", "intent": "Returns a new instance of the SysLogHandler class intended to communicate with a remote Unix machine whose `address` is given by address in the form of a ( host , port ) tuple . If `facility` is not specified , LOG_USER is used . The type of socket opened depends on the `socktype` argument , which defaults to socket.SOCK_DGRAM and thus opens a UDP socket . With arguments `SYSLOG_UDP_PORT)`.", "question_id": 5501}
{"snippet": "sys_log_handler.close()", "intent": "Closes the socket to the remote host .", "question_id": 5502}
{"snippet": "sys_log_handler.emit(record)", "intent": "The `record` is formatted , and then sent to the syslog server .", "question_id": 5503}
{"snippet": "sys_log_handler.encodePriority(facility, priority)", "intent": "Encodes the `facility` and `priority` into an integer .", "question_id": 5504}
{"snippet": "sys_log_handler.mapPriority(levelname)", "intent": "Maps a logging level name to a syslog priority name . With arguments `levelname`.", "question_id": 5505}
{"snippet": "logging.handlers.NTEventLogHandler(appname)", "intent": "Returns a new instance of the NTEventLogHandler class . The `appname` is used to define the application name as it appears in the event log .", "question_id": 5506}
{"snippet": "logging.handlers.NTEventLogHandler(appname, dllname=None)", "intent": "Returns a new instance of the NTEventLogHandler class . The `appname` is used to define the application name as it appears in the event log . The `dllname` should give the fully qualified pathname of a .dll or .exe which contains message definitions to hold in the log ( if not specified , 'win32service.pyd ' is used - this is installed with the Win32 extensions and contains some basic placeholder message definitions .", "question_id": 5507}
{"snippet": "logging.handlers.NTEventLogHandler(appname, logtype='Application')", "intent": "Returns a new instance of the NTEventLogHandler class . The `appname` is used to define the application name as it appears in the event log . The `logtype` is one of 'Application ' , 'System ' or 'Security ' , and defaults to 'Application ' .", "question_id": 5508}
{"snippet": "logging.handlers.NTEventLogHandler(appname, dllname=None, logtype='Application')", "intent": "Returns a new instance of the NTEventLogHandler class . The `appname` is used to define the application name as it appears in the event log . The `dllname` should give the fully qualified pathname of a .dll or .exe which contains message definitions to hold in the log ( if not specified , 'win32service.pyd ' is used - this is installed with the Win32 extensions and contains some basic placeholder message definitions . The `logtype` is one of 'Application ' , 'System ' or 'Security ' , and defaults to 'Application ' .", "question_id": 5509}
{"snippet": "nt_event_log_handler.close()", "intent": "At this point , you can remove the application name from the registry as a source of event log entries .", "question_id": 5510}
{"snippet": "nt_event_log_handler.emit(record)", "intent": "Determines the message ID , event category and event type , and then logs the message in the NT event log . With arguments `record`.", "question_id": 5511}
{"snippet": "nt_event_log_handler.getEventCategory(record)", "intent": "Returns the event category for the `record` .", "question_id": 5512}
{"snippet": "nt_event_log_handler.getEventType(record)", "intent": "Returns the event type for the `record` .", "question_id": 5513}
{"snippet": "nt_event_log_handler.getMessageID(record)", "intent": "Returns the message ID for the `record` .", "question_id": 5514}
{"snippet": "logging.handlers.SMTPHandler(mailhost, fromaddr, toaddrs, subject)", "intent": "Returns a new instance of the SMTPHandler class . To specify a non-standard SMTP port , use the ( host , port ) tuple format for the `mailhost` argument . The `toaddrs` should be a list of strings . The instance is initialized with the from and to addresses and `subject` line of the email . With arguments `fromaddr`.", "question_id": 5515}
{"snippet": "logging.handlers.SMTPHandler(mailhost, fromaddr, toaddrs, subject, credentials=None)", "intent": "Returns a new instance of the SMTPHandler class . To specify a non-standard SMTP port , use the ( host , port ) tuple format for the `mailhost` argument . The `toaddrs` should be a list of strings . The instance is initialized with the from and to addresses and `subject` line of the email . If your SMTP server requires authentication , you can specify a ( username , password ) tuple for the `credentials` argument . With arguments `fromaddr`.", "question_id": 5516}
{"snippet": "logging.handlers.SMTPHandler(mailhost, fromaddr, toaddrs, subject, secure=None)", "intent": "Returns a new instance of the SMTPHandler class . To specify a non-standard SMTP port , use the ( host , port ) tuple format for the `mailhost` argument . The `toaddrs` should be a list of strings . The instance is initialized with the from and to addresses and `subject` line of the email . To specify the use of a `secure` protocol ( TLS ) , pass in a tuple to the secure argument . With arguments `fromaddr`.", "question_id": 5517}
{"snippet": "logging.handlers.SMTPHandler(mailhost, fromaddr, toaddrs, subject, timeout=1.0)", "intent": "Returns a new instance of the SMTPHandler class . To specify a non-standard SMTP port , use the ( host , port ) tuple format for the `mailhost` argument . The `toaddrs` should be a list of strings . The instance is initialized with the from and to addresses and `subject` line of the email . A `timeout` can be specified for communication with the SMTP server using the timeout argument . With arguments `fromaddr`.", "question_id": 5518}
{"snippet": "logging.handlers.SMTPHandler(mailhost, fromaddr, toaddrs, subject, credentials=None, secure=None)", "intent": "Returns a new instance of the SMTPHandler class . To specify a non-standard SMTP port , use the ( host , port ) tuple format for the `mailhost` argument . The `toaddrs` should be a list of strings . The instance is initialized with the from and to addresses and `subject` line of the email . If your SMTP server requires authentication , you can specify a ( username , password ) tuple for the `credentials` argument . To specify the use of a `secure` protocol ( TLS ) , pass in a tuple to the secure argument . With arguments `fromaddr`.", "question_id": 5519}
{"snippet": "logging.handlers.SMTPHandler(mailhost, fromaddr, toaddrs, subject, credentials=None, timeout=1.0)", "intent": "Returns a new instance of the SMTPHandler class . To specify a non-standard SMTP port , use the ( host , port ) tuple format for the `mailhost` argument . The `toaddrs` should be a list of strings . The instance is initialized with the from and to addresses and `subject` line of the email . If your SMTP server requires authentication , you can specify a ( username , password ) tuple for the `credentials` argument . A `timeout` can be specified for communication with the SMTP server using the timeout argument . With arguments `fromaddr`.", "question_id": 5520}
{"snippet": "logging.handlers.SMTPHandler(mailhost, fromaddr, toaddrs, subject, secure=None, timeout=1.0)", "intent": "Returns a new instance of the SMTPHandler class . To specify a non-standard SMTP port , use the ( host , port ) tuple format for the `mailhost` argument . The `toaddrs` should be a list of strings . The instance is initialized with the from and to addresses and `subject` line of the email . To specify the use of a `secure` protocol ( TLS ) , pass in a tuple to the secure argument . A `timeout` can be specified for communication with the SMTP server using the timeout argument . With arguments `fromaddr`.", "question_id": 5521}
{"snippet": "logging.handlers.SMTPHandler(mailhost, fromaddr, toaddrs, subject, credentials=None, secure=None, timeout=1.0)", "intent": "Returns a new instance of the SMTPHandler class . To specify a non-standard SMTP port , use the ( host , port ) tuple format for the `mailhost` argument . The `toaddrs` should be a list of strings . The instance is initialized with the from and to addresses and `subject` line of the email . If your SMTP server requires authentication , you can specify a ( username , password ) tuple for the `credentials` argument . To specify the use of a `secure` protocol ( TLS ) , pass in a tuple to the secure argument . A `timeout` can be specified for communication with the SMTP server using the timeout argument . With arguments `fromaddr`.", "question_id": 5522}
{"snippet": "smtp_handler.emit(record)", "intent": "Formats the `record` and sends it to the specified addressees .", "question_id": 5523}
{"snippet": "smtp_handler.getSubject(record)", "intent": "If you want to specify a subject line which is record-dependent , override this method . With arguments `record`.", "question_id": 5524}
{"snippet": "logging.handlers.BufferingHandler(capacity)", "intent": "Initializes the handler with a buffer of the specified `capacity` .", "question_id": 5525}
{"snippet": "buffering_handler.emit(record)", "intent": "Appends the `record` to the buffer .", "question_id": 5526}
{"snippet": "buffering_handler.flush()", "intent": "You can override this to implement custom flushing behavior .", "question_id": 5527}
{"snippet": "buffering_handler.shouldFlush(record)", "intent": "Returns true if the buffer is up to capacity . With arguments `record`.", "question_id": 5528}
{"snippet": "logging.handlers.MemoryHandler(capacity)", "intent": "Returns a new instance of the MemoryHandler class . The instance is initialized with a buffer size of `capacity` ( number of records buffered ) .", "question_id": 5529}
{"snippet": "logging.handlers.MemoryHandler(capacity, flushLevel=ERROR)", "intent": "Returns a new instance of the MemoryHandler class . The instance is initialized with a buffer size of `capacity` ( number of records buffered ) . If `flushLevel` is not specified , ERROR is used .", "question_id": 5530}
{"snippet": "logging.handlers.MemoryHandler(capacity, target=None)", "intent": "Returns a new instance of the MemoryHandler class . The instance is initialized with a buffer size of `capacity` ( number of records buffered ) . If no `target` is specified , the target will need to be set using setTarget ( ) before this handler does anything useful .", "question_id": 5531}
{"snippet": "logging.handlers.MemoryHandler(capacity, flushOnClose=True)", "intent": "Returns a new instance of the MemoryHandler class . The instance is initialized with a buffer size of `capacity` ( number of records buffered ) . If `flushOnClose` is specified as False , then the buffer is not flushed when the handler is closed .", "question_id": 5532}
{"snippet": "logging.handlers.MemoryHandler(capacity, flushLevel=ERROR, target=None)", "intent": "Returns a new instance of the MemoryHandler class . The instance is initialized with a buffer size of `capacity` ( number of records buffered ) . If `flushLevel` is not specified , ERROR is used . If no `target` is specified , the target will need to be set using setTarget ( ) before this handler does anything useful .", "question_id": 5533}
{"snippet": "logging.handlers.MemoryHandler(capacity, flushLevel=ERROR, flushOnClose=True)", "intent": "Returns a new instance of the MemoryHandler class . The instance is initialized with a buffer size of `capacity` ( number of records buffered ) . If `flushLevel` is not specified , ERROR is used . If `flushOnClose` is specified as False , then the buffer is not flushed when the handler is closed .", "question_id": 5534}
{"snippet": "logging.handlers.MemoryHandler(capacity, target=None, flushOnClose=True)", "intent": "Returns a new instance of the MemoryHandler class . The instance is initialized with a buffer size of `capacity` ( number of records buffered ) . If no `target` is specified , the target will need to be set using setTarget ( ) before this handler does anything useful . If `flushOnClose` is specified as False , then the buffer is not flushed when the handler is closed .", "question_id": 5535}
{"snippet": "logging.handlers.MemoryHandler(capacity, flushLevel=ERROR, target=None, flushOnClose=True)", "intent": "Returns a new instance of the MemoryHandler class . The instance is initialized with a buffer size of `capacity` ( number of records buffered ) . If `flushLevel` is not specified , ERROR is used . If no `target` is specified , the target will need to be set using setTarget ( ) before this handler does anything useful . If `flushOnClose` is specified as False , then the buffer is not flushed when the handler is closed .", "question_id": 5536}
{"snippet": "memory_handler.close()", "intent": "Calls flush ( ) , sets the target to None and clears the buffer .", "question_id": 5537}
{"snippet": "memory_handler.flush()", "intent": "For a MemoryHandler , flushing means just sending the buffered records to the target , if there is one .", "question_id": 5538}
{"snippet": "memory_handler.setTarget(target)", "intent": "Sets the `target` handler for this handler .", "question_id": 5539}
{"snippet": "memory_handler.shouldFlush(record)", "intent": "Checks for buffer full or a `record` at the flushLevel or higher .", "question_id": 5540}
{"snippet": "logging.handlers.HTTPHandler(host, url)", "intent": "Returns a new instance of the HTTPHandler class . The `host` can be of the form host : port , should you need to use a specific port number . With arguments `url`.", "question_id": 5541}
{"snippet": "logging.handlers.HTTPHandler(host, url, method='GET')", "intent": "Returns a new instance of the HTTPHandler class . The `host` can be of the form host : port , should you need to use a specific port number . If no `method` is specified , GET is used . With arguments `url`.", "question_id": 5542}
{"snippet": "logging.handlers.HTTPHandler(host, url, secure=False)", "intent": "Returns a new instance of the HTTPHandler class . The `host` can be of the form host : port , should you need to use a specific port number . If `secure` is true , a HTTPS connection will be used . With arguments `url`.", "question_id": 5543}
{"snippet": "logging.handlers.HTTPHandler(host, url, credentials=None)", "intent": "Returns a new instance of the HTTPHandler class . The `host` can be of the form host : port , should you need to use a specific port number . If `credentials` is specified , it should be a 2-tuple consisting of userid and password , which will be placed in a HTTP \u2018 Authorization \u2019 header using Basic authentication . With arguments `url`.", "question_id": 5544}
{"snippet": "logging.handlers.HTTPHandler(host, url, context=None)", "intent": "Returns a new instance of the HTTPHandler class . The `host` can be of the form host : port , should you need to use a specific port number . The `context` parameter may be set to a ssl.SSLContext instance to configure the SSL settings used for the HTTPS connection . With arguments `url`.", "question_id": 5545}
{"snippet": "logging.handlers.HTTPHandler(host, url, method='GET', secure=False)", "intent": "Returns a new instance of the HTTPHandler class . The `host` can be of the form host : port , should you need to use a specific port number . If no `method` is specified , GET is used . If `secure` is true , a HTTPS connection will be used . With arguments `url`.", "question_id": 5546}
{"snippet": "logging.handlers.HTTPHandler(host, url, method='GET', credentials=None)", "intent": "Returns a new instance of the HTTPHandler class . The `host` can be of the form host : port , should you need to use a specific port number . If no `method` is specified , GET is used . If `credentials` is specified , it should be a 2-tuple consisting of userid and password , which will be placed in a HTTP \u2018 Authorization \u2019 header using Basic authentication . With arguments `url`.", "question_id": 5547}
{"snippet": "logging.handlers.HTTPHandler(host, url, method='GET', context=None)", "intent": "Returns a new instance of the HTTPHandler class . The `host` can be of the form host : port , should you need to use a specific port number . If no `method` is specified , GET is used . The `context` parameter may be set to a ssl.SSLContext instance to configure the SSL settings used for the HTTPS connection . With arguments `url`.", "question_id": 5548}
{"snippet": "logging.handlers.HTTPHandler(host, url, secure=False, credentials=None)", "intent": "Returns a new instance of the HTTPHandler class . The `host` can be of the form host : port , should you need to use a specific port number . If `secure` is true , a HTTPS connection will be used . If `credentials` is specified , it should be a 2-tuple consisting of userid and password , which will be placed in a HTTP \u2018 Authorization \u2019 header using Basic authentication . With arguments `url`.", "question_id": 5549}
{"snippet": "logging.handlers.HTTPHandler(host, url, secure=False, context=None)", "intent": "Returns a new instance of the HTTPHandler class . The `host` can be of the form host : port , should you need to use a specific port number . If `secure` is true , a HTTPS connection will be used . The `context` parameter may be set to a ssl.SSLContext instance to configure the SSL settings used for the HTTPS connection . With arguments `url`.", "question_id": 5550}
{"snippet": "http_handler.mapLogRecord(record)", "intent": "Provides a dictionary , based on `record` , which is to be URL-encoded and sent to the web server .", "question_id": 5551}
{"snippet": "http_handler.emit(record)", "intent": "Sends the `record` to the Web server as a URL-encoded dictionary .", "question_id": 5552}
{"snippet": "logging.handlers.QueueHandler(queue)", "intent": "Returns a new instance of the QueueHandler class . The instance is initialized with the `queue` to send messages to .", "question_id": 5553}
{"snippet": "queue_handler.emit(record)", "intent": "Enqueues the result of preparing the LogRecord . This can result in the `record` silently being dropped ( if logging.raiseExceptions is False ) or a message printed to sys.stderr ( if logging.raiseExceptions is True ) .", "question_id": 5554}
{"snippet": "queue_handler.prepare(record)", "intent": "Prepares a `record` for queuing .", "question_id": 5555}
{"snippet": "queue_handler.enqueue(record)", "intent": "Enqueues the `record` on the queue using put_nowait ( ) ; you may want to override this if you want to use blocking behaviour , or a timeout , or a customized queue implementation .", "question_id": 5556}
{"snippet": "logging.handlers.QueueListener(queue, *handlers)", "intent": "Returns a new instance of the QueueListener class . The instance is initialized with the `queue` to send messages to and a list of handlers which will handle entries placed on the queue . With arguments `*handlers`.", "question_id": 5557}
{"snippet": "logging.handlers.QueueListener(queue, *handlers, respect_handler_level=False)", "intent": "Returns a new instance of the QueueListener class . The instance is initialized with the `queue` to send messages to and a list of handlers which will handle entries placed on the queue . If `respect_handler_level` is True , a handler \u2019 s level is respected ( compared with the level for the message ) when deciding whether to pass messages to that handler ; otherwise , the behaviour is as in previous Python versions - to always pass each message to each handler . With arguments `*handlers`.", "question_id": 5558}
{"snippet": "queue_listener.dequeue(block)", "intent": "Dequeues a record and return it , optionally blocking . With arguments `block`.", "question_id": 5559}
{"snippet": "queue_listener.prepare(record)", "intent": "Prepare a `record` for handling .", "question_id": 5560}
{"snippet": "queue_listener.handle(record)", "intent": "Handle a `record` .", "question_id": 5561}
{"snippet": "queue_listener.start()", "intent": "Starts the listener .", "question_id": 5562}
{"snippet": "queue_listener.stop()", "intent": "Stops the listener .", "question_id": 5563}
{"snippet": "queue_listener.enqueue_sentinel()", "intent": "Writes a sentinel to the queue to tell the listener to quit .", "question_id": 5564}
{"snippet": "queue_listener.propagate", "intent": "If this attribute evaluates to true, events logged to this logger will be passed to the handlers of higher level (ancestor) loggers, in addition to any handlers attached to this logger.", "question_id": 5565}
{"snippet": "queue_listener.setLevel(level)", "intent": "Sets the threshold for this logger to `level` .", "question_id": 5566}
{"snippet": "queue_listener.isEnabledFor(level)", "intent": "Indicates if a message of severity `level` would be processed by this logger .", "question_id": 5567}
{"snippet": "queue_listener.getEffectiveLevel()", "intent": "Indicates the effective level for this logger .", "question_id": 5568}
{"snippet": "queue_listener.getChild(suffix)", "intent": "Returns a logger which is a descendant to this logger , as determined by the `suffix` .", "question_id": 5569}
{"snippet": "queue_listener.debug(msg, *args, **kwargs)", "intent": "Logs a message with level DEBUG on this logger . The `msg` is the message format string , and the args are the arguments which are merged into msg using the string formatting operator . With arguments `*args`, `**kwargs`.", "question_id": 5570}
{"snippet": "queue_listener.info(msg, *args, **kwargs)", "intent": "Logs a message with level INFO on this logger . With arguments `msg`, `*args`, `**kwargs`.", "question_id": 5571}
{"snippet": "queue_listener.warning(msg, *args, **kwargs)", "intent": "Logs a message with level WARNING on this logger . With arguments `msg`, `*args`, `**kwargs`.", "question_id": 5572}
{"snippet": "queue_listener.error(msg, *args, **kwargs)", "intent": "Logs a message with level ERROR on this logger . With arguments `msg`, `*args`, `**kwargs`.", "question_id": 5573}
{"snippet": "queue_listener.critical(msg, *args, **kwargs)", "intent": "Logs a message with level CRITICAL on this logger . With arguments `msg`, `*args`, `**kwargs`.", "question_id": 5574}
{"snippet": "queue_listener.log(level, msg, *args, **kwargs)", "intent": "Logs a message with integer `level` level on this logger . With arguments `msg`, `*args`, `**kwargs`.", "question_id": 5575}
{"snippet": "queue_listener.exception(msg, *args, **kwargs)", "intent": "Logs a message with level ERROR on this logger . With arguments `msg`, `*args`, `**kwargs`.", "question_id": 5576}
{"snippet": "queue_listener.addFilter(filter)", "intent": "Adds the specified `filter` filter to this logger .", "question_id": 5577}
{"snippet": "queue_listener.removeFilter(filter)", "intent": "Removes the specified `filter` filter from this logger .", "question_id": 5578}
{"snippet": "queue_listener.filter(record)", "intent": "Applies this logger \u2019 s filters to the `record` and returns a true value if the record is to be processed .", "question_id": 5579}
{"snippet": "queue_listener.addHandler(hdlr)", "intent": "Adds the specified handler `hdlr` to this logger .", "question_id": 5580}
{"snippet": "queue_listener.removeHandler(hdlr)", "intent": "Removes the specified handler `hdlr` from this logger .", "question_id": 5581}
{"snippet": "queue_listener.findCaller()", "intent": "Finds the caller \u2019 s source filename and line number .", "question_id": 5582}
{"snippet": "queue_listener.findCaller(stack_info=False)", "intent": "Finds the caller \u2019 s source filename and line number . The stack information is returned as None unless `stack_info` is True .", "question_id": 5583}
{"snippet": "queue_listener.handle(record)", "intent": "Handles a `record` by passing it to all handlers associated with this logger and its ancestors ( until a false value of propagate is found ) .", "question_id": 5584}
{"snippet": "queue_listener.makeRecord(name, level, fn, lno, msg, args, exc_info)", "intent": "This is a factory method which can be overridden in subclasses to create specialized LogRecord instances . With arguments `name`, `level`, `fn`, `lno`, `msg`, `args`, `exc_info`.", "question_id": 5585}
{"snippet": "queue_listener.makeRecord(name, level, fn, lno, msg, args, exc_info, func=None)", "intent": "This is a factory method which can be overridden in subclasses to create specialized LogRecord instances . With arguments `name`, `level`, `fn`, `lno`, `msg`, `args`, `exc_info`, `func`.", "question_id": 5586}
{"snippet": "queue_listener.makeRecord(name, level, fn, lno, msg, args, exc_info, extra=None)", "intent": "This is a factory method which can be overridden in subclasses to create specialized LogRecord instances . With arguments `name`, `level`, `fn`, `lno`, `msg`, `args`, `exc_info`, `extra`.", "question_id": 5587}
{"snippet": "queue_listener.makeRecord(name, level, fn, lno, msg, args, exc_info, sinfo=None)", "intent": "This is a factory method which can be overridden in subclasses to create specialized LogRecord instances . With arguments `name`, `level`, `fn`, `lno`, `msg`, `args`, `exc_info`, `sinfo`.", "question_id": 5588}
{"snippet": "queue_listener.makeRecord(name, level, fn, lno, msg, args, exc_info, func=None, extra=None)", "intent": "This is a factory method which can be overridden in subclasses to create specialized LogRecord instances . With arguments `name`, `level`, `fn`, `lno`, `msg`, `args`, `exc_info`, `func`, `extra`.", "question_id": 5589}
{"snippet": "queue_listener.makeRecord(name, level, fn, lno, msg, args, exc_info, func=None, sinfo=None)", "intent": "This is a factory method which can be overridden in subclasses to create specialized LogRecord instances . With arguments `name`, `level`, `fn`, `lno`, `msg`, `args`, `exc_info`, `func`, `sinfo`.", "question_id": 5590}
{"snippet": "queue_listener.makeRecord(name, level, fn, lno, msg, args, exc_info, extra=None, sinfo=None)", "intent": "This is a factory method which can be overridden in subclasses to create specialized LogRecord instances . With arguments `name`, `level`, `fn`, `lno`, `msg`, `args`, `exc_info`, `extra`, `sinfo`.", "question_id": 5591}
{"snippet": "queue_listener.makeRecord(name, level, fn, lno, msg, args, exc_info, func=None, extra=None, sinfo=None)", "intent": "This is a factory method which can be overridden in subclasses to create specialized LogRecord instances . With arguments `name`, `level`, `fn`, `lno`, `msg`, `args`, `exc_info`, `func`, `extra`, `sinfo`.", "question_id": 5592}
{"snippet": "queue_listener.hasHandlers()", "intent": "Checks to see if this logger has any handlers configured .", "question_id": 5593}
{"snippet": "queue_listener.__init__()", "intent": "Initializes the Handler instance by setting its `level` , setting the list of filters to the empty list and creating a lock ( using createLock ( ) ) for serializing access to an I/O mechanism .", "question_id": 5594}
{"snippet": "queue_listener.__init__(level=NOTSET)", "intent": "Initializes the Handler instance by setting its `level` , setting the list of filters to the empty list and creating a lock ( using createLock ( ) ) for serializing access to an I/O mechanism .", "question_id": 5595}
{"snippet": "queue_listener.createLock()", "intent": "Initializes a thread lock which can be used to serialize access to underlying I/O functionality which may not be threadsafe .", "question_id": 5596}
{"snippet": "queue_listener.acquire()", "intent": "Acquires the thread lock created with createLock ( ) .", "question_id": 5597}
{"snippet": "queue_listener.release()", "intent": "Releases the thread lock acquired with acquire ( ) .", "question_id": 5598}
{"snippet": "queue_listener.setLevel(level)", "intent": "Sets the threshold for this handler to `level` .", "question_id": 5599}
{"snippet": "queue_listener.setFormatter(fmt)", "intent": "Sets the Formatter for this handler to `fmt` .", "question_id": 5600}
{"snippet": "queue_listener.addFilter(filter)", "intent": "Adds the specified `filter` filter to this handler .", "question_id": 5601}
{"snippet": "queue_listener.removeFilter(filter)", "intent": "Removes the specified `filter` filter from this handler .", "question_id": 5602}
{"snippet": "queue_listener.filter(record)", "intent": "Applies this handler \u2019 s filters to the `record` and returns a true value if the record is to be processed .", "question_id": 5603}
{"snippet": "queue_listener.flush()", "intent": "Ensure all logging output has been flushed .", "question_id": 5604}
{"snippet": "queue_listener.close()", "intent": "Tidy up any resources used by the handler .", "question_id": 5605}
{"snippet": "queue_listener.handle(record)", "intent": "Conditionally emits the specified logging `record` , depending on filters which may have been added to the handler .", "question_id": 5606}
{"snippet": "queue_listener.handleError(record)", "intent": "This method should be called from handlers when an exception is encountered during an emit ( ) call . The specified `record` is the one which was being processed when the exception occurred .", "question_id": 5607}
{"snippet": "queue_listener.format(record)", "intent": "Do formatting for a `record` - if a formatter is set , use it .", "question_id": 5608}
{"snippet": "queue_listener.emit(record)", "intent": "Do whatever it takes to actually log the specified logging `record` .", "question_id": 5609}
{"snippet": "logging.Formatter()", "intent": "Returns a new instance of the Formatter class .", "question_id": 5610}
{"snippet": "logging.Formatter(fmt=None)", "intent": "Returns a new instance of the Formatter class . If no `fmt` is specified , ' % ( message ) s ' is used .", "question_id": 5611}
{"snippet": "logging.Formatter(datefmt=None)", "intent": "Returns a new instance of the Formatter class . If no `datefmt` is specified , a format is used which is described in the formatTime ( ) documentation .", "question_id": 5612}
{"snippet": "logging.Formatter(style='%')", "intent": "Returns a new instance of the Formatter class . The `style` parameter can be one of \u2018 % \u2019 , \u2018 { \u2018 or \u2018 $ \u2019 and determines how the format string will be merged with its data : using one of % -formatting , str.format ( ) or string.Template .", "question_id": 5613}
{"snippet": "logging.Formatter(fmt=None, datefmt=None)", "intent": "Returns a new instance of the Formatter class . If no `fmt` is specified , ' % ( message ) s ' is used . If no `datefmt` is specified , a format is used which is described in the formatTime ( ) documentation .", "question_id": 5614}
{"snippet": "logging.Formatter(fmt=None, style='%')", "intent": "Returns a new instance of the Formatter class . If no `fmt` is specified , ' % ( message ) s ' is used . The `style` parameter can be one of \u2018 % \u2019 , \u2018 { \u2018 or \u2018 $ \u2019 and determines how the format string will be merged with its data : using one of % -formatting , str.format ( ) or string.Template .", "question_id": 5615}
{"snippet": "logging.Formatter(datefmt=None, style='%')", "intent": "Returns a new instance of the Formatter class . If no `datefmt` is specified , a format is used which is described in the formatTime ( ) documentation . The `style` parameter can be one of \u2018 % \u2019 , \u2018 { \u2018 or \u2018 $ \u2019 and determines how the format string will be merged with its data : using one of % -formatting , str.format ( ) or string.Template .", "question_id": 5616}
{"snippet": "logging.Formatter(fmt=None, datefmt=None, style='%')", "intent": "Returns a new instance of the Formatter class . If no `fmt` is specified , ' % ( message ) s ' is used . If no `datefmt` is specified , a format is used which is described in the formatTime ( ) documentation . The `style` parameter can be one of \u2018 % \u2019 , \u2018 { \u2018 or \u2018 $ \u2019 and determines how the format string will be merged with its data : using one of % -formatting , str.format ( ) or string.Template .", "question_id": 5617}
{"snippet": "formatter.format(record)", "intent": "The `record` \u2019 s attribute dictionary is used as the operand to a string formatting operation .", "question_id": 5618}
{"snippet": "formatter.formatTime(record)", "intent": "This method should be called from format ( ) by a formatter which wants to make use of a formatted time . This method can be overridden in formatters to provide for any specific requirement , but the basic behavior is as follows : if `datefmt` ( a string ) is specified , it is used with time.strftime ( ) to format the creation time of the `record` .", "question_id": 5619}
{"snippet": "formatter.formatTime(record, datefmt=None)", "intent": "This method should be called from format ( ) by a formatter which wants to make use of a formatted time . This method can be overridden in formatters to provide for any specific requirement , but the basic behavior is as follows : if `datefmt` ( a string ) is specified , it is used with time.strftime ( ) to format the creation time of the `record` .", "question_id": 5620}
{"snippet": "formatter.formatException(exc_info)", "intent": "Formats the specified exception information ( a standard exception tuple as returned by sys.exc_info ( ) ) as a string . With arguments `exc_info`.", "question_id": 5621}
{"snippet": "formatter.formatStack(stack_info)", "intent": "Formats the specified stack information ( a string as returned by traceback.print_stack ( ) , but with the last newline removed ) as a string . With arguments `stack_info`.", "question_id": 5622}
{"snippet": "logging.Filter()", "intent": "Returns an instance of the Filter class .", "question_id": 5623}
{"snippet": "logging.Filter(name='')", "intent": "Returns an instance of the Filter class . If `name` is specified , it names a logger which , together with its children , will have its events allowed through the filter .", "question_id": 5624}
{"snippet": "filter.filter(record)", "intent": "Is the specified `record` to be logged ?", "question_id": 5625}
{"snippet": "logging.LogRecord(name, level, pathname, lineno, msg, args, exc_info)", "intent": "Contains all the information pertinent to the event being logged . The primary information is passed in `msg` and `args` , which are combined using msg % args to create the message field of the record . With arguments `name`, `level`, `pathname`, `lineno`, `exc_info`.", "question_id": 5626}
{"snippet": "logging.LogRecord(name, level, pathname, lineno, msg, args, exc_info, func=None)", "intent": "Contains all the information pertinent to the event being logged . The primary information is passed in `msg` and `args` , which are combined using msg % args to create the message field of the record . With arguments `name`, `level`, `pathname`, `lineno`, `exc_info`, `func`.", "question_id": 5627}
{"snippet": "logging.LogRecord(name, level, pathname, lineno, msg, args, exc_info, sinfo=None)", "intent": "Contains all the information pertinent to the event being logged . The primary information is passed in `msg` and `args` , which are combined using msg % args to create the message field of the record . With arguments `name`, `level`, `pathname`, `lineno`, `exc_info`, `sinfo`.", "question_id": 5628}
{"snippet": "logging.LogRecord(name, level, pathname, lineno, msg, args, exc_info, func=None, sinfo=None)", "intent": "Contains all the information pertinent to the event being logged . The primary information is passed in `msg` and `args` , which are combined using msg % args to create the message field of the record . With arguments `name`, `level`, `pathname`, `lineno`, `exc_info`, `func`, `sinfo`.", "question_id": 5629}
{"snippet": "log_record.getMessage()", "intent": "Returns the message for this LogRecord instance after merging any user-supplied arguments with the message .", "question_id": 5630}
{"snippet": "logging.LoggerAdapter(logger, extra)", "intent": "Returns an instance of LoggerAdapter initialized with an underlying Logger instance and a dict-like object . With arguments `logger`, `extra`.", "question_id": 5631}
{"snippet": "logger_adapter.process(msg, kwargs)", "intent": "Modifies the message and/or keyword arguments passed to a logging call in order to insert contextual information . The return value is a ( `msg` , kwargs ) tuple which has the ( possibly modified ) versions of the arguments passed in . This implementation takes the object passed as extra to the constructor and adds it to `kwargs` using key \u2018 extra \u2019 .", "question_id": 5632}
{"snippet": "logging.getLogger()", "intent": "Return a logger with the specified `name` or , if name is None , return a logger which is the root logger of the hierarchy .", "question_id": 5633}
{"snippet": "logging.getLogger(name=None)", "intent": "Return a logger with the specified `name` or , if name is None , return a logger which is the root logger of the hierarchy .", "question_id": 5634}
{"snippet": "logging.getLoggerClass()", "intent": "Return either the standard Logger class , or the last class passed to setLoggerClass ( ) .", "question_id": 5635}
{"snippet": "logging.getLogRecordFactory()", "intent": "Return a callable which is used to create a LogRecord .", "question_id": 5636}
{"snippet": "logging.debug(msg, *args, **kwargs)", "intent": "Logs a message with level DEBUG on the root logger . The `msg` is the message format string , and the args are the arguments which are merged into msg using the string formatting operator . With arguments `*args`, `**kwargs`.", "question_id": 5637}
{"snippet": "logging.info(msg, *args, **kwargs)", "intent": "Logs a message with level INFO on the root logger . With arguments `msg`, `*args`, `**kwargs`.", "question_id": 5638}
{"snippet": "logging.warning(msg, *args, **kwargs)", "intent": "Logs a message with level WARNING on the root logger . With arguments `msg`, `*args`, `**kwargs`.", "question_id": 5639}
{"snippet": "logging.error(msg, *args, **kwargs)", "intent": "Logs a message with level ERROR on the root logger . With arguments `msg`, `*args`, `**kwargs`.", "question_id": 5640}
{"snippet": "logging.critical(msg, *args, **kwargs)", "intent": "Logs a message with level CRITICAL on the root logger . With arguments `msg`, `*args`, `**kwargs`.", "question_id": 5641}
{"snippet": "logging.exception(msg, *args, **kwargs)", "intent": "Logs a message with level ERROR on the root logger . With arguments `msg`, `*args`, `**kwargs`.", "question_id": 5642}
{"snippet": "logging.log(level, msg, *args, **kwargs)", "intent": "Logs a message with `level` level on the root logger . With arguments `msg`, `*args`, `**kwargs`.", "question_id": 5643}
{"snippet": "logging.disable()", "intent": "Provides an overriding `level` level for all loggers which takes precedence over the logger \u2019 s own level .", "question_id": 5644}
{"snippet": "logging.disable(level=CRITICAL)", "intent": "Provides an overriding `level` level for all loggers which takes precedence over the logger \u2019 s own level .", "question_id": 5645}
{"snippet": "logging.addLevelName(level, levelName)", "intent": "Associates `level` level with text `levelName` in an internal dictionary , which is used to map numeric levels to a textual representation , for example when a Formatter formats a message .", "question_id": 5646}
{"snippet": "logging.getLevelName(level)", "intent": "Returns the textual representation of logging `level` level .", "question_id": 5647}
{"snippet": "logging.makeLogRecord(attrdict)", "intent": "Creates and returns a new LogRecord instance whose attributes are defined by `attrdict` .", "question_id": 5648}
{"snippet": "logging.basicConfig(**kwargs)", "intent": "Does basic configuration for the logging system by creating a StreamHandler with a default Formatter and adding it to the root logger . With arguments `**kwargs`.", "question_id": 5649}
{"snippet": "logging.shutdown()", "intent": "Informs the logging system to perform an orderly shutdown by flushing and closing all handlers .", "question_id": 5650}
{"snippet": "logging.setLoggerClass(klass)", "intent": "Tells the logging system to use the class `klass` when instantiating a logger .", "question_id": 5651}
{"snippet": "logging.setLogRecordFactory(factory)", "intent": "Set a callable which is used to create a LogRecord . The `factory` has the following signature :", "question_id": 5652}
{"snippet": "logging.lastResort", "intent": "A \u201chandler of last resort\u201d is available through this attribute.", "question_id": 5653}
{"snippet": "logging.captureWarnings(capture)", "intent": "This function is used to turn the `capture` of warnings by logging on and off .", "question_id": 5654}
{"snippet": "lzma.LZMAError", "intent": "This exception is raised when an error occurs during compression or decompression, or while initializing the compressor/decompressor state.", "question_id": 5655}
{"snippet": "lzma.open(filename)", "intent": "Open an LZMA-compressed file in binary or text `mode` , returning a file object . The `filename` argument can be either an actual file name ( given as a str , bytes or path-like object ) , in which case the named file is opened , or it can be an existing file object to read from or write to .", "question_id": 5656}
{"snippet": "lzma.open(filename, mode=\"rb\")", "intent": "Open an LZMA-compressed file in binary or text `mode` , returning a file object . The `filename` argument can be either an actual file name ( given as a str , bytes or path-like object ) , in which case the named file is opened , or it can be an existing file object to read from or write to .", "question_id": 5657}
{"snippet": "lzma.open(filename, format=None)", "intent": "Open an LZMA-compressed file in binary or text `mode` , returning a file object . The `filename` argument can be either an actual file name ( given as a str , bytes or path-like object ) , in which case the named file is opened , or it can be an existing file object to read from or write to . When opening a file for reading , the `format` and `filters` arguments have the same meanings as for LZMADecompressor .", "question_id": 5658}
{"snippet": "lzma.open(filename, check=-1)", "intent": "Open an LZMA-compressed file in binary or text `mode` , returning a file object . The `filename` argument can be either an actual file name ( given as a str , bytes or path-like object ) , in which case the named file is opened , or it can be an existing file object to read from or write to . In this case , the `check` and `preset` arguments should not be used .", "question_id": 5659}
{"snippet": "lzma.open(filename, preset=None)", "intent": "Open an LZMA-compressed file in binary or text `mode` , returning a file object . The `filename` argument can be either an actual file name ( given as a str , bytes or path-like object ) , in which case the named file is opened , or it can be an existing file object to read from or write to . In this case , the `check` and `preset` arguments should not be used .", "question_id": 5660}
{"snippet": "lzma.open(filename, filters=None)", "intent": "Open an LZMA-compressed file in binary or text `mode` , returning a file object . The `filename` argument can be either an actual file name ( given as a str , bytes or path-like object ) , in which case the named file is opened , or it can be an existing file object to read from or write to . When opening a file for reading , the `format` and `filters` arguments have the same meanings as for LZMADecompressor .", "question_id": 5661}
{"snippet": "lzma.open(filename, encoding=None)", "intent": "Open an LZMA-compressed file in binary or text `mode` , returning a file object . The `filename` argument can be either an actual file name ( given as a str , bytes or path-like object ) , in which case the named file is opened , or it can be an existing file object to read from or write to . In this case , the `encoding` , `errors` and `newline` arguments must not be provided .", "question_id": 5662}
{"snippet": "lzma.open(filename, errors=None)", "intent": "Open an LZMA-compressed file in binary or text `mode` , returning a file object . The `filename` argument can be either an actual file name ( given as a str , bytes or path-like object ) , in which case the named file is opened , or it can be an existing file object to read from or write to . In this case , the `encoding` , `errors` and `newline` arguments must not be provided .", "question_id": 5663}
{"snippet": "lzma.open(filename, newline=None)", "intent": "Open an LZMA-compressed file in binary or text `mode` , returning a file object . The `filename` argument can be either an actual file name ( given as a str , bytes or path-like object ) , in which case the named file is opened , or it can be an existing file object to read from or write to . In this case , the `encoding` , `errors` and `newline` arguments must not be provided .", "question_id": 5664}
{"snippet": "lzma.open(filename, mode=\"rb\", format=None)", "intent": "Open an LZMA-compressed file in binary or text `mode` , returning a file object . The `filename` argument can be either an actual file name ( given as a str , bytes or path-like object ) , in which case the named file is opened , or it can be an existing file object to read from or write to . When opening a file for reading , the `format` and `filters` arguments have the same meanings as for LZMADecompressor .", "question_id": 5665}
{"snippet": "lzma.LZMAFile()", "intent": "Open an LZMA-compressed file in binary `mode` .", "question_id": 5666}
{"snippet": "lzma.LZMAFile(filename=None)", "intent": "Open an LZMA-compressed file in binary `mode` . The `filename` argument specifies either the file object to wrap , or the name of the file to open ( as a str , bytes or path-like object ) .", "question_id": 5667}
{"snippet": "lzma.LZMAFile(mode=\"r\")", "intent": "Open an LZMA-compressed file in binary `mode` .", "question_id": 5668}
{"snippet": "lzma.LZMAFile(format=None)", "intent": "Open an LZMA-compressed file in binary `mode` . When opening a file for reading , the `format` and `filters` arguments have the same meanings as for LZMADecompressor .", "question_id": 5669}
{"snippet": "lzma.LZMAFile(check=-1)", "intent": "Open an LZMA-compressed file in binary `mode` . In this case , the `check` and `preset` arguments should not be used .", "question_id": 5670}
{"snippet": "lzma.LZMAFile(preset=None)", "intent": "Open an LZMA-compressed file in binary `mode` . In this case , the `check` and `preset` arguments should not be used .", "question_id": 5671}
{"snippet": "lzma.LZMAFile(filters=None)", "intent": "Open an LZMA-compressed file in binary `mode` . When opening a file for reading , the `format` and `filters` arguments have the same meanings as for LZMADecompressor .", "question_id": 5672}
{"snippet": "lzma.LZMAFile(filename=None, mode=\"r\")", "intent": "Open an LZMA-compressed file in binary `mode` . The `filename` argument specifies either the file object to wrap , or the name of the file to open ( as a str , bytes or path-like object ) .", "question_id": 5673}
{"snippet": "lzma.LZMAFile(filename=None, format=None)", "intent": "Open an LZMA-compressed file in binary `mode` . The `filename` argument specifies either the file object to wrap , or the name of the file to open ( as a str , bytes or path-like object ) . When opening a file for reading , the `format` and `filters` arguments have the same meanings as for LZMADecompressor .", "question_id": 5674}
{"snippet": "lzma.LZMAFile(filename=None, check=-1)", "intent": "Open an LZMA-compressed file in binary `mode` . The `filename` argument specifies either the file object to wrap , or the name of the file to open ( as a str , bytes or path-like object ) . In this case , the `check` and `preset` arguments should not be used .", "question_id": 5675}
{"snippet": "lzma_file.peek()", "intent": "Return buffered data without advancing the file position .", "question_id": 5676}
{"snippet": "lzma_file.peek(size=-1)", "intent": "Return buffered data without advancing the file position . The exact number of bytes returned is unspecified ( the `size` argument is ignored ) .", "question_id": 5677}
{"snippet": "lzma.LZMACompressor()", "intent": "Create a compressor object , which can be used to compress data incrementally .", "question_id": 5678}
{"snippet": "lzma.LZMACompressor(format=FORMAT_XZ)", "intent": "Create a compressor object , which can be used to compress data incrementally . The `format` argument specifies what container format should be used .", "question_id": 5679}
{"snippet": "lzma.LZMACompressor(check=-1)", "intent": "Create a compressor object , which can be used to compress data incrementally . The `check` argument specifies the type of integrity check to include in the compressed data .", "question_id": 5680}
{"snippet": "lzma.LZMACompressor(preset=None)", "intent": "Create a compressor object , which can be used to compress data incrementally . The compression settings can be specified either as a `preset` compression level ( with the preset argument ) , or in detail as a custom filter chain ( with the `filters` argument ) .", "question_id": 5681}
{"snippet": "lzma.LZMACompressor(filters=None)", "intent": "Create a compressor object , which can be used to compress data incrementally . The compression settings can be specified either as a `preset` compression level ( with the preset argument ) , or in detail as a custom filter chain ( with the `filters` argument ) .", "question_id": 5682}
{"snippet": "lzma.LZMACompressor(format=FORMAT_XZ, check=-1)", "intent": "Create a compressor object , which can be used to compress data incrementally . The `format` argument specifies what container format should be used . The `check` argument specifies the type of integrity check to include in the compressed data .", "question_id": 5683}
{"snippet": "lzma.LZMACompressor(format=FORMAT_XZ, preset=None)", "intent": "Create a compressor object , which can be used to compress data incrementally . The `format` argument specifies what container format should be used . The compression settings can be specified either as a `preset` compression level ( with the preset argument ) , or in detail as a custom filter chain ( with the `filters` argument ) .", "question_id": 5684}
{"snippet": "lzma.LZMACompressor(format=FORMAT_XZ, filters=None)", "intent": "Create a compressor object , which can be used to compress data incrementally . The `format` argument specifies what container format should be used . The compression settings can be specified either as a `preset` compression level ( with the preset argument ) , or in detail as a custom filter chain ( with the `filters` argument ) .", "question_id": 5685}
{"snippet": "lzma.LZMACompressor(check=-1, preset=None)", "intent": "Create a compressor object , which can be used to compress data incrementally . The `check` argument specifies the type of integrity check to include in the compressed data . The compression settings can be specified either as a `preset` compression level ( with the preset argument ) , or in detail as a custom filter chain ( with the `filters` argument ) .", "question_id": 5686}
{"snippet": "lzma.LZMACompressor(check=-1, filters=None)", "intent": "Create a compressor object , which can be used to compress data incrementally . The `check` argument specifies the type of integrity check to include in the compressed data . The compression settings can be specified either as a `preset` compression level ( with the preset argument ) , or in detail as a custom filter chain ( with the `filters` argument ) .", "question_id": 5687}
{"snippet": "lzma_compressor.compress(data)", "intent": "Compress `data` ( a bytes object ) , returning a bytes object containing compressed data for at least part of the input .", "question_id": 5688}
{"snippet": "lzma_compressor.flush()", "intent": "Finish the compression process , returning a bytes object containing any data stored in the compressor \u2019 s internal buffers .", "question_id": 5689}
{"snippet": "lzma.LZMADecompressor()", "intent": "Create a decompressor object , which can be used to decompress data incrementally .", "question_id": 5690}
{"snippet": "lzma.LZMADecompressor(format=FORMAT_AUTO)", "intent": "Create a decompressor object , which can be used to decompress data incrementally . The `format` argument specifies the container format that should be used .", "question_id": 5691}
{"snippet": "lzma.LZMADecompressor(memlimit=None)", "intent": "Create a decompressor object , which can be used to decompress data incrementally . The `memlimit` argument specifies a limit ( in bytes ) on the amount of memory that the decompressor can use .", "question_id": 5692}
{"snippet": "lzma.LZMADecompressor(filters=None)", "intent": "Create a decompressor object , which can be used to decompress data incrementally . The `filters` argument specifies the filter chain that was used to create the stream being decompressed .", "question_id": 5693}
{"snippet": "lzma.LZMADecompressor(format=FORMAT_AUTO, memlimit=None)", "intent": "Create a decompressor object , which can be used to decompress data incrementally . The `format` argument specifies the container format that should be used . The `memlimit` argument specifies a limit ( in bytes ) on the amount of memory that the decompressor can use .", "question_id": 5694}
{"snippet": "lzma.LZMADecompressor(format=FORMAT_AUTO, filters=None)", "intent": "Create a decompressor object , which can be used to decompress data incrementally . The `format` argument specifies the container format that should be used . The `filters` argument specifies the filter chain that was used to create the stream being decompressed .", "question_id": 5695}
{"snippet": "lzma.LZMADecompressor(memlimit=None, filters=None)", "intent": "Create a decompressor object , which can be used to decompress data incrementally . The `memlimit` argument specifies a limit ( in bytes ) on the amount of memory that the decompressor can use . The `filters` argument specifies the filter chain that was used to create the stream being decompressed .", "question_id": 5696}
{"snippet": "lzma.LZMADecompressor(format=FORMAT_AUTO, memlimit=None, filters=None)", "intent": "Create a decompressor object , which can be used to decompress data incrementally . The `format` argument specifies the container format that should be used . The `memlimit` argument specifies a limit ( in bytes ) on the amount of memory that the decompressor can use . The `filters` argument specifies the filter chain that was used to create the stream being decompressed .", "question_id": 5697}
{"snippet": "lzma_decompressor.decompress(data)", "intent": "Decompress `data` ( a bytes-like object ) , returning uncompressed data as bytes .", "question_id": 5698}
{"snippet": "lzma_decompressor.decompress(data, max_length=-1)", "intent": "Decompress `data` ( a bytes-like object ) , returning uncompressed data as bytes . If `max_length` is nonnegative , returns at most max_length bytes of decompressed data .", "question_id": 5699}
{"snippet": "lzma_decompressor.check", "intent": "The ID of the integrity check used by the input stream.", "question_id": 5700}
{"snippet": "lzma_decompressor.eof", "intent": "True if the end-of-stream marker has been reached.", "question_id": 5701}
{"snippet": "lzma_decompressor.unused_data", "intent": "Data found after the end of the compressed stream.", "question_id": 5702}
{"snippet": "lzma_decompressor.needs_input", "intent": "False if the decompress() method can provide more decompressed data before requiring new uncompressed input.", "question_id": 5703}
{"snippet": "lzma.compress(data)", "intent": "Compress `data` ( a bytes object ) , returning the compressed data as a bytes object .", "question_id": 5704}
{"snippet": "lzma.compress(data, format=FORMAT_XZ)", "intent": "Compress `data` ( a bytes object ) , returning the compressed data as a bytes object . See LZMACompressor above for a description of the `format` , `check` , `preset` and `filters` arguments .", "question_id": 5705}
{"snippet": "lzma.compress(data, check=-1)", "intent": "Compress `data` ( a bytes object ) , returning the compressed data as a bytes object . See LZMACompressor above for a description of the `format` , `check` , `preset` and `filters` arguments .", "question_id": 5706}
{"snippet": "lzma.compress(data, preset=None)", "intent": "Compress `data` ( a bytes object ) , returning the compressed data as a bytes object . See LZMACompressor above for a description of the `format` , `check` , `preset` and `filters` arguments .", "question_id": 5707}
{"snippet": "lzma.compress(data, filters=None)", "intent": "Compress `data` ( a bytes object ) , returning the compressed data as a bytes object . See LZMACompressor above for a description of the `format` , `check` , `preset` and `filters` arguments .", "question_id": 5708}
{"snippet": "lzma.compress(data, format=FORMAT_XZ, check=-1)", "intent": "Compress `data` ( a bytes object ) , returning the compressed data as a bytes object . See LZMACompressor above for a description of the `format` , `check` , `preset` and `filters` arguments .", "question_id": 5709}
{"snippet": "lzma.compress(data, format=FORMAT_XZ, preset=None)", "intent": "Compress `data` ( a bytes object ) , returning the compressed data as a bytes object . See LZMACompressor above for a description of the `format` , `check` , `preset` and `filters` arguments .", "question_id": 5710}
{"snippet": "lzma.compress(data, format=FORMAT_XZ, filters=None)", "intent": "Compress `data` ( a bytes object ) , returning the compressed data as a bytes object . See LZMACompressor above for a description of the `format` , `check` , `preset` and `filters` arguments .", "question_id": 5711}
{"snippet": "lzma.compress(data, check=-1, preset=None)", "intent": "Compress `data` ( a bytes object ) , returning the compressed data as a bytes object . See LZMACompressor above for a description of the `format` , `check` , `preset` and `filters` arguments .", "question_id": 5712}
{"snippet": "lzma.compress(data, check=-1, filters=None)", "intent": "Compress `data` ( a bytes object ) , returning the compressed data as a bytes object . See LZMACompressor above for a description of the `format` , `check` , `preset` and `filters` arguments .", "question_id": 5713}
{"snippet": "lzma.decompress(data)", "intent": "Decompress `data` ( a bytes object ) , returning the uncompressed data as a bytes object .", "question_id": 5714}
{"snippet": "lzma.decompress(data, format=FORMAT_AUTO)", "intent": "Decompress `data` ( a bytes object ) , returning the uncompressed data as a bytes object . See LZMADecompressor above for a description of the `format` , `memlimit` and `filters` arguments .", "question_id": 5715}
{"snippet": "lzma.decompress(data, memlimit=None)", "intent": "Decompress `data` ( a bytes object ) , returning the uncompressed data as a bytes object . See LZMADecompressor above for a description of the `format` , `memlimit` and `filters` arguments .", "question_id": 5716}
{"snippet": "lzma.decompress(data, filters=None)", "intent": "Decompress `data` ( a bytes object ) , returning the uncompressed data as a bytes object . See LZMADecompressor above for a description of the `format` , `memlimit` and `filters` arguments .", "question_id": 5717}
{"snippet": "lzma.decompress(data, format=FORMAT_AUTO, memlimit=None)", "intent": "Decompress `data` ( a bytes object ) , returning the uncompressed data as a bytes object . See LZMADecompressor above for a description of the `format` , `memlimit` and `filters` arguments .", "question_id": 5718}
{"snippet": "lzma.decompress(data, format=FORMAT_AUTO, filters=None)", "intent": "Decompress `data` ( a bytes object ) , returning the uncompressed data as a bytes object . See LZMADecompressor above for a description of the `format` , `memlimit` and `filters` arguments .", "question_id": 5719}
{"snippet": "lzma.decompress(data, memlimit=None, filters=None)", "intent": "Decompress `data` ( a bytes object ) , returning the uncompressed data as a bytes object . See LZMADecompressor above for a description of the `format` , `memlimit` and `filters` arguments .", "question_id": 5720}
{"snippet": "lzma.decompress(data, format=FORMAT_AUTO, memlimit=None, filters=None)", "intent": "Decompress `data` ( a bytes object ) , returning the uncompressed data as a bytes object . See LZMADecompressor above for a description of the `format` , `memlimit` and `filters` arguments .", "question_id": 5721}
{"snippet": "lzma.is_check_supported(check)", "intent": "Returns true if the given integrity `check` is supported on this system .", "question_id": 5722}
{"snippet": "mailbox.Mailbox", "intent": "A mailbox, which may be inspected and modified.", "question_id": 5723}
{"snippet": "mailbox.add(message)", "intent": "Add `message` to the mailbox and return the key that has been assigned to it .", "question_id": 5724}
{"snippet": "mailbox.remove(key)", "intent": "Delete the message corresponding to `key` from the mailbox .", "question_id": 5725}
{"snippet": "mailbox.__delitem__(key)", "intent": "Delete the message corresponding to `key` from the mailbox .", "question_id": 5726}
{"snippet": "mailbox.discard(key)", "intent": "Delete the message corresponding to `key` from the mailbox .", "question_id": 5727}
{"snippet": "mailbox.__setitem__(key, message)", "intent": "Replace the `message` corresponding to `key` with message .", "question_id": 5728}
{"snippet": "mailbox.iterkeys()", "intent": "Return an iterator over all keys if called as iterkeys ( ) or return a list of keys if called as keys ( ) .", "question_id": 5729}
{"snippet": "mailbox.keys()", "intent": "Return an iterator over all keys if called as iterkeys ( ) or return a list of keys if called as keys ( ) .", "question_id": 5730}
{"snippet": "mailbox.itervalues()", "intent": "Return an iterator over representations of all messages if called as itervalues ( ) or __iter__ ( ) or return a list of such representations if called as values ( ) .", "question_id": 5731}
{"snippet": "mailbox.__iter__()", "intent": "Return an iterator over representations of all messages if called as itervalues ( ) or __iter__ ( ) or return a list of such representations if called as values ( ) .", "question_id": 5732}
{"snippet": "mailbox.values()", "intent": "Return an iterator over representations of all messages if called as itervalues ( ) or __iter__ ( ) or return a list of such representations if called as values ( ) .", "question_id": 5733}
{"snippet": "mailbox.iteritems()", "intent": "Return an iterator over ( key , message ) pairs , where key is a key and message is a message representation , if called as iteritems ( ) or return a list of such pairs if called as items ( ) .", "question_id": 5734}
{"snippet": "mailbox.items()", "intent": "Return an iterator over ( key , message ) pairs , where key is a key and message is a message representation , if called as iteritems ( ) or return a list of such pairs if called as items ( ) .", "question_id": 5735}
{"snippet": "mailbox.get(key)", "intent": "Return a representation of the message corresponding to `key` .", "question_id": 5736}
{"snippet": "mailbox.get(key, default=None)", "intent": "Return a representation of the message corresponding to `key` . If no such message exists , `default` is returned if the method was called as get ( ) and a KeyError exception is raised if the method was called as __getitem__ ( ) .", "question_id": 5737}
{"snippet": "mailbox.__getitem__(key)", "intent": "Return a representation of the message corresponding to `key` .", "question_id": 5738}
{"snippet": "mailbox.get_message(key)", "intent": "Return a representation of the message corresponding to `key` as an instance of the appropriate format-specific Message subclass , or raise a KeyError exception if no such message exists .", "question_id": 5739}
{"snippet": "mailbox.get_bytes(key)", "intent": "Return a byte representation of the message corresponding to `key` , or raise a KeyError exception if no such message exists .", "question_id": 5740}
{"snippet": "mailbox.get_string(key)", "intent": "Return a string representation of the message corresponding to `key` , or raise a KeyError exception if no such message exists .", "question_id": 5741}
{"snippet": "mailbox.get_file(key)", "intent": "Return a file-like representation of the message corresponding to `key` , or raise a KeyError exception if no such message exists .", "question_id": 5742}
{"snippet": "mailbox.__contains__(key)", "intent": "Return True if `key` corresponds to a message , False otherwise .", "question_id": 5743}
{"snippet": "mailbox.__len__()", "intent": "Return a count of messages in the mailbox .", "question_id": 5744}
{"snippet": "mailbox.clear()", "intent": "Delete all messages from the mailbox .", "question_id": 5745}
{"snippet": "mailbox.pop(key)", "intent": "Return a representation of the message corresponding to `key` and delete the message .", "question_id": 5746}
{"snippet": "mailbox.pop(key, default=None)", "intent": "Return a representation of the message corresponding to `key` and delete the message . If no such message exists , return `default` .", "question_id": 5747}
{"snippet": "mailbox.popitem()", "intent": "Return an arbitrary ( key , message ) pair , where key is a key and message is a message representation , and delete the corresponding message .", "question_id": 5748}
{"snippet": "mailbox.update(arg)", "intent": "Parameter `arg` should be a key-to-message mapping or an iterable of ( key , message ) pairs .", "question_id": 5749}
{"snippet": "mailbox.flush()", "intent": "Write any pending changes to the filesystem .", "question_id": 5750}
{"snippet": "mailbox.lock()", "intent": "Acquire an exclusive advisory lock on the mailbox so that other processes know not to modify it .", "question_id": 5751}
{"snippet": "mailbox.unlock()", "intent": "Release the lock on the mailbox , if any .", "question_id": 5752}
{"snippet": "mailbox.close()", "intent": "Flush the mailbox , unlock it if necessary , and close any open files .", "question_id": 5753}
{"snippet": "mailbox.Maildir(dirname)", "intent": "A subclass of Mailbox for mailboxes in Maildir format . If create is True and the `dirname` path exists , it will be treated as an existing maildir without attempting to verify its directory layout .", "question_id": 5754}
{"snippet": "mailbox.Maildir(dirname, factory=None)", "intent": "A subclass of Mailbox for mailboxes in Maildir format . If create is True and the `dirname` path exists , it will be treated as an existing maildir without attempting to verify its directory layout . Parameter `factory` is a callable object that accepts a file-like message representation ( which behaves as if opened in binary mode ) and returns a custom representation .", "question_id": 5755}
{"snippet": "mailbox.Maildir(dirname, create=True)", "intent": "A subclass of Mailbox for mailboxes in Maildir format . If create is True and the `dirname` path exists , it will be treated as an existing maildir without attempting to verify its directory layout . If `create` is True , the mailbox is created if it does not exist .", "question_id": 5756}
{"snippet": "mailbox.Maildir(dirname, factory=None, create=True)", "intent": "A subclass of Mailbox for mailboxes in Maildir format . If create is True and the `dirname` path exists , it will be treated as an existing maildir without attempting to verify its directory layout . Parameter `factory` is a callable object that accepts a file-like message representation ( which behaves as if opened in binary mode ) and returns a custom representation . If `create` is True , the mailbox is created if it does not exist .", "question_id": 5757}
{"snippet": "maildir.list_folders()", "intent": "Return a list of the names of all folders .", "question_id": 5758}
{"snippet": "maildir.get_folder(folder)", "intent": "Return a Maildir instance representing the `folder` whose name is folder .", "question_id": 5759}
{"snippet": "maildir.add_folder(folder)", "intent": "Create a `folder` whose name is folder and return a Maildir instance representing it .", "question_id": 5760}
{"snippet": "maildir.remove_folder(folder)", "intent": "Delete the `folder` whose name is folder .", "question_id": 5761}
{"snippet": "maildir.clean()", "intent": "Delete temporary files from the mailbox that have not been accessed in the last 36 hours .", "question_id": 5762}
{"snippet": "maildir.flush()", "intent": "All changes to Maildir mailboxes are immediately applied , so this method does nothing .", "question_id": 5763}
{"snippet": "maildir.lock()", "intent": "Maildir mailboxes do not support ( or require ) locking , so these methods do nothing .", "question_id": 5764}
{"snippet": "maildir.unlock()", "intent": "Maildir mailboxes do not support ( or require ) locking , so these methods do nothing .", "question_id": 5765}
{"snippet": "maildir.close()", "intent": "Maildir instances do not keep any open files and the underlying mailboxes do not support locking , so this method does nothing .", "question_id": 5766}
{"snippet": "maildir.get_file(key)", "intent": "Depending upon the host platform , it may not be possible to modify or remove the underlying message while the returned file remains open . With arguments `key`.", "question_id": 5767}
{"snippet": "mailbox.mbox(path)", "intent": "A subclass of Mailbox for mailboxes in mbox format . With arguments `path`.", "question_id": 5768}
{"snippet": "mailbox.mbox(path, factory=None)", "intent": "A subclass of Mailbox for mailboxes in mbox format . Parameter `factory` is a callable object that accepts a file-like message representation ( which behaves as if opened in binary mode ) and returns a custom representation . With arguments `path`.", "question_id": 5769}
{"snippet": "mailbox.mbox(path, create=True)", "intent": "A subclass of Mailbox for mailboxes in mbox format . If `create` is True , the mailbox is created if it does not exist . With arguments `path`.", "question_id": 5770}
{"snippet": "mailbox.mbox(path, factory=None, create=True)", "intent": "A subclass of Mailbox for mailboxes in mbox format . Parameter `factory` is a callable object that accepts a file-like message representation ( which behaves as if opened in binary mode ) and returns a custom representation . If `create` is True , the mailbox is created if it does not exist . With arguments `path`.", "question_id": 5771}
{"snippet": "mbox.get_file(key)", "intent": "Using the file after calling flush ( ) or close ( ) on the mbox instance may yield unpredictable results or raise an exception . With arguments `key`.", "question_id": 5772}
{"snippet": "mbox.lock()", "intent": "Three locking mechanisms are used\u2014dot locking and , if available , the flock ( ) and lockf ( ) system calls .", "question_id": 5773}
{"snippet": "mbox.unlock()", "intent": "Three locking mechanisms are used\u2014dot locking and , if available , the flock ( ) and lockf ( ) system calls .", "question_id": 5774}
{"snippet": "mailbox.MH(path)", "intent": "A subclass of Mailbox for mailboxes in MH format . With arguments `path`.", "question_id": 5775}
{"snippet": "mailbox.MH(path, factory=None)", "intent": "A subclass of Mailbox for mailboxes in MH format . Parameter `factory` is a callable object that accepts a file-like message representation ( which behaves as if opened in binary mode ) and returns a custom representation . With arguments `path`.", "question_id": 5776}
{"snippet": "mailbox.MH(path, create=True)", "intent": "A subclass of Mailbox for mailboxes in MH format . If `create` is True , the mailbox is created if it does not exist . With arguments `path`.", "question_id": 5777}
{"snippet": "mailbox.MH(path, factory=None, create=True)", "intent": "A subclass of Mailbox for mailboxes in MH format . Parameter `factory` is a callable object that accepts a file-like message representation ( which behaves as if opened in binary mode ) and returns a custom representation . If `create` is True , the mailbox is created if it does not exist . With arguments `path`.", "question_id": 5778}
{"snippet": "mh.list_folders()", "intent": "Return a list of the names of all folders .", "question_id": 5779}
{"snippet": "mh.get_folder(folder)", "intent": "Return an MH instance representing the `folder` whose name is folder .", "question_id": 5780}
{"snippet": "mh.add_folder(folder)", "intent": "Create a `folder` whose name is folder and return an MH instance representing it .", "question_id": 5781}
{"snippet": "mh.remove_folder(folder)", "intent": "Delete the `folder` whose name is folder .", "question_id": 5782}
{"snippet": "mh.get_sequences()", "intent": "Return a dictionary of sequence names mapped to key lists .", "question_id": 5783}
{"snippet": "mh.set_sequences(sequences)", "intent": "Re-define the `sequences` that exist in the mailbox based upon sequences , a dictionary of names mapped to key lists , like returned by get_sequences ( ) .", "question_id": 5784}
{"snippet": "mh.pack()", "intent": "Rename messages in the mailbox as necessary to eliminate gaps in numbering .", "question_id": 5785}
{"snippet": "mh.remove(key)", "intent": "These methods immediately delete the message . With arguments `key`.", "question_id": 5786}
{"snippet": "mh.__delitem__(key)", "intent": "These methods immediately delete the message . With arguments `key`.", "question_id": 5787}
{"snippet": "mh.discard(key)", "intent": "These methods immediately delete the message . With arguments `key`.", "question_id": 5788}
{"snippet": "mh.lock()", "intent": "Three locking mechanisms are used\u2014dot locking and , if available , the flock ( ) and lockf ( ) system calls .", "question_id": 5789}
{"snippet": "mh.unlock()", "intent": "Three locking mechanisms are used\u2014dot locking and , if available , the flock ( ) and lockf ( ) system calls .", "question_id": 5790}
{"snippet": "mh.get_file(key)", "intent": "Depending upon the host platform , it may not be possible to remove the underlying message while the returned file remains open . With arguments `key`.", "question_id": 5791}
{"snippet": "mh.flush()", "intent": "All changes to MH mailboxes are immediately applied , so this method does nothing .", "question_id": 5792}
{"snippet": "mh.close()", "intent": "MH instances do not keep any open files , so this method is equivalent to unlock ( ) .", "question_id": 5793}
{"snippet": "mailbox.Babyl(path)", "intent": "A subclass of Mailbox for mailboxes in Babyl format . With arguments `path`.", "question_id": 5794}
{"snippet": "mailbox.Babyl(path, factory=None)", "intent": "A subclass of Mailbox for mailboxes in Babyl format . Parameter `factory` is a callable object that accepts a file-like message representation ( which behaves as if opened in binary mode ) and returns a custom representation . With arguments `path`.", "question_id": 5795}
{"snippet": "mailbox.Babyl(path, create=True)", "intent": "A subclass of Mailbox for mailboxes in Babyl format . If `create` is True , the mailbox is created if it does not exist . With arguments `path`.", "question_id": 5796}
{"snippet": "mailbox.Babyl(path, factory=None, create=True)", "intent": "A subclass of Mailbox for mailboxes in Babyl format . Parameter `factory` is a callable object that accepts a file-like message representation ( which behaves as if opened in binary mode ) and returns a custom representation . If `create` is True , the mailbox is created if it does not exist . With arguments `path`.", "question_id": 5797}
{"snippet": "babyl.get_labels()", "intent": "Return a list of the names of all user-defined labels used in the mailbox .", "question_id": 5798}
{"snippet": "babyl.get_file(key)", "intent": "In Babyl mailboxes , the headers of a message are not stored contiguously with the body of the message . With arguments `key`.", "question_id": 5799}
{"snippet": "babyl.lock()", "intent": "Three locking mechanisms are used\u2014dot locking and , if available , the flock ( ) and lockf ( ) system calls .", "question_id": 5800}
{"snippet": "babyl.unlock()", "intent": "Three locking mechanisms are used\u2014dot locking and , if available , the flock ( ) and lockf ( ) system calls .", "question_id": 5801}
{"snippet": "mailbox.MMDF(path)", "intent": "A subclass of Mailbox for mailboxes in MMDF format . With arguments `path`.", "question_id": 5802}
{"snippet": "mailbox.MMDF(path, factory=None)", "intent": "A subclass of Mailbox for mailboxes in MMDF format . Parameter `factory` is a callable object that accepts a file-like message representation ( which behaves as if opened in binary mode ) and returns a custom representation . With arguments `path`.", "question_id": 5803}
{"snippet": "mailbox.MMDF(path, create=True)", "intent": "A subclass of Mailbox for mailboxes in MMDF format . If `create` is True , the mailbox is created if it does not exist . With arguments `path`.", "question_id": 5804}
{"snippet": "mailbox.MMDF(path, factory=None, create=True)", "intent": "A subclass of Mailbox for mailboxes in MMDF format . Parameter `factory` is a callable object that accepts a file-like message representation ( which behaves as if opened in binary mode ) and returns a custom representation . If `create` is True , the mailbox is created if it does not exist . With arguments `path`.", "question_id": 5805}
{"snippet": "mmdf.get_file(key)", "intent": "Using the file after calling flush ( ) or close ( ) on the MMDF instance may yield unpredictable results or raise an exception . With arguments `key`.", "question_id": 5806}
{"snippet": "mmdf.lock()", "intent": "Three locking mechanisms are used\u2014dot locking and , if available , the flock ( ) and lockf ( ) system calls .", "question_id": 5807}
{"snippet": "mmdf.unlock()", "intent": "Three locking mechanisms are used\u2014dot locking and , if available , the flock ( ) and lockf ( ) system calls .", "question_id": 5808}
{"snippet": "mailbox.Message()", "intent": "A subclass of the email.message module \u2019 s Message .", "question_id": 5809}
{"snippet": "mailbox.Message(message=None)", "intent": "A subclass of the email.message module \u2019 s Message . If `message` is omitted , the new instance is created in a default , empty state .", "question_id": 5810}
{"snippet": "mailbox.MaildirMessage()", "intent": "A `message` with Maildir-specific behaviors .", "question_id": 5811}
{"snippet": "mailbox.MaildirMessage(message=None)", "intent": "A `message` with Maildir-specific behaviors .", "question_id": 5812}
{"snippet": "maildir_message.get_subdir()", "intent": "Return either \u201c new \u201d ( if the message should be stored in the new subdirectory ) or \u201c cur \u201d ( if the message should be stored in the cur subdirectory ) .", "question_id": 5813}
{"snippet": "maildir_message.set_subdir(subdir)", "intent": "Set the subdirectory the message should be stored in . Parameter `subdir` must be either \u201c new \u201d or \u201c cur \u201d .", "question_id": 5814}
{"snippet": "maildir_message.get_flags()", "intent": "Return a string specifying the flags that are currently set .", "question_id": 5815}
{"snippet": "maildir_message.set_flags(flags)", "intent": "Set the `flags` specified by flags and unset all others .", "question_id": 5816}
{"snippet": "maildir_message.add_flag(flag)", "intent": "Set the `flag` ( s ) specified by flag without changing other flags .", "question_id": 5817}
{"snippet": "maildir_message.remove_flag(flag)", "intent": "Unset the `flag` ( s ) specified by flag without changing other flags .", "question_id": 5818}
{"snippet": "maildir_message.get_date()", "intent": "Return the delivery date of the message as a floating-point number representing seconds since the epoch .", "question_id": 5819}
{"snippet": "maildir_message.set_date(date)", "intent": "Set the delivery `date` of the message to date , a floating-point number representing seconds since the epoch .", "question_id": 5820}
{"snippet": "maildir_message.get_info()", "intent": "Return a string containing the \u201c info \u201d for a message .", "question_id": 5821}
{"snippet": "maildir_message.set_info(info)", "intent": "Set \u201c `info` \u201d to info , which should be a string .", "question_id": 5822}
{"snippet": "mailbox.mboxMessage()", "intent": "A `message` with mbox-specific behaviors .", "question_id": 5823}
{"snippet": "mailbox.mboxMessage(message=None)", "intent": "A `message` with mbox-specific behaviors .", "question_id": 5824}
{"snippet": "mbox_message.get_from()", "intent": "Return a string representing the \u201c From \u201d line that marks the start of the message in an mbox mailbox .", "question_id": 5825}
{"snippet": "mbox_message.set_from(from_)", "intent": "Set the \u201c From \u201d line to `from_` , which should be specified without a leading \u201c From \u201d or trailing newline .", "question_id": 5826}
{"snippet": "mbox_message.set_from(from_, time_=None)", "intent": "Set the \u201c From \u201d line to `from_` , which should be specified without a leading \u201c From \u201d or trailing newline . For convenience , `time_` may be specified and will be formatted appropriately and appended to from_ .", "question_id": 5827}
{"snippet": "mbox_message.get_flags()", "intent": "Return a string specifying the flags that are currently set .", "question_id": 5828}
{"snippet": "mbox_message.set_flags(flags)", "intent": "Set the `flags` specified by flags and unset all others .", "question_id": 5829}
{"snippet": "mbox_message.add_flag(flag)", "intent": "Set the `flag` ( s ) specified by flag without changing other flags .", "question_id": 5830}
{"snippet": "mbox_message.remove_flag(flag)", "intent": "Unset the `flag` ( s ) specified by flag without changing other flags .", "question_id": 5831}
{"snippet": "mailbox.MHMessage()", "intent": "A `message` with MH-specific behaviors .", "question_id": 5832}
{"snippet": "mailbox.MHMessage(message=None)", "intent": "A `message` with MH-specific behaviors .", "question_id": 5833}
{"snippet": "mh_message.get_sequences()", "intent": "Return a list of the names of sequences that include this message .", "question_id": 5834}
{"snippet": "mh_message.set_sequences(sequences)", "intent": "Set the list of `sequences` that include this message .", "question_id": 5835}
{"snippet": "mh_message.add_sequence(sequence)", "intent": "Add `sequence` to the list of sequences that include this message .", "question_id": 5836}
{"snippet": "mh_message.remove_sequence(sequence)", "intent": "Remove `sequence` from the list of sequences that include this message .", "question_id": 5837}
{"snippet": "mailbox.BabylMessage()", "intent": "A `message` with Babyl-specific behaviors .", "question_id": 5838}
{"snippet": "mailbox.BabylMessage(message=None)", "intent": "A `message` with Babyl-specific behaviors .", "question_id": 5839}
{"snippet": "babyl_message.get_labels()", "intent": "Return a list of labels on the message .", "question_id": 5840}
{"snippet": "babyl_message.set_labels(labels)", "intent": "Set the list of `labels` on the message to labels .", "question_id": 5841}
{"snippet": "babyl_message.add_label(label)", "intent": "Add `label` to the list of labels on the message .", "question_id": 5842}
{"snippet": "babyl_message.remove_label(label)", "intent": "Remove `label` from the list of labels on the message .", "question_id": 5843}
{"snippet": "babyl_message.get_visible()", "intent": "Return an Message instance whose headers are the message \u2019 s visible headers and whose body is empty .", "question_id": 5844}
{"snippet": "babyl_message.set_visible(visible)", "intent": "Set the message \u2019 s `visible` headers to be the same as the headers in message .", "question_id": 5845}
{"snippet": "babyl_message.update_visible()", "intent": "When a BabylMessage instance \u2019 s original headers are modified , the visible headers are not automatically modified to correspond .", "question_id": 5846}
{"snippet": "mailbox.MMDFMessage()", "intent": "A `message` with MMDF-specific behaviors .", "question_id": 5847}
{"snippet": "mailbox.MMDFMessage(message=None)", "intent": "A `message` with MMDF-specific behaviors .", "question_id": 5848}
{"snippet": "mmdf_message.get_from()", "intent": "Return a string representing the \u201c From \u201d line that marks the start of the message in an mbox mailbox .", "question_id": 5849}
{"snippet": "mmdf_message.set_from(from_)", "intent": "Set the \u201c From \u201d line to `from_` , which should be specified without a leading \u201c From \u201d or trailing newline .", "question_id": 5850}
{"snippet": "mmdf_message.set_from(from_, time_=None)", "intent": "Set the \u201c From \u201d line to `from_` , which should be specified without a leading \u201c From \u201d or trailing newline . For convenience , `time_` may be specified and will be formatted appropriately and appended to from_ .", "question_id": 5851}
{"snippet": "mmdf_message.get_flags()", "intent": "Return a string specifying the flags that are currently set .", "question_id": 5852}
{"snippet": "mmdf_message.set_flags(flags)", "intent": "Set the `flags` specified by flags and unset all others .", "question_id": 5853}
{"snippet": "mmdf_message.add_flag(flag)", "intent": "Set the `flag` ( s ) specified by flag without changing other flags .", "question_id": 5854}
{"snippet": "mmdf_message.remove_flag(flag)", "intent": "Unset the `flag` ( s ) specified by flag without changing other flags .", "question_id": 5855}
{"snippet": "mailbox.Error", "intent": "The based class for all other module-specific exceptions.", "question_id": 5856}
{"snippet": "mailbox.NoSuchMailboxError", "intent": "Raised when a mailbox is expected but is not found, such as when instantiating a Mailbox subclass with a path that does not exist (and with the create parameter set to False), or when opening a folder that does not exist.", "question_id": 5857}
{"snippet": "mailbox.NotEmptyError", "intent": "Raised when a mailbox is not empty but is expected to be, such as when deleting a folder that contains messages.", "question_id": 5858}
{"snippet": "mailbox.ExternalClashError", "intent": "Raised when some mailbox-related condition beyond the control of the program causes it to be unable to proceed, such as when failing to acquire a lock that another program already holds a lock, or when a uniquely-generated file name already exists.", "question_id": 5859}
{"snippet": "mailbox.FormatError", "intent": "Raised when the data in a file cannot be parsed, such as when an MH instance attempts to read a corrupted .mh_sequences file.", "question_id": 5860}
{"snippet": "mailcap.findmatch(caps, MIMEtype)", "intent": "Return a 2-tuple ; the first element is a string containing the command line to be executed ( which can be passed to os.system ( ) ) , and the second element is the mailcap entry for a given MIME type . With arguments `caps`, `MIMEtype`.", "question_id": 5861}
{"snippet": "mailcap.findmatch(caps, MIMEtype, key='view')", "intent": "Return a 2-tuple ; the first element is a string containing the command line to be executed ( which can be passed to os.system ( ) ) , and the second element is the mailcap entry for a given MIME type . `key` is the name of the field desired , which represents the type of activity to be performed ; the default value is \u2018 view \u2019 , since in the most common case you simply want to view the body of the MIME-typed data . With arguments `caps`, `MIMEtype`.", "question_id": 5862}
{"snippet": "mailcap.findmatch(caps, MIMEtype, filename='/dev/null')", "intent": "Return a 2-tuple ; the first element is a string containing the command line to be executed ( which can be passed to os.system ( ) ) , and the second element is the mailcap entry for a given MIME type . `filename` is the filename to be substituted for % s in the command line ; the default value is '/dev/null ' which is almost certainly not what you want , so usually you \u2019 ll override it by specifying a filename . With arguments `caps`, `MIMEtype`.", "question_id": 5863}
{"snippet": "mailcap.findmatch(caps, MIMEtype, plist=)", "intent": "Return a 2-tuple ; the first element is a string containing the command line to be executed ( which can be passed to os.system ( ) ) , and the second element is the mailcap entry for a given MIME type . `plist` can be a list containing named parameters ; the default value is simply an empty list . With arguments `caps`, `MIMEtype`.", "question_id": 5864}
{"snippet": "mailcap.findmatch(caps, MIMEtype, key='view', filename='/dev/null')", "intent": "Return a 2-tuple ; the first element is a string containing the command line to be executed ( which can be passed to os.system ( ) ) , and the second element is the mailcap entry for a given MIME type . `key` is the name of the field desired , which represents the type of activity to be performed ; the default value is \u2018 view \u2019 , since in the most common case you simply want to view the body of the MIME-typed data . `filename` is the filename to be substituted for % s in the command line ; the default value is '/dev/null ' which is almost certainly not what you want , so usually you \u2019 ll override it by specifying a filename . With arguments `caps`, `MIMEtype`.", "question_id": 5865}
{"snippet": "mailcap.findmatch(caps, MIMEtype, key='view', plist=)", "intent": "Return a 2-tuple ; the first element is a string containing the command line to be executed ( which can be passed to os.system ( ) ) , and the second element is the mailcap entry for a given MIME type . `key` is the name of the field desired , which represents the type of activity to be performed ; the default value is \u2018 view \u2019 , since in the most common case you simply want to view the body of the MIME-typed data . `plist` can be a list containing named parameters ; the default value is simply an empty list . With arguments `caps`, `MIMEtype`.", "question_id": 5866}
{"snippet": "mailcap.findmatch(caps, MIMEtype, filename='/dev/null', plist=)", "intent": "Return a 2-tuple ; the first element is a string containing the command line to be executed ( which can be passed to os.system ( ) ) , and the second element is the mailcap entry for a given MIME type . `filename` is the filename to be substituted for % s in the command line ; the default value is '/dev/null ' which is almost certainly not what you want , so usually you \u2019 ll override it by specifying a filename . `plist` can be a list containing named parameters ; the default value is simply an empty list . With arguments `caps`, `MIMEtype`.", "question_id": 5867}
{"snippet": "mailcap.findmatch(caps, MIMEtype, key='view', filename='/dev/null', plist=)", "intent": "Return a 2-tuple ; the first element is a string containing the command line to be executed ( which can be passed to os.system ( ) ) , and the second element is the mailcap entry for a given MIME type . `key` is the name of the field desired , which represents the type of activity to be performed ; the default value is \u2018 view \u2019 , since in the most common case you simply want to view the body of the MIME-typed data . `filename` is the filename to be substituted for % s in the command line ; the default value is '/dev/null ' which is almost certainly not what you want , so usually you \u2019 ll override it by specifying a filename . `plist` can be a list containing named parameters ; the default value is simply an empty list . With arguments `caps`, `MIMEtype`.", "question_id": 5868}
{"snippet": "mailcap.findmatch(caps)", "intent": "Return a 2-tuple ; the first element is a string containing the command line to be executed ( which can be passed to os.system ( ) ) , and the second element is the mailcap entry for a given MIME type . With arguments `caps`.", "question_id": 5869}
{"snippet": "mailcap.findmatch(caps, key='view')", "intent": "Return a 2-tuple ; the first element is a string containing the command line to be executed ( which can be passed to os.system ( ) ) , and the second element is the mailcap entry for a given MIME type . `key` is the name of the field desired , which represents the type of activity to be performed ; the default value is \u2018 view \u2019 , since in the most common case you simply want to view the body of the MIME-typed data . With arguments `caps`.", "question_id": 5870}
{"snippet": "mailcap.findmatch(caps, filename='/dev/null')", "intent": "Return a 2-tuple ; the first element is a string containing the command line to be executed ( which can be passed to os.system ( ) ) , and the second element is the mailcap entry for a given MIME type . `filename` is the filename to be substituted for % s in the command line ; the default value is '/dev/null ' which is almost certainly not what you want , so usually you \u2019 ll override it by specifying a filename . With arguments `caps`.", "question_id": 5871}
{"snippet": "mailcap.findmatch(caps, plist=)", "intent": "Return a 2-tuple ; the first element is a string containing the command line to be executed ( which can be passed to os.system ( ) ) , and the second element is the mailcap entry for a given MIME type . `plist` can be a list containing named parameters ; the default value is simply an empty list . With arguments `caps`.", "question_id": 5872}
{"snippet": "mailcap.findmatch(caps, key='view', filename='/dev/null')", "intent": "Return a 2-tuple ; the first element is a string containing the command line to be executed ( which can be passed to os.system ( ) ) , and the second element is the mailcap entry for a given MIME type . `key` is the name of the field desired , which represents the type of activity to be performed ; the default value is \u2018 view \u2019 , since in the most common case you simply want to view the body of the MIME-typed data . `filename` is the filename to be substituted for % s in the command line ; the default value is '/dev/null ' which is almost certainly not what you want , so usually you \u2019 ll override it by specifying a filename . With arguments `caps`.", "question_id": 5873}
{"snippet": "mailcap.findmatch(caps, key='view', plist=)", "intent": "Return a 2-tuple ; the first element is a string containing the command line to be executed ( which can be passed to os.system ( ) ) , and the second element is the mailcap entry for a given MIME type . `key` is the name of the field desired , which represents the type of activity to be performed ; the default value is \u2018 view \u2019 , since in the most common case you simply want to view the body of the MIME-typed data . `plist` can be a list containing named parameters ; the default value is simply an empty list . With arguments `caps`.", "question_id": 5874}
{"snippet": "mailcap.findmatch(caps, filename='/dev/null', plist=)", "intent": "Return a 2-tuple ; the first element is a string containing the command line to be executed ( which can be passed to os.system ( ) ) , and the second element is the mailcap entry for a given MIME type . `filename` is the filename to be substituted for % s in the command line ; the default value is '/dev/null ' which is almost certainly not what you want , so usually you \u2019 ll override it by specifying a filename . `plist` can be a list containing named parameters ; the default value is simply an empty list . With arguments `caps`.", "question_id": 5875}
{"snippet": "mailcap.findmatch(caps, key='view', filename='/dev/null', plist=)", "intent": "Return a 2-tuple ; the first element is a string containing the command line to be executed ( which can be passed to os.system ( ) ) , and the second element is the mailcap entry for a given MIME type . `key` is the name of the field desired , which represents the type of activity to be performed ; the default value is \u2018 view \u2019 , since in the most common case you simply want to view the body of the MIME-typed data . `filename` is the filename to be substituted for % s in the command line ; the default value is '/dev/null ' which is almost certainly not what you want , so usually you \u2019 ll override it by specifying a filename . `plist` can be a list containing named parameters ; the default value is simply an empty list . With arguments `caps`.", "question_id": 5876}
{"snippet": "mailcap.getcaps()", "intent": "Returns a dictionary mapping MIME types to a list of mailcap file entries .", "question_id": 5877}
{"snippet": "marshal.dump(value, file, version)", "intent": "Write the `value` on the open `file` . The `version` argument indicates the data format that dump should use ( see below ) .", "question_id": 5878}
{"snippet": "marshal.dump(value, file)", "intent": "Write the `value` on the open `file` .", "question_id": 5879}
{"snippet": "marshal.load(file)", "intent": "Read one value from the open `file` and return it .", "question_id": 5880}
{"snippet": "marshal.dumps(value, version)", "intent": "Return the bytes object that would be written to a file by dump ( `value` , file ) . The `version` argument indicates the data format that dumps should use ( see below ) .", "question_id": 5881}
{"snippet": "marshal.dumps(value)", "intent": "Return the bytes object that would be written to a file by dump ( `value` , file ) .", "question_id": 5882}
{"snippet": "marshal.loads(bytes)", "intent": "Convert the bytes-like object to a value . Extra `bytes` in the input are ignored .", "question_id": 5883}
{"snippet": "marshal.version", "intent": "Indicates the format that the module uses.", "question_id": 5884}
{"snippet": "math.ceil(x)", "intent": "Return the ceiling of `x` , the smallest integer greater than or equal to x .", "question_id": 5885}
{"snippet": "math.copysign(x, y)", "intent": "Return a float with the magnitude ( absolute value ) of `x` but the sign of `y` .", "question_id": 5886}
{"snippet": "math.fabs(x)", "intent": "Return the absolute value of `x` .", "question_id": 5887}
{"snippet": "math.factorial(x)", "intent": "Return `x` factorial as an integer .", "question_id": 5888}
{"snippet": "math.floor(x)", "intent": "Return the floor of `x` , the largest integer less than or equal to x .", "question_id": 5889}
{"snippet": "math.fmod(x, y)", "intent": "Return fmod ( `x` , `y` ) , as defined by the platform C library .", "question_id": 5890}
{"snippet": "math.frexp(x)", "intent": "Return the mantissa and exponent of `x` as the pair ( m , e ) .", "question_id": 5891}
{"snippet": "math.fsum(iterable)", "intent": "Return an accurate floating point sum of values in the `iterable` .", "question_id": 5892}
{"snippet": "math.gcd(a, b)", "intent": "Return the greatest common divisor of the integers `a` and `b` .", "question_id": 5893}
{"snippet": "math.isclose(a, b)", "intent": "Return True if the values `a` and `b` are close to each other and False otherwise .", "question_id": 5894}
{"snippet": "math.isclose(a, b, rel_tol=1e-09)", "intent": "Return True if the values `a` and `b` are close to each other and False otherwise . `rel_tol` is the relative tolerance \u2013 it is the maximum allowed difference between a and b , relative to the larger absolute value of a or b .", "question_id": 5895}
{"snippet": "math.isclose(a, b, abs_tol=0.0)", "intent": "Return True if the values `a` and `b` are close to each other and False otherwise . `abs_tol` is the minimum absolute tolerance \u2013 useful for comparisons near zero .", "question_id": 5896}
{"snippet": "math.isclose(a, b, rel_tol=1e-09, abs_tol=0.0)", "intent": "Return True if the values `a` and `b` are close to each other and False otherwise . `rel_tol` is the relative tolerance \u2013 it is the maximum allowed difference between a and b , relative to the larger absolute value of a or b . `abs_tol` is the minimum absolute tolerance \u2013 useful for comparisons near zero .", "question_id": 5897}
{"snippet": "math.isfinite(x)", "intent": "Return True if `x` is neither an infinity nor a NaN , and False otherwise .", "question_id": 5898}
{"snippet": "math.isinf(x)", "intent": "Return True if `x` is a positive or negative infinity , and False otherwise .", "question_id": 5899}
{"snippet": "math.isnan(x)", "intent": "Return True if `x` is a NaN ( not a number ) , and False otherwise .", "question_id": 5900}
{"snippet": "math.ldexp(x, i)", "intent": "Return `x` * ( 2**i ) . With arguments `i`.", "question_id": 5901}
{"snippet": "math.modf(x)", "intent": "Return the fractional and integer parts of `x` .", "question_id": 5902}
{"snippet": "math.remainder(x, y)", "intent": "Return the IEEE 754-style remainder of `x` with respect to `y` .", "question_id": 5903}
{"snippet": "math.trunc(x)", "intent": "Return the Real value `x` truncated to an Integral ( usually an integer ) .", "question_id": 5904}
{"snippet": "math.exp(x)", "intent": "Return e raised to the power `x` , where e = 2.718281\u2026 is the base of natural logarithms .", "question_id": 5905}
{"snippet": "math.expm1(x)", "intent": "Return e raised to the power `x` , minus 1 .", "question_id": 5906}
{"snippet": "math.log(x, base)", "intent": "With one argument , return the natural logarithm of `x` ( to `base` e ) .", "question_id": 5907}
{"snippet": "math.log(x)", "intent": "With one argument , return the natural logarithm of `x` ( to `base` e ) .", "question_id": 5908}
{"snippet": "math.log1p(x)", "intent": "Return the natural logarithm of 1+x ( base e ) . The result is calculated in a way which is accurate for `x` near zero .", "question_id": 5909}
{"snippet": "math.log2(x)", "intent": "Return the base-2 logarithm of `x` .", "question_id": 5910}
{"snippet": "math.log10(x)", "intent": "Return the base-10 logarithm of `x` .", "question_id": 5911}
{"snippet": "math.pow(x, y)", "intent": "Return `x` raised to the power `y` .", "question_id": 5912}
{"snippet": "math.sqrt(x)", "intent": "Return the square root of `x` .", "question_id": 5913}
{"snippet": "math.acos(x)", "intent": "Return the arc cosine of `x` , in radians .", "question_id": 5914}
{"snippet": "math.asin(x)", "intent": "Return the arc sine of `x` , in radians .", "question_id": 5915}
{"snippet": "math.atan(x)", "intent": "Return the arc tangent of `x` , in radians .", "question_id": 5916}
{"snippet": "math.atan2(y, x)", "intent": "Return atan ( `y` / `x` ) , in radians .", "question_id": 5917}
{"snippet": "math.cos(x)", "intent": "Return the cosine of `x` radians .", "question_id": 5918}
{"snippet": "math.hypot(x, y)", "intent": "Return the Euclidean norm , sqrt ( x*x + y*y ) . This is the length of the vector from the origin to point ( `x` , `y` ) .", "question_id": 5919}
{"snippet": "math.sin(x)", "intent": "Return the sine of `x` radians .", "question_id": 5920}
{"snippet": "math.tan(x)", "intent": "Return the tangent of `x` radians .", "question_id": 5921}
{"snippet": "math.degrees(x)", "intent": "Convert angle `x` from radians to degrees .", "question_id": 5922}
{"snippet": "math.radians(x)", "intent": "Convert angle `x` from degrees to radians .", "question_id": 5923}
{"snippet": "math.acosh(x)", "intent": "Return the inverse hyperbolic cosine of `x` .", "question_id": 5924}
{"snippet": "math.asinh(x)", "intent": "Return the inverse hyperbolic sine of `x` .", "question_id": 5925}
{"snippet": "math.atanh(x)", "intent": "Return the inverse hyperbolic tangent of `x` .", "question_id": 5926}
{"snippet": "math.cosh(x)", "intent": "Return the hyperbolic cosine of `x` .", "question_id": 5927}
{"snippet": "math.sinh(x)", "intent": "Return the hyperbolic sine of `x` .", "question_id": 5928}
{"snippet": "math.tanh(x)", "intent": "Return the hyperbolic tangent of `x` .", "question_id": 5929}
{"snippet": "math.erf(x)", "intent": "Return the error function at `x` .", "question_id": 5930}
{"snippet": "math.erfc(x)", "intent": "Return the complementary error function at `x` .", "question_id": 5931}
{"snippet": "math.gamma(x)", "intent": "Return the Gamma function at `x` .", "question_id": 5932}
{"snippet": "math.lgamma(x)", "intent": "Return the natural logarithm of the absolute value of the Gamma function at `x` .", "question_id": 5933}
{"snippet": "math.pi", "intent": "The mathematical constant \u03c0 = 3.141592\u2026, to available precision.", "question_id": 5934}
{"snippet": "math.e", "intent": "The mathematical constant e = 2.718281\u2026, to available precision.", "question_id": 5935}
{"snippet": "math.tau", "intent": "The mathematical constant \u03c4 = 6.283185\u2026, to available precision.", "question_id": 5936}
{"snippet": "math.inf", "intent": "A floating-point positive infinity.", "question_id": 5937}
{"snippet": "math.nan", "intent": "A floating-point \u201cnot a number\u201d (NaN) value.", "question_id": 5938}
{"snippet": "mimetypes.guess_type(url)", "intent": "Guess the type of a file based on its filename or URL , given by `url` .", "question_id": 5939}
{"snippet": "mimetypes.guess_type(url, strict=True)", "intent": "Guess the type of a file based on its filename or URL , given by `url` . The optional `strict` argument is a flag specifying whether the list of known MIME types is limited to only the official types registered with IANA .", "question_id": 5940}
{"snippet": "mimetypes.guess_all_extensions(type)", "intent": "Guess the extensions for a file based on its MIME `type` , given by type .", "question_id": 5941}
{"snippet": "mimetypes.guess_all_extensions(type, strict=True)", "intent": "Guess the extensions for a file based on its MIME `type` , given by type . The optional `strict` argument has the same meaning as with the guess_type ( ) function .", "question_id": 5942}
{"snippet": "mimetypes.guess_extension(type)", "intent": "Guess the extension for a file based on its MIME `type` , given by type .", "question_id": 5943}
{"snippet": "mimetypes.guess_extension(type, strict=True)", "intent": "Guess the extension for a file based on its MIME `type` , given by type . The optional `strict` argument has the same meaning as with the guess_type ( ) function .", "question_id": 5944}
{"snippet": "mimetypes.init()", "intent": "Initialize the internal data structures .", "question_id": 5945}
{"snippet": "mimetypes.init(files=None)", "intent": "Initialize the internal data structures . If given , `files` must be a sequence of file names which should be used to augment the default type map .", "question_id": 5946}
{"snippet": "mimetypes.read_mime_types(filename)", "intent": "Load the type map given in the file `filename` , if it exists .", "question_id": 5947}
{"snippet": "mimetypes.add_type(type, ext)", "intent": "Add a mapping from the MIME `type` type to the extension `ext` .", "question_id": 5948}
{"snippet": "mimetypes.add_type(type, ext, strict=True)", "intent": "Add a mapping from the MIME `type` type to the extension `ext` . When `strict` is True ( the default ) , the mapping will be added to the official MIME types , otherwise to the non-standard ones .", "question_id": 5949}
{"snippet": "mimetypes.inited", "intent": "Flag indicating whether or not the global data structures have been initialized.", "question_id": 5950}
{"snippet": "mimetypes.knownfiles", "intent": "List of type map file names commonly installed.", "question_id": 5951}
{"snippet": "mimetypes.suffix_map", "intent": "Dictionary mapping suffixes to suffixes.", "question_id": 5952}
{"snippet": "mimetypes.encodings_map", "intent": "Dictionary mapping filename extensions to encoding types.", "question_id": 5953}
{"snippet": "mimetypes.types_map", "intent": "Dictionary mapping filename extensions to MIME types.", "question_id": 5954}
{"snippet": "mimetypes.common_types", "intent": "Dictionary mapping filename extensions to non-standard, but commonly found MIME types.", "question_id": 5955}
{"snippet": "mimetypes.MimeTypes()", "intent": "This class represents a MIME-types database .", "question_id": 5956}
{"snippet": "mimetypes.MimeTypes(filenames=())", "intent": "This class represents a MIME-types database . The optional `filenames` parameter can be used to cause additional files to be loaded \u201c on top \u201d of the default database .", "question_id": 5957}
{"snippet": "mimetypes.MimeTypes(strict=True)", "intent": "This class represents a MIME-types database . With arguments `strict`.", "question_id": 5958}
{"snippet": "mimetypes.MimeTypes(filenames=(), strict=True)", "intent": "This class represents a MIME-types database . The optional `filenames` parameter can be used to cause additional files to be loaded \u201c on top \u201d of the default database . With arguments `strict`.", "question_id": 5959}
{"snippet": "mime_types.suffix_map", "intent": "Dictionary mapping suffixes to suffixes.", "question_id": 5960}
{"snippet": "mime_types.encodings_map", "intent": "Dictionary mapping filename extensions to encoding types.", "question_id": 5961}
{"snippet": "mime_types.types_map", "intent": "Tuple containing two dictionaries, mapping filename extensions to MIME types: the first dictionary is for the non-standards types and the second one is for the standard types.", "question_id": 5962}
{"snippet": "mime_types.types_map_inv", "intent": "Tuple containing two dictionaries, mapping MIME types to a list of filename extensions: the first dictionary is for the non-standards types and the second one is for the standard types.", "question_id": 5963}
{"snippet": "mime_types.guess_extension(type)", "intent": "Similar to the guess_extension ( ) function , using the tables stored as part of the object . With arguments `type`.", "question_id": 5964}
{"snippet": "mime_types.guess_extension(type, strict=True)", "intent": "Similar to the guess_extension ( ) function , using the tables stored as part of the object . With arguments `type`, `strict`.", "question_id": 5965}
{"snippet": "mime_types.guess_type(url)", "intent": "Similar to the guess_type ( ) function , using the tables stored as part of the object . With arguments `url`.", "question_id": 5966}
{"snippet": "mime_types.guess_type(url, strict=True)", "intent": "Similar to the guess_type ( ) function , using the tables stored as part of the object . With arguments `url`, `strict`.", "question_id": 5967}
{"snippet": "mime_types.guess_all_extensions(type)", "intent": "Similar to the guess_all_extensions ( ) function , using the tables stored as part of the object . With arguments `type`.", "question_id": 5968}
{"snippet": "mime_types.guess_all_extensions(type, strict=True)", "intent": "Similar to the guess_all_extensions ( ) function , using the tables stored as part of the object . With arguments `type`, `strict`.", "question_id": 5969}
{"snippet": "mime_types.read(filename)", "intent": "Load MIME information from a file named `filename` .", "question_id": 5970}
{"snippet": "mime_types.read(filename, strict=True)", "intent": "Load MIME information from a file named `filename` . If `strict` is True , information will be added to list of standard types , else to the list of non-standard types .", "question_id": 5971}
{"snippet": "mime_types.readfp(fp)", "intent": "Load MIME type information from an open file `fp` .", "question_id": 5972}
{"snippet": "mime_types.readfp(fp, strict=True)", "intent": "Load MIME type information from an open file `fp` . If `strict` is True , information will be added to the list of standard types , else to the list of non-standard types .", "question_id": 5973}
{"snippet": "mime_types.read_windows_registry()", "intent": "Load MIME type information from the Windows registry .", "question_id": 5974}
{"snippet": "mime_types.read_windows_registry(strict=True)", "intent": "Load MIME type information from the Windows registry . If `strict` is True , information will be added to the list of standard types , else to the list of non-standard types .", "question_id": 5975}
{"snippet": "mmap.mmap(fileno, length, offset)", "intent": "( Windows version ) Maps `length` bytes from the file specified by the file handle `fileno` , and creates a mmap object . `offset` may be specified as a non-negative integer offset .", "question_id": 5976}
{"snippet": "mmap.mmap(fileno, length, offset, tagname=None)", "intent": "( Windows version ) Maps `length` bytes from the file specified by the file handle `fileno` , and creates a mmap object . `offset` may be specified as a non-negative integer offset . `tagname` , if specified and not None , is a string giving a tag name for the mapping .", "question_id": 5977}
{"snippet": "mmap.mmap(fileno, length, offset, access=ACCESS_DEFAULT)", "intent": "( Windows version ) Maps `length` bytes from the file specified by the file handle `fileno` , and creates a mmap object . `offset` may be specified as a non-negative integer offset . With arguments `access`.", "question_id": 5978}
{"snippet": "mmap.mmap(fileno, length, offset, tagname=None, access=ACCESS_DEFAULT)", "intent": "( Windows version ) Maps `length` bytes from the file specified by the file handle `fileno` , and creates a mmap object . `offset` may be specified as a non-negative integer offset . `tagname` , if specified and not None , is a string giving a tag name for the mapping . With arguments `access`.", "question_id": 5979}
{"snippet": "mmap.mmap(fileno, length)", "intent": "( Windows version ) Maps `length` bytes from the file specified by the file handle `fileno` , and creates a mmap object .", "question_id": 5980}
{"snippet": "mmap.mmap(fileno, length, tagname=None)", "intent": "( Windows version ) Maps `length` bytes from the file specified by the file handle `fileno` , and creates a mmap object . `tagname` , if specified and not None , is a string giving a tag name for the mapping .", "question_id": 5981}
{"snippet": "mmap.mmap(fileno, length, access=ACCESS_DEFAULT)", "intent": "( Windows version ) Maps `length` bytes from the file specified by the file handle `fileno` , and creates a mmap object . With arguments `access`.", "question_id": 5982}
{"snippet": "mmap.mmap(fileno, length, tagname=None, access=ACCESS_DEFAULT)", "intent": "( Windows version ) Maps `length` bytes from the file specified by the file handle `fileno` , and creates a mmap object . `tagname` , if specified and not None , is a string giving a tag name for the mapping . With arguments `access`.", "question_id": 5983}
{"snippet": "mmap.mmap(fileno, length, offset)", "intent": "( Unix version ) Maps `length` bytes from the file specified by the file descriptor `fileno` , and returns a mmap object . `offset` may be specified as a non-negative integer offset .", "question_id": 5984}
{"snippet": "mmap.mmap(fileno, length, offset, flags=MAP_SHARED)", "intent": "( Unix version ) Maps `length` bytes from the file specified by the file descriptor `fileno` , and returns a mmap object . `offset` may be specified as a non-negative integer offset . `flags` specifies the nature of the mapping .", "question_id": 5985}
{"snippet": "mmap.mmap(fileno, length, offset, prot=PROT_WRITE|PROT_READ)", "intent": "( Unix version ) Maps `length` bytes from the file specified by the file descriptor `fileno` , and returns a mmap object . `offset` may be specified as a non-negative integer offset . `prot` , if specified , gives the desired memory protection ; the two most useful values are PROT_READ and PROT_WRITE , to specify that the pages may be read or written .", "question_id": 5986}
{"snippet": "mmap.mmap(fileno, length, offset, access=ACCESS_DEFAULT)", "intent": "( Unix version ) Maps `length` bytes from the file specified by the file descriptor `fileno` , and returns a mmap object . `offset` may be specified as a non-negative integer offset . `access` may be specified in lieu of flags and prot as an optional keyword parameter .", "question_id": 5987}
{"snippet": "mmap.mmap(fileno, length, offset, flags=MAP_SHARED, prot=PROT_WRITE|PROT_READ)", "intent": "( Unix version ) Maps `length` bytes from the file specified by the file descriptor `fileno` , and returns a mmap object . `offset` may be specified as a non-negative integer offset . `flags` specifies the nature of the mapping . `prot` , if specified , gives the desired memory protection ; the two most useful values are PROT_READ and PROT_WRITE , to specify that the pages may be read or written .", "question_id": 5988}
{"snippet": "mmap.mmap(fileno, length, offset, flags=MAP_SHARED, access=ACCESS_DEFAULT)", "intent": "( Unix version ) Maps `length` bytes from the file specified by the file descriptor `fileno` , and returns a mmap object . `offset` may be specified as a non-negative integer offset . `flags` specifies the nature of the mapping . `access` may be specified in lieu of flags and prot as an optional keyword parameter .", "question_id": 5989}
{"snippet": "mmap.mmap(fileno, length, offset, prot=PROT_WRITE|PROT_READ, access=ACCESS_DEFAULT)", "intent": "( Unix version ) Maps `length` bytes from the file specified by the file descriptor `fileno` , and returns a mmap object . `offset` may be specified as a non-negative integer offset . `prot` , if specified , gives the desired memory protection ; the two most useful values are PROT_READ and PROT_WRITE , to specify that the pages may be read or written . `access` may be specified in lieu of flags and prot as an optional keyword parameter .", "question_id": 5990}
{"snippet": "mmap.mmap(fileno, length, offset, flags=MAP_SHARED, prot=PROT_WRITE|PROT_READ, access=ACCESS_DEFAULT)", "intent": "( Unix version ) Maps `length` bytes from the file specified by the file descriptor `fileno` , and returns a mmap object . `offset` may be specified as a non-negative integer offset . `flags` specifies the nature of the mapping . `prot` , if specified , gives the desired memory protection ; the two most useful values are PROT_READ and PROT_WRITE , to specify that the pages may be read or written . `access` may be specified in lieu of flags and prot as an optional keyword parameter .", "question_id": 5991}
{"snippet": "mmap.mmap(fileno, length)", "intent": "( Unix version ) Maps `length` bytes from the file specified by the file descriptor `fileno` , and returns a mmap object .", "question_id": 5992}
{"snippet": "mmap.mmap(fileno, length, flags=MAP_SHARED)", "intent": "( Unix version ) Maps `length` bytes from the file specified by the file descriptor `fileno` , and returns a mmap object . `flags` specifies the nature of the mapping .", "question_id": 5993}
{"snippet": "mmap.mmap(fileno, length, prot=PROT_WRITE|PROT_READ)", "intent": "( Unix version ) Maps `length` bytes from the file specified by the file descriptor `fileno` , and returns a mmap object . `prot` , if specified , gives the desired memory protection ; the two most useful values are PROT_READ and PROT_WRITE , to specify that the pages may be read or written .", "question_id": 5994}
{"snippet": "mmap.mmap(fileno, length, access=ACCESS_DEFAULT)", "intent": "( Unix version ) Maps `length` bytes from the file specified by the file descriptor `fileno` , and returns a mmap object . `access` may be specified in lieu of flags and prot as an optional keyword parameter .", "question_id": 5995}
{"snippet": "mmap.mmap(fileno, length, flags=MAP_SHARED, prot=PROT_WRITE|PROT_READ)", "intent": "( Unix version ) Maps `length` bytes from the file specified by the file descriptor `fileno` , and returns a mmap object . `flags` specifies the nature of the mapping . `prot` , if specified , gives the desired memory protection ; the two most useful values are PROT_READ and PROT_WRITE , to specify that the pages may be read or written .", "question_id": 5996}
{"snippet": "mmap.mmap(fileno, length, flags=MAP_SHARED, access=ACCESS_DEFAULT)", "intent": "( Unix version ) Maps `length` bytes from the file specified by the file descriptor `fileno` , and returns a mmap object . `flags` specifies the nature of the mapping . `access` may be specified in lieu of flags and prot as an optional keyword parameter .", "question_id": 5997}
{"snippet": "mmap.mmap(fileno, length, prot=PROT_WRITE|PROT_READ, access=ACCESS_DEFAULT)", "intent": "( Unix version ) Maps `length` bytes from the file specified by the file descriptor `fileno` , and returns a mmap object . `prot` , if specified , gives the desired memory protection ; the two most useful values are PROT_READ and PROT_WRITE , to specify that the pages may be read or written . `access` may be specified in lieu of flags and prot as an optional keyword parameter .", "question_id": 5998}
{"snippet": "mmap.mmap(fileno, length, flags=MAP_SHARED, prot=PROT_WRITE|PROT_READ, access=ACCESS_DEFAULT)", "intent": "( Unix version ) Maps `length` bytes from the file specified by the file descriptor `fileno` , and returns a mmap object . `flags` specifies the nature of the mapping . `prot` , if specified , gives the desired memory protection ; the two most useful values are PROT_READ and PROT_WRITE , to specify that the pages may be read or written . `access` may be specified in lieu of flags and prot as an optional keyword parameter .", "question_id": 5999}
{"snippet": "mmap.close()", "intent": "Closes the mmap .", "question_id": 6000}
{"snippet": "mmap.closed", "intent": "True if the file is closed.", "question_id": 6001}
{"snippet": "mmap.find(sub, start, end)", "intent": "Returns the lowest index in the object where the subsequence `sub` is found , such that sub is contained in the range [ `start` , `end` ] .", "question_id": 6002}
{"snippet": "mmap.find(sub, start)", "intent": "Returns the lowest index in the object where the subsequence `sub` is found , such that sub is contained in the range [ `start` , `end` ] .", "question_id": 6003}
{"snippet": "mmap.find(sub)", "intent": "Returns the lowest index in the object where the subsequence `sub` is found , such that sub is contained in the range [ `start` , `end` ] .", "question_id": 6004}
{"snippet": "mmap.flush(offset, size)", "intent": "Flushes changes made to the in-memory copy of a file back to disk . If `offset` and `size` are specified , only changes to the given range of bytes will be flushed to disk ; otherwise , the whole extent of the mapping is flushed .", "question_id": 6005}
{"snippet": "mmap.flush(offset)", "intent": "Flushes changes made to the in-memory copy of a file back to disk . If `offset` and `size` are specified , only changes to the given range of bytes will be flushed to disk ; otherwise , the whole extent of the mapping is flushed .", "question_id": 6006}
{"snippet": "mmap.flush()", "intent": "Flushes changes made to the in-memory copy of a file back to disk .", "question_id": 6007}
{"snippet": "mmap.move(dest, src, count)", "intent": "Copy the `count` bytes starting at offset `src` to the destination index `dest` .", "question_id": 6008}
{"snippet": "mmap.read(n)", "intent": "Return a bytes containing up to `n` bytes starting from the current file position .", "question_id": 6009}
{"snippet": "mmap.read()", "intent": "Return a bytes containing up to `n` bytes starting from the current file position .", "question_id": 6010}
{"snippet": "mmap.read_byte()", "intent": "Returns a byte at the current file position as an integer , and advances the file position by 1 .", "question_id": 6011}
{"snippet": "mmap.readline()", "intent": "Returns a single line , starting at the current file position and up to the next newline .", "question_id": 6012}
{"snippet": "mmap.resize(newsize)", "intent": "Resizes the map and the underlying file , if any . With arguments `newsize`.", "question_id": 6013}
{"snippet": "mmap.rfind(sub, start, end)", "intent": "Returns the highest index in the object where the subsequence `sub` is found , such that sub is contained in the range [ `start` , `end` ] .", "question_id": 6014}
{"snippet": "mmap.rfind(sub, start)", "intent": "Returns the highest index in the object where the subsequence `sub` is found , such that sub is contained in the range [ `start` , `end` ] .", "question_id": 6015}
{"snippet": "mmap.rfind(sub)", "intent": "Returns the highest index in the object where the subsequence `sub` is found , such that sub is contained in the range [ `start` , `end` ] .", "question_id": 6016}
{"snippet": "mmap.seek(pos, whence)", "intent": "Set the file \u2019 s current position . `whence` argument is optional and defaults to os.SEEK_SET or 0 ( absolute file positioning ) ; other values are os.SEEK_CUR or 1 ( seek relative to the current position ) and os.SEEK_END or 2 ( seek relative to the file \u2019 s end ) . With arguments `pos`.", "question_id": 6017}
{"snippet": "mmap.seek(pos)", "intent": "Set the file \u2019 s current position . With arguments `pos`.", "question_id": 6018}
{"snippet": "mmap.size()", "intent": "Return the length of the file , which can be larger than the size of the memory-mapped area .", "question_id": 6019}
{"snippet": "mmap.tell()", "intent": "Returns the current position of the file pointer .", "question_id": 6020}
{"snippet": "mmap.write(bytes)", "intent": "Write the `bytes` in bytes into memory at the current position of the file pointer and return the number of bytes written ( never less than len ( bytes ) , since if the write fails , a ValueError will be raised ) .", "question_id": 6021}
{"snippet": "mmap.write_byte(byte)", "intent": "Write the integer `byte` into memory at the current position of the file pointer ; the file position is advanced by 1 .", "question_id": 6022}
{"snippet": "modulefinder.AddPackagePath(pkg_name, path)", "intent": "Record that the package named `pkg_name` can be found in the specified `path` .", "question_id": 6023}
{"snippet": "modulefinder.ReplacePackage(oldname, newname)", "intent": "Allows specifying that the module named `oldname` is in fact the package named `newname` .", "question_id": 6024}
{"snippet": "modulefinder.ModuleFinder()", "intent": "This class provides run_script ( ) and report ( ) methods to determine the set of modules imported by a script .", "question_id": 6025}
{"snippet": "modulefinder.ModuleFinder(path=None)", "intent": "This class provides run_script ( ) and report ( ) methods to determine the set of modules imported by a script . `path` can be a list of directories to search for modules ; if not specified , sys.path is used .", "question_id": 6026}
{"snippet": "modulefinder.ModuleFinder(debug=0)", "intent": "This class provides run_script ( ) and report ( ) methods to determine the set of modules imported by a script . `debug` sets the debugging level ; higher values make the class print debugging messages about what it \u2019 s doing .", "question_id": 6027}
{"snippet": "modulefinder.ModuleFinder(excludes=)", "intent": "This class provides run_script ( ) and report ( ) methods to determine the set of modules imported by a script . `excludes` is a list of module names to exclude from the analysis .", "question_id": 6028}
{"snippet": "modulefinder.ModuleFinder(replace_paths=)", "intent": "This class provides run_script ( ) and report ( ) methods to determine the set of modules imported by a script . `replace_paths` is a list of ( oldpath , newpath ) tuples that will be replaced in module paths .", "question_id": 6029}
{"snippet": "modulefinder.ModuleFinder(path=None, debug=0)", "intent": "This class provides run_script ( ) and report ( ) methods to determine the set of modules imported by a script . `path` can be a list of directories to search for modules ; if not specified , sys.path is used . `debug` sets the debugging level ; higher values make the class print debugging messages about what it \u2019 s doing .", "question_id": 6030}
{"snippet": "modulefinder.ModuleFinder(path=None, excludes=)", "intent": "This class provides run_script ( ) and report ( ) methods to determine the set of modules imported by a script . `path` can be a list of directories to search for modules ; if not specified , sys.path is used . `excludes` is a list of module names to exclude from the analysis .", "question_id": 6031}
{"snippet": "modulefinder.ModuleFinder(path=None, replace_paths=)", "intent": "This class provides run_script ( ) and report ( ) methods to determine the set of modules imported by a script . `path` can be a list of directories to search for modules ; if not specified , sys.path is used . `replace_paths` is a list of ( oldpath , newpath ) tuples that will be replaced in module paths .", "question_id": 6032}
{"snippet": "modulefinder.ModuleFinder(debug=0, excludes=)", "intent": "This class provides run_script ( ) and report ( ) methods to determine the set of modules imported by a script . `debug` sets the debugging level ; higher values make the class print debugging messages about what it \u2019 s doing . `excludes` is a list of module names to exclude from the analysis .", "question_id": 6033}
{"snippet": "modulefinder.ModuleFinder(debug=0, replace_paths=)", "intent": "This class provides run_script ( ) and report ( ) methods to determine the set of modules imported by a script . `debug` sets the debugging level ; higher values make the class print debugging messages about what it \u2019 s doing . `replace_paths` is a list of ( oldpath , newpath ) tuples that will be replaced in module paths .", "question_id": 6034}
{"snippet": "modulefinder.ModuleFinder()", "intent": "This class provides run_script ( ) and report ( ) methods to determine the set of modules imported by a script .", "question_id": 6035}
{"snippet": "modulefinder.ModuleFinder(path=None)", "intent": "This class provides run_script ( ) and report ( ) methods to determine the set of modules imported by a script . `path` can be a list of directories to search for modules ; if not specified , sys.path is used .", "question_id": 6036}
{"snippet": "modulefinder.ModuleFinder(debug=0)", "intent": "This class provides run_script ( ) and report ( ) methods to determine the set of modules imported by a script . `debug` sets the debugging level ; higher values make the class print debugging messages about what it \u2019 s doing .", "question_id": 6037}
{"snippet": "modulefinder.ModuleFinder(excludes=)", "intent": "This class provides run_script ( ) and report ( ) methods to determine the set of modules imported by a script . `excludes` is a list of module names to exclude from the analysis .", "question_id": 6038}
{"snippet": "modulefinder.ModuleFinder(replace_paths=)", "intent": "This class provides run_script ( ) and report ( ) methods to determine the set of modules imported by a script . `replace_paths` is a list of ( oldpath , newpath ) tuples that will be replaced in module paths .", "question_id": 6039}
{"snippet": "modulefinder.ModuleFinder(path=None, debug=0)", "intent": "This class provides run_script ( ) and report ( ) methods to determine the set of modules imported by a script . `path` can be a list of directories to search for modules ; if not specified , sys.path is used . `debug` sets the debugging level ; higher values make the class print debugging messages about what it \u2019 s doing .", "question_id": 6040}
{"snippet": "modulefinder.ModuleFinder(path=None, excludes=)", "intent": "This class provides run_script ( ) and report ( ) methods to determine the set of modules imported by a script . `path` can be a list of directories to search for modules ; if not specified , sys.path is used . `excludes` is a list of module names to exclude from the analysis .", "question_id": 6041}
{"snippet": "modulefinder.ModuleFinder(path=None, replace_paths=)", "intent": "This class provides run_script ( ) and report ( ) methods to determine the set of modules imported by a script . `path` can be a list of directories to search for modules ; if not specified , sys.path is used . `replace_paths` is a list of ( oldpath , newpath ) tuples that will be replaced in module paths .", "question_id": 6042}
{"snippet": "modulefinder.ModuleFinder(debug=0, excludes=)", "intent": "This class provides run_script ( ) and report ( ) methods to determine the set of modules imported by a script . `debug` sets the debugging level ; higher values make the class print debugging messages about what it \u2019 s doing . `excludes` is a list of module names to exclude from the analysis .", "question_id": 6043}
{"snippet": "modulefinder.ModuleFinder(debug=0, replace_paths=)", "intent": "This class provides run_script ( ) and report ( ) methods to determine the set of modules imported by a script . `debug` sets the debugging level ; higher values make the class print debugging messages about what it \u2019 s doing . `replace_paths` is a list of ( oldpath , newpath ) tuples that will be replaced in module paths .", "question_id": 6044}
{"snippet": "modulefinder.ModuleFinder()", "intent": "This class provides run_script ( ) and report ( ) methods to determine the set of modules imported by a script .", "question_id": 6045}
{"snippet": "modulefinder.ModuleFinder(path=None)", "intent": "This class provides run_script ( ) and report ( ) methods to determine the set of modules imported by a script . `path` can be a list of directories to search for modules ; if not specified , sys.path is used .", "question_id": 6046}
{"snippet": "modulefinder.ModuleFinder(debug=0)", "intent": "This class provides run_script ( ) and report ( ) methods to determine the set of modules imported by a script . `debug` sets the debugging level ; higher values make the class print debugging messages about what it \u2019 s doing .", "question_id": 6047}
{"snippet": "modulefinder.ModuleFinder(excludes=)", "intent": "This class provides run_script ( ) and report ( ) methods to determine the set of modules imported by a script . `excludes` is a list of module names to exclude from the analysis .", "question_id": 6048}
{"snippet": "modulefinder.ModuleFinder(replace_paths=)", "intent": "This class provides run_script ( ) and report ( ) methods to determine the set of modules imported by a script . `replace_paths` is a list of ( oldpath , newpath ) tuples that will be replaced in module paths .", "question_id": 6049}
{"snippet": "modulefinder.ModuleFinder(path=None, debug=0)", "intent": "This class provides run_script ( ) and report ( ) methods to determine the set of modules imported by a script . `path` can be a list of directories to search for modules ; if not specified , sys.path is used . `debug` sets the debugging level ; higher values make the class print debugging messages about what it \u2019 s doing .", "question_id": 6050}
{"snippet": "modulefinder.ModuleFinder(path=None, excludes=)", "intent": "This class provides run_script ( ) and report ( ) methods to determine the set of modules imported by a script . `path` can be a list of directories to search for modules ; if not specified , sys.path is used . `excludes` is a list of module names to exclude from the analysis .", "question_id": 6051}
{"snippet": "modulefinder.ModuleFinder(path=None, replace_paths=)", "intent": "This class provides run_script ( ) and report ( ) methods to determine the set of modules imported by a script . `path` can be a list of directories to search for modules ; if not specified , sys.path is used . `replace_paths` is a list of ( oldpath , newpath ) tuples that will be replaced in module paths .", "question_id": 6052}
{"snippet": "modulefinder.ModuleFinder(debug=0, excludes=)", "intent": "This class provides run_script ( ) and report ( ) methods to determine the set of modules imported by a script . `debug` sets the debugging level ; higher values make the class print debugging messages about what it \u2019 s doing . `excludes` is a list of module names to exclude from the analysis .", "question_id": 6053}
{"snippet": "modulefinder.ModuleFinder(debug=0, replace_paths=)", "intent": "This class provides run_script ( ) and report ( ) methods to determine the set of modules imported by a script . `debug` sets the debugging level ; higher values make the class print debugging messages about what it \u2019 s doing . `replace_paths` is a list of ( oldpath , newpath ) tuples that will be replaced in module paths .", "question_id": 6054}
{"snippet": "module_finder.report()", "intent": "Print a report to standard output that lists the modules imported by the script and their paths , as well as modules that are missing or seem to be missing .", "question_id": 6055}
{"snippet": "module_finder.run_script(pathname)", "intent": "Analyze the contents of the `pathname` file , which must contain Python code .", "question_id": 6056}
{"snippet": "module_finder.modules", "intent": "A dictionary mapping module names to modules.", "question_id": 6057}
{"snippet": "msilib.FCICreate(cabname, files)", "intent": "Create a new CAB file named `cabname` . `files` must be a list of tuples , each containing the name of the file on disk , and the name of the file inside the CAB file .", "question_id": 6058}
{"snippet": "msilib.UuidCreate()", "intent": "Return the string representation of a new unique identifier .", "question_id": 6059}
{"snippet": "msilib.OpenDatabase(path, persist)", "intent": "Return a new database object by calling MsiOpenDatabase . `path` is the file name of the MSI file ; `persist` can be one of the constants MSIDBOPEN_CREATEDIRECT , MSIDBOPEN_CREATE , MSIDBOPEN_DIRECT , MSIDBOPEN_READONLY , or MSIDBOPEN_TRANSACT , and may include the flag MSIDBOPEN_PATCHFILE .", "question_id": 6060}
{"snippet": "msilib.CreateRecord(count)", "intent": "Return a new record object by calling MSICreateRecord ( ) . `count` is the number of fields of the record .", "question_id": 6061}
{"snippet": "msilib.init_database(name, schema, ProductName, ProductCode, ProductVersion, Manufacturer)", "intent": "Create and return a new database `name` , initialize it with `schema` , and set the properties `ProductName` , `ProductCode` , `ProductVersion` , and `Manufacturer` .", "question_id": 6062}
{"snippet": "msilib.add_data(database, table, records)", "intent": "Add all `records` to the `table` named table in `database` .", "question_id": 6063}
{"snippet": "msilib.Binary(filename)", "intent": "Represents entries in the Binary table ; inserting such an object using add_data ( ) reads the file named `filename` into the table .", "question_id": 6064}
{"snippet": "msilib.add_tables(database, module)", "intent": "Add all table content from `module` to `database` .", "question_id": 6065}
{"snippet": "msilib.add_stream(database, name, path)", "intent": "Add the file `path` into the _Stream table of `database` , with the stream `name` name .", "question_id": 6066}
{"snippet": "msilib.gen_uuid()", "intent": "Return a new UUID , in the format that MSI typically requires ( i.e .", "question_id": 6067}
{"snippet": "Database.OpenView(sql)", "intent": "Return a view object , by calling MSIDatabaseOpenView ( ) . `sql` is the SQL statement to execute .", "question_id": 6068}
{"snippet": "Database.Commit()", "intent": "Commit the changes pending in the current transaction , by calling MSIDatabaseCommit ( ) .", "question_id": 6069}
{"snippet": "Database.GetSummaryInformation(count)", "intent": "Return a new summary information object , by calling MsiGetSummaryInformation ( ) . `count` is the maximum number of updated values .", "question_id": 6070}
{"snippet": "Database.Close()", "intent": "Close the database object , through MsiCloseHandle ( ) .", "question_id": 6071}
{"snippet": "View.Execute(params)", "intent": "Execute the SQL query of the view , through MSIViewExecute ( ) . If `params` is not None , it is a record describing actual values of the parameter tokens in the query .", "question_id": 6072}
{"snippet": "View.GetColumnInfo(kind)", "intent": "Return a record describing the columns of the view , through calling MsiViewGetColumnInfo ( ) . `kind` can be either MSICOLINFO_NAMES or MSICOLINFO_TYPES .", "question_id": 6073}
{"snippet": "View.Fetch()", "intent": "Return a result record of the query , through calling MsiViewFetch ( ) .", "question_id": 6074}
{"snippet": "View.Modify(kind, data)", "intent": "Modify the view , by calling MsiViewModify ( ) . `kind` can be one of MSIMODIFY_SEEK , MSIMODIFY_REFRESH , MSIMODIFY_INSERT , MSIMODIFY_UPDATE , MSIMODIFY_ASSIGN , MSIMODIFY_REPLACE , MSIMODIFY_MERGE , MSIMODIFY_DELETE , MSIMODIFY_INSERT_TEMPORARY , MSIMODIFY_VALIDATE , MSIMODIFY_VALIDATE_NEW , MSIMODIFY_VALIDATE_FIELD , or MSIMODIFY_VALIDATE_DELETE . `data` must be a record describing the new data .", "question_id": 6075}
{"snippet": "View.Close()", "intent": "Close the view , through MsiViewClose ( ) .", "question_id": 6076}
{"snippet": "SummaryInformation.GetProperty(field)", "intent": "Return a property of the summary , through MsiSummaryInfoGetProperty ( ) . `field` is the name of the property , and can be one of the constants PID_CODEPAGE , PID_TITLE , PID_SUBJECT , PID_AUTHOR , PID_KEYWORDS , PID_COMMENTS , PID_TEMPLATE , PID_LASTAUTHOR , PID_REVNUMBER , PID_LASTPRINTED , PID_CREATE_DTM , PID_LASTSAVE_DTM , PID_PAGECOUNT , PID_WORDCOUNT , PID_CHARCOUNT , PID_APPNAME , or PID_SECURITY .", "question_id": 6077}
{"snippet": "SummaryInformation.GetPropertyCount()", "intent": "Return the number of summary properties , through MsiSummaryInfoGetPropertyCount ( ) .", "question_id": 6078}
{"snippet": "SummaryInformation.SetProperty(field, value)", "intent": "Set a property through MsiSummaryInfoSetProperty ( ) . `field` can have the same values as in GetProperty ( ) , `value` is the new value of the property .", "question_id": 6079}
{"snippet": "SummaryInformation.Persist()", "intent": "Write the modified properties to the summary information stream , using MsiSummaryInfoPersist ( ) .", "question_id": 6080}
{"snippet": "Record.GetFieldCount()", "intent": "Return the number of fields of the record , through MsiRecordGetFieldCount ( ) .", "question_id": 6081}
{"snippet": "Record.GetInteger(field)", "intent": "Return the value of `field` as an integer where possible .", "question_id": 6082}
{"snippet": "Record.GetString(field)", "intent": "Return the value of `field` as a string where possible .", "question_id": 6083}
{"snippet": "Record.SetString(field, value)", "intent": "Set `field` to `value` through MsiRecordSetString ( ) .", "question_id": 6084}
{"snippet": "Record.SetStream(field, value)", "intent": "Set `field` to the contents of the file named `value` , through MsiRecordSetStream ( ) .", "question_id": 6085}
{"snippet": "Record.SetInteger(field, value)", "intent": "Set `field` to `value` through MsiRecordSetInteger ( ) .", "question_id": 6086}
{"snippet": "Record.ClearData()", "intent": "Set all fields of the record to 0 , through MsiRecordClearData ( ) .", "question_id": 6087}
{"snippet": "msilib.CAB(name)", "intent": "The class CAB represents a CAB file . `name` is the name of the CAB file in the MSI file .", "question_id": 6088}
{"snippet": "cab.append(full, file, logical)", "intent": "Add the `file` with the pathname `full` to the CAB file , under the name `logical` .", "question_id": 6089}
{"snippet": "cab.commit(database)", "intent": "Generate a CAB file , add it as a stream to the MSI file , put it into the Media table , and remove the generated file from the disk . With arguments `database`.", "question_id": 6090}
{"snippet": "msilib.Directory(database, cab, basedir, physical, logical, default, componentflags)", "intent": "Create a new directory in the Directory table . Files are added into the current component , and into the `cab` file . To create a directory , a base directory object needs to be specified ( can be None ) , the path to the `physical` directory , and a `logical` directory name . `default` specifies the DefaultDir slot in the directory table . `componentflags` specifies the default flags that new components get . With arguments `database`, `basedir`.", "question_id": 6091}
{"snippet": "msilib.Directory(database, cab, basedir, physical, logical, default)", "intent": "Create a new directory in the Directory table . Files are added into the current component , and into the `cab` file . To create a directory , a base directory object needs to be specified ( can be None ) , the path to the `physical` directory , and a `logical` directory name . `default` specifies the DefaultDir slot in the directory table . With arguments `database`, `basedir`.", "question_id": 6092}
{"snippet": "directory.start_component()", "intent": "Add an entry to the Component table , and make this `component` the current component for this directory .", "question_id": 6093}
{"snippet": "directory.start_component(component=None)", "intent": "Add an entry to the Component table , and make this `component` the current component for this directory .", "question_id": 6094}
{"snippet": "directory.start_component(feature=None)", "intent": "Add an entry to the Component table , and make this `component` the current component for this directory . If no `feature` is given , the current feature is used .", "question_id": 6095}
{"snippet": "directory.start_component(flags=None)", "intent": "Add an entry to the Component table , and make this `component` the current component for this directory . If no `flags` are given , the directory \u2019 s default flags are used .", "question_id": 6096}
{"snippet": "directory.start_component(keyfile=None)", "intent": "Add an entry to the Component table , and make this `component` the current component for this directory . If no `keyfile` is given , the KeyPath is left null in the Component table .", "question_id": 6097}
{"snippet": "directory.start_component(uuid=None)", "intent": "Add an entry to the Component table , and make this `component` the current component for this directory . With arguments `uuid`.", "question_id": 6098}
{"snippet": "directory.start_component(component=None, feature=None)", "intent": "Add an entry to the Component table , and make this `component` the current component for this directory . If no `feature` is given , the current feature is used .", "question_id": 6099}
{"snippet": "directory.start_component(component=None, flags=None)", "intent": "Add an entry to the Component table , and make this `component` the current component for this directory . If no `flags` are given , the directory \u2019 s default flags are used .", "question_id": 6100}
{"snippet": "directory.start_component(component=None, keyfile=None)", "intent": "Add an entry to the Component table , and make this `component` the current component for this directory . If no `keyfile` is given , the KeyPath is left null in the Component table .", "question_id": 6101}
{"snippet": "directory.start_component(component=None, uuid=None)", "intent": "Add an entry to the Component table , and make this `component` the current component for this directory . With arguments `uuid`.", "question_id": 6102}
{"snippet": "directory.add_file(file)", "intent": "Add a `file` to the current component of the directory , starting a new one if there is no current component .", "question_id": 6103}
{"snippet": "directory.add_file(file, src=None)", "intent": "Add a `file` to the current component of the directory , starting a new one if there is no current component . If the `src` file is specified , it is interpreted relative to the current directory .", "question_id": 6104}
{"snippet": "directory.add_file(file, version=None)", "intent": "Add a `file` to the current component of the directory , starting a new one if there is no current component . Optionally , a `version` and a `language` can be specified for the entry in the File table .", "question_id": 6105}
{"snippet": "directory.add_file(file, language=None)", "intent": "Add a `file` to the current component of the directory , starting a new one if there is no current component . Optionally , a `version` and a `language` can be specified for the entry in the File table .", "question_id": 6106}
{"snippet": "directory.add_file(file, src=None, version=None)", "intent": "Add a `file` to the current component of the directory , starting a new one if there is no current component . If the `src` file is specified , it is interpreted relative to the current directory . Optionally , a `version` and a `language` can be specified for the entry in the File table .", "question_id": 6107}
{"snippet": "directory.add_file(file, src=None, language=None)", "intent": "Add a `file` to the current component of the directory , starting a new one if there is no current component . If the `src` file is specified , it is interpreted relative to the current directory . Optionally , a `version` and a `language` can be specified for the entry in the File table .", "question_id": 6108}
{"snippet": "directory.add_file(file, version=None, language=None)", "intent": "Add a `file` to the current component of the directory , starting a new one if there is no current component . Optionally , a `version` and a `language` can be specified for the entry in the File table .", "question_id": 6109}
{"snippet": "directory.add_file(file, src=None, version=None, language=None)", "intent": "Add a `file` to the current component of the directory , starting a new one if there is no current component . If the `src` file is specified , it is interpreted relative to the current directory . Optionally , a `version` and a `language` can be specified for the entry in the File table .", "question_id": 6110}
{"snippet": "directory.glob(pattern)", "intent": "Add a list of files to the current component as specified in the glob `pattern` .", "question_id": 6111}
{"snippet": "directory.glob(pattern, exclude=None)", "intent": "Add a list of files to the current component as specified in the glob `pattern` . Individual files can be excluded in the `exclude` list .", "question_id": 6112}
{"snippet": "directory.remove_pyc()", "intent": "Remove .pyc files on uninstall .", "question_id": 6113}
{"snippet": "msilib.Feature(db, id, title, desc, display)", "intent": "Add a new record to the Feature table , using the values `id` , parent.id , `title` , `desc` , `display` , `level` , `directory` , and `attributes` . With arguments `db`.", "question_id": 6114}
{"snippet": "msilib.Feature(db, id, title, desc, display, level=1)", "intent": "Add a new record to the Feature table , using the values `id` , parent.id , `title` , `desc` , `display` , `level` , `directory` , and `attributes` . With arguments `db`.", "question_id": 6115}
{"snippet": "msilib.Feature(db, id, title, desc, display, parent=None)", "intent": "Add a new record to the Feature table , using the values `id` , parent.id , `title` , `desc` , `display` , `level` , `directory` , and `attributes` . With arguments `db`, `parent`.", "question_id": 6116}
{"snippet": "msilib.Feature(db, id, title, desc, display, directory=None)", "intent": "Add a new record to the Feature table , using the values `id` , parent.id , `title` , `desc` , `display` , `level` , `directory` , and `attributes` . With arguments `db`.", "question_id": 6117}
{"snippet": "msilib.Feature(db, id, title, desc, display, attributes=0)", "intent": "Add a new record to the Feature table , using the values `id` , parent.id , `title` , `desc` , `display` , `level` , `directory` , and `attributes` . With arguments `db`.", "question_id": 6118}
{"snippet": "msilib.Feature(db, id, title, desc, display, level=1, parent=None)", "intent": "Add a new record to the Feature table , using the values `id` , parent.id , `title` , `desc` , `display` , `level` , `directory` , and `attributes` . With arguments `db`, `parent`.", "question_id": 6119}
{"snippet": "msilib.Feature(db, id, title, desc, display, level=1, directory=None)", "intent": "Add a new record to the Feature table , using the values `id` , parent.id , `title` , `desc` , `display` , `level` , `directory` , and `attributes` . With arguments `db`.", "question_id": 6120}
{"snippet": "msilib.Feature(db, id, title, desc, display, level=1, attributes=0)", "intent": "Add a new record to the Feature table , using the values `id` , parent.id , `title` , `desc` , `display` , `level` , `directory` , and `attributes` . With arguments `db`.", "question_id": 6121}
{"snippet": "msilib.Feature(db, id, title, desc, display, parent=None, directory=None)", "intent": "Add a new record to the Feature table , using the values `id` , parent.id , `title` , `desc` , `display` , `level` , `directory` , and `attributes` . With arguments `db`, `parent`.", "question_id": 6122}
{"snippet": "msilib.Feature(db, id, title, desc, display, parent=None, attributes=0)", "intent": "Add a new record to the Feature table , using the values `id` , parent.id , `title` , `desc` , `display` , `level` , `directory` , and `attributes` . With arguments `db`, `parent`.", "question_id": 6123}
{"snippet": "feature.set_current()", "intent": "Make this feature the current feature of msilib .", "question_id": 6124}
{"snippet": "msilib.Control(dlg, name)", "intent": "Base class of the dialog controls . `dlg` is the dialog object the control belongs to , and `name` is the control \u2019 s name .", "question_id": 6125}
{"snippet": "control.event(event, argument)", "intent": "Make an entry into the ControlEvent table for this control . With arguments `event`, `argument`.", "question_id": 6126}
{"snippet": "control.event(event, argument, condition=1)", "intent": "Make an entry into the ControlEvent table for this control . With arguments `event`, `argument`, `condition`.", "question_id": 6127}
{"snippet": "control.event(event, argument, ordering=None)", "intent": "Make an entry into the ControlEvent table for this control . With arguments `event`, `argument`, `ordering`.", "question_id": 6128}
{"snippet": "control.event(event, argument, condition=1, ordering=None)", "intent": "Make an entry into the ControlEvent table for this control . With arguments `event`, `argument`, `condition`, `ordering`.", "question_id": 6129}
{"snippet": "control.mapping(event, attribute)", "intent": "Make an entry into the EventMapping table for this control . With arguments `event`, `attribute`.", "question_id": 6130}
{"snippet": "control.condition(action, condition)", "intent": "Make an entry into the ControlCondition table for this control . With arguments `action`, `condition`.", "question_id": 6131}
{"snippet": "msilib.RadioButtonGroup(dlg, name, property)", "intent": "Create a radio button control named `name` . `property` is the installer property that gets set when a radio button is selected . With arguments `dlg`.", "question_id": 6132}
{"snippet": "radio_button_group.add(name, x, y, width, height, text)", "intent": "Add a radio button named `name` to the group , at the coordinates `x` , `y` , `width` , `height` , and with the label `text` .", "question_id": 6133}
{"snippet": "radio_button_group.add(name, x, y, width, height, text, value=None)", "intent": "Add a radio button named `name` to the group , at the coordinates `x` , `y` , `width` , `height` , and with the label `text` . If `value` is None , it defaults to name .", "question_id": 6134}
{"snippet": "msilib.Dialog(db, name, x, y, w, h, attr, title, first, default, cancel)", "intent": "Return a new Dialog object . An entry in the Dialog table is made , with the specified coordinates , dialog attributes , `title` , `name` of the `first` , `default` , and `cancel` controls . With arguments `db`, `x`, `y`, `w`, `h`, `attr`.", "question_id": 6135}
{"snippet": "dialog.control(name, type, x, y, width, height, attributes, property, text, control_next, help)", "intent": "Return a new Control object . With arguments `name`, `type`, `x`, `y`, `width`, `height`, `attributes`, `property`, `text`, `control_next`, `help`.", "question_id": 6136}
{"snippet": "dialog.text(name, x, y, width, height, attributes, text)", "intent": "Add and return a Text control . With arguments `name`, `x`, `y`, `width`, `height`, `attributes`, `text`.", "question_id": 6137}
{"snippet": "dialog.bitmap(name, x, y, width, height, text)", "intent": "Add and return a Bitmap control . With arguments `name`, `x`, `y`, `width`, `height`, `text`.", "question_id": 6138}
{"snippet": "dialog.line(name, x, y, width, height)", "intent": "Add and return a Line control . With arguments `name`, `x`, `y`, `width`, `height`.", "question_id": 6139}
{"snippet": "dialog.pushbutton(name, x, y, width, height, attributes, text, next_control)", "intent": "Add and return a PushButton control . With arguments `name`, `x`, `y`, `width`, `height`, `attributes`, `text`, `next_control`.", "question_id": 6140}
{"snippet": "dialog.radiogroup(name, x, y, width, height, attributes, property, text, next_control)", "intent": "Add and return a RadioButtonGroup control . With arguments `name`, `x`, `y`, `width`, `height`, `attributes`, `property`, `text`, `next_control`.", "question_id": 6141}
{"snippet": "dialog.checkbox(name, x, y, width, height, attributes, property, text, next_control)", "intent": "Add and return a CheckBox control . With arguments `name`, `x`, `y`, `width`, `height`, `attributes`, `property`, `text`, `next_control`.", "question_id": 6142}
{"snippet": "msilib.schema", "intent": "This is the standard MSI schema for MSI 2.0, with the tables variable providing a list of table definitions, and _Validation_records providing the data for MSI validation.", "question_id": 6143}
{"snippet": "msilib.sequence", "intent": "This module contains table contents for the standard sequence tables: AdminExecuteSequence, AdminUISequence, AdvtExecuteSequence, InstallExecuteSequence, and InstallUISequence.", "question_id": 6144}
{"snippet": "msilib.text", "intent": "This module contains definitions for the UIText and ActionText tables, for the standard installer actions.", "question_id": 6145}
{"snippet": "msvcrt.locking(fd, mode, nbytes)", "intent": "Lock part of a file based on file descriptor `fd` from the C runtime . `mode` must be one of the LK_* constants listed below . The locked region of the file extends from the current file position for `nbytes` bytes , and may continue beyond the end of the file .", "question_id": 6146}
{"snippet": "msvcrt.LK_LOCK", "intent": "Locks the specified bytes.", "question_id": 6147}
{"snippet": "msvcrt.LK_RLCK", "intent": "Locks the specified bytes.", "question_id": 6148}
{"snippet": "msvcrt.LK_NBLCK", "intent": "Locks the specified bytes.", "question_id": 6149}
{"snippet": "msvcrt.LK_NBRLCK", "intent": "Locks the specified bytes.", "question_id": 6150}
{"snippet": "msvcrt.LK_UNLCK", "intent": "Unlocks the specified bytes, which must have been previously locked.", "question_id": 6151}
{"snippet": "msvcrt.setmode(fd, flags)", "intent": "Set the line-end translation mode for the file descriptor `fd` . To set it to text mode , `flags` should be os.O_TEXT ; for binary , it should be os.O_BINARY .", "question_id": 6152}
{"snippet": "msvcrt.open_osfhandle(handle, flags)", "intent": "Create a C runtime file descriptor from the file `handle` handle . The `flags` parameter should be a bitwise OR of os.O_APPEND , os.O_RDONLY , and os.O_TEXT .", "question_id": 6153}
{"snippet": "msvcrt.get_osfhandle(fd)", "intent": "Return the file handle for the file descriptor `fd` .", "question_id": 6154}
{"snippet": "msvcrt.kbhit()", "intent": "Return true if a keypress is waiting to be read .", "question_id": 6155}
{"snippet": "msvcrt.getch()", "intent": "Read a keypress and return the resulting character as a byte string .", "question_id": 6156}
{"snippet": "msvcrt.getwch()", "intent": "Wide char variant of getch ( ) , returning a Unicode value .", "question_id": 6157}
{"snippet": "msvcrt.getche()", "intent": "Similar to getch ( ) , but the keypress will be echoed if it represents a printable character .", "question_id": 6158}
{"snippet": "msvcrt.getwche()", "intent": "Wide char variant of getche ( ) , returning a Unicode value .", "question_id": 6159}
{"snippet": "msvcrt.putch(char)", "intent": "Print the byte string `char` to the console without buffering .", "question_id": 6160}
{"snippet": "msvcrt.putwch(unicode_char)", "intent": "Wide char variant of putch ( ) , accepting a Unicode value . With arguments `unicode_char`.", "question_id": 6161}
{"snippet": "msvcrt.ungetch(char)", "intent": "Cause the byte string `char` to be \u201c pushed back \u201d into the console buffer ; it will be the next character read by getch ( ) or getche ( ) .", "question_id": 6162}
{"snippet": "msvcrt.ungetwch(unicode_char)", "intent": "Wide char variant of ungetch ( ) , accepting a Unicode value . With arguments `unicode_char`.", "question_id": 6163}
{"snippet": "msvcrt.heapmin()", "intent": "Force the malloc ( ) heap to clean itself up and return unused blocks to the operating system .", "question_id": 6164}
{"snippet": "multiprocessing.Process()", "intent": "Process objects represent activity that is run in a separate process .", "question_id": 6165}
{"snippet": "multiprocessing.Process(group=None)", "intent": "Process objects represent activity that is run in a separate process . `group` should always be None ; it exists solely for compatibility with threading.Thread .", "question_id": 6166}
{"snippet": "multiprocessing.Process(target=None)", "intent": "Process objects represent activity that is run in a separate process . `target` is the callable object to be invoked by the run ( ) method .", "question_id": 6167}
{"snippet": "multiprocessing.Process(name=None)", "intent": "Process objects represent activity that is run in a separate process . `name` is the process name ( see name for more details ) .", "question_id": 6168}
{"snippet": "multiprocessing.Process(args=())", "intent": "Process objects represent activity that is run in a separate process . `args` is the argument tuple for the target invocation .", "question_id": 6169}
{"snippet": "multiprocessing.Process(kwargs={})", "intent": "Process objects represent activity that is run in a separate process . `kwargs` is a dictionary of keyword arguments for the target invocation .", "question_id": 6170}
{"snippet": "multiprocessing.Process(daemon=None)", "intent": "Process objects represent activity that is run in a separate process . If provided , the keyword-only `daemon` argument sets the process daemon flag to True or False .", "question_id": 6171}
{"snippet": "multiprocessing.Process(group=None, target=None)", "intent": "Process objects represent activity that is run in a separate process . `group` should always be None ; it exists solely for compatibility with threading.Thread . `target` is the callable object to be invoked by the run ( ) method .", "question_id": 6172}
{"snippet": "multiprocessing.Process(group=None, name=None)", "intent": "Process objects represent activity that is run in a separate process . `group` should always be None ; it exists solely for compatibility with threading.Thread . `name` is the process name ( see name for more details ) .", "question_id": 6173}
{"snippet": "multiprocessing.Process(group=None, args=())", "intent": "Process objects represent activity that is run in a separate process . `group` should always be None ; it exists solely for compatibility with threading.Thread . `args` is the argument tuple for the target invocation .", "question_id": 6174}
{"snippet": "process.run()", "intent": "Method representing the process \u2019 s activity .", "question_id": 6175}
{"snippet": "process.start()", "intent": "Start the process \u2019 s activity .", "question_id": 6176}
{"snippet": "process.join(timeout)", "intent": "If the optional argument `timeout` is None ( the default ) , the method blocks until the process whose join ( ) method is called terminates .", "question_id": 6177}
{"snippet": "process.join()", "intent": "If the optional argument `timeout` is None ( the default ) , the method blocks until the process whose join ( ) method is called terminates .", "question_id": 6178}
{"snippet": "process.name", "intent": "The process\u2019s name.", "question_id": 6179}
{"snippet": "process.is_alive()", "intent": "Return whether the process is alive .", "question_id": 6180}
{"snippet": "process.daemon", "intent": "The process\u2019s daemon flag, a Boolean value.", "question_id": 6181}
{"snippet": "process.pid", "intent": "Return the process ID.", "question_id": 6182}
{"snippet": "process.exitcode", "intent": "The child\u2019s exit code.", "question_id": 6183}
{"snippet": "process.authkey", "intent": "The process\u2019s authentication key (a byte string).", "question_id": 6184}
{"snippet": "process.sentinel", "intent": "A numeric handle of a system object which will become \u201cready\u201d when the process ends.", "question_id": 6185}
{"snippet": "process.terminate()", "intent": "Terminate the process .", "question_id": 6186}
{"snippet": "process.kill()", "intent": "Same as terminate ( ) but using the SIGKILL signal on Unix .", "question_id": 6187}
{"snippet": "process.close()", "intent": "Close the Process object , releasing all resources associated with it .", "question_id": 6188}
{"snippet": "multiprocessing.ProcessError", "intent": "The base class of all multiprocessing exceptions.", "question_id": 6189}
{"snippet": "multiprocessing.BufferTooShort", "intent": "Exception raised by Connection.recv_bytes_into() when the supplied buffer object is too small for the message read.", "question_id": 6190}
{"snippet": "multiprocessing.AuthenticationError", "intent": "Raised when there is an authentication error.", "question_id": 6191}
{"snippet": "multiprocessing.TimeoutError", "intent": "Raised by methods with a timeout when the timeout expires.", "question_id": 6192}
{"snippet": "multiprocessing.Pipe(duplex)", "intent": "Returns a pair ( conn1 , conn2 ) of Connection objects representing the ends of a pipe . If `duplex` is True ( the default ) then the pipe is bidirectional .", "question_id": 6193}
{"snippet": "multiprocessing.Pipe()", "intent": "Returns a pair ( conn1 , conn2 ) of Connection objects representing the ends of a pipe .", "question_id": 6194}
{"snippet": "multiprocessing.Queue(maxsize)", "intent": "Returns a process shared queue implemented using a pipe and a few locks/semaphores . With arguments `maxsize`.", "question_id": 6195}
{"snippet": "multiprocessing.Queue()", "intent": "Returns a process shared queue implemented using a pipe and a few locks/semaphores .", "question_id": 6196}
{"snippet": "queue.qsize()", "intent": "Return the approximate size of the queue .", "question_id": 6197}
{"snippet": "queue.empty()", "intent": "Return True if the queue is empty , False otherwise .", "question_id": 6198}
{"snippet": "queue.full()", "intent": "Return True if the queue is full , False otherwise .", "question_id": 6199}
{"snippet": "queue.put(obj, block, timeout)", "intent": "Put `obj` into the queue . If the optional argument `block` is True ( the default ) and `timeout` is None ( the default ) , block if necessary until a free slot is available .", "question_id": 6200}
{"snippet": "queue.put(obj, block)", "intent": "Put `obj` into the queue . If the optional argument `block` is True ( the default ) and `timeout` is None ( the default ) , block if necessary until a free slot is available .", "question_id": 6201}
{"snippet": "queue.put(obj)", "intent": "Put `obj` into the queue .", "question_id": 6202}
{"snippet": "queue.put_nowait(obj)", "intent": "Equivalent to put ( `obj` , False ) .", "question_id": 6203}
{"snippet": "queue.get(block, timeout)", "intent": "Remove and return an item from the queue . If optional args `block` is True ( the default ) and `timeout` is None ( the default ) , block if necessary until an item is available .", "question_id": 6204}
{"snippet": "queue.get(block)", "intent": "Remove and return an item from the queue . If optional args `block` is True ( the default ) and `timeout` is None ( the default ) , block if necessary until an item is available .", "question_id": 6205}
{"snippet": "queue.get()", "intent": "Remove and return an item from the queue .", "question_id": 6206}
{"snippet": "queue.get_nowait()", "intent": "Equivalent to get ( False ) .", "question_id": 6207}
{"snippet": "queue.close()", "intent": "Indicate that no more data will be put on this queue by the current process .", "question_id": 6208}
{"snippet": "queue.join_thread()", "intent": "Join the background thread .", "question_id": 6209}
{"snippet": "queue.cancel_join_thread()", "intent": "Prevent join_thread ( ) from blocking .", "question_id": 6210}
{"snippet": "multiprocessing.SimpleQueue", "intent": "It is a simplified Queue type, very close to a locked Pipe.", "question_id": 6211}
{"snippet": "simple_queue.empty()", "intent": "Return True if the queue is empty , False otherwise .", "question_id": 6212}
{"snippet": "simple_queue.get()", "intent": "Remove and return an item from the queue .", "question_id": 6213}
{"snippet": "simple_queue.put(item)", "intent": "Put `item` into the queue .", "question_id": 6214}
{"snippet": "multiprocessing.JoinableQueue(maxsize)", "intent": "JoinableQueue , a Queue subclass , is a queue which additionally has task_done ( ) and join ( ) methods . With arguments `maxsize`.", "question_id": 6215}
{"snippet": "multiprocessing.JoinableQueue()", "intent": "JoinableQueue , a Queue subclass , is a queue which additionally has task_done ( ) and join ( ) methods .", "question_id": 6216}
{"snippet": "joinable_queue.task_done()", "intent": "Indicate that a formerly enqueued task is complete .", "question_id": 6217}
{"snippet": "joinable_queue.join()", "intent": "Block until all items in the queue have been gotten and processed .", "question_id": 6218}
{"snippet": "multiprocessing.active_children()", "intent": "Return list of all live children of the current process .", "question_id": 6219}
{"snippet": "multiprocessing.cpu_count()", "intent": "Return the number of CPUs in the system .", "question_id": 6220}
{"snippet": "multiprocessing.current_process()", "intent": "Return the Process object corresponding to the current process .", "question_id": 6221}
{"snippet": "multiprocessing.freeze_support()", "intent": "Add support for when a program which uses multiprocessing has been frozen to produce a Windows executable .", "question_id": 6222}
{"snippet": "multiprocessing.get_all_start_methods()", "intent": "Returns a list of the supported start methods , the first of which is the default .", "question_id": 6223}
{"snippet": "multiprocessing.get_context()", "intent": "Return a context object which has the same attributes as the multiprocessing module .", "question_id": 6224}
{"snippet": "multiprocessing.get_context(method=None)", "intent": "Return a context object which has the same attributes as the multiprocessing module . If `method` is None then the default context is returned .", "question_id": 6225}
{"snippet": "multiprocessing.get_start_method()", "intent": "Return the name of start method used for starting processes .", "question_id": 6226}
{"snippet": "multiprocessing.get_start_method(allow_none=False)", "intent": "Return the name of start method used for starting processes . If the start method has not been fixed and `allow_none` is false , then the start method is fixed to the default and the name is returned .", "question_id": 6227}
{"snippet": "multiprocessing.set_executable()", "intent": "Sets the path of the Python interpreter to use when starting a child process .", "question_id": 6228}
{"snippet": "multiprocessing.set_start_method(method)", "intent": "Set the `method` which should be used to start child processes .", "question_id": 6229}
{"snippet": "joinable_queue.send(obj)", "intent": "Send an object to the other end of the connection which should be read using recv ( ) . With arguments `obj`.", "question_id": 6230}
{"snippet": "joinable_queue.recv()", "intent": "Return an object sent from the other end of the connection using send ( ) .", "question_id": 6231}
{"snippet": "joinable_queue.fileno()", "intent": "Return the file descriptor or handle used by the connection .", "question_id": 6232}
{"snippet": "joinable_queue.close()", "intent": "Close the connection .", "question_id": 6233}
{"snippet": "joinable_queue.poll(timeout)", "intent": "Return whether there is any data available to be read . If `timeout` is not specified then it will return immediately .", "question_id": 6234}
{"snippet": "joinable_queue.poll()", "intent": "Return whether there is any data available to be read .", "question_id": 6235}
{"snippet": "joinable_queue.send_bytes(buffer, offset, size)", "intent": "Send byte data from a bytes-like object as a complete message . If `offset` is given then data is read from that position in `buffer` . If `size` is given then that many bytes will be read from buffer .", "question_id": 6236}
{"snippet": "joinable_queue.send_bytes(buffer, offset)", "intent": "Send byte data from a bytes-like object as a complete message . If `offset` is given then data is read from that position in `buffer` .", "question_id": 6237}
{"snippet": "joinable_queue.send_bytes(buffer)", "intent": "Send byte data from a bytes-like object as a complete message . If `offset` is given then data is read from that position in `buffer` .", "question_id": 6238}
{"snippet": "joinable_queue.recv_bytes(maxlength)", "intent": "Return a complete message of byte data sent from the other end of the connection as a string . If `maxlength` is specified and the message is longer than maxlength then OSError is raised and the connection will no longer be readable .", "question_id": 6239}
{"snippet": "joinable_queue.recv_bytes()", "intent": "Return a complete message of byte data sent from the other end of the connection as a string .", "question_id": 6240}
{"snippet": "joinable_queue.recv_bytes_into(buffer, offset)", "intent": "Read into `buffer` a complete message of byte data sent from the other end of the connection and return the number of bytes in the message . If `offset` is given then the message will be written into the buffer from that position .", "question_id": 6241}
{"snippet": "joinable_queue.recv_bytes_into(buffer)", "intent": "Read into `buffer` a complete message of byte data sent from the other end of the connection and return the number of bytes in the message .", "question_id": 6242}
{"snippet": "multiprocessing.Barrier(parties, action, timeout)", "intent": "A barrier object : a clone of threading.Barrier . With arguments `parties`, `action`, `timeout`.", "question_id": 6243}
{"snippet": "multiprocessing.Barrier(parties, action)", "intent": "A barrier object : a clone of threading.Barrier . With arguments `parties`, `action`.", "question_id": 6244}
{"snippet": "multiprocessing.Barrier(parties)", "intent": "A barrier object : a clone of threading.Barrier . With arguments `parties`.", "question_id": 6245}
{"snippet": "multiprocessing.BoundedSemaphore(value)", "intent": "A bounded semaphore object : a close analog of threading.BoundedSemaphore . With arguments `value`.", "question_id": 6246}
{"snippet": "multiprocessing.BoundedSemaphore()", "intent": "A bounded semaphore object : a close analog of threading.BoundedSemaphore .", "question_id": 6247}
{"snippet": "multiprocessing.Condition(lock)", "intent": "A condition variable : an alias for threading.Condition . If `lock` is specified then it should be a Lock or RLock object from multiprocessing .", "question_id": 6248}
{"snippet": "multiprocessing.Condition()", "intent": "A condition variable : an alias for threading.Condition .", "question_id": 6249}
{"snippet": "multiprocessing.Event", "intent": "A clone of threading.Event.", "question_id": 6250}
{"snippet": "multiprocessing.Lock", "intent": "A non-recursive lock object: a close analog of threading.Lock.", "question_id": 6251}
{"snippet": "lock.acquire()", "intent": "Acquire a lock , blocking or non-blocking .", "question_id": 6252}
{"snippet": "lock.acquire(block=True)", "intent": "Acquire a lock , blocking or non-blocking . With the `block` argument set to True ( the default ) , the method call will block until the lock is in an unlocked state , then set it to locked and return True .", "question_id": 6253}
{"snippet": "lock.acquire(timeout=None)", "intent": "Acquire a lock , blocking or non-blocking . When invoked with a positive , floating-point value for `timeout` , block for at most the number of seconds specified by timeout as long as the lock can not be acquired .", "question_id": 6254}
{"snippet": "lock.acquire(block=True, timeout=None)", "intent": "Acquire a lock , blocking or non-blocking . With the `block` argument set to True ( the default ) , the method call will block until the lock is in an unlocked state , then set it to locked and return True . When invoked with a positive , floating-point value for `timeout` , block for at most the number of seconds specified by timeout as long as the lock can not be acquired .", "question_id": 6255}
{"snippet": "lock.release()", "intent": "Release a lock .", "question_id": 6256}
{"snippet": "multiprocessing.RLock", "intent": "A recursive lock object: a close analog of threading.RLock.", "question_id": 6257}
{"snippet": "r_lock.acquire()", "intent": "Acquire a lock , blocking or non-blocking .", "question_id": 6258}
{"snippet": "r_lock.acquire(block=True)", "intent": "Acquire a lock , blocking or non-blocking . When invoked with the `block` argument set to True , block until the lock is in an unlocked state ( not owned by any process or thread ) unless the lock is already owned by the current process or thread .", "question_id": 6259}
{"snippet": "r_lock.acquire(timeout=None)", "intent": "Acquire a lock , blocking or non-blocking . Use and behaviors of the `timeout` argument are the same as in Lock.acquire ( ) .", "question_id": 6260}
{"snippet": "r_lock.acquire(block=True, timeout=None)", "intent": "Acquire a lock , blocking or non-blocking . When invoked with the `block` argument set to True , block until the lock is in an unlocked state ( not owned by any process or thread ) unless the lock is already owned by the current process or thread . Use and behaviors of the `timeout` argument are the same as in Lock.acquire ( ) .", "question_id": 6261}
{"snippet": "r_lock.release()", "intent": "Release a lock , decrementing the recursion level .", "question_id": 6262}
{"snippet": "multiprocessing.Semaphore(value)", "intent": "A semaphore object : a close analog of threading.Semaphore . With arguments `value`.", "question_id": 6263}
{"snippet": "multiprocessing.Semaphore()", "intent": "A semaphore object : a close analog of threading.Semaphore .", "question_id": 6264}
{"snippet": "multiprocessing.Value(typecode_or_type, *args)", "intent": "Return a ctypes object allocated from shared memory . `typecode_or_type` determines the type of the returned object : it is either a ctypes type or a one character typecode of the kind used by the array module . `*args` is passed on to the constructor for the type .", "question_id": 6265}
{"snippet": "multiprocessing.Value(typecode_or_type, *args, lock=True)", "intent": "Return a ctypes object allocated from shared memory . `typecode_or_type` determines the type of the returned object : it is either a ctypes type or a one character typecode of the kind used by the array module . `*args` is passed on to the constructor for the type . If `lock` is True ( the default ) then a new recursive lock object is created to synchronize access to the value .", "question_id": 6266}
{"snippet": "multiprocessing.Array(typecode_or_type, size_or_initializer)", "intent": "Return a ctypes array allocated from shared memory . `typecode_or_type` determines the type of the elements of the returned array : it is either a ctypes type or a one character typecode of the kind used by the array module . If `size_or_initializer` is an integer , then it determines the length of the array , and the array will be initially zeroed .", "question_id": 6267}
{"snippet": "multiprocessing.Array(typecode_or_type, size_or_initializer, lock=True)", "intent": "Return a ctypes array allocated from shared memory . `typecode_or_type` determines the type of the elements of the returned array : it is either a ctypes type or a one character typecode of the kind used by the array module . If `size_or_initializer` is an integer , then it determines the length of the array , and the array will be initially zeroed . If `lock` is True ( the default ) then a new lock object is created to synchronize access to the value .", "question_id": 6268}
{"snippet": "multiprocessing.sharedctypes.RawArray(typecode_or_type, size_or_initializer)", "intent": "Return a ctypes array allocated from shared memory . `typecode_or_type` determines the type of the elements of the returned array : it is either a ctypes type or a one character typecode of the kind used by the array module . If `size_or_initializer` is an integer then it determines the length of the array , and the array will be initially zeroed .", "question_id": 6269}
{"snippet": "multiprocessing.sharedctypes.RawValue(typecode_or_type, *args)", "intent": "Return a ctypes object allocated from shared memory . `typecode_or_type` determines the type of the returned object : it is either a ctypes type or a one character typecode of the kind used by the array module . `*args` is passed on to the constructor for the type .", "question_id": 6270}
{"snippet": "multiprocessing.sharedctypes.Array(typecode_or_type, size_or_initializer)", "intent": "The same as RawArray ( ) except that depending on the value of `lock` a process-safe synchronization wrapper may be returned instead of a raw ctypes array . With arguments `typecode_or_type`, `size_or_initializer`.", "question_id": 6271}
{"snippet": "multiprocessing.sharedctypes.Array(typecode_or_type, size_or_initializer, lock=True)", "intent": "The same as RawArray ( ) except that depending on the value of `lock` a process-safe synchronization wrapper may be returned instead of a raw ctypes array . With arguments `typecode_or_type`, `size_or_initializer`.", "question_id": 6272}
{"snippet": "multiprocessing.sharedctypes.Value(typecode_or_type, *args)", "intent": "The same as RawValue ( ) except that depending on the value of `lock` a process-safe synchronization wrapper may be returned instead of a raw ctypes object . With arguments `typecode_or_type`, `*args`.", "question_id": 6273}
{"snippet": "multiprocessing.sharedctypes.Value(typecode_or_type, *args, lock=True)", "intent": "The same as RawValue ( ) except that depending on the value of `lock` a process-safe synchronization wrapper may be returned instead of a raw ctypes object . With arguments `typecode_or_type`, `*args`.", "question_id": 6274}
{"snippet": "multiprocessing.sharedctypes.copy(obj)", "intent": "Return a ctypes object allocated from shared memory which is a copy of the ctypes object `obj` .", "question_id": 6275}
{"snippet": "multiprocessing.sharedctypes.synchronized(obj, lock)", "intent": "Return a process-safe wrapper object for a ctypes object which uses `lock` to synchronize access . With arguments `obj`.", "question_id": 6276}
{"snippet": "multiprocessing.sharedctypes.synchronized(obj)", "intent": "Return a process-safe wrapper object for a ctypes object which uses `lock` to synchronize access . With arguments `obj`.", "question_id": 6277}
{"snippet": "multiprocessing.Manager()", "intent": "Returns a started SyncManager object which can be used for sharing objects between processes .", "question_id": 6278}
{"snippet": "multiprocessing.managers.BaseManager(address, authkey)", "intent": "Create a BaseManager object . `address` is the address on which the manager process listens for new connections . `authkey` is the authentication key which will be used to check the validity of incoming connections to the server process .", "question_id": 6279}
{"snippet": "multiprocessing.managers.BaseManager(address)", "intent": "Create a BaseManager object . `address` is the address on which the manager process listens for new connections .", "question_id": 6280}
{"snippet": "multiprocessing.managers.BaseManager()", "intent": "Create a BaseManager object .", "question_id": 6281}
{"snippet": "base_manager.start(initializer, initargs)", "intent": "Start a subprocess to start the manager . If `initializer` is not None then the subprocess will call initializer ( *initargs ) when it starts . With arguments `initargs`.", "question_id": 6282}
{"snippet": "base_manager.start(initializer)", "intent": "Start a subprocess to start the manager . If `initializer` is not None then the subprocess will call initializer ( *initargs ) when it starts .", "question_id": 6283}
{"snippet": "base_manager.start()", "intent": "Start a subprocess to start the manager .", "question_id": 6284}
{"snippet": "base_manager.get_server()", "intent": "Returns a Server object which represents the actual server under the control of the Manager .", "question_id": 6285}
{"snippet": "base_manager.connect()", "intent": "Connect a local manager object to a remote manager process :", "question_id": 6286}
{"snippet": "base_manager.shutdown()", "intent": "Stop the process used by the manager .", "question_id": 6287}
{"snippet": "base_manager.register(typeid, callable, proxytype, exposed, method_to_typeid, create_method)", "intent": "A classmethod which can be used for registering a type or `callable` with the manager class . `typeid` is a \u201c type identifier \u201d which is used to identify a particular type of shared object . `proxytype` is a subclass of BaseProxy which is used to create proxies for shared objects with this typeid . `exposed` is used to specify a sequence of method names which proxies for this typeid should be allowed to access using BaseProxy._callmethod ( ) . `method_to_typeid` is a mapping used to specify the return type of those exposed methods which should return a proxy . If a manager instance will be connected to the server using the connect ( ) method , or if the `create_method` argument is False then this can be left as None .", "question_id": 6288}
{"snippet": "base_manager.register(typeid, callable, proxytype, exposed, method_to_typeid)", "intent": "A classmethod which can be used for registering a type or `callable` with the manager class . `typeid` is a \u201c type identifier \u201d which is used to identify a particular type of shared object . `proxytype` is a subclass of BaseProxy which is used to create proxies for shared objects with this typeid . `exposed` is used to specify a sequence of method names which proxies for this typeid should be allowed to access using BaseProxy._callmethod ( ) . `method_to_typeid` is a mapping used to specify the return type of those exposed methods which should return a proxy .", "question_id": 6289}
{"snippet": "base_manager.register(typeid, callable, proxytype, exposed)", "intent": "A classmethod which can be used for registering a type or `callable` with the manager class . `typeid` is a \u201c type identifier \u201d which is used to identify a particular type of shared object . `proxytype` is a subclass of BaseProxy which is used to create proxies for shared objects with this typeid . `exposed` is used to specify a sequence of method names which proxies for this typeid should be allowed to access using BaseProxy._callmethod ( ) .", "question_id": 6290}
{"snippet": "base_manager.register(typeid, callable, proxytype)", "intent": "A classmethod which can be used for registering a type or `callable` with the manager class . `typeid` is a \u201c type identifier \u201d which is used to identify a particular type of shared object . `proxytype` is a subclass of BaseProxy which is used to create proxies for shared objects with this typeid .", "question_id": 6291}
{"snippet": "base_manager.register(typeid, callable)", "intent": "A classmethod which can be used for registering a type or `callable` with the manager class . `typeid` is a \u201c type identifier \u201d which is used to identify a particular type of shared object .", "question_id": 6292}
{"snippet": "base_manager.register(typeid)", "intent": "A classmethod which can be used for registering a type or `callable` with the manager class . `typeid` is a \u201c type identifier \u201d which is used to identify a particular type of shared object .", "question_id": 6293}
{"snippet": "base_manager.address", "intent": "The address used by the manager.", "question_id": 6294}
{"snippet": "multiprocessing.managers.SyncManager", "intent": "A subclass of BaseManager which can be used for the synchronization of processes.", "question_id": 6295}
{"snippet": "sync_manager.Barrier(parties, action, timeout)", "intent": "Create a shared threading.Barrier object and return a proxy for it . With arguments `parties`, `action`, `timeout`.", "question_id": 6296}
{"snippet": "sync_manager.Barrier(parties, action)", "intent": "Create a shared threading.Barrier object and return a proxy for it . With arguments `parties`, `action`.", "question_id": 6297}
{"snippet": "sync_manager.Barrier(parties)", "intent": "Create a shared threading.Barrier object and return a proxy for it . With arguments `parties`.", "question_id": 6298}
{"snippet": "sync_manager.BoundedSemaphore(value)", "intent": "Create a shared threading.BoundedSemaphore object and return a proxy for it . With arguments `value`.", "question_id": 6299}
{"snippet": "sync_manager.BoundedSemaphore()", "intent": "Create a shared threading.BoundedSemaphore object and return a proxy for it .", "question_id": 6300}
{"snippet": "sync_manager.Condition(lock)", "intent": "Create a shared threading.Condition object and return a proxy for it . If `lock` is supplied then it should be a proxy for a threading.Lock or threading.RLock object .", "question_id": 6301}
{"snippet": "sync_manager.Condition()", "intent": "Create a shared threading.Condition object and return a proxy for it .", "question_id": 6302}
{"snippet": "sync_manager.Event()", "intent": "Create a shared threading.Event object and return a proxy for it .", "question_id": 6303}
{"snippet": "sync_manager.Lock()", "intent": "Create a shared threading.Lock object and return a proxy for it .", "question_id": 6304}
{"snippet": "sync_manager.Namespace()", "intent": "Create a shared Namespace object and return a proxy for it .", "question_id": 6305}
{"snippet": "sync_manager.Queue(maxsize)", "intent": "Create a shared queue.Queue object and return a proxy for it . With arguments `maxsize`.", "question_id": 6306}
{"snippet": "sync_manager.Queue()", "intent": "Create a shared queue.Queue object and return a proxy for it .", "question_id": 6307}
{"snippet": "sync_manager.RLock()", "intent": "Create a shared threading.RLock object and return a proxy for it .", "question_id": 6308}
{"snippet": "sync_manager.Semaphore(value)", "intent": "Create a shared threading.Semaphore object and return a proxy for it . With arguments `value`.", "question_id": 6309}
{"snippet": "sync_manager.Semaphore()", "intent": "Create a shared threading.Semaphore object and return a proxy for it .", "question_id": 6310}
{"snippet": "sync_manager.Array(typecode, sequence)", "intent": "Create an array and return a proxy for it . With arguments `typecode`, `sequence`.", "question_id": 6311}
{"snippet": "sync_manager.Value(typecode, value)", "intent": "Create an object with a writable `value` attribute and return a proxy for it . With arguments `typecode`.", "question_id": 6312}
{"snippet": "sync_manager.dict()", "intent": "Create a shared dict object and return a proxy for it .", "question_id": 6313}
{"snippet": "sync_manager.dict(mapping)", "intent": "Create a shared dict object and return a proxy for it . With arguments `mapping`.", "question_id": 6314}
{"snippet": "sync_manager.dict(sequence)", "intent": "Create a shared dict object and return a proxy for it . With arguments `sequence`.", "question_id": 6315}
{"snippet": "sync_manager.list()", "intent": "Create a shared list object and return a proxy for it .", "question_id": 6316}
{"snippet": "sync_manager.list(sequence)", "intent": "Create a shared list object and return a proxy for it . With arguments `sequence`.", "question_id": 6317}
{"snippet": "multiprocessing.managers.Namespace", "intent": "A type that can register with SyncManager.", "question_id": 6318}
{"snippet": "multiprocessing.managers.BaseProxy", "intent": "Proxy objects are instances of subclasses of BaseProxy.", "question_id": 6319}
{"snippet": "base_proxy._callmethod(methodname, args, kwds)", "intent": "Call and return the result of a method of the proxy \u2019 s referent . Note in particular that an exception will be raised if `methodname` has not been exposed . With arguments `args`, `kwds`.", "question_id": 6320}
{"snippet": "base_proxy._callmethod(methodname, args)", "intent": "Call and return the result of a method of the proxy \u2019 s referent . Note in particular that an exception will be raised if `methodname` has not been exposed . With arguments `args`.", "question_id": 6321}
{"snippet": "base_proxy._callmethod(methodname)", "intent": "Call and return the result of a method of the proxy \u2019 s referent . Note in particular that an exception will be raised if `methodname` has not been exposed .", "question_id": 6322}
{"snippet": "base_proxy._getvalue()", "intent": "Return a copy of the referent .", "question_id": 6323}
{"snippet": "base_proxy.__repr__()", "intent": "Return a representation of the proxy object .", "question_id": 6324}
{"snippet": "base_proxy.__str__()", "intent": "Return the representation of the referent .", "question_id": 6325}
{"snippet": "multiprocessing.pool.Pool(processes, initializer, initargs, maxtasksperchild, context)", "intent": "A process pool object which controls a pool of worker `processes` to which jobs can be submitted . If `initializer` is not None then each worker process will call initializer ( *initargs ) when it starts . `maxtasksperchild` is the number of tasks a worker process can complete before it will exit and be replaced with a fresh worker process , to enable unused resources to be freed . `context` can be used to specify the context used for starting the worker processes . With arguments `initargs`.", "question_id": 6326}
{"snippet": "multiprocessing.pool.Pool(processes, initializer, initargs, maxtasksperchild)", "intent": "A process pool object which controls a pool of worker `processes` to which jobs can be submitted . If `initializer` is not None then each worker process will call initializer ( *initargs ) when it starts . `maxtasksperchild` is the number of tasks a worker process can complete before it will exit and be replaced with a fresh worker process , to enable unused resources to be freed . With arguments `initargs`.", "question_id": 6327}
{"snippet": "multiprocessing.pool.Pool(processes, initializer, initargs)", "intent": "A process pool object which controls a pool of worker `processes` to which jobs can be submitted . If `initializer` is not None then each worker process will call initializer ( *initargs ) when it starts . With arguments `initargs`.", "question_id": 6328}
{"snippet": "multiprocessing.pool.Pool(processes, initializer)", "intent": "A process pool object which controls a pool of worker `processes` to which jobs can be submitted . If `initializer` is not None then each worker process will call initializer ( *initargs ) when it starts .", "question_id": 6329}
{"snippet": "multiprocessing.pool.Pool(processes)", "intent": "A process pool object which controls a pool of worker `processes` to which jobs can be submitted .", "question_id": 6330}
{"snippet": "multiprocessing.pool.Pool()", "intent": "A process pool object which controls a pool of worker `processes` to which jobs can be submitted .", "question_id": 6331}
{"snippet": "pool.apply(func, args, kwds)", "intent": "Call `func` with arguments `args` and keyword arguments `kwds` .", "question_id": 6332}
{"snippet": "pool.apply(func, args)", "intent": "Call `func` with arguments `args` and keyword arguments `kwds` .", "question_id": 6333}
{"snippet": "pool.apply(func)", "intent": "Call `func` with arguments `args` and keyword arguments `kwds` .", "question_id": 6334}
{"snippet": "pool.apply_async(func, args, kwds, callback, error_callback)", "intent": "A variant of the apply ( ) method which returns a result object . If `callback` is specified then it should be a callable which accepts a single argument . When the result becomes ready callback is applied to it , that is unless the call failed , in which case the `error_callback` is applied instead . With arguments `func`, `args`, `kwds`.", "question_id": 6335}
{"snippet": "pool.apply_async(func, args, kwds, callback)", "intent": "A variant of the apply ( ) method which returns a result object . If `callback` is specified then it should be a callable which accepts a single argument . With arguments `func`, `args`, `kwds`.", "question_id": 6336}
{"snippet": "pool.apply_async(func, args, kwds)", "intent": "A variant of the apply ( ) method which returns a result object . With arguments `func`, `args`, `kwds`.", "question_id": 6337}
{"snippet": "pool.apply_async(func, args)", "intent": "A variant of the apply ( ) method which returns a result object . With arguments `func`, `args`.", "question_id": 6338}
{"snippet": "pool.apply_async(func)", "intent": "A variant of the apply ( ) method which returns a result object . With arguments `func`.", "question_id": 6339}
{"snippet": "pool.map(func, iterable, chunksize)", "intent": "A parallel equivalent of the map ( ) built-in function ( it supports only one `iterable` argument though ) . The ( approximate ) size of these chunks can be specified by setting `chunksize` to a positive integer . With arguments `func`.", "question_id": 6340}
{"snippet": "pool.map(func, iterable)", "intent": "A parallel equivalent of the map ( ) built-in function ( it supports only one `iterable` argument though ) . With arguments `func`.", "question_id": 6341}
{"snippet": "pool.map_async(func, iterable, chunksize, callback, error_callback)", "intent": "A variant of the map ( ) method which returns a result object . If `callback` is specified then it should be a callable which accepts a single argument . When the result becomes ready callback is applied to it , that is unless the call failed , in which case the `error_callback` is applied instead . With arguments `func`, `iterable`, `chunksize`.", "question_id": 6342}
{"snippet": "pool.map_async(func, iterable, chunksize, callback)", "intent": "A variant of the map ( ) method which returns a result object . If `callback` is specified then it should be a callable which accepts a single argument . With arguments `func`, `iterable`, `chunksize`.", "question_id": 6343}
{"snippet": "pool.map_async(func, iterable, chunksize)", "intent": "A variant of the map ( ) method which returns a result object . With arguments `func`, `iterable`, `chunksize`.", "question_id": 6344}
{"snippet": "pool.map_async(func, iterable)", "intent": "A variant of the map ( ) method which returns a result object . With arguments `func`, `iterable`.", "question_id": 6345}
{"snippet": "pool.imap(func, iterable, chunksize)", "intent": "A lazier version of map ( ) . The `chunksize` argument is the same as the one used by the map ( ) method . With arguments `func`, `iterable`.", "question_id": 6346}
{"snippet": "pool.imap(func, iterable)", "intent": "A lazier version of map ( ) . With arguments `func`, `iterable`.", "question_id": 6347}
{"snippet": "pool.imap_unordered(func, iterable, chunksize)", "intent": "The same as imap ( ) except that the ordering of the results from the returned iterator should be considered arbitrary . With arguments `func`, `iterable`, `chunksize`.", "question_id": 6348}
{"snippet": "pool.imap_unordered(func, iterable)", "intent": "The same as imap ( ) except that the ordering of the results from the returned iterator should be considered arbitrary . With arguments `func`, `iterable`.", "question_id": 6349}
{"snippet": "pool.starmap(func, iterable, chunksize)", "intent": "Like map ( ) except that the elements of the `iterable` are expected to be iterables that are unpacked as arguments . Hence an iterable of [ ( 1,2 ) , ( 3 , 4 ) ] results in [ `func` ( 1,2 ) , func ( 3,4 ) ] . With arguments `chunksize`.", "question_id": 6350}
{"snippet": "pool.starmap(func, iterable)", "intent": "Like map ( ) except that the elements of the `iterable` are expected to be iterables that are unpacked as arguments . Hence an iterable of [ ( 1,2 ) , ( 3 , 4 ) ] results in [ `func` ( 1,2 ) , func ( 3,4 ) ] .", "question_id": 6351}
{"snippet": "pool.starmap_async(func, iterable, chunksize, callback, error_callback)", "intent": "A combination of starmap ( ) and map_async ( ) that iterates over `iterable` of iterables and calls `func` with the iterables unpacked . With arguments `chunksize`, `callback`, `error_callback`.", "question_id": 6352}
{"snippet": "pool.starmap_async(func, iterable, chunksize, callback)", "intent": "A combination of starmap ( ) and map_async ( ) that iterates over `iterable` of iterables and calls `func` with the iterables unpacked . With arguments `chunksize`, `callback`.", "question_id": 6353}
{"snippet": "pool.starmap_async(func, iterable, chunksize)", "intent": "A combination of starmap ( ) and map_async ( ) that iterates over `iterable` of iterables and calls `func` with the iterables unpacked . With arguments `chunksize`.", "question_id": 6354}
{"snippet": "pool.starmap_async(func, iterable)", "intent": "A combination of starmap ( ) and map_async ( ) that iterates over `iterable` of iterables and calls `func` with the iterables unpacked .", "question_id": 6355}
{"snippet": "pool.close()", "intent": "Prevents any more tasks from being submitted to the pool .", "question_id": 6356}
{"snippet": "pool.terminate()", "intent": "Stops the worker processes immediately without completing outstanding work .", "question_id": 6357}
{"snippet": "pool.join()", "intent": "Wait for the worker processes to exit .", "question_id": 6358}
{"snippet": "multiprocessing.pool.AsyncResult", "intent": "The class of the result returned by Pool.apply_async() and Pool.map_async().", "question_id": 6359}
{"snippet": "async_result.get(timeout)", "intent": "Return the result when it arrives . If `timeout` is not None and the result does not arrive within timeout seconds then multiprocessing.TimeoutError is raised .", "question_id": 6360}
{"snippet": "async_result.get()", "intent": "Return the result when it arrives .", "question_id": 6361}
{"snippet": "async_result.wait(timeout)", "intent": "Wait until the result is available or until `timeout` seconds pass .", "question_id": 6362}
{"snippet": "async_result.wait()", "intent": "Wait until the result is available or until `timeout` seconds pass .", "question_id": 6363}
{"snippet": "async_result.ready()", "intent": "Return whether the call has completed .", "question_id": 6364}
{"snippet": "async_result.successful()", "intent": "Return whether the call completed without raising an exception .", "question_id": 6365}
{"snippet": "multiprocessing.connection.deliver_challenge(connection, authkey)", "intent": "Send a randomly generated message to the other end of the `connection` and wait for a reply . If the reply matches the digest of the message using `authkey` as the key then a welcome message is sent to the other end of the connection .", "question_id": 6366}
{"snippet": "multiprocessing.connection.answer_challenge(connection, authkey)", "intent": "Receive a message , calculate the digest of the message using `authkey` as the key , and then send the digest back . With arguments `connection`.", "question_id": 6367}
{"snippet": "multiprocessing.connection.Client(address, family, authkey)", "intent": "Attempt to set up a connection to the listener which is using `address` address , returning a Connection . The type of the connection is determined by `family` argument , but this can generally be omitted since it can usually be inferred from the format of address . If `authkey` is given and not None , it should be a byte string and will be used as the secret key for an HMAC-based authentication challenge .", "question_id": 6368}
{"snippet": "multiprocessing.connection.Client(address, family)", "intent": "Attempt to set up a connection to the listener which is using `address` address , returning a Connection . The type of the connection is determined by `family` argument , but this can generally be omitted since it can usually be inferred from the format of address .", "question_id": 6369}
{"snippet": "multiprocessing.connection.Client(address)", "intent": "Attempt to set up a connection to the listener which is using `address` address , returning a Connection .", "question_id": 6370}
{"snippet": "multiprocessing.connection.Listener(address, family, backlog, authkey)", "intent": "A wrapper for a bound socket or Windows named pipe which is \u2018 listening \u2019 for connections . `address` is the address to be used by the bound socket or named pipe of the listener object . `family` is the type of socket ( or named pipe ) to use . If the listener object uses a socket then `backlog` ( 1 by default ) is passed to the listen ( ) method of the socket once it has been bound . If `authkey` is given and not None , it should be a byte string and will be used as the secret key for an HMAC-based authentication challenge .", "question_id": 6371}
{"snippet": "multiprocessing.connection.Listener(address, family, backlog)", "intent": "A wrapper for a bound socket or Windows named pipe which is \u2018 listening \u2019 for connections . `address` is the address to be used by the bound socket or named pipe of the listener object . `family` is the type of socket ( or named pipe ) to use . If the listener object uses a socket then `backlog` ( 1 by default ) is passed to the listen ( ) method of the socket once it has been bound .", "question_id": 6372}
{"snippet": "multiprocessing.connection.Listener(address, family)", "intent": "A wrapper for a bound socket or Windows named pipe which is \u2018 listening \u2019 for connections . `address` is the address to be used by the bound socket or named pipe of the listener object . `family` is the type of socket ( or named pipe ) to use .", "question_id": 6373}
{"snippet": "multiprocessing.connection.Listener(address)", "intent": "A wrapper for a bound socket or Windows named pipe which is \u2018 listening \u2019 for connections . `address` is the address to be used by the bound socket or named pipe of the listener object .", "question_id": 6374}
{"snippet": "multiprocessing.connection.Listener()", "intent": "A wrapper for a bound socket or Windows named pipe which is \u2018 listening \u2019 for connections .", "question_id": 6375}
{"snippet": "listener.accept()", "intent": "Accept a connection on the bound socket or named pipe of the listener object and return a Connection object .", "question_id": 6376}
{"snippet": "listener.close()", "intent": "Close the bound socket or named pipe of the listener object .", "question_id": 6377}
{"snippet": "listener.address", "intent": "The address which is being used by the Listener object.", "question_id": 6378}
{"snippet": "listener.last_accepted", "intent": "The address from which the last accepted connection came.", "question_id": 6379}
{"snippet": "multiprocessing.connection.wait(object_list)", "intent": "Wait till an object in `object_list` is ready .", "question_id": 6380}
{"snippet": "multiprocessing.connection.wait(object_list, timeout=None)", "intent": "Wait till an object in `object_list` is ready . If `timeout` is a float then the call blocks for at most that many seconds .", "question_id": 6381}
{"snippet": "multiprocessing.get_logger()", "intent": "Returns the logger used by multiprocessing .", "question_id": 6382}
{"snippet": "multiprocessing.log_to_stderr()", "intent": "This function performs a call to get_logger ( ) but in addition to returning the logger created by get_logger , it adds a handler which sends output to sys.stderr using format ' [ % ( levelname ) s/ % ( processName ) s ] % ( message ) s ' .", "question_id": 6383}
{"snippet": "netrc.netrc(file)", "intent": "A netrc instance or subclass instance encapsulates data from a netrc `file` .", "question_id": 6384}
{"snippet": "netrc.netrc()", "intent": "A netrc instance or subclass instance encapsulates data from a netrc `file` .", "question_id": 6385}
{"snippet": "netrc.NetrcParseError", "intent": "Exception raised by the netrc class when syntactical errors are encountered in source text.", "question_id": 6386}
{"snippet": "netrc.authenticators(host)", "intent": "Return a 3-tuple ( login , account , password ) of authenticators for `host` .", "question_id": 6387}
{"snippet": "netrc.__repr__()", "intent": "Dump the class data as a string in the format of a netrc file .", "question_id": 6388}
{"snippet": "netrc.hosts", "intent": "Dictionary mapping host names to (login, account, password) tuples.", "question_id": 6389}
{"snippet": "netrc.macros", "intent": "Dictionary mapping macro names to string lists.", "question_id": 6390}
{"snippet": "nis.match(key, mapname)", "intent": "Return the match for `key` in map `mapname` , or raise an error ( nis.error ) if there is none .", "question_id": 6391}
{"snippet": "nis.match(key, mapname, domain=default_domain)", "intent": "Return the match for `key` in map `mapname` , or raise an error ( nis.error ) if there is none . The `domain` argument allows overriding the NIS domain used for the lookup .", "question_id": 6392}
{"snippet": "nis.cat(mapname)", "intent": "Return a dictionary mapping key to value such that match ( key , `mapname` ) ==value .", "question_id": 6393}
{"snippet": "nis.cat(mapname, domain=default_domain)", "intent": "Return a dictionary mapping key to value such that match ( key , `mapname` ) ==value . The `domain` argument allows overriding the NIS domain used for the lookup .", "question_id": 6394}
{"snippet": "nis.maps()", "intent": "Return a list of all valid maps .", "question_id": 6395}
{"snippet": "nis.maps(domain=default_domain)", "intent": "Return a list of all valid maps . The `domain` argument allows overriding the NIS domain used for the lookup .", "question_id": 6396}
{"snippet": "nis.get_default_domain()", "intent": "Return the system default NIS domain .", "question_id": 6397}
{"snippet": "nis.error", "intent": "An error raised when a NIS function returns an error code.", "question_id": 6398}
{"snippet": "nntplib.NNTP(host, timeout)", "intent": "Return a new NNTP object , representing a connection to the NNTP server running on `host` host , listening at `port` port . An optional `timeout` can be specified for the socket connection .", "question_id": 6399}
{"snippet": "nntplib.NNTP(host, timeout, port=119)", "intent": "Return a new NNTP object , representing a connection to the NNTP server running on `host` host , listening at `port` port . An optional `timeout` can be specified for the socket connection .", "question_id": 6400}
{"snippet": "nntplib.NNTP(host, timeout, user=None)", "intent": "Return a new NNTP object , representing a connection to the NNTP server running on `host` host , listening at `port` port . An optional `timeout` can be specified for the socket connection . If the optional `user` and `password` are provided , or if suitable credentials are present in /.netrc and the optional flag `usenetrc` is true , the AUTHINFO USER and AUTHINFO PASS commands are used to identify and authenticate the user to the server .", "question_id": 6401}
{"snippet": "nntplib.NNTP(host, timeout, password=None)", "intent": "Return a new NNTP object , representing a connection to the NNTP server running on `host` host , listening at `port` port . An optional `timeout` can be specified for the socket connection . If the optional `user` and `password` are provided , or if suitable credentials are present in /.netrc and the optional flag `usenetrc` is true , the AUTHINFO USER and AUTHINFO PASS commands are used to identify and authenticate the user to the server .", "question_id": 6402}
{"snippet": "nntplib.NNTP(host, timeout, readermode=None)", "intent": "Return a new NNTP object , representing a connection to the NNTP server running on `host` host , listening at `port` port . An optional `timeout` can be specified for the socket connection . If the optional flag `readermode` is true , then a mode reader command is sent before authentication is performed .", "question_id": 6403}
{"snippet": "nntplib.NNTP(host, timeout, usenetrc=False)", "intent": "Return a new NNTP object , representing a connection to the NNTP server running on `host` host , listening at `port` port . An optional `timeout` can be specified for the socket connection . If the optional `user` and `password` are provided , or if suitable credentials are present in /.netrc and the optional flag `usenetrc` is true , the AUTHINFO USER and AUTHINFO PASS commands are used to identify and authenticate the user to the server .", "question_id": 6404}
{"snippet": "nntplib.NNTP(host, timeout, port=119, user=None)", "intent": "Return a new NNTP object , representing a connection to the NNTP server running on `host` host , listening at `port` port . An optional `timeout` can be specified for the socket connection . If the optional `user` and `password` are provided , or if suitable credentials are present in /.netrc and the optional flag `usenetrc` is true , the AUTHINFO USER and AUTHINFO PASS commands are used to identify and authenticate the user to the server .", "question_id": 6405}
{"snippet": "nntplib.NNTP(host, timeout, port=119, password=None)", "intent": "Return a new NNTP object , representing a connection to the NNTP server running on `host` host , listening at `port` port . An optional `timeout` can be specified for the socket connection . If the optional `user` and `password` are provided , or if suitable credentials are present in /.netrc and the optional flag `usenetrc` is true , the AUTHINFO USER and AUTHINFO PASS commands are used to identify and authenticate the user to the server .", "question_id": 6406}
{"snippet": "nntplib.NNTP(host, timeout, port=119, readermode=None)", "intent": "Return a new NNTP object , representing a connection to the NNTP server running on `host` host , listening at `port` port . An optional `timeout` can be specified for the socket connection . If the optional flag `readermode` is true , then a mode reader command is sent before authentication is performed .", "question_id": 6407}
{"snippet": "nntplib.NNTP(host, timeout, port=119, usenetrc=False)", "intent": "Return a new NNTP object , representing a connection to the NNTP server running on `host` host , listening at `port` port . An optional `timeout` can be specified for the socket connection . If the optional `user` and `password` are provided , or if suitable credentials are present in /.netrc and the optional flag `usenetrc` is true , the AUTHINFO USER and AUTHINFO PASS commands are used to identify and authenticate the user to the server .", "question_id": 6408}
{"snippet": "nntplib.NNTP(host)", "intent": "Return a new NNTP object , representing a connection to the NNTP server running on `host` host , listening at `port` port .", "question_id": 6409}
{"snippet": "nntplib.NNTP(host, port=119)", "intent": "Return a new NNTP object , representing a connection to the NNTP server running on `host` host , listening at `port` port .", "question_id": 6410}
{"snippet": "nntplib.NNTP(host, user=None)", "intent": "Return a new NNTP object , representing a connection to the NNTP server running on `host` host , listening at `port` port . If the optional `user` and `password` are provided , or if suitable credentials are present in /.netrc and the optional flag `usenetrc` is true , the AUTHINFO USER and AUTHINFO PASS commands are used to identify and authenticate the user to the server .", "question_id": 6411}
{"snippet": "nntplib.NNTP(host, password=None)", "intent": "Return a new NNTP object , representing a connection to the NNTP server running on `host` host , listening at `port` port . If the optional `user` and `password` are provided , or if suitable credentials are present in /.netrc and the optional flag `usenetrc` is true , the AUTHINFO USER and AUTHINFO PASS commands are used to identify and authenticate the user to the server .", "question_id": 6412}
{"snippet": "nntplib.NNTP(host, readermode=None)", "intent": "Return a new NNTP object , representing a connection to the NNTP server running on `host` host , listening at `port` port . If the optional flag `readermode` is true , then a mode reader command is sent before authentication is performed .", "question_id": 6413}
{"snippet": "nntplib.NNTP(host, usenetrc=False)", "intent": "Return a new NNTP object , representing a connection to the NNTP server running on `host` host , listening at `port` port . If the optional `user` and `password` are provided , or if suitable credentials are present in /.netrc and the optional flag `usenetrc` is true , the AUTHINFO USER and AUTHINFO PASS commands are used to identify and authenticate the user to the server .", "question_id": 6414}
{"snippet": "nntplib.NNTP(host, port=119, user=None)", "intent": "Return a new NNTP object , representing a connection to the NNTP server running on `host` host , listening at `port` port . If the optional `user` and `password` are provided , or if suitable credentials are present in /.netrc and the optional flag `usenetrc` is true , the AUTHINFO USER and AUTHINFO PASS commands are used to identify and authenticate the user to the server .", "question_id": 6415}
{"snippet": "nntplib.NNTP(host, port=119, password=None)", "intent": "Return a new NNTP object , representing a connection to the NNTP server running on `host` host , listening at `port` port . If the optional `user` and `password` are provided , or if suitable credentials are present in /.netrc and the optional flag `usenetrc` is true , the AUTHINFO USER and AUTHINFO PASS commands are used to identify and authenticate the user to the server .", "question_id": 6416}
{"snippet": "nntplib.NNTP(host, port=119, readermode=None)", "intent": "Return a new NNTP object , representing a connection to the NNTP server running on `host` host , listening at `port` port . If the optional flag `readermode` is true , then a mode reader command is sent before authentication is performed .", "question_id": 6417}
{"snippet": "nntplib.NNTP(host, port=119, usenetrc=False)", "intent": "Return a new NNTP object , representing a connection to the NNTP server running on `host` host , listening at `port` port . If the optional `user` and `password` are provided , or if suitable credentials are present in /.netrc and the optional flag `usenetrc` is true , the AUTHINFO USER and AUTHINFO PASS commands are used to identify and authenticate the user to the server .", "question_id": 6418}
{"snippet": "nntplib.NNTP_SSL(host, timeout)", "intent": "Return a new NNTP_SSL object , representing an encrypted connection to the NNTP server running on `host` host , listening at `port` port . With arguments `timeout`.", "question_id": 6419}
{"snippet": "nntplib.NNTP_SSL(host, timeout, port=563)", "intent": "Return a new NNTP_SSL object , representing an encrypted connection to the NNTP server running on `host` host , listening at `port` port . With arguments `timeout`.", "question_id": 6420}
{"snippet": "nntplib.NNTP_SSL(host, timeout, user=None)", "intent": "Return a new NNTP_SSL object , representing an encrypted connection to the NNTP server running on `host` host , listening at `port` port . With arguments `timeout`, `user`.", "question_id": 6421}
{"snippet": "nntplib.NNTP_SSL(host, timeout, password=None)", "intent": "Return a new NNTP_SSL object , representing an encrypted connection to the NNTP server running on `host` host , listening at `port` port . With arguments `timeout`, `password`.", "question_id": 6422}
{"snippet": "nntplib.NNTP_SSL(host, timeout, ssl_context=None)", "intent": "Return a new NNTP_SSL object , representing an encrypted connection to the NNTP server running on `host` host , listening at `port` port . `ssl_context` is also optional , and is a SSLContext object . With arguments `timeout`.", "question_id": 6423}
{"snippet": "nntplib.NNTP_SSL(host, timeout, readermode=None)", "intent": "Return a new NNTP_SSL object , representing an encrypted connection to the NNTP server running on `host` host , listening at `port` port . With arguments `timeout`, `readermode`.", "question_id": 6424}
{"snippet": "nntplib.NNTP_SSL(host, timeout, usenetrc=False)", "intent": "Return a new NNTP_SSL object , representing an encrypted connection to the NNTP server running on `host` host , listening at `port` port . With arguments `timeout`, `usenetrc`.", "question_id": 6425}
{"snippet": "nntplib.NNTP_SSL(host, timeout, port=563, user=None)", "intent": "Return a new NNTP_SSL object , representing an encrypted connection to the NNTP server running on `host` host , listening at `port` port . With arguments `timeout`, `user`.", "question_id": 6426}
{"snippet": "nntplib.NNTP_SSL(host, timeout, port=563, password=None)", "intent": "Return a new NNTP_SSL object , representing an encrypted connection to the NNTP server running on `host` host , listening at `port` port . With arguments `timeout`, `password`.", "question_id": 6427}
{"snippet": "nntplib.NNTP_SSL(host, timeout, port=563, ssl_context=None)", "intent": "Return a new NNTP_SSL object , representing an encrypted connection to the NNTP server running on `host` host , listening at `port` port . `ssl_context` is also optional , and is a SSLContext object . With arguments `timeout`.", "question_id": 6428}
{"snippet": "nntplib.NNTP_SSL(host)", "intent": "Return a new NNTP_SSL object , representing an encrypted connection to the NNTP server running on `host` host , listening at `port` port .", "question_id": 6429}
{"snippet": "nntplib.NNTP_SSL(host, port=563)", "intent": "Return a new NNTP_SSL object , representing an encrypted connection to the NNTP server running on `host` host , listening at `port` port .", "question_id": 6430}
{"snippet": "nntplib.NNTP_SSL(host, user=None)", "intent": "Return a new NNTP_SSL object , representing an encrypted connection to the NNTP server running on `host` host , listening at `port` port . With arguments `user`.", "question_id": 6431}
{"snippet": "nntplib.NNTP_SSL(host, password=None)", "intent": "Return a new NNTP_SSL object , representing an encrypted connection to the NNTP server running on `host` host , listening at `port` port . With arguments `password`.", "question_id": 6432}
{"snippet": "nntplib.NNTP_SSL(host, ssl_context=None)", "intent": "Return a new NNTP_SSL object , representing an encrypted connection to the NNTP server running on `host` host , listening at `port` port . `ssl_context` is also optional , and is a SSLContext object .", "question_id": 6433}
{"snippet": "nntplib.NNTP_SSL(host, readermode=None)", "intent": "Return a new NNTP_SSL object , representing an encrypted connection to the NNTP server running on `host` host , listening at `port` port . With arguments `readermode`.", "question_id": 6434}
{"snippet": "nntplib.NNTP_SSL(host, usenetrc=False)", "intent": "Return a new NNTP_SSL object , representing an encrypted connection to the NNTP server running on `host` host , listening at `port` port . With arguments `usenetrc`.", "question_id": 6435}
{"snippet": "nntplib.NNTP_SSL(host, port=563, user=None)", "intent": "Return a new NNTP_SSL object , representing an encrypted connection to the NNTP server running on `host` host , listening at `port` port . With arguments `user`.", "question_id": 6436}
{"snippet": "nntplib.NNTP_SSL(host, port=563, password=None)", "intent": "Return a new NNTP_SSL object , representing an encrypted connection to the NNTP server running on `host` host , listening at `port` port . With arguments `password`.", "question_id": 6437}
{"snippet": "nntplib.NNTP_SSL(host, port=563, ssl_context=None)", "intent": "Return a new NNTP_SSL object , representing an encrypted connection to the NNTP server running on `host` host , listening at `port` port . `ssl_context` is also optional , and is a SSLContext object .", "question_id": 6438}
{"snippet": "nntplib.NNTPError", "intent": "Derived from the standard exception Exception, this is the base class for all exceptions raised by the nntplib module.", "question_id": 6439}
{"snippet": "nntp_ssl.response", "intent": "The response of the server if available, as a str object.", "question_id": 6440}
{"snippet": "nntplib.NNTPReplyError", "intent": "Exception raised when an unexpected reply is received from the server.", "question_id": 6441}
{"snippet": "nntplib.NNTPTemporaryError", "intent": "Exception raised when a response code in the range 400\u2013499 is received.", "question_id": 6442}
{"snippet": "nntplib.NNTPPermanentError", "intent": "Exception raised when a response code in the range 500\u2013599 is received.", "question_id": 6443}
{"snippet": "nntplib.NNTPProtocolError", "intent": "Exception raised when a reply is received from the server that does not begin with a digit in the range 1\u20135.", "question_id": 6444}
{"snippet": "nntplib.NNTPDataError", "intent": "Exception raised when there is some error in the response data.", "question_id": 6445}
{"snippet": "NNTP.nntp_version", "intent": "An integer representing the version of the NNTP protocol supported by the server.", "question_id": 6446}
{"snippet": "NNTP.nntp_implementation", "intent": "A string describing the software name and version of the NNTP server, or None if not advertised by the server.", "question_id": 6447}
{"snippet": "NNTP.quit()", "intent": "Send a QUIT command and close the connection .", "question_id": 6448}
{"snippet": "NNTP.getwelcome()", "intent": "Return the welcome message sent by the server in reply to the initial connection .", "question_id": 6449}
{"snippet": "NNTP.getcapabilities()", "intent": "Return the RFC 3977 capabilities advertised by the server , as a dict instance mapping capability names to ( possibly empty ) lists of values .", "question_id": 6450}
{"snippet": "NNTP.login()", "intent": "Send AUTHINFO commands with the `user` name and `password` .", "question_id": 6451}
{"snippet": "NNTP.login(user=None)", "intent": "Send AUTHINFO commands with the `user` name and `password` .", "question_id": 6452}
{"snippet": "NNTP.login(password=None)", "intent": "Send AUTHINFO commands with the `user` name and `password` .", "question_id": 6453}
{"snippet": "NNTP.login(usenetrc=True)", "intent": "Send AUTHINFO commands with the `user` name and `password` . If user and password are None and `usenetrc` is true , credentials from ~/.netrc will be used if possible .", "question_id": 6454}
{"snippet": "NNTP.login(user=None, password=None)", "intent": "Send AUTHINFO commands with the `user` name and `password` .", "question_id": 6455}
{"snippet": "NNTP.login(user=None, usenetrc=True)", "intent": "Send AUTHINFO commands with the `user` name and `password` . If user and password are None and `usenetrc` is true , credentials from ~/.netrc will be used if possible .", "question_id": 6456}
{"snippet": "NNTP.login(password=None, usenetrc=True)", "intent": "Send AUTHINFO commands with the `user` name and `password` . If user and password are None and `usenetrc` is true , credentials from ~/.netrc will be used if possible .", "question_id": 6457}
{"snippet": "NNTP.login(user=None, password=None, usenetrc=True)", "intent": "Send AUTHINFO commands with the `user` name and `password` . If user and password are None and `usenetrc` is true , credentials from ~/.netrc will be used if possible .", "question_id": 6458}
{"snippet": "NNTP.starttls()", "intent": "Send a STARTTLS command .", "question_id": 6459}
{"snippet": "NNTP.starttls(context=None)", "intent": "Send a STARTTLS command . The `context` argument is optional and should be a ssl.SSLContext object .", "question_id": 6460}
{"snippet": "NNTP.newgroups(date)", "intent": "Send a NEWGROUPS command . The `date` argument should be a datetime.date or datetime.datetime object .", "question_id": 6461}
{"snippet": "NNTP.newgroups(date, file=None)", "intent": "Send a NEWGROUPS command . The `date` argument should be a datetime.date or datetime.datetime object . If `file` is supplied , though , then groups will be empty .", "question_id": 6462}
{"snippet": "NNTP.newnews(group, date)", "intent": "Send a NEWNEWS command . Here , `group` is a group name or '* ' , and `date` has the same meaning as for newgroups ( ) .", "question_id": 6463}
{"snippet": "NNTP.newnews(group, date, file=None)", "intent": "Send a NEWNEWS command . Here , `group` is a group name or '* ' , and `date` has the same meaning as for newgroups ( ) . With arguments `file`.", "question_id": 6464}
{"snippet": "NNTP.list()", "intent": "Send a LIST or LIST ACTIVE command .", "question_id": 6465}
{"snippet": "NNTP.list(group_pattern=None)", "intent": "Send a LIST or LIST ACTIVE command . Return a pair ( response , list ) where list is a list of tuples representing all the groups available from this NNTP server , optionally matching the pattern string `group_pattern` .", "question_id": 6466}
{"snippet": "NNTP.list(file=None)", "intent": "Send a LIST or LIST ACTIVE command . With arguments `file`.", "question_id": 6467}
{"snippet": "NNTP.list(group_pattern=None, file=None)", "intent": "Send a LIST or LIST ACTIVE command . Return a pair ( response , list ) where list is a list of tuples representing all the groups available from this NNTP server , optionally matching the pattern string `group_pattern` . With arguments `file`.", "question_id": 6468}
{"snippet": "NNTP.descriptions(grouppattern)", "intent": "Send a LIST NEWSGROUPS command , where `grouppattern` is a wildmat string as specified in RFC 3977 ( it \u2019 s essentially the same as DOS or UNIX shell wildcard strings ) .", "question_id": 6469}
{"snippet": "NNTP.description(group)", "intent": "Get a description for a single `group` group .", "question_id": 6470}
{"snippet": "NNTP.group(name)", "intent": "Send a GROUP command , where `name` is the group name .", "question_id": 6471}
{"snippet": "NNTP.over(message_spec)", "intent": "Send an OVER command , or an XOVER command on legacy servers . `message_spec` can be either a string representing a message id , or a ( first , last ) tuple of numbers indicating a range of articles in the current group , or a ( first , None ) tuple indicating a range of articles starting from first to the last article in the current group , or None to select the current article in the current group .", "question_id": 6472}
{"snippet": "NNTP.over(message_spec, file=None)", "intent": "Send an OVER command , or an XOVER command on legacy servers . `message_spec` can be either a string representing a message id , or a ( first , last ) tuple of numbers indicating a range of articles in the current group , or a ( first , None ) tuple indicating a range of articles starting from first to the last article in the current group , or None to select the current article in the current group . With arguments `file`.", "question_id": 6473}
{"snippet": "NNTP.help()", "intent": "Send a HELP command .", "question_id": 6474}
{"snippet": "NNTP.help(file=None)", "intent": "Send a HELP command . With arguments `file`.", "question_id": 6475}
{"snippet": "NNTP.stat()", "intent": "Send a STAT command , where `message_spec` is either a message id ( enclosed in ' < ' and ' > ' ) or an article number in the current group .", "question_id": 6476}
{"snippet": "NNTP.stat(message_spec=None)", "intent": "Send a STAT command , where `message_spec` is either a message id ( enclosed in ' < ' and ' > ' ) or an article number in the current group .", "question_id": 6477}
{"snippet": "NNTP.next()", "intent": "Send a NEXT command .", "question_id": 6478}
{"snippet": "NNTP.last()", "intent": "Send a LAST command .", "question_id": 6479}
{"snippet": "NNTP.article()", "intent": "Send an ARTICLE command , where `message_spec` has the same meaning as for stat ( ) .", "question_id": 6480}
{"snippet": "NNTP.article(message_spec=None)", "intent": "Send an ARTICLE command , where `message_spec` has the same meaning as for stat ( ) .", "question_id": 6481}
{"snippet": "NNTP.article(file=None)", "intent": "Send an ARTICLE command , where `message_spec` has the same meaning as for stat ( ) . With arguments `file`.", "question_id": 6482}
{"snippet": "NNTP.article(message_spec=None, file=None)", "intent": "Send an ARTICLE command , where `message_spec` has the same meaning as for stat ( ) . With arguments `file`.", "question_id": 6483}
{"snippet": "NNTP.head()", "intent": "Same as article ( ) , but sends a HEAD command .", "question_id": 6484}
{"snippet": "NNTP.head(message_spec=None)", "intent": "Same as article ( ) , but sends a HEAD command . With arguments `message_spec`.", "question_id": 6485}
{"snippet": "NNTP.head(file=None)", "intent": "Same as article ( ) , but sends a HEAD command . The lines returned ( or written to `file` ) will only contain the message headers , not the body .", "question_id": 6486}
{"snippet": "NNTP.head(message_spec=None, file=None)", "intent": "Same as article ( ) , but sends a HEAD command . The lines returned ( or written to `file` ) will only contain the message headers , not the body . With arguments `message_spec`.", "question_id": 6487}
{"snippet": "NNTP.body()", "intent": "Same as article ( ) , but sends a BODY command .", "question_id": 6488}
{"snippet": "NNTP.body(message_spec=None)", "intent": "Same as article ( ) , but sends a BODY command . With arguments `message_spec`.", "question_id": 6489}
{"snippet": "NNTP.body(file=None)", "intent": "Same as article ( ) , but sends a BODY command . The lines returned ( or written to `file` ) will only contain the message body , not the headers .", "question_id": 6490}
{"snippet": "NNTP.body(message_spec=None, file=None)", "intent": "Same as article ( ) , but sends a BODY command . The lines returned ( or written to `file` ) will only contain the message body , not the headers . With arguments `message_spec`.", "question_id": 6491}
{"snippet": "NNTP.post(data)", "intent": "Post an article using the POST command . The `data` argument is either a file object opened for binary reading , or any iterable of bytes objects ( representing raw lines of the article to be posted ) .", "question_id": 6492}
{"snippet": "NNTP.ihave(message_id, data)", "intent": "Send an IHAVE command . `message_id` is the id of the message to send to the server ( enclosed in ' < ' and ' > ' ) . The `data` parameter and the return value are the same as for post ( ) .", "question_id": 6493}
{"snippet": "NNTP.date()", "intent": "Return a pair ( response , date ) .", "question_id": 6494}
{"snippet": "NNTP.slave()", "intent": "Send a SLAVE command .", "question_id": 6495}
{"snippet": "NNTP.set_debuglevel(level)", "intent": "Set the instance \u2019 s debugging `level` .", "question_id": 6496}
{"snippet": "NNTP.xhdr(hdr, str)", "intent": "Send an XHDR command . The `hdr` argument is a header keyword , e.g . The `str` argument should have the form 'first-last ' where first and last are the first and last article numbers to search .", "question_id": 6497}
{"snippet": "NNTP.xhdr(hdr, str, file=None)", "intent": "Send an XHDR command . The `hdr` argument is a header keyword , e.g . The `str` argument should have the form 'first-last ' where first and last are the first and last article numbers to search . If the `file` parameter is supplied , then the output of the XHDR command is stored in a file .", "question_id": 6498}
{"snippet": "NNTP.xover(start, end)", "intent": "Send an XOVER command . `start` and `end` are article numbers delimiting the range of articles to select .", "question_id": 6499}
{"snippet": "NNTP.xover(start, end, file=None)", "intent": "Send an XOVER command . `start` and `end` are article numbers delimiting the range of articles to select . With arguments `file`.", "question_id": 6500}
{"snippet": "NNTP.xpath(id)", "intent": "Return a pair ( resp , path ) , where path is the directory path to the article with message ID `id` .", "question_id": 6501}
{"snippet": "nntplib.decode_header(header_str)", "intent": "Decode a header value , un-escaping any escaped non-ASCII characters . `header_str` must be a str object .", "question_id": 6502}
{"snippet": "numbers.Number", "intent": "The root of the numeric hierarchy.", "question_id": 6503}
{"snippet": "numbers.Complex", "intent": "Subclasses of this type describe complex numbers and include the operations that work on the built-in complex type.", "question_id": 6504}
{"snippet": "complex.real", "intent": "Abstract.", "question_id": 6505}
{"snippet": "complex.imag", "intent": "Abstract.", "question_id": 6506}
{"snippet": "complex.conjugate()", "intent": "Abstract .", "question_id": 6507}
{"snippet": "numbers.Real", "intent": "To Complex, Real adds the operations that work on real numbers.", "question_id": 6508}
{"snippet": "numbers.Rational", "intent": "Subtypes Real and adds numerator and denominator properties, which should be in lowest terms.", "question_id": 6509}
{"snippet": "rational.numerator", "intent": "Abstract.", "question_id": 6510}
{"snippet": "rational.denominator", "intent": "Abstract.", "question_id": 6511}
{"snippet": "numbers.Integral", "intent": "Subtypes Rational and adds a conversion to int.", "question_id": 6512}
{"snippet": "operator.lt(a, b)", "intent": "Perform \u201c rich comparisons \u201d between `a` and `b` .", "question_id": 6513}
{"snippet": "operator.le(a, b)", "intent": "Perform \u201c rich comparisons \u201d between `a` and `b` .", "question_id": 6514}
{"snippet": "operator.eq(a, b)", "intent": "Perform \u201c rich comparisons \u201d between `a` and `b` .", "question_id": 6515}
{"snippet": "operator.ne(a, b)", "intent": "Perform \u201c rich comparisons \u201d between `a` and `b` .", "question_id": 6516}
{"snippet": "operator.ge(a, b)", "intent": "Perform \u201c rich comparisons \u201d between `a` and `b` .", "question_id": 6517}
{"snippet": "operator.gt(a, b)", "intent": "Perform \u201c rich comparisons \u201d between `a` and `b` .", "question_id": 6518}
{"snippet": "operator.__lt__(a, b)", "intent": "Perform \u201c rich comparisons \u201d between `a` and `b` .", "question_id": 6519}
{"snippet": "operator.__le__(a, b)", "intent": "Perform \u201c rich comparisons \u201d between `a` and `b` .", "question_id": 6520}
{"snippet": "operator.__eq__(a, b)", "intent": "Perform \u201c rich comparisons \u201d between `a` and `b` .", "question_id": 6521}
{"snippet": "operator.__ne__(a, b)", "intent": "Perform \u201c rich comparisons \u201d between `a` and `b` .", "question_id": 6522}
{"snippet": "operator.__ge__(a, b)", "intent": "Perform \u201c rich comparisons \u201d between `a` and `b` .", "question_id": 6523}
{"snippet": "operator.__gt__(a, b)", "intent": "Perform \u201c rich comparisons \u201d between `a` and `b` .", "question_id": 6524}
{"snippet": "operator.not_(obj)", "intent": "Return the outcome of not `obj` .", "question_id": 6525}
{"snippet": "operator.__not__(obj)", "intent": "Return the outcome of not `obj` .", "question_id": 6526}
{"snippet": "operator.truth(obj)", "intent": "Return True if `obj` is true , and False otherwise .", "question_id": 6527}
{"snippet": "operator.is_(a, b)", "intent": "Return `a` is `b` .", "question_id": 6528}
{"snippet": "operator.is_not(a, b)", "intent": "Return `a` is not `b` .", "question_id": 6529}
{"snippet": "operator.abs(obj)", "intent": "Return the absolute value of `obj` .", "question_id": 6530}
{"snippet": "operator.__abs__(obj)", "intent": "Return the absolute value of `obj` .", "question_id": 6531}
{"snippet": "operator.add(a, b)", "intent": "Return `a` + `b` , for a and b numbers .", "question_id": 6532}
{"snippet": "operator.__add__(a, b)", "intent": "Return `a` + `b` , for a and b numbers .", "question_id": 6533}
{"snippet": "operator.and_(a, b)", "intent": "Return the bitwise and of `a` and `b` .", "question_id": 6534}
{"snippet": "operator.__and__(a, b)", "intent": "Return the bitwise and of `a` and `b` .", "question_id": 6535}
{"snippet": "operator.floordiv(a, b)", "intent": "Return `a` // `b` .", "question_id": 6536}
{"snippet": "operator.__floordiv__(a, b)", "intent": "Return `a` // `b` .", "question_id": 6537}
{"snippet": "operator.index(a)", "intent": "Return `a` converted to an integer .", "question_id": 6538}
{"snippet": "operator.__index__(a)", "intent": "Return `a` converted to an integer .", "question_id": 6539}
{"snippet": "operator.inv(obj)", "intent": "Return the bitwise inverse of the number `obj` .", "question_id": 6540}
{"snippet": "operator.invert(obj)", "intent": "Return the bitwise inverse of the number `obj` .", "question_id": 6541}
{"snippet": "operator.__inv__(obj)", "intent": "Return the bitwise inverse of the number `obj` .", "question_id": 6542}
{"snippet": "operator.__invert__(obj)", "intent": "Return the bitwise inverse of the number `obj` .", "question_id": 6543}
{"snippet": "operator.lshift(a, b)", "intent": "Return `a` shifted left by `b` .", "question_id": 6544}
{"snippet": "operator.__lshift__(a, b)", "intent": "Return `a` shifted left by `b` .", "question_id": 6545}
{"snippet": "operator.mod(a, b)", "intent": "Return `a` % `b` .", "question_id": 6546}
{"snippet": "operator.__mod__(a, b)", "intent": "Return `a` % `b` .", "question_id": 6547}
{"snippet": "operator.mul(a, b)", "intent": "Return `a` * `b` , for a and b numbers .", "question_id": 6548}
{"snippet": "operator.__mul__(a, b)", "intent": "Return `a` * `b` , for a and b numbers .", "question_id": 6549}
{"snippet": "operator.matmul(a, b)", "intent": "Return `a` @ `b` .", "question_id": 6550}
{"snippet": "operator.__matmul__(a, b)", "intent": "Return `a` @ `b` .", "question_id": 6551}
{"snippet": "operator.neg(obj)", "intent": "Return `obj` negated ( -obj ) .", "question_id": 6552}
{"snippet": "operator.__neg__(obj)", "intent": "Return `obj` negated ( -obj ) .", "question_id": 6553}
{"snippet": "operator.or_(a, b)", "intent": "Return the bitwise or of `a` and `b` .", "question_id": 6554}
{"snippet": "operator.__or__(a, b)", "intent": "Return the bitwise or of `a` and `b` .", "question_id": 6555}
{"snippet": "operator.pos(obj)", "intent": "Return `obj` positive ( +obj ) .", "question_id": 6556}
{"snippet": "operator.__pos__(obj)", "intent": "Return `obj` positive ( +obj ) .", "question_id": 6557}
{"snippet": "operator.pow(a, b)", "intent": "Return `a` ** `b` , for a and b numbers .", "question_id": 6558}
{"snippet": "operator.__pow__(a, b)", "intent": "Return `a` ** `b` , for a and b numbers .", "question_id": 6559}
{"snippet": "operator.rshift(a, b)", "intent": "Return `a` shifted right by `b` .", "question_id": 6560}
{"snippet": "operator.__rshift__(a, b)", "intent": "Return `a` shifted right by `b` .", "question_id": 6561}
{"snippet": "operator.sub(a, b)", "intent": "Return `a` - `b` .", "question_id": 6562}
{"snippet": "operator.__sub__(a, b)", "intent": "Return `a` - `b` .", "question_id": 6563}
{"snippet": "operator.truediv(a, b)", "intent": "Return `a` / `b` where 2/3 is .66 rather than 0 .", "question_id": 6564}
{"snippet": "operator.__truediv__(a, b)", "intent": "Return `a` / `b` where 2/3 is .66 rather than 0 .", "question_id": 6565}
{"snippet": "operator.xor(a, b)", "intent": "Return the bitwise exclusive or of `a` and `b` .", "question_id": 6566}
{"snippet": "operator.__xor__(a, b)", "intent": "Return the bitwise exclusive or of `a` and `b` .", "question_id": 6567}
{"snippet": "operator.concat(a, b)", "intent": "Return `a` + `b` for a and b sequences .", "question_id": 6568}
{"snippet": "operator.__concat__(a, b)", "intent": "Return `a` + `b` for a and b sequences .", "question_id": 6569}
{"snippet": "operator.contains(a, b)", "intent": "Return the outcome of the test `b` in `a` .", "question_id": 6570}
{"snippet": "operator.__contains__(a, b)", "intent": "Return the outcome of the test `b` in `a` .", "question_id": 6571}
{"snippet": "operator.countOf(a, b)", "intent": "Return the number of occurrences of `b` in `a` .", "question_id": 6572}
{"snippet": "operator.delitem(a, b)", "intent": "Remove the value of `a` at index `b` .", "question_id": 6573}
{"snippet": "operator.__delitem__(a, b)", "intent": "Remove the value of `a` at index `b` .", "question_id": 6574}
{"snippet": "operator.getitem(a, b)", "intent": "Return the value of `a` at index `b` .", "question_id": 6575}
{"snippet": "operator.__getitem__(a, b)", "intent": "Return the value of `a` at index `b` .", "question_id": 6576}
{"snippet": "operator.indexOf(a, b)", "intent": "Return the index of the first of occurrence of `b` in `a` .", "question_id": 6577}
{"snippet": "operator.setitem(a, b, c)", "intent": "Set the value of `a` at index `b` to `c` .", "question_id": 6578}
{"snippet": "operator.__setitem__(a, b, c)", "intent": "Set the value of `a` at index `b` to `c` .", "question_id": 6579}
{"snippet": "operator.length_hint(obj)", "intent": "Return an estimated length for the object o . With arguments `obj`.", "question_id": 6580}
{"snippet": "operator.length_hint(obj, default=0)", "intent": "Return an estimated length for the object o . First try to return its actual length , then an estimate using object.__length_hint__ ( ) , and finally return the `default` value . With arguments `obj`.", "question_id": 6581}
{"snippet": "operator.attrgetter(attr)", "intent": "Return a callable object that fetches `attr` from its operand .", "question_id": 6582}
{"snippet": "operator.attrgetter(*attrs)", "intent": "Return a callable object that fetches attr from its operand . With arguments `*attrs`.", "question_id": 6583}
{"snippet": "operator.itemgetter(item)", "intent": "Return a callable object that fetches `item` from its operand using the operand \u2019 s __getitem__ ( ) method .", "question_id": 6584}
{"snippet": "operator.itemgetter(*items)", "intent": "Return a callable object that fetches item from its operand using the operand \u2019 s __getitem__ ( ) method . With arguments `*items`.", "question_id": 6585}
{"snippet": "operator.methodcaller(name, args...)", "intent": "Return a callable object that calls the method `name` on its operand . With arguments `args...`.", "question_id": 6586}
{"snippet": "operator.methodcaller(name)", "intent": "Return a callable object that calls the method `name` on its operand .", "question_id": 6587}
{"snippet": "operator.iadd(a, b)", "intent": "`a` = iadd ( a , `b` ) is equivalent to a += b .", "question_id": 6588}
{"snippet": "operator.__iadd__(a, b)", "intent": "`a` = iadd ( a , `b` ) is equivalent to a += b .", "question_id": 6589}
{"snippet": "operator.iand(a, b)", "intent": "`a` = iand ( a , `b` ) is equivalent to a & = b .", "question_id": 6590}
{"snippet": "operator.__iand__(a, b)", "intent": "`a` = iand ( a , `b` ) is equivalent to a & = b .", "question_id": 6591}
{"snippet": "operator.iconcat(a, b)", "intent": "`a` = iconcat ( a , `b` ) is equivalent to a += b for a and b sequences .", "question_id": 6592}
{"snippet": "operator.__iconcat__(a, b)", "intent": "`a` = iconcat ( a , `b` ) is equivalent to a += b for a and b sequences .", "question_id": 6593}
{"snippet": "operator.ifloordiv(a, b)", "intent": "`a` = ifloordiv ( a , `b` ) is equivalent to a //= b .", "question_id": 6594}
{"snippet": "operator.__ifloordiv__(a, b)", "intent": "`a` = ifloordiv ( a , `b` ) is equivalent to a //= b .", "question_id": 6595}
{"snippet": "operator.ilshift(a, b)", "intent": "`a` = ilshift ( a , `b` ) is equivalent to a < < = b .", "question_id": 6596}
{"snippet": "operator.__ilshift__(a, b)", "intent": "`a` = ilshift ( a , `b` ) is equivalent to a < < = b .", "question_id": 6597}
{"snippet": "operator.imod(a, b)", "intent": "`a` = imod ( a , `b` ) is equivalent to a % = b .", "question_id": 6598}
{"snippet": "operator.__imod__(a, b)", "intent": "`a` = imod ( a , `b` ) is equivalent to a % = b .", "question_id": 6599}
{"snippet": "operator.imul(a, b)", "intent": "`a` = imul ( a , `b` ) is equivalent to a *= b .", "question_id": 6600}
{"snippet": "operator.__imul__(a, b)", "intent": "`a` = imul ( a , `b` ) is equivalent to a *= b .", "question_id": 6601}
{"snippet": "operator.imatmul(a, b)", "intent": "`a` = imatmul ( a , `b` ) is equivalent to a @ = b .", "question_id": 6602}
{"snippet": "operator.__imatmul__(a, b)", "intent": "`a` = imatmul ( a , `b` ) is equivalent to a @ = b .", "question_id": 6603}
{"snippet": "operator.ior(a, b)", "intent": "`a` = ior ( a , `b` ) is equivalent to a |= b .", "question_id": 6604}
{"snippet": "operator.__ior__(a, b)", "intent": "`a` = ior ( a , `b` ) is equivalent to a |= b .", "question_id": 6605}
{"snippet": "operator.ipow(a, b)", "intent": "`a` = ipow ( a , `b` ) is equivalent to a **= b .", "question_id": 6606}
{"snippet": "operator.__ipow__(a, b)", "intent": "`a` = ipow ( a , `b` ) is equivalent to a **= b .", "question_id": 6607}
{"snippet": "operator.irshift(a, b)", "intent": "`a` = irshift ( a , `b` ) is equivalent to a > > = b .", "question_id": 6608}
{"snippet": "operator.__irshift__(a, b)", "intent": "`a` = irshift ( a , `b` ) is equivalent to a > > = b .", "question_id": 6609}
{"snippet": "operator.isub(a, b)", "intent": "`a` = isub ( a , `b` ) is equivalent to a -= b .", "question_id": 6610}
{"snippet": "operator.__isub__(a, b)", "intent": "`a` = isub ( a , `b` ) is equivalent to a -= b .", "question_id": 6611}
{"snippet": "operator.itruediv(a, b)", "intent": "`a` = itruediv ( a , `b` ) is equivalent to a /= b .", "question_id": 6612}
{"snippet": "operator.__itruediv__(a, b)", "intent": "`a` = itruediv ( a , `b` ) is equivalent to a /= b .", "question_id": 6613}
{"snippet": "operator.ixor(a, b)", "intent": "`a` = ixor ( a , `b` ) is equivalent to a ^= b .", "question_id": 6614}
{"snippet": "operator.__ixor__(a, b)", "intent": "`a` = ixor ( a , `b` ) is equivalent to a ^= b .", "question_id": 6615}
{"snippet": "optparse.OptionGroup(parser, title)", "intent": "where With arguments `parser`, `title`.", "question_id": 6616}
{"snippet": "optparse.OptionGroup(parser, title, description=None)", "intent": "where With arguments `parser`, `title`, `description`.", "question_id": 6617}
{"snippet": "OptionParser.get_option_group(opt_str)", "intent": "Return the OptionGroup to which the short or long option string `opt_str` ( e.g .", "question_id": 6618}
{"snippet": "OptionParser.print_version()", "intent": "Print the version message for the current program ( self.version ) to `file` ( default stdout ) .", "question_id": 6619}
{"snippet": "OptionParser.print_version(file=None)", "intent": "Print the version message for the current program ( self.version ) to `file` ( default stdout ) .", "question_id": 6620}
{"snippet": "OptionParser.get_version()", "intent": "Same as print_version ( ) but returns the version string instead of printing it .", "question_id": 6621}
{"snippet": "optparse.OptionParser()", "intent": "The OptionParser constructor has no required arguments , but a number of optional keyword arguments .", "question_id": 6622}
{"snippet": "OptionParser.add_option(option)", "intent": "To define an `option` with only a short option string :", "question_id": 6623}
{"snippet": "OptionParser.add_option(*opt_str)", "intent": "To define an option with only a short option string : With arguments `*opt_str`.", "question_id": 6624}
{"snippet": "OptionParser.add_option(*opt_str, attr=value)", "intent": "To define an option with only a short option string : With arguments `*opt_str`, `attr`.", "question_id": 6625}
{"snippet": "Option.action", "intent": "(default: \"store\")", "question_id": 6626}
{"snippet": "Option.type", "intent": "(default: \"string\")", "question_id": 6627}
{"snippet": "Option.dest", "intent": "(default: derived from option strings)", "question_id": 6628}
{"snippet": "Option.default", "intent": "The value to use for this option\u2019s destination if the option is not seen on the command line.", "question_id": 6629}
{"snippet": "Option.nargs", "intent": "(default: 1)", "question_id": 6630}
{"snippet": "Option.const", "intent": "For actions that store a constant value, the constant value to store.", "question_id": 6631}
{"snippet": "Option.choices", "intent": "For options of type \"choice\", the list of strings the user may choose from.", "question_id": 6632}
{"snippet": "Option.callback", "intent": "For options with action \"callback\", the callable to call when this option is seen.", "question_id": 6633}
{"snippet": "Option.callback_args", "intent": "Additional positional and keyword arguments to pass to callback after the four standard callback arguments.", "question_id": 6634}
{"snippet": "Option.callback_kwargs", "intent": "Additional positional and keyword arguments to pass to callback after the four standard callback arguments.", "question_id": 6635}
{"snippet": "Option.help", "intent": "Help text to print for this option when listing all available options after the user supplies a help option (such as --help).", "question_id": 6636}
{"snippet": "Option.metavar", "intent": "(default: derived from option strings)", "question_id": 6637}
{"snippet": "OptionParser.disable_interspersed_args()", "intent": "Set parsing to stop on the first non-option .", "question_id": 6638}
{"snippet": "OptionParser.enable_interspersed_args()", "intent": "Set parsing to not stop on the first non-option , allowing interspersing switches with command arguments .", "question_id": 6639}
{"snippet": "OptionParser.get_option(opt_str)", "intent": "Returns the Option instance with the option string `opt_str` , or None if no options have that option string .", "question_id": 6640}
{"snippet": "OptionParser.has_option(opt_str)", "intent": "Return true if the OptionParser has an option with option string `opt_str` ( e.g. , -q or -- verbose ) .", "question_id": 6641}
{"snippet": "OptionParser.remove_option(opt_str)", "intent": "If the OptionParser has an option corresponding to `opt_str` , that option is removed .", "question_id": 6642}
{"snippet": "OptionParser.set_usage(usage)", "intent": "Set the `usage` string according to the rules described above for the usage constructor keyword argument .", "question_id": 6643}
{"snippet": "OptionParser.print_usage()", "intent": "Print the usage message for the current program ( self.usage ) to `file` ( default stdout ) .", "question_id": 6644}
{"snippet": "OptionParser.print_usage(file=None)", "intent": "Print the usage message for the current program ( self.usage ) to `file` ( default stdout ) .", "question_id": 6645}
{"snippet": "OptionParser.get_usage()", "intent": "Same as print_usage ( ) but returns the usage string instead of printing it .", "question_id": 6646}
{"snippet": "OptionParser.set_defaults()", "intent": "Set default values for several option destinations at once .", "question_id": 6647}
{"snippet": "OptionParser.set_defaults(dest=value)", "intent": "Set default values for several option destinations at once . With arguments `dest`.", "question_id": 6648}
{"snippet": "Option.TYPES", "intent": "A tuple of type names; in your subclass, simply define a new tuple TYPES that builds on the standard one.", "question_id": 6649}
{"snippet": "Option.TYPE_CHECKER", "intent": "A dictionary mapping type names to type-checking functions.", "question_id": 6650}
{"snippet": "Option.ACTIONS", "intent": "All actions must be listed in ACTIONS.", "question_id": 6651}
{"snippet": "Option.STORE_ACTIONS", "intent": "\u201cstore\u201d actions are additionally listed here.", "question_id": 6652}
{"snippet": "Option.TYPED_ACTIONS", "intent": "\u201ctyped\u201d actions are additionally listed here.", "question_id": 6653}
{"snippet": "Option.ALWAYS_TYPED_ACTIONS", "intent": "Actions that always take a type (i.e.", "question_id": 6654}
{"snippet": "os.error", "intent": "An alias for the built-in OSError exception.", "question_id": 6655}
{"snippet": "os.name", "intent": "The name of the operating system dependent module imported.", "question_id": 6656}
{"snippet": "os.ctermid()", "intent": "Return the filename corresponding to the controlling terminal of the process .", "question_id": 6657}
{"snippet": "os.environ", "intent": "A mapping object representing the string environment.", "question_id": 6658}
{"snippet": "os.environb", "intent": "Bytes version of environ: a mapping object representing the environment as byte strings.", "question_id": 6659}
{"snippet": "os.chdir(path)", "intent": "These functions are described in Files and Directories . With arguments `path`.", "question_id": 6660}
{"snippet": "os.fchdir(fd)", "intent": "These functions are described in Files and Directories . With arguments `fd`.", "question_id": 6661}
{"snippet": "os.getcwd()", "intent": "These functions are described in Files and Directories .", "question_id": 6662}
{"snippet": "os.fsencode(filename)", "intent": "Encode path-like `filename` to the filesystem encoding with 'surrogateescape ' error handler , or 'strict ' on Windows ; return bytes unchanged .", "question_id": 6663}
{"snippet": "os.fsdecode(filename)", "intent": "Decode the path-like `filename` from the filesystem encoding with 'surrogateescape ' error handler , or 'strict ' on Windows ; return str unchanged .", "question_id": 6664}
{"snippet": "os.fspath(path)", "intent": "Return the file system representation of the `path` .", "question_id": 6665}
{"snippet": "os.PathLike", "intent": "An abstract base class for objects representing a file system path, e.g.", "question_id": 6666}
{"snippet": "path_like.__fspath__()", "intent": "Return the file system path representation of the object .", "question_id": 6667}
{"snippet": "os.getenv(key)", "intent": "Return the value of the environment variable `key` if it exists , or `default` if it doesn \u2019 t .", "question_id": 6668}
{"snippet": "os.getenv(key, default=None)", "intent": "Return the value of the environment variable `key` if it exists , or `default` if it doesn \u2019 t .", "question_id": 6669}
{"snippet": "os.getenvb(key)", "intent": "Return the value of the environment variable `key` if it exists , or `default` if it doesn \u2019 t .", "question_id": 6670}
{"snippet": "os.getenvb(key, default=None)", "intent": "Return the value of the environment variable `key` if it exists , or `default` if it doesn \u2019 t .", "question_id": 6671}
{"snippet": "os.get_exec_path()", "intent": "Returns the list of directories that will be searched for a named executable , similar to a shell , when launching a process .", "question_id": 6672}
{"snippet": "os.get_exec_path(env=None)", "intent": "Returns the list of directories that will be searched for a named executable , similar to a shell , when launching a process . `env` , when specified , should be an environment variable dictionary to lookup the PATH in .", "question_id": 6673}
{"snippet": "os.getegid()", "intent": "Return the effective group id of the current process .", "question_id": 6674}
{"snippet": "os.geteuid()", "intent": "Return the current process \u2019 s effective user id .", "question_id": 6675}
{"snippet": "os.getgid()", "intent": "Return the real group id of the current process .", "question_id": 6676}
{"snippet": "os.getgrouplist(user, group)", "intent": "Return list of `group` ids that `user` belongs to .", "question_id": 6677}
{"snippet": "os.getgroups()", "intent": "Return list of supplemental group ids associated with the current process .", "question_id": 6678}
{"snippet": "os.getlogin()", "intent": "Return the name of the user logged in on the controlling terminal of the process .", "question_id": 6679}
{"snippet": "os.getpgid(pid)", "intent": "Return the process group id of the process with process id `pid` .", "question_id": 6680}
{"snippet": "os.getpgrp()", "intent": "Return the id of the current process group .", "question_id": 6681}
{"snippet": "os.getpid()", "intent": "Return the current process id .", "question_id": 6682}
{"snippet": "os.getppid()", "intent": "Return the parent \u2019 s process id .", "question_id": 6683}
{"snippet": "os.getpriority(which, who)", "intent": "Get program scheduling priority . The value `which` is one of PRIO_PROCESS , PRIO_PGRP , or PRIO_USER , and `who` is interpreted relative to which ( a process identifier for PRIO_PROCESS , process group identifier for PRIO_PGRP , and a user ID for PRIO_USER ) .", "question_id": 6684}
{"snippet": "os.PRIO_PROCESS", "intent": "Parameters for the getpriority() and setpriority() functions.", "question_id": 6685}
{"snippet": "os.PRIO_PGRP", "intent": "Parameters for the getpriority() and setpriority() functions.", "question_id": 6686}
{"snippet": "os.PRIO_USER", "intent": "Parameters for the getpriority() and setpriority() functions.", "question_id": 6687}
{"snippet": "os.getresuid()", "intent": "Return a tuple ( ruid , euid , suid ) denoting the current process \u2019 s real , effective , and saved user ids .", "question_id": 6688}
{"snippet": "os.getresgid()", "intent": "Return a tuple ( rgid , egid , sgid ) denoting the current process \u2019 s real , effective , and saved group ids .", "question_id": 6689}
{"snippet": "os.getuid()", "intent": "Return the current process \u2019 s real user id .", "question_id": 6690}
{"snippet": "os.initgroups(username, gid)", "intent": "Call the system initgroups ( ) to initialize the group access list with all of the groups of which the specified `username` is a member , plus the specified group id . With arguments `gid`.", "question_id": 6691}
{"snippet": "os.putenv(key, value)", "intent": "Set the environment variable named `key` to the string `value` .", "question_id": 6692}
{"snippet": "os.setegid(egid)", "intent": "Set the current process \u2019 s effective group id . With arguments `egid`.", "question_id": 6693}
{"snippet": "os.seteuid(euid)", "intent": "Set the current process \u2019 s effective user id . With arguments `euid`.", "question_id": 6694}
{"snippet": "os.setgid(gid)", "intent": "Set the current process \u2019 group id . With arguments `gid`.", "question_id": 6695}
{"snippet": "os.setgroups(groups)", "intent": "Set the list of supplemental group ids associated with the current process to `groups` .", "question_id": 6696}
{"snippet": "os.setpgrp()", "intent": "Call the system call setpgrp ( ) or setpgrp ( 0 , 0 ) depending on which version is implemented ( if any ) .", "question_id": 6697}
{"snippet": "os.setpgid(pid, pgrp)", "intent": "Call the system call setpgid ( ) to set the process group id of the process with id `pid` to the process group with id `pgrp` .", "question_id": 6698}
{"snippet": "os.setpriority(which, who, priority)", "intent": "Set program scheduling `priority` . The value `which` is one of PRIO_PROCESS , PRIO_PGRP , or PRIO_USER , and `who` is interpreted relative to which ( a process identifier for PRIO_PROCESS , process group identifier for PRIO_PGRP , and a user ID for PRIO_USER ) .", "question_id": 6699}
{"snippet": "os.setregid(rgid, egid)", "intent": "Set the current process \u2019 s real and effective group ids . With arguments `rgid`, `egid`.", "question_id": 6700}
{"snippet": "os.setresgid(rgid, egid, sgid)", "intent": "Set the current process \u2019 s real , effective , and saved group ids . With arguments `rgid`, `egid`, `sgid`.", "question_id": 6701}
{"snippet": "os.setresuid(ruid, euid, suid)", "intent": "Set the current process \u2019 s real , effective , and saved user ids . With arguments `ruid`, `euid`, `suid`.", "question_id": 6702}
{"snippet": "os.setreuid(ruid, euid)", "intent": "Set the current process \u2019 s real and effective user ids . With arguments `ruid`, `euid`.", "question_id": 6703}
{"snippet": "os.getsid(pid)", "intent": "Call the system call getsid ( ) . With arguments `pid`.", "question_id": 6704}
{"snippet": "os.setsid()", "intent": "Call the system call setsid ( ) .", "question_id": 6705}
{"snippet": "os.setuid(uid)", "intent": "Set the current process \u2019 s user id . With arguments `uid`.", "question_id": 6706}
{"snippet": "os.strerror(code)", "intent": "Return the error message corresponding to the error `code` in code .", "question_id": 6707}
{"snippet": "os.supports_bytes_environ", "intent": "True if the native OS type of the environment is bytes (eg.", "question_id": 6708}
{"snippet": "os.umask(mask)", "intent": "Set the current numeric umask and return the previous umask . With arguments `mask`.", "question_id": 6709}
{"snippet": "os.uname()", "intent": "Returns information identifying the current operating system .", "question_id": 6710}
{"snippet": "os.unsetenv(key)", "intent": "Unset ( delete ) the environment variable named `key` .", "question_id": 6711}
{"snippet": "os.fdopen(fd, *args, **kwargs)", "intent": "Return an open file object connected to the file descriptor `fd` . With arguments `*args`, `**kwargs`.", "question_id": 6712}
{"snippet": "os.close(fd)", "intent": "Close file descriptor `fd` .", "question_id": 6713}
{"snippet": "os.closerange(fd_low, fd_high)", "intent": "Close all file descriptors from `fd_low` ( inclusive ) to `fd_high` ( exclusive ) , ignoring errors .", "question_id": 6714}
{"snippet": "os.device_encoding(fd)", "intent": "Return a string describing the encoding of the device associated with `fd` if it is connected to a terminal ; else return None .", "question_id": 6715}
{"snippet": "os.dup(fd)", "intent": "Return a duplicate of file descriptor `fd` .", "question_id": 6716}
{"snippet": "os.dup2(fd, fd2)", "intent": "Duplicate file descriptor `fd` to `fd2` , closing the latter first if necessary .", "question_id": 6717}
{"snippet": "os.dup2(fd, fd2, inheritable=True)", "intent": "Duplicate file descriptor `fd` to `fd2` , closing the latter first if necessary . The new file descriptor is `inheritable` by default or non-inheritable if inheritable is False .", "question_id": 6718}
{"snippet": "os.fchmod(fd, mode)", "intent": "Change the `mode` of the file given by `fd` to the numeric mode .", "question_id": 6719}
{"snippet": "os.fchown(fd, uid, gid)", "intent": "Change the owner and group id of the file given by `fd` to the numeric `uid` and `gid` .", "question_id": 6720}
{"snippet": "os.fdatasync(fd)", "intent": "Force write of file with filedescriptor `fd` to disk .", "question_id": 6721}
{"snippet": "os.fpathconf(fd, name)", "intent": "Return system configuration information relevant to an open file . As of Python 3.3 , this is equivalent to os.pathconf ( `fd` , name ) . `name` specifies the configuration value to retrieve ; it may be a string which is the name of a defined system value ; these names are specified in a number of standards ( POSIX.1 , Unix 95 , Unix 98 , and others ) .", "question_id": 6722}
{"snippet": "os.fstat(fd)", "intent": "Get the status of the file descriptor `fd` .", "question_id": 6723}
{"snippet": "os.fstatvfs(fd)", "intent": "Return information about the filesystem containing the file associated with file descriptor `fd` , like statvfs ( ) .", "question_id": 6724}
{"snippet": "os.fsync(fd)", "intent": "Force write of file with filedescriptor `fd` to disk .", "question_id": 6725}
{"snippet": "os.ftruncate(fd, length)", "intent": "Truncate the file corresponding to file descriptor `fd` , so that it is at most `length` bytes in size .", "question_id": 6726}
{"snippet": "os.get_blocking(fd)", "intent": "Get the blocking mode of the file descriptor : False if the O_NONBLOCK flag is set , True if the flag is cleared . With arguments `fd`.", "question_id": 6727}
{"snippet": "os.isatty(fd)", "intent": "Return True if the file descriptor `fd` is open and connected to a tty ( -like ) device , else False .", "question_id": 6728}
{"snippet": "os.lockf(fd, cmd, len)", "intent": "Apply , test or remove a POSIX lock on an open file descriptor . `fd` is an open file descriptor . `cmd` specifies the command to use - one of F_LOCK , F_TLOCK , F_ULOCK or F_TEST . `len` specifies the section of the file to lock .", "question_id": 6729}
{"snippet": "os.F_LOCK", "intent": "Flags that specify what action lockf() will take.", "question_id": 6730}
{"snippet": "os.F_TLOCK", "intent": "Flags that specify what action lockf() will take.", "question_id": 6731}
{"snippet": "os.F_ULOCK", "intent": "Flags that specify what action lockf() will take.", "question_id": 6732}
{"snippet": "os.F_TEST", "intent": "Flags that specify what action lockf() will take.", "question_id": 6733}
{"snippet": "os.lseek(fd, pos, how)", "intent": "Set the current position of file descriptor `fd` to position `pos` , modified by `how` : SEEK_SET or 0 to set the position relative to the beginning of the file ; SEEK_CUR or 1 to set it relative to the current position ; SEEK_END or 2 to set it relative to the end of the file .", "question_id": 6734}
{"snippet": "os.SEEK_SET", "intent": "Parameters to the lseek() function.", "question_id": 6735}
{"snippet": "os.SEEK_CUR", "intent": "Parameters to the lseek() function.", "question_id": 6736}
{"snippet": "os.SEEK_END", "intent": "Parameters to the lseek() function.", "question_id": 6737}
{"snippet": "os.open(path, flags)", "intent": "Open the file `path` and set various `flags` according to flags and possibly its `mode` according to mode .", "question_id": 6738}
{"snippet": "os.open(path, flags, mode=0o777)", "intent": "Open the file `path` and set various `flags` according to flags and possibly its `mode` according to mode .", "question_id": 6739}
{"snippet": "os.open(path, flags, dir_fd=None)", "intent": "Open the file `path` and set various `flags` according to flags and possibly its `mode` according to mode . This function can support paths relative to directory descriptors with the `dir_fd` parameter .", "question_id": 6740}
{"snippet": "os.open(path, flags, mode=0o777, dir_fd=None)", "intent": "Open the file `path` and set various `flags` according to flags and possibly its `mode` according to mode . This function can support paths relative to directory descriptors with the `dir_fd` parameter .", "question_id": 6741}
{"snippet": "os.O_RDONLY", "intent": "The above constants are available on Unix and Windows.", "question_id": 6742}
{"snippet": "os.O_WRONLY", "intent": "The above constants are available on Unix and Windows.", "question_id": 6743}
{"snippet": "os.O_RDWR", "intent": "The above constants are available on Unix and Windows.", "question_id": 6744}
{"snippet": "os.O_APPEND", "intent": "The above constants are available on Unix and Windows.", "question_id": 6745}
{"snippet": "os.O_CREAT", "intent": "The above constants are available on Unix and Windows.", "question_id": 6746}
{"snippet": "os.O_EXCL", "intent": "The above constants are available on Unix and Windows.", "question_id": 6747}
{"snippet": "os.O_TRUNC", "intent": "The above constants are available on Unix and Windows.", "question_id": 6748}
{"snippet": "os.O_DSYNC", "intent": "The above constants are only available on Unix.", "question_id": 6749}
{"snippet": "os.O_RSYNC", "intent": "The above constants are only available on Unix.", "question_id": 6750}
{"snippet": "os.O_SYNC", "intent": "The above constants are only available on Unix.", "question_id": 6751}
{"snippet": "os.O_NDELAY", "intent": "The above constants are only available on Unix.", "question_id": 6752}
{"snippet": "os.O_NONBLOCK", "intent": "The above constants are only available on Unix.", "question_id": 6753}
{"snippet": "os.O_NOCTTY", "intent": "The above constants are only available on Unix.", "question_id": 6754}
{"snippet": "os.O_CLOEXEC", "intent": "The above constants are only available on Unix.", "question_id": 6755}
{"snippet": "os.O_BINARY", "intent": "The above constants are only available on Windows.", "question_id": 6756}
{"snippet": "os.O_NOINHERIT", "intent": "The above constants are only available on Windows.", "question_id": 6757}
{"snippet": "os.O_SHORT_LIVED", "intent": "The above constants are only available on Windows.", "question_id": 6758}
{"snippet": "os.O_TEMPORARY", "intent": "The above constants are only available on Windows.", "question_id": 6759}
{"snippet": "os.O_RANDOM", "intent": "The above constants are only available on Windows.", "question_id": 6760}
{"snippet": "os.O_SEQUENTIAL", "intent": "The above constants are only available on Windows.", "question_id": 6761}
{"snippet": "os.O_TEXT", "intent": "The above constants are only available on Windows.", "question_id": 6762}
{"snippet": "os.O_ASYNC", "intent": "The above constants are extensions and not present if they are not defined by the C library.", "question_id": 6763}
{"snippet": "os.O_DIRECT", "intent": "The above constants are extensions and not present if they are not defined by the C library.", "question_id": 6764}
{"snippet": "os.O_DIRECTORY", "intent": "The above constants are extensions and not present if they are not defined by the C library.", "question_id": 6765}
{"snippet": "os.O_NOFOLLOW", "intent": "The above constants are extensions and not present if they are not defined by the C library.", "question_id": 6766}
{"snippet": "os.O_NOATIME", "intent": "The above constants are extensions and not present if they are not defined by the C library.", "question_id": 6767}
{"snippet": "os.O_PATH", "intent": "The above constants are extensions and not present if they are not defined by the C library.", "question_id": 6768}
{"snippet": "os.O_TMPFILE", "intent": "The above constants are extensions and not present if they are not defined by the C library.", "question_id": 6769}
{"snippet": "os.O_SHLOCK", "intent": "The above constants are extensions and not present if they are not defined by the C library.", "question_id": 6770}
{"snippet": "os.O_EXLOCK", "intent": "The above constants are extensions and not present if they are not defined by the C library.", "question_id": 6771}
{"snippet": "os.openpty()", "intent": "Open a new pseudo-terminal pair .", "question_id": 6772}
{"snippet": "os.pipe()", "intent": "Create a pipe .", "question_id": 6773}
{"snippet": "os.pipe2(flags)", "intent": "Create a pipe with `flags` set atomically .", "question_id": 6774}
{"snippet": "os.posix_fallocate(fd, offset, len)", "intent": "Ensures that enough disk space is allocated for the file specified by `fd` starting from `offset` and continuing for `len` bytes .", "question_id": 6775}
{"snippet": "os.posix_fadvise(fd, offset, len, advice)", "intent": "Announces an intention to access data in a specific pattern thus allowing the kernel to make optimizations . The `advice` applies to the region of the file specified by `fd` starting at `offset` and continuing for `len` bytes .", "question_id": 6776}
{"snippet": "os.POSIX_FADV_NORMAL", "intent": "Flags that can be used in advice in posix_fadvise() that specify the access pattern that is likely to be used.", "question_id": 6777}
{"snippet": "os.POSIX_FADV_SEQUENTIAL", "intent": "Flags that can be used in advice in posix_fadvise() that specify the access pattern that is likely to be used.", "question_id": 6778}
{"snippet": "os.POSIX_FADV_RANDOM", "intent": "Flags that can be used in advice in posix_fadvise() that specify the access pattern that is likely to be used.", "question_id": 6779}
{"snippet": "os.POSIX_FADV_NOREUSE", "intent": "Flags that can be used in advice in posix_fadvise() that specify the access pattern that is likely to be used.", "question_id": 6780}
{"snippet": "os.POSIX_FADV_WILLNEED", "intent": "Flags that can be used in advice in posix_fadvise() that specify the access pattern that is likely to be used.", "question_id": 6781}
{"snippet": "os.POSIX_FADV_DONTNEED", "intent": "Flags that can be used in advice in posix_fadvise() that specify the access pattern that is likely to be used.", "question_id": 6782}
{"snippet": "os.pread(fd, n, offset)", "intent": "Read at most `n` bytes from file descriptor `fd` at a position of `offset` , leaving the file offset unchanged .", "question_id": 6783}
{"snippet": "os.preadv(fd, buffers, offset)", "intent": "Read from a file descriptor `fd` at a position of `offset` into mutable bytes-like objects `buffers` , leaving the file offset unchanged .", "question_id": 6784}
{"snippet": "os.preadv(fd, buffers, offset, flags=0)", "intent": "Read from a file descriptor `fd` at a position of `offset` into mutable bytes-like objects `buffers` , leaving the file offset unchanged . The `flags` argument contains a bitwise OR of zero or more of the following flags :", "question_id": 6785}
{"snippet": "os.RWF_NOWAIT", "intent": "Do not wait for data which is not immediately available.", "question_id": 6786}
{"snippet": "os.RWF_HIPRI", "intent": "High priority read/write.", "question_id": 6787}
{"snippet": "os.pwrite(fd, str, offset)", "intent": "Write the bytestring in `str` to file descriptor `fd` at position of `offset` , leaving the file offset unchanged .", "question_id": 6788}
{"snippet": "os.pwritev(fd, buffers, offset)", "intent": "Write the `buffers` contents to file descriptor `fd` at a `offset` offset , leaving the file offset unchanged .", "question_id": 6789}
{"snippet": "os.pwritev(fd, buffers, offset, flags=0)", "intent": "Write the `buffers` contents to file descriptor `fd` at a `offset` offset , leaving the file offset unchanged . The `flags` argument contains a bitwise OR of zero or more of the following flags :", "question_id": 6790}
{"snippet": "os.RWF_DSYNC", "intent": "Provide a per-write equivalent of the O_DSYNC open(2) flag.", "question_id": 6791}
{"snippet": "os.RWF_SYNC", "intent": "Provide a per-write equivalent of the O_SYNC open(2) flag.", "question_id": 6792}
{"snippet": "os.read(fd, n)", "intent": "Read at most `n` bytes from file descriptor `fd` .", "question_id": 6793}
{"snippet": "os.sendfile(out, in, offset, count)", "intent": "Copy `count` bytes from file descriptor `in` to file descriptor `out` starting at `offset` .", "question_id": 6794}
{"snippet": "os.sendfile(out, in, offset, count, headers, trailers)", "intent": "Copy `count` bytes from file descriptor `in` to file descriptor `out` starting at `offset` . The second case may be used on Mac OS X and FreeBSD where `headers` and `trailers` are arbitrary sequences of buffers that are written before and after the data from in is written .", "question_id": 6795}
{"snippet": "os.sendfile(out, in, offset, count, headers, trailers, flags=0)", "intent": "Copy `count` bytes from file descriptor `in` to file descriptor `out` starting at `offset` . The second case may be used on Mac OS X and FreeBSD where `headers` and `trailers` are arbitrary sequences of buffers that are written before and after the data from in is written . Cross-platform applications should not use headers , trailers and `flags` arguments .", "question_id": 6796}
{"snippet": "os.sendfile(out, in, offset, count, headers)", "intent": "Copy `count` bytes from file descriptor `in` to file descriptor `out` starting at `offset` . The second case may be used on Mac OS X and FreeBSD where `headers` and `trailers` are arbitrary sequences of buffers that are written before and after the data from in is written .", "question_id": 6797}
{"snippet": "os.sendfile(out, in, offset, count, headers, flags=0)", "intent": "Copy `count` bytes from file descriptor `in` to file descriptor `out` starting at `offset` . The second case may be used on Mac OS X and FreeBSD where `headers` and `trailers` are arbitrary sequences of buffers that are written before and after the data from in is written . Cross-platform applications should not use headers , trailers and `flags` arguments .", "question_id": 6798}
{"snippet": "os.sendfile(out, in, offset, count)", "intent": "Copy `count` bytes from file descriptor `in` to file descriptor `out` starting at `offset` .", "question_id": 6799}
{"snippet": "os.sendfile(out, in, offset, count, flags=0)", "intent": "Copy `count` bytes from file descriptor `in` to file descriptor `out` starting at `offset` . Cross-platform applications should not use headers , trailers and `flags` arguments .", "question_id": 6800}
{"snippet": "os.set_blocking(fd, blocking)", "intent": "Set the `blocking` mode of the specified file descriptor . With arguments `fd`.", "question_id": 6801}
{"snippet": "os.SF_NODISKIO", "intent": "Parameters to the sendfile() function, if the implementation supports them.", "question_id": 6802}
{"snippet": "os.SF_MNOWAIT", "intent": "Parameters to the sendfile() function, if the implementation supports them.", "question_id": 6803}
{"snippet": "os.SF_SYNC", "intent": "Parameters to the sendfile() function, if the implementation supports them.", "question_id": 6804}
{"snippet": "os.readv(fd, buffers)", "intent": "Read from a file descriptor `fd` into a number of mutable bytes-like objects `buffers` .", "question_id": 6805}
{"snippet": "os.tcgetpgrp(fd)", "intent": "Return the process group associated with the terminal given by `fd` ( an open file descriptor as returned by os.open ( ) ) .", "question_id": 6806}
{"snippet": "os.tcsetpgrp(fd, pg)", "intent": "Set the process group associated with the terminal given by `fd` ( an open file descriptor as returned by os.open ( ) ) to `pg` .", "question_id": 6807}
{"snippet": "os.ttyname(fd)", "intent": "Return a string which specifies the terminal device associated with file descriptor `fd` .", "question_id": 6808}
{"snippet": "os.write(fd, str)", "intent": "Write the bytestring in `str` to file descriptor `fd` .", "question_id": 6809}
{"snippet": "os.writev(fd, buffers)", "intent": "Write the contents of `buffers` to file descriptor `fd` .", "question_id": 6810}
{"snippet": "os.get_terminal_size()", "intent": "Return the size of the terminal window as ( columns , lines ) , tuple of type terminal_size .", "question_id": 6811}
{"snippet": "os.get_terminal_size(fd=STDOUT_FILENO)", "intent": "Return the size of the terminal window as ( columns , lines ) , tuple of type terminal_size . The optional argument `fd` ( default STDOUT_FILENO , or standard output ) specifies which file descriptor should be queried .", "question_id": 6812}
{"snippet": "os.terminal_size", "intent": "A subclass of tuple, holding (columns, lines) of the terminal window size.", "question_id": 6813}
{"snippet": "terminal_size.columns", "intent": "Width of the terminal window in characters.", "question_id": 6814}
{"snippet": "terminal_size.lines", "intent": "Height of the terminal window in characters.", "question_id": 6815}
{"snippet": "os.get_inheritable(fd)", "intent": "Get the \u201c inheritable \u201d flag of the specified file descriptor ( a boolean ) . With arguments `fd`.", "question_id": 6816}
{"snippet": "os.set_inheritable(fd, inheritable)", "intent": "Set the \u201c `inheritable` \u201d flag of the specified file descriptor . With arguments `fd`.", "question_id": 6817}
{"snippet": "os.get_handle_inheritable(handle)", "intent": "Get the \u201c inheritable \u201d flag of the specified `handle` ( a boolean ) .", "question_id": 6818}
{"snippet": "os.set_handle_inheritable(handle, inheritable)", "intent": "Set the \u201c `inheritable` \u201d flag of the specified `handle` .", "question_id": 6819}
{"snippet": "os.access(path, mode)", "intent": "Use the real uid/gid to test for access to `path` . `mode` should be F_OK to test the existence of path , or it can be the inclusive OR of one or more of R_OK , W_OK , and X_OK to test permissions .", "question_id": 6820}
{"snippet": "os.access(path, mode, dir_fd=None)", "intent": "Use the real uid/gid to test for access to `path` . `mode` should be F_OK to test the existence of path , or it can be the inclusive OR of one or more of R_OK , W_OK , and X_OK to test permissions . With arguments `dir_fd`.", "question_id": 6821}
{"snippet": "os.access(path, mode, effective_ids=False)", "intent": "Use the real uid/gid to test for access to `path` . `mode` should be F_OK to test the existence of path , or it can be the inclusive OR of one or more of R_OK , W_OK , and X_OK to test permissions . If `effective_ids` is True , access ( ) will perform its access checks using the effective uid/gid instead of the real uid/gid .", "question_id": 6822}
{"snippet": "os.access(path, mode, follow_symlinks=True)", "intent": "Use the real uid/gid to test for access to `path` . `mode` should be F_OK to test the existence of path , or it can be the inclusive OR of one or more of R_OK , W_OK , and X_OK to test permissions . With arguments `follow_symlinks`.", "question_id": 6823}
{"snippet": "os.access(path, mode, dir_fd=None, effective_ids=False)", "intent": "Use the real uid/gid to test for access to `path` . `mode` should be F_OK to test the existence of path , or it can be the inclusive OR of one or more of R_OK , W_OK , and X_OK to test permissions . If `effective_ids` is True , access ( ) will perform its access checks using the effective uid/gid instead of the real uid/gid . With arguments `dir_fd`.", "question_id": 6824}
{"snippet": "os.access(path, mode, dir_fd=None, follow_symlinks=True)", "intent": "Use the real uid/gid to test for access to `path` . `mode` should be F_OK to test the existence of path , or it can be the inclusive OR of one or more of R_OK , W_OK , and X_OK to test permissions . With arguments `dir_fd`, `follow_symlinks`.", "question_id": 6825}
{"snippet": "os.access(path, mode, effective_ids=False, follow_symlinks=True)", "intent": "Use the real uid/gid to test for access to `path` . `mode` should be F_OK to test the existence of path , or it can be the inclusive OR of one or more of R_OK , W_OK , and X_OK to test permissions . If `effective_ids` is True , access ( ) will perform its access checks using the effective uid/gid instead of the real uid/gid . With arguments `follow_symlinks`.", "question_id": 6826}
{"snippet": "os.access(path, mode, dir_fd=None, effective_ids=False, follow_symlinks=True)", "intent": "Use the real uid/gid to test for access to `path` . `mode` should be F_OK to test the existence of path , or it can be the inclusive OR of one or more of R_OK , W_OK , and X_OK to test permissions . If `effective_ids` is True , access ( ) will perform its access checks using the effective uid/gid instead of the real uid/gid . With arguments `dir_fd`, `follow_symlinks`.", "question_id": 6827}
{"snippet": "os.F_OK", "intent": "Values to pass as the mode parameter of access() to test the existence, readability, writability and executability of path, respectively.", "question_id": 6828}
{"snippet": "os.R_OK", "intent": "Values to pass as the mode parameter of access() to test the existence, readability, writability and executability of path, respectively.", "question_id": 6829}
{"snippet": "os.W_OK", "intent": "Values to pass as the mode parameter of access() to test the existence, readability, writability and executability of path, respectively.", "question_id": 6830}
{"snippet": "os.X_OK", "intent": "Values to pass as the mode parameter of access() to test the existence, readability, writability and executability of path, respectively.", "question_id": 6831}
{"snippet": "os.chdir(path)", "intent": "Change the current working directory to `path` .", "question_id": 6832}
{"snippet": "os.chflags(path, flags)", "intent": "Set the `flags` of `path` to the numeric flags .", "question_id": 6833}
{"snippet": "os.chflags(path, flags, follow_symlinks=True)", "intent": "Set the `flags` of `path` to the numeric flags . With arguments `follow_symlinks`.", "question_id": 6834}
{"snippet": "os.chmod(path, mode)", "intent": "Change the `mode` of `path` to the numeric mode .", "question_id": 6835}
{"snippet": "os.chmod(path, mode, dir_fd=None)", "intent": "Change the `mode` of `path` to the numeric mode . With arguments `dir_fd`.", "question_id": 6836}
{"snippet": "os.chmod(path, mode, follow_symlinks=True)", "intent": "Change the `mode` of `path` to the numeric mode . With arguments `follow_symlinks`.", "question_id": 6837}
{"snippet": "os.chmod(path, mode, dir_fd=None, follow_symlinks=True)", "intent": "Change the `mode` of `path` to the numeric mode . With arguments `dir_fd`, `follow_symlinks`.", "question_id": 6838}
{"snippet": "os.chown(path, uid, gid)", "intent": "Change the owner and group id of `path` to the numeric `uid` and `gid` .", "question_id": 6839}
{"snippet": "os.chown(path, uid, gid, dir_fd=None)", "intent": "Change the owner and group id of `path` to the numeric `uid` and `gid` . With arguments `dir_fd`.", "question_id": 6840}
{"snippet": "os.chown(path, uid, gid, follow_symlinks=True)", "intent": "Change the owner and group id of `path` to the numeric `uid` and `gid` . With arguments `follow_symlinks`.", "question_id": 6841}
{"snippet": "os.chown(path, uid, gid, dir_fd=None, follow_symlinks=True)", "intent": "Change the owner and group id of `path` to the numeric `uid` and `gid` . With arguments `dir_fd`, `follow_symlinks`.", "question_id": 6842}
{"snippet": "os.chroot(path)", "intent": "Change the root directory of the current process to `path` .", "question_id": 6843}
{"snippet": "os.fchdir(fd)", "intent": "Change the current working directory to the directory represented by the file descriptor `fd` .", "question_id": 6844}
{"snippet": "os.getcwd()", "intent": "Return a string representing the current working directory .", "question_id": 6845}
{"snippet": "os.getcwdb()", "intent": "Return a bytestring representing the current working directory .", "question_id": 6846}
{"snippet": "os.lchflags(path, flags)", "intent": "Set the `flags` of `path` to the numeric flags , like chflags ( ) , but do not follow symbolic links .", "question_id": 6847}
{"snippet": "os.lchmod(path, mode)", "intent": "Change the `mode` of `path` to the numeric mode .", "question_id": 6848}
{"snippet": "os.lchown(path, uid, gid)", "intent": "Change the owner and group id of `path` to the numeric `uid` and `gid` .", "question_id": 6849}
{"snippet": "os.link(src, dst)", "intent": "Create a hard link pointing to `src` named `dst` .", "question_id": 6850}
{"snippet": "os.link(src, dst, src_dir_fd=None)", "intent": "Create a hard link pointing to `src` named `dst` . This function can support specifying `src_dir_fd` and/or `dst_dir_fd` to supply paths relative to directory descriptors , and not following symlinks .", "question_id": 6851}
{"snippet": "os.link(src, dst, dst_dir_fd=None)", "intent": "Create a hard link pointing to `src` named `dst` . This function can support specifying `src_dir_fd` and/or `dst_dir_fd` to supply paths relative to directory descriptors , and not following symlinks .", "question_id": 6852}
{"snippet": "os.link(src, dst, follow_symlinks=True)", "intent": "Create a hard link pointing to `src` named `dst` . With arguments `follow_symlinks`.", "question_id": 6853}
{"snippet": "os.link(src, dst, src_dir_fd=None, dst_dir_fd=None)", "intent": "Create a hard link pointing to `src` named `dst` . This function can support specifying `src_dir_fd` and/or `dst_dir_fd` to supply paths relative to directory descriptors , and not following symlinks .", "question_id": 6854}
{"snippet": "os.link(src, dst, src_dir_fd=None, follow_symlinks=True)", "intent": "Create a hard link pointing to `src` named `dst` . This function can support specifying `src_dir_fd` and/or `dst_dir_fd` to supply paths relative to directory descriptors , and not following symlinks . With arguments `follow_symlinks`.", "question_id": 6855}
{"snippet": "os.link(src, dst, dst_dir_fd=None, follow_symlinks=True)", "intent": "Create a hard link pointing to `src` named `dst` . This function can support specifying `src_dir_fd` and/or `dst_dir_fd` to supply paths relative to directory descriptors , and not following symlinks . With arguments `follow_symlinks`.", "question_id": 6856}
{"snippet": "os.link(src, dst, src_dir_fd=None, dst_dir_fd=None, follow_symlinks=True)", "intent": "Create a hard link pointing to `src` named `dst` . This function can support specifying `src_dir_fd` and/or `dst_dir_fd` to supply paths relative to directory descriptors , and not following symlinks . With arguments `follow_symlinks`.", "question_id": 6857}
{"snippet": "os.listdir()", "intent": "Return a list containing the names of the entries in the directory given by `path` .", "question_id": 6858}
{"snippet": "os.listdir(path='.')", "intent": "Return a list containing the names of the entries in the directory given by `path` .", "question_id": 6859}
{"snippet": "os.lstat(path)", "intent": "Perform the equivalent of an lstat ( ) system call on the given `path` .", "question_id": 6860}
{"snippet": "os.lstat(path, dir_fd=None)", "intent": "Perform the equivalent of an lstat ( ) system call on the given `path` . With arguments `dir_fd`.", "question_id": 6861}
{"snippet": "os.mkdir(path)", "intent": "Create a directory named `path` with numeric `mode` mode .", "question_id": 6862}
{"snippet": "os.mkdir(path, mode=0o777)", "intent": "Create a directory named `path` with numeric `mode` mode .", "question_id": 6863}
{"snippet": "os.mkdir(path, dir_fd=None)", "intent": "Create a directory named `path` with numeric `mode` mode . With arguments `dir_fd`.", "question_id": 6864}
{"snippet": "os.mkdir(path, mode=0o777, dir_fd=None)", "intent": "Create a directory named `path` with numeric `mode` mode . With arguments `dir_fd`.", "question_id": 6865}
{"snippet": "os.makedirs(name)", "intent": "Recursive directory creation function . With arguments `name`.", "question_id": 6866}
{"snippet": "os.makedirs(name, mode=0o777)", "intent": "Recursive directory creation function . The `mode` parameter is passed to mkdir ( ) for creating the leaf directory ; see the mkdir ( ) description for how it is interpreted . With arguments `name`.", "question_id": 6867}
{"snippet": "os.makedirs(name, exist_ok=False)", "intent": "Recursive directory creation function . If `exist_ok` is False ( the default ) , an FileExistsError is raised if the target directory already exists . With arguments `name`.", "question_id": 6868}
{"snippet": "os.makedirs(name, mode=0o777, exist_ok=False)", "intent": "Recursive directory creation function . The `mode` parameter is passed to mkdir ( ) for creating the leaf directory ; see the mkdir ( ) description for how it is interpreted . If `exist_ok` is False ( the default ) , an FileExistsError is raised if the target directory already exists . With arguments `name`.", "question_id": 6869}
{"snippet": "os.mkfifo(path)", "intent": "Create a FIFO ( a named pipe ) named `path` with numeric `mode` mode .", "question_id": 6870}
{"snippet": "os.mkfifo(path, mode=0o666)", "intent": "Create a FIFO ( a named pipe ) named `path` with numeric `mode` mode .", "question_id": 6871}
{"snippet": "os.mkfifo(path, dir_fd=None)", "intent": "Create a FIFO ( a named pipe ) named `path` with numeric `mode` mode . With arguments `dir_fd`.", "question_id": 6872}
{"snippet": "os.mkfifo(path, mode=0o666, dir_fd=None)", "intent": "Create a FIFO ( a named pipe ) named `path` with numeric `mode` mode . With arguments `dir_fd`.", "question_id": 6873}
{"snippet": "os.mknod(path)", "intent": "Create a filesystem node ( file , `device` special file or named pipe ) named `path` .", "question_id": 6874}
{"snippet": "os.mknod(path, mode=0o600)", "intent": "Create a filesystem node ( file , `device` special file or named pipe ) named `path` . `mode` specifies both the permissions to use and the type of node to be created , being combined ( bitwise OR ) with one of stat.S_IFREG , stat.S_IFCHR , stat.S_IFBLK , and stat.S_IFIFO ( those constants are available in stat ) .", "question_id": 6875}
{"snippet": "os.mknod(path, device=0)", "intent": "Create a filesystem node ( file , `device` special file or named pipe ) named `path` .", "question_id": 6876}
{"snippet": "os.mknod(path, dir_fd=None)", "intent": "Create a filesystem node ( file , `device` special file or named pipe ) named `path` . With arguments `dir_fd`.", "question_id": 6877}
{"snippet": "os.mknod(path, mode=0o600, device=0)", "intent": "Create a filesystem node ( file , `device` special file or named pipe ) named `path` . `mode` specifies both the permissions to use and the type of node to be created , being combined ( bitwise OR ) with one of stat.S_IFREG , stat.S_IFCHR , stat.S_IFBLK , and stat.S_IFIFO ( those constants are available in stat ) .", "question_id": 6878}
{"snippet": "os.mknod(path, mode=0o600, dir_fd=None)", "intent": "Create a filesystem node ( file , `device` special file or named pipe ) named `path` . `mode` specifies both the permissions to use and the type of node to be created , being combined ( bitwise OR ) with one of stat.S_IFREG , stat.S_IFCHR , stat.S_IFBLK , and stat.S_IFIFO ( those constants are available in stat ) . With arguments `dir_fd`.", "question_id": 6879}
{"snippet": "os.mknod(path, device=0, dir_fd=None)", "intent": "Create a filesystem node ( file , `device` special file or named pipe ) named `path` . With arguments `dir_fd`.", "question_id": 6880}
{"snippet": "os.mknod(path, mode=0o600, device=0, dir_fd=None)", "intent": "Create a filesystem node ( file , `device` special file or named pipe ) named `path` . `mode` specifies both the permissions to use and the type of node to be created , being combined ( bitwise OR ) with one of stat.S_IFREG , stat.S_IFCHR , stat.S_IFBLK , and stat.S_IFIFO ( those constants are available in stat ) . With arguments `dir_fd`.", "question_id": 6881}
{"snippet": "os.major(device)", "intent": "Extract the `device` major number from a raw device number ( usually the st_dev or st_rdev field from stat ) .", "question_id": 6882}
{"snippet": "os.minor(device)", "intent": "Extract the `device` minor number from a raw device number ( usually the st_dev or st_rdev field from stat ) .", "question_id": 6883}
{"snippet": "os.makedev(major, minor)", "intent": "Compose a raw device number from the `major` and `minor` device numbers .", "question_id": 6884}
{"snippet": "os.pathconf(path, name)", "intent": "Return system configuration information relevant to a named file . `name` specifies the configuration value to retrieve ; it may be a string which is the name of a defined system value ; these names are specified in a number of standards ( POSIX.1 , Unix 95 , Unix 98 , and others ) . With arguments `path`.", "question_id": 6885}
{"snippet": "os.pathconf_names", "intent": "Dictionary mapping names accepted by pathconf() and fpathconf() to the integer values defined for those names by the host operating system.", "question_id": 6886}
{"snippet": "os.readlink(path)", "intent": "Return a string representing the `path` to which the symbolic link points .", "question_id": 6887}
{"snippet": "os.readlink(path, dir_fd=None)", "intent": "Return a string representing the `path` to which the symbolic link points . With arguments `dir_fd`.", "question_id": 6888}
{"snippet": "os.remove(path)", "intent": "Remove ( delete ) the file `path` .", "question_id": 6889}
{"snippet": "os.remove(path, dir_fd=None)", "intent": "Remove ( delete ) the file `path` . With arguments `dir_fd`.", "question_id": 6890}
{"snippet": "os.removedirs(name)", "intent": "Remove directories recursively . With arguments `name`.", "question_id": 6891}
{"snippet": "os.rename(src, dst)", "intent": "Rename the file or directory `src` to `dst` .", "question_id": 6892}
{"snippet": "os.rename(src, dst, src_dir_fd=None)", "intent": "Rename the file or directory `src` to `dst` . This function can support specifying `src_dir_fd` and/or `dst_dir_fd` to supply paths relative to directory descriptors .", "question_id": 6893}
{"snippet": "os.rename(src, dst, dst_dir_fd=None)", "intent": "Rename the file or directory `src` to `dst` . This function can support specifying `src_dir_fd` and/or `dst_dir_fd` to supply paths relative to directory descriptors .", "question_id": 6894}
{"snippet": "os.rename(src, dst, src_dir_fd=None, dst_dir_fd=None)", "intent": "Rename the file or directory `src` to `dst` . This function can support specifying `src_dir_fd` and/or `dst_dir_fd` to supply paths relative to directory descriptors .", "question_id": 6895}
{"snippet": "os.renames(old, new)", "intent": "Recursive directory or file renaming function . After the rename , directories corresponding to rightmost path segments of the `old` name will be pruned away using removedirs ( ) . Works like rename ( ) , except creation of any intermediate directories needed to make the `new` pathname good is attempted first .", "question_id": 6896}
{"snippet": "os.replace(src, dst)", "intent": "Rename the file or directory `src` to `dst` .", "question_id": 6897}
{"snippet": "os.replace(src, dst, src_dir_fd=None)", "intent": "Rename the file or directory `src` to `dst` . This function can support specifying `src_dir_fd` and/or `dst_dir_fd` to supply paths relative to directory descriptors .", "question_id": 6898}
{"snippet": "os.replace(src, dst, dst_dir_fd=None)", "intent": "Rename the file or directory `src` to `dst` . This function can support specifying `src_dir_fd` and/or `dst_dir_fd` to supply paths relative to directory descriptors .", "question_id": 6899}
{"snippet": "os.replace(src, dst, src_dir_fd=None, dst_dir_fd=None)", "intent": "Rename the file or directory `src` to `dst` . This function can support specifying `src_dir_fd` and/or `dst_dir_fd` to supply paths relative to directory descriptors .", "question_id": 6900}
{"snippet": "os.rmdir(path)", "intent": "Remove ( delete ) the directory `path` .", "question_id": 6901}
{"snippet": "os.rmdir(path, dir_fd=None)", "intent": "Remove ( delete ) the directory `path` . With arguments `dir_fd`.", "question_id": 6902}
{"snippet": "os.scandir()", "intent": "Return an iterator of os.DirEntry objects corresponding to the entries in the directory given by `path` .", "question_id": 6903}
{"snippet": "os.scandir(path='.')", "intent": "Return an iterator of os.DirEntry objects corresponding to the entries in the directory given by `path` .", "question_id": 6904}
{"snippet": "scandir.close()", "intent": "Close the iterator and free acquired resources .", "question_id": 6905}
{"snippet": "os.DirEntry", "intent": "Object yielded by scandir() to expose the file path and other file attributes of a directory entry.", "question_id": 6906}
{"snippet": "dir_entry.name", "intent": "The entry\u2019s base filename, relative to the scandir() path argument.", "question_id": 6907}
{"snippet": "dir_entry.path", "intent": "The entry\u2019s full path name: equivalent to os.path.join(scandir_path, entry.name) where scandir_path is the scandir() path argument.", "question_id": 6908}
{"snippet": "dir_entry.inode()", "intent": "Return the inode number of the entry .", "question_id": 6909}
{"snippet": "dir_entry.is_dir()", "intent": "Return True if this entry is a directory or a symbolic link pointing to a directory ; return False if the entry is or points to any other kind of file , or if it doesn \u2019 t exist anymore .", "question_id": 6910}
{"snippet": "dir_entry.is_dir(follow_symlinks=True)", "intent": "Return True if this entry is a directory or a symbolic link pointing to a directory ; return False if the entry is or points to any other kind of file , or if it doesn \u2019 t exist anymore . If `follow_symlinks` is False , return True only if this entry is a directory ( without following symlinks ) ; return False if the entry is any other kind of file or if it doesn \u2019 t exist anymore .", "question_id": 6911}
{"snippet": "dir_entry.is_file()", "intent": "Return True if this entry is a file or a symbolic link pointing to a file ; return False if the entry is or points to a directory or other non-file entry , or if it doesn \u2019 t exist anymore .", "question_id": 6912}
{"snippet": "dir_entry.is_file(follow_symlinks=True)", "intent": "Return True if this entry is a file or a symbolic link pointing to a file ; return False if the entry is or points to a directory or other non-file entry , or if it doesn \u2019 t exist anymore . If `follow_symlinks` is False , return True only if this entry is a file ( without following symlinks ) ; return False if the entry is a directory or other non-file entry , or if it doesn \u2019 t exist anymore .", "question_id": 6913}
{"snippet": "dir_entry.is_symlink()", "intent": "Return True if this entry is a symbolic link ( even if broken ) ; return False if the entry points to a directory or any kind of file , or if it doesn \u2019 t exist anymore .", "question_id": 6914}
{"snippet": "dir_entry.stat()", "intent": "Return a stat_result object for this entry .", "question_id": 6915}
{"snippet": "dir_entry.stat(follow_symlinks=True)", "intent": "Return a stat_result object for this entry . On Windows , it only requires a system call if `follow_symlinks` is True and the entry is a symbolic link .", "question_id": 6916}
{"snippet": "os.stat(path)", "intent": "Get the status of a file or a file descriptor . Perform the equivalent of a stat ( ) system call on the given `path` .", "question_id": 6917}
{"snippet": "os.stat(path, dir_fd=None)", "intent": "Get the status of a file or a file descriptor . Perform the equivalent of a stat ( ) system call on the given `path` . With arguments `dir_fd`.", "question_id": 6918}
{"snippet": "os.stat(path, follow_symlinks=True)", "intent": "Get the status of a file or a file descriptor . Perform the equivalent of a stat ( ) system call on the given `path` . With arguments `follow_symlinks`.", "question_id": 6919}
{"snippet": "os.stat(path, dir_fd=None, follow_symlinks=True)", "intent": "Get the status of a file or a file descriptor . Perform the equivalent of a stat ( ) system call on the given `path` . With arguments `dir_fd`, `follow_symlinks`.", "question_id": 6920}
{"snippet": "os.stat_result", "intent": "Object whose attributes correspond roughly to the members of the stat structure.", "question_id": 6921}
{"snippet": "stat_result.st_mode", "intent": "File mode: file type and file mode bits (permissions).", "question_id": 6922}
{"snippet": "stat_result.st_ino", "intent": "Platform dependent, but if non-zero, uniquely identifies the file for a given value of st_dev.", "question_id": 6923}
{"snippet": "stat_result.st_dev", "intent": "Identifier of the device on which this file resides.", "question_id": 6924}
{"snippet": "stat_result.st_nlink", "intent": "Number of hard links.", "question_id": 6925}
{"snippet": "stat_result.st_uid", "intent": "User identifier of the file owner.", "question_id": 6926}
{"snippet": "stat_result.st_gid", "intent": "Group identifier of the file owner.", "question_id": 6927}
{"snippet": "stat_result.st_size", "intent": "Size of the file in bytes, if it is a regular file or a symbolic link.", "question_id": 6928}
{"snippet": "stat_result.st_atime", "intent": "Time of most recent access expressed in seconds.", "question_id": 6929}
{"snippet": "stat_result.st_mtime", "intent": "Time of most recent content modification expressed in seconds.", "question_id": 6930}
{"snippet": "stat_result.st_ctime", "intent": "Platform dependent:", "question_id": 6931}
{"snippet": "stat_result.st_atime_ns", "intent": "Time of most recent access expressed in nanoseconds as an integer.", "question_id": 6932}
{"snippet": "stat_result.st_mtime_ns", "intent": "Time of most recent content modification expressed in nanoseconds as an integer.", "question_id": 6933}
{"snippet": "stat_result.st_ctime_ns", "intent": "Platform dependent:", "question_id": 6934}
{"snippet": "stat_result.st_blocks", "intent": "Number of 512-byte blocks allocated for file.", "question_id": 6935}
{"snippet": "stat_result.st_blksize", "intent": "\u201cPreferred\u201d blocksize for efficient file system I/O.", "question_id": 6936}
{"snippet": "stat_result.st_rdev", "intent": "Type of device if an inode device.", "question_id": 6937}
{"snippet": "stat_result.st_flags", "intent": "User defined flags for file.", "question_id": 6938}
{"snippet": "stat_result.st_gen", "intent": "File generation number.", "question_id": 6939}
{"snippet": "stat_result.st_birthtime", "intent": "Time of file creation.", "question_id": 6940}
{"snippet": "stat_result.st_fstype", "intent": "String that uniquely identifies the type of the filesystem that contains the file.", "question_id": 6941}
{"snippet": "stat_result.st_rsize", "intent": "Real size of the file.", "question_id": 6942}
{"snippet": "stat_result.st_creator", "intent": "Creator of the file.", "question_id": 6943}
{"snippet": "stat_result.st_type", "intent": "File type.", "question_id": 6944}
{"snippet": "stat_result.st_file_attributes", "intent": "Windows file attributes: dwFileAttributes member of the BY_HANDLE_FILE_INFORMATION structure returned by GetFileInformationByHandle().", "question_id": 6945}
{"snippet": "os.statvfs(path)", "intent": "Perform a statvfs ( ) system call on the given `path` .", "question_id": 6946}
{"snippet": "os.supports_dir_fd", "intent": "A Set object indicating which functions in the os module permit use of their dir_fd parameter.", "question_id": 6947}
{"snippet": "os.supports_effective_ids", "intent": "A Set object indicating which functions in the os module permit use of the effective_ids parameter for os.access().", "question_id": 6948}
{"snippet": "os.supports_fd", "intent": "A Set object indicating which functions in the os module permit specifying their path parameter as an open file descriptor.", "question_id": 6949}
{"snippet": "os.supports_follow_symlinks", "intent": "A Set object indicating which functions in the os module permit use of their follow_symlinks parameter.", "question_id": 6950}
{"snippet": "os.symlink(src, dst)", "intent": "Create a symbolic link pointing to `src` named `dst` .", "question_id": 6951}
{"snippet": "os.symlink(src, dst, target_is_directory=False)", "intent": "Create a symbolic link pointing to `src` named `dst` . Otherwise , the symlink will be created as a directory if `target_is_directory` is True or a file symlink ( the default ) otherwise .", "question_id": 6952}
{"snippet": "os.symlink(src, dst, dir_fd=None)", "intent": "Create a symbolic link pointing to `src` named `dst` . With arguments `dir_fd`.", "question_id": 6953}
{"snippet": "os.symlink(src, dst, target_is_directory=False, dir_fd=None)", "intent": "Create a symbolic link pointing to `src` named `dst` . Otherwise , the symlink will be created as a directory if `target_is_directory` is True or a file symlink ( the default ) otherwise . With arguments `dir_fd`.", "question_id": 6954}
{"snippet": "os.sync()", "intent": "Force write of everything to disk .", "question_id": 6955}
{"snippet": "os.truncate(path, length)", "intent": "Truncate the file corresponding to `path` , so that it is at most `length` bytes in size .", "question_id": 6956}
{"snippet": "os.unlink(path)", "intent": "Remove ( delete ) the file `path` .", "question_id": 6957}
{"snippet": "os.unlink(path, dir_fd=None)", "intent": "Remove ( delete ) the file `path` . With arguments `dir_fd`.", "question_id": 6958}
{"snippet": "os.utime(path, ns)", "intent": "Set the access and modified `times` of the file specified by `path` . utime ( ) takes two optional parameters , times and `ns` .", "question_id": 6959}
{"snippet": "os.utime(path, ns, times=None)", "intent": "Set the access and modified `times` of the file specified by `path` . utime ( ) takes two optional parameters , times and `ns` .", "question_id": 6960}
{"snippet": "os.utime(path, ns, dir_fd=None)", "intent": "Set the access and modified `times` of the file specified by `path` . utime ( ) takes two optional parameters , times and `ns` . With arguments `dir_fd`.", "question_id": 6961}
{"snippet": "os.utime(path, ns, follow_symlinks=True)", "intent": "Set the access and modified `times` of the file specified by `path` . utime ( ) takes two optional parameters , times and `ns` . With arguments `follow_symlinks`.", "question_id": 6962}
{"snippet": "os.utime(path, ns, times=None, dir_fd=None)", "intent": "Set the access and modified `times` of the file specified by `path` . utime ( ) takes two optional parameters , times and `ns` . With arguments `dir_fd`.", "question_id": 6963}
{"snippet": "os.utime(path, ns, times=None, follow_symlinks=True)", "intent": "Set the access and modified `times` of the file specified by `path` . utime ( ) takes two optional parameters , times and `ns` . With arguments `follow_symlinks`.", "question_id": 6964}
{"snippet": "os.utime(path, ns, dir_fd=None, follow_symlinks=True)", "intent": "Set the access and modified `times` of the file specified by `path` . utime ( ) takes two optional parameters , times and `ns` . With arguments `dir_fd`, `follow_symlinks`.", "question_id": 6965}
{"snippet": "os.utime(path, ns, times=None, dir_fd=None, follow_symlinks=True)", "intent": "Set the access and modified `times` of the file specified by `path` . utime ( ) takes two optional parameters , times and `ns` . With arguments `dir_fd`, `follow_symlinks`.", "question_id": 6966}
{"snippet": "os.utime(path)", "intent": "Set the access and modified `times` of the file specified by `path` .", "question_id": 6967}
{"snippet": "os.utime(path, times=None)", "intent": "Set the access and modified `times` of the file specified by `path` .", "question_id": 6968}
{"snippet": "os.utime(path, dir_fd=None)", "intent": "Set the access and modified `times` of the file specified by `path` . With arguments `dir_fd`.", "question_id": 6969}
{"snippet": "os.utime(path, follow_symlinks=True)", "intent": "Set the access and modified `times` of the file specified by `path` . With arguments `follow_symlinks`.", "question_id": 6970}
{"snippet": "os.utime(path, times=None, dir_fd=None)", "intent": "Set the access and modified `times` of the file specified by `path` . With arguments `dir_fd`.", "question_id": 6971}
{"snippet": "os.utime(path, times=None, follow_symlinks=True)", "intent": "Set the access and modified `times` of the file specified by `path` . With arguments `follow_symlinks`.", "question_id": 6972}
{"snippet": "os.utime(path, dir_fd=None, follow_symlinks=True)", "intent": "Set the access and modified `times` of the file specified by `path` . With arguments `dir_fd`, `follow_symlinks`.", "question_id": 6973}
{"snippet": "os.utime(path, times=None, dir_fd=None, follow_symlinks=True)", "intent": "Set the access and modified `times` of the file specified by `path` . With arguments `dir_fd`, `follow_symlinks`.", "question_id": 6974}
{"snippet": "os.walk(top)", "intent": "Generate the file names in a directory tree by walking the tree either top-down or bottom-up . For each directory in the tree rooted at directory `top` ( including top itself ) , it yields a 3-tuple ( dirpath , dirnames , filenames ) .", "question_id": 6975}
{"snippet": "os.walk(top, topdown=True)", "intent": "Generate the file names in a directory tree by walking the tree either top-down or bottom-up . For each directory in the tree rooted at directory `top` ( including top itself ) , it yields a 3-tuple ( dirpath , dirnames , filenames ) . If optional argument `topdown` is True or not specified , the triple for a directory is generated before the triples for any of its subdirectories ( directories are generated top-down ) .", "question_id": 6976}
{"snippet": "os.walk(top, onerror=None)", "intent": "Generate the file names in a directory tree by walking the tree either top-down or bottom-up . For each directory in the tree rooted at directory `top` ( including top itself ) , it yields a 3-tuple ( dirpath , dirnames , filenames ) . If optional argument `onerror` is specified , it should be a function ; it will be called with one argument , an OSError instance .", "question_id": 6977}
{"snippet": "os.walk(top, followlinks=False)", "intent": "Generate the file names in a directory tree by walking the tree either top-down or bottom-up . For each directory in the tree rooted at directory `top` ( including top itself ) , it yields a 3-tuple ( dirpath , dirnames , filenames ) . Set `followlinks` to True to visit directories pointed to by symlinks , on systems that support them .", "question_id": 6978}
{"snippet": "os.walk(top, topdown=True, onerror=None)", "intent": "Generate the file names in a directory tree by walking the tree either top-down or bottom-up . For each directory in the tree rooted at directory `top` ( including top itself ) , it yields a 3-tuple ( dirpath , dirnames , filenames ) . If optional argument `topdown` is True or not specified , the triple for a directory is generated before the triples for any of its subdirectories ( directories are generated top-down ) . If optional argument `onerror` is specified , it should be a function ; it will be called with one argument , an OSError instance .", "question_id": 6979}
{"snippet": "os.walk(top, topdown=True, followlinks=False)", "intent": "Generate the file names in a directory tree by walking the tree either top-down or bottom-up . For each directory in the tree rooted at directory `top` ( including top itself ) , it yields a 3-tuple ( dirpath , dirnames , filenames ) . If optional argument `topdown` is True or not specified , the triple for a directory is generated before the triples for any of its subdirectories ( directories are generated top-down ) . Set `followlinks` to True to visit directories pointed to by symlinks , on systems that support them .", "question_id": 6980}
{"snippet": "os.walk(top, onerror=None, followlinks=False)", "intent": "Generate the file names in a directory tree by walking the tree either top-down or bottom-up . For each directory in the tree rooted at directory `top` ( including top itself ) , it yields a 3-tuple ( dirpath , dirnames , filenames ) . If optional argument `onerror` is specified , it should be a function ; it will be called with one argument , an OSError instance . Set `followlinks` to True to visit directories pointed to by symlinks , on systems that support them .", "question_id": 6981}
{"snippet": "os.walk(top, topdown=True, onerror=None, followlinks=False)", "intent": "Generate the file names in a directory tree by walking the tree either top-down or bottom-up . For each directory in the tree rooted at directory `top` ( including top itself ) , it yields a 3-tuple ( dirpath , dirnames , filenames ) . If optional argument `topdown` is True or not specified , the triple for a directory is generated before the triples for any of its subdirectories ( directories are generated top-down ) . If optional argument `onerror` is specified , it should be a function ; it will be called with one argument , an OSError instance . Set `followlinks` to True to visit directories pointed to by symlinks , on systems that support them .", "question_id": 6982}
{"snippet": "os.fwalk()", "intent": "This behaves exactly like walk ( ) , except that it yields a 4-tuple ( dirpath , dirnames , filenames , dirfd ) , and it supports `dir_fd` .", "question_id": 6983}
{"snippet": "os.fwalk(top='.')", "intent": "This behaves exactly like walk ( ) , except that it yields a 4-tuple ( dirpath , dirnames , filenames , dirfd ) , and it supports `dir_fd` . With arguments `top`.", "question_id": 6984}
{"snippet": "os.fwalk(topdown=True)", "intent": "This behaves exactly like walk ( ) , except that it yields a 4-tuple ( dirpath , dirnames , filenames , dirfd ) , and it supports `dir_fd` . With arguments `topdown`.", "question_id": 6985}
{"snippet": "os.fwalk(onerror=None)", "intent": "This behaves exactly like walk ( ) , except that it yields a 4-tuple ( dirpath , dirnames , filenames , dirfd ) , and it supports `dir_fd` . With arguments `onerror`.", "question_id": 6986}
{"snippet": "os.fwalk(follow_symlinks=False)", "intent": "This behaves exactly like walk ( ) , except that it yields a 4-tuple ( dirpath , dirnames , filenames , dirfd ) , and it supports `dir_fd` . Note however that , unlike other functions , the fwalk ( ) default value for `follow_symlinks` is False .", "question_id": 6987}
{"snippet": "os.fwalk(dir_fd=None)", "intent": "This behaves exactly like walk ( ) , except that it yields a 4-tuple ( dirpath , dirnames , filenames , dirfd ) , and it supports `dir_fd` .", "question_id": 6988}
{"snippet": "os.fwalk(top='.', topdown=True)", "intent": "This behaves exactly like walk ( ) , except that it yields a 4-tuple ( dirpath , dirnames , filenames , dirfd ) , and it supports `dir_fd` . With arguments `top`, `topdown`.", "question_id": 6989}
{"snippet": "os.fwalk(top='.', onerror=None)", "intent": "This behaves exactly like walk ( ) , except that it yields a 4-tuple ( dirpath , dirnames , filenames , dirfd ) , and it supports `dir_fd` . With arguments `top`, `onerror`.", "question_id": 6990}
{"snippet": "os.fwalk(top='.', follow_symlinks=False)", "intent": "This behaves exactly like walk ( ) , except that it yields a 4-tuple ( dirpath , dirnames , filenames , dirfd ) , and it supports `dir_fd` . Note however that , unlike other functions , the fwalk ( ) default value for `follow_symlinks` is False . With arguments `top`.", "question_id": 6991}
{"snippet": "os.fwalk(top='.', dir_fd=None)", "intent": "This behaves exactly like walk ( ) , except that it yields a 4-tuple ( dirpath , dirnames , filenames , dirfd ) , and it supports `dir_fd` . With arguments `top`.", "question_id": 6992}
{"snippet": "os.getxattr(path, attribute)", "intent": "Return the value of the extended filesystem `attribute` attribute for `path` .", "question_id": 6993}
{"snippet": "os.getxattr(path, attribute, follow_symlinks=True)", "intent": "Return the value of the extended filesystem `attribute` attribute for `path` . With arguments `follow_symlinks`.", "question_id": 6994}
{"snippet": "os.listxattr()", "intent": "Return a list of the extended filesystem attributes on `path` .", "question_id": 6995}
{"snippet": "os.listxattr(path=None)", "intent": "Return a list of the extended filesystem attributes on `path` .", "question_id": 6996}
{"snippet": "os.listxattr(follow_symlinks=True)", "intent": "Return a list of the extended filesystem attributes on `path` . With arguments `follow_symlinks`.", "question_id": 6997}
{"snippet": "os.listxattr(path=None, follow_symlinks=True)", "intent": "Return a list of the extended filesystem attributes on `path` . With arguments `follow_symlinks`.", "question_id": 6998}
{"snippet": "os.removexattr(path, attribute)", "intent": "Removes the extended filesystem `attribute` attribute from `path` .", "question_id": 6999}
{"snippet": "os.removexattr(path, attribute, follow_symlinks=True)", "intent": "Removes the extended filesystem `attribute` attribute from `path` . With arguments `follow_symlinks`.", "question_id": 7000}
{"snippet": "os.setxattr(path, attribute, value)", "intent": "Set the extended filesystem `attribute` attribute on `path` to `value` .", "question_id": 7001}
{"snippet": "os.setxattr(path, attribute, value, flags=0)", "intent": "Set the extended filesystem `attribute` attribute on `path` to `value` . `flags` may be XATTR_REPLACE or XATTR_CREATE .", "question_id": 7002}
{"snippet": "os.setxattr(path, attribute, value, follow_symlinks=True)", "intent": "Set the extended filesystem `attribute` attribute on `path` to `value` . With arguments `follow_symlinks`.", "question_id": 7003}
{"snippet": "os.setxattr(path, attribute, value, flags=0, follow_symlinks=True)", "intent": "Set the extended filesystem `attribute` attribute on `path` to `value` . `flags` may be XATTR_REPLACE or XATTR_CREATE . With arguments `follow_symlinks`.", "question_id": 7004}
{"snippet": "os.XATTR_SIZE_MAX", "intent": "The maximum size the value of an extended attribute can be.", "question_id": 7005}
{"snippet": "os.XATTR_CREATE", "intent": "This is a possible value for the flags argument in setxattr().", "question_id": 7006}
{"snippet": "os.XATTR_REPLACE", "intent": "This is a possible value for the flags argument in setxattr().", "question_id": 7007}
{"snippet": "os.abort()", "intent": "Generate a SIGABRT signal to the current process .", "question_id": 7008}
{"snippet": "os.execl(path, arg0, arg1)", "intent": "These functions all execute a new program , replacing the current process ; they do not return . The other variants , execl ( ) , execle ( ) , execv ( ) , and execve ( ) , will not use the PATH variable to locate the executable ; `path` must contain an appropriate absolute or relative path . With arguments `arg0`, `arg1`.", "question_id": 7009}
{"snippet": "os.execle(path, arg0, arg1, env)", "intent": "These functions all execute a new program , replacing the current process ; they do not return . The other variants , execl ( ) , execle ( ) , execv ( ) , and execve ( ) , will not use the PATH variable to locate the executable ; `path` must contain an appropriate absolute or relative path . For execle ( ) , execlpe ( ) , execve ( ) , and execvpe ( ) ( note that these all end in \u201c e \u201d ) , the `env` parameter must be a mapping which is used to define the environment variables for the new process ( these are used instead of the current process \u2019 environment ) ; the functions execl ( ) , execlp ( ) , execv ( ) , and execvp ( ) all cause the new process to inherit the environment of the current process . With arguments `arg0`, `arg1`.", "question_id": 7010}
{"snippet": "os.execlp(file, arg0, arg1)", "intent": "These functions all execute a new program , replacing the current process ; they do not return . Open `file` objects and descriptors are not flushed , so if there may be data buffered on these open files , you should flush them using sys.stdout.flush ( ) or os.fsync ( ) before calling an exec* function . With arguments `arg0`, `arg1`.", "question_id": 7011}
{"snippet": "os.execlpe(file, arg0, arg1, env)", "intent": "These functions all execute a new program , replacing the current process ; they do not return . Open `file` objects and descriptors are not flushed , so if there may be data buffered on these open files , you should flush them using sys.stdout.flush ( ) or os.fsync ( ) before calling an exec* function . For execle ( ) , execlpe ( ) , execve ( ) , and execvpe ( ) ( note that these all end in \u201c e \u201d ) , the `env` parameter must be a mapping which is used to define the environment variables for the new process ( these are used instead of the current process \u2019 environment ) ; the functions execl ( ) , execlp ( ) , execv ( ) , and execvp ( ) all cause the new process to inherit the environment of the current process . With arguments `arg0`, `arg1`.", "question_id": 7012}
{"snippet": "os.execv(path, args)", "intent": "These functions all execute a new program , replacing the current process ; they do not return . The other variants , execl ( ) , execle ( ) , execv ( ) , and execve ( ) , will not use the PATH variable to locate the executable ; `path` must contain an appropriate absolute or relative path . The \u201c v \u201d variants are good when the number of parameters is variable , with the arguments being passed in a list or tuple as the `args` parameter .", "question_id": 7013}
{"snippet": "os.execve(path, args, env)", "intent": "These functions all execute a new program , replacing the current process ; they do not return . The other variants , execl ( ) , execle ( ) , execv ( ) , and execve ( ) , will not use the PATH variable to locate the executable ; `path` must contain an appropriate absolute or relative path . The \u201c v \u201d variants are good when the number of parameters is variable , with the arguments being passed in a list or tuple as the `args` parameter . For execle ( ) , execlpe ( ) , execve ( ) , and execvpe ( ) ( note that these all end in \u201c e \u201d ) , the `env` parameter must be a mapping which is used to define the environment variables for the new process ( these are used instead of the current process \u2019 environment ) ; the functions execl ( ) , execlp ( ) , execv ( ) , and execvp ( ) all cause the new process to inherit the environment of the current process .", "question_id": 7014}
{"snippet": "os.execvp(file, args)", "intent": "These functions all execute a new program , replacing the current process ; they do not return . Open `file` objects and descriptors are not flushed , so if there may be data buffered on these open files , you should flush them using sys.stdout.flush ( ) or os.fsync ( ) before calling an exec* function . The \u201c v \u201d variants are good when the number of parameters is variable , with the arguments being passed in a list or tuple as the `args` parameter .", "question_id": 7015}
{"snippet": "os.execvpe(file, args, env)", "intent": "These functions all execute a new program , replacing the current process ; they do not return . Open `file` objects and descriptors are not flushed , so if there may be data buffered on these open files , you should flush them using sys.stdout.flush ( ) or os.fsync ( ) before calling an exec* function . The \u201c v \u201d variants are good when the number of parameters is variable , with the arguments being passed in a list or tuple as the `args` parameter . For execle ( ) , execlpe ( ) , execve ( ) , and execvpe ( ) ( note that these all end in \u201c e \u201d ) , the `env` parameter must be a mapping which is used to define the environment variables for the new process ( these are used instead of the current process \u2019 environment ) ; the functions execl ( ) , execlp ( ) , execv ( ) , and execvp ( ) all cause the new process to inherit the environment of the current process .", "question_id": 7016}
{"snippet": "os._exit(n)", "intent": "Exit the process with status `n` , without calling cleanup handlers , flushing stdio buffers , etc .", "question_id": 7017}
{"snippet": "os.EX_OK", "intent": "Exit code that means no error occurred.", "question_id": 7018}
{"snippet": "os.EX_USAGE", "intent": "Exit code that means the command was used incorrectly, such as when the wrong number of arguments are given.", "question_id": 7019}
{"snippet": "os.EX_DATAERR", "intent": "Exit code that means the input data was incorrect.", "question_id": 7020}
{"snippet": "os.EX_NOINPUT", "intent": "Exit code that means an input file did not exist or was not readable.", "question_id": 7021}
{"snippet": "os.EX_NOUSER", "intent": "Exit code that means a specified user did not exist.", "question_id": 7022}
{"snippet": "os.EX_NOHOST", "intent": "Exit code that means a specified host did not exist.", "question_id": 7023}
{"snippet": "os.EX_UNAVAILABLE", "intent": "Exit code that means that a required service is unavailable.", "question_id": 7024}
{"snippet": "os.EX_SOFTWARE", "intent": "Exit code that means an internal software error was detected.", "question_id": 7025}
{"snippet": "os.EX_OSERR", "intent": "Exit code that means an operating system error was detected, such as the inability to fork or create a pipe.", "question_id": 7026}
{"snippet": "os.EX_OSFILE", "intent": "Exit code that means some system file did not exist, could not be opened, or had some other kind of error.", "question_id": 7027}
{"snippet": "os.EX_CANTCREAT", "intent": "Exit code that means a user specified output file could not be created.", "question_id": 7028}
{"snippet": "os.EX_IOERR", "intent": "Exit code that means that an error occurred while doing I/O on some file.", "question_id": 7029}
{"snippet": "os.EX_TEMPFAIL", "intent": "Exit code that means a temporary failure occurred.", "question_id": 7030}
{"snippet": "os.EX_PROTOCOL", "intent": "Exit code that means that a protocol exchange was illegal, invalid, or not understood.", "question_id": 7031}
{"snippet": "os.EX_NOPERM", "intent": "Exit code that means that there were insufficient permissions to perform the operation (but not intended for file system problems).", "question_id": 7032}
{"snippet": "os.EX_CONFIG", "intent": "Exit code that means that some kind of configuration error occurred.", "question_id": 7033}
{"snippet": "os.EX_NOTFOUND", "intent": "Exit code that means something like \u201can entry was not found\u201d.", "question_id": 7034}
{"snippet": "os.fork()", "intent": "Fork a child process .", "question_id": 7035}
{"snippet": "os.forkpty()", "intent": "Fork a child process , using a new pseudo-terminal as the child \u2019 s controlling terminal .", "question_id": 7036}
{"snippet": "os.kill(pid, sig)", "intent": "Send signal `sig` to the process `pid` .", "question_id": 7037}
{"snippet": "os.killpg(pgid, sig)", "intent": "Send the signal `sig` to the process group `pgid` .", "question_id": 7038}
{"snippet": "os.nice(increment)", "intent": "Add `increment` to the process \u2019 s \u201c niceness \u201d .", "question_id": 7039}
{"snippet": "os.plock(op)", "intent": "Lock program segments into memory . The value of `op` ( defined in < sys/lock.h > ) determines which segments are locked .", "question_id": 7040}
{"snippet": "os.popen(cmd)", "intent": "Open a pipe to or from command `cmd` .", "question_id": 7041}
{"snippet": "os.popen(cmd, mode='r')", "intent": "Open a pipe to or from command `cmd` . The return value is an open file object connected to the pipe , which can be read or written depending on whether `mode` is ' r ' ( default ) or ' w ' .", "question_id": 7042}
{"snippet": "os.popen(cmd, buffering=-1)", "intent": "Open a pipe to or from command `cmd` . The `buffering` argument has the same meaning as the corresponding argument to the built-in open ( ) function .", "question_id": 7043}
{"snippet": "os.popen(cmd, mode='r', buffering=-1)", "intent": "Open a pipe to or from command `cmd` . The return value is an open file object connected to the pipe , which can be read or written depending on whether `mode` is ' r ' ( default ) or ' w ' . The `buffering` argument has the same meaning as the corresponding argument to the built-in open ( ) function .", "question_id": 7044}
{"snippet": "os.register_at_fork()", "intent": "Register callables to be executed when a new child process is forked using os.fork ( ) or similar process cloning APIs .", "question_id": 7045}
{"snippet": "os.register_at_fork(before=None)", "intent": "Register callables to be executed when a new child process is forked using os.fork ( ) or similar process cloning APIs . Functions registered for execution `before` forking are called in reverse registration order .", "question_id": 7046}
{"snippet": "os.register_at_fork(after_in_parent=None)", "intent": "Register callables to be executed when a new child process is forked using os.fork ( ) or similar process cloning APIs . With arguments `after_in_parent`.", "question_id": 7047}
{"snippet": "os.register_at_fork(after_in_child=None)", "intent": "Register callables to be executed when a new child process is forked using os.fork ( ) or similar process cloning APIs . With arguments `after_in_child`.", "question_id": 7048}
{"snippet": "os.register_at_fork(before=None, after_in_parent=None)", "intent": "Register callables to be executed when a new child process is forked using os.fork ( ) or similar process cloning APIs . Functions registered for execution `before` forking are called in reverse registration order . With arguments `after_in_parent`.", "question_id": 7049}
{"snippet": "os.register_at_fork(before=None, after_in_child=None)", "intent": "Register callables to be executed when a new child process is forked using os.fork ( ) or similar process cloning APIs . Functions registered for execution `before` forking are called in reverse registration order . With arguments `after_in_child`.", "question_id": 7050}
{"snippet": "os.register_at_fork(after_in_parent=None, after_in_child=None)", "intent": "Register callables to be executed when a new child process is forked using os.fork ( ) or similar process cloning APIs . With arguments `after_in_parent`, `after_in_child`.", "question_id": 7051}
{"snippet": "os.register_at_fork(before=None, after_in_parent=None, after_in_child=None)", "intent": "Register callables to be executed when a new child process is forked using os.fork ( ) or similar process cloning APIs . Functions registered for execution `before` forking are called in reverse registration order . With arguments `after_in_parent`, `after_in_child`.", "question_id": 7052}
{"snippet": "os.spawnl(mode, path)", "intent": "Execute the program `path` in a new process . If `mode` is P_NOWAIT , this function returns the process id of the new process ; if mode is P_WAIT , returns the process \u2019 s exit code if it exits normally , or -signal , where signal is the signal that killed the process .", "question_id": 7053}
{"snippet": "os.spawnle(mode, path, env)", "intent": "Execute the program `path` in a new process . If `mode` is P_NOWAIT , this function returns the process id of the new process ; if mode is P_WAIT , returns the process \u2019 s exit code if it exits normally , or -signal , where signal is the signal that killed the process . For spawnle ( ) , spawnlpe ( ) , spawnve ( ) , and spawnvpe ( ) ( note that these all end in \u201c e \u201d ) , the `env` parameter must be a mapping which is used to define the environment variables for the new process ( they are used instead of the current process \u2019 environment ) ; the functions spawnl ( ) , spawnlp ( ) , spawnv ( ) , and spawnvp ( ) all cause the new process to inherit the environment of the current process .", "question_id": 7054}
{"snippet": "os.spawnlp(mode, file)", "intent": "Execute the program path in a new process . If `mode` is P_NOWAIT , this function returns the process id of the new process ; if mode is P_WAIT , returns the process \u2019 s exit code if it exits normally , or -signal , where signal is the signal that killed the process . The variants which include a second \u201c p \u201d near the end ( spawnlp ( ) , spawnlpe ( ) , spawnvp ( ) , and spawnvpe ( ) ) will use the PATH environment variable to locate the program `file` .", "question_id": 7055}
{"snippet": "os.spawnlpe(mode, file, env)", "intent": "Execute the program path in a new process . If `mode` is P_NOWAIT , this function returns the process id of the new process ; if mode is P_WAIT , returns the process \u2019 s exit code if it exits normally , or -signal , where signal is the signal that killed the process . The variants which include a second \u201c p \u201d near the end ( spawnlp ( ) , spawnlpe ( ) , spawnvp ( ) , and spawnvpe ( ) ) will use the PATH environment variable to locate the program `file` . For spawnle ( ) , spawnlpe ( ) , spawnve ( ) , and spawnvpe ( ) ( note that these all end in \u201c e \u201d ) , the `env` parameter must be a mapping which is used to define the environment variables for the new process ( they are used instead of the current process \u2019 environment ) ; the functions spawnl ( ) , spawnlp ( ) , spawnv ( ) , and spawnvp ( ) all cause the new process to inherit the environment of the current process .", "question_id": 7056}
{"snippet": "os.spawnv(mode, path, args)", "intent": "Execute the program `path` in a new process . If `mode` is P_NOWAIT , this function returns the process id of the new process ; if mode is P_WAIT , returns the process \u2019 s exit code if it exits normally , or -signal , where signal is the signal that killed the process . The \u201c v \u201d variants are good when the number of parameters is variable , with the arguments being passed in a list or tuple as the `args` parameter .", "question_id": 7057}
{"snippet": "os.spawnve(mode, path, args, env)", "intent": "Execute the program `path` in a new process . If `mode` is P_NOWAIT , this function returns the process id of the new process ; if mode is P_WAIT , returns the process \u2019 s exit code if it exits normally , or -signal , where signal is the signal that killed the process . The \u201c v \u201d variants are good when the number of parameters is variable , with the arguments being passed in a list or tuple as the `args` parameter . For spawnle ( ) , spawnlpe ( ) , spawnve ( ) , and spawnvpe ( ) ( note that these all end in \u201c e \u201d ) , the `env` parameter must be a mapping which is used to define the environment variables for the new process ( they are used instead of the current process \u2019 environment ) ; the functions spawnl ( ) , spawnlp ( ) , spawnv ( ) , and spawnvp ( ) all cause the new process to inherit the environment of the current process .", "question_id": 7058}
{"snippet": "os.spawnvp(mode, file, args)", "intent": "Execute the program path in a new process . If `mode` is P_NOWAIT , this function returns the process id of the new process ; if mode is P_WAIT , returns the process \u2019 s exit code if it exits normally , or -signal , where signal is the signal that killed the process . The variants which include a second \u201c p \u201d near the end ( spawnlp ( ) , spawnlpe ( ) , spawnvp ( ) , and spawnvpe ( ) ) will use the PATH environment variable to locate the program `file` . The \u201c v \u201d variants are good when the number of parameters is variable , with the arguments being passed in a list or tuple as the `args` parameter .", "question_id": 7059}
{"snippet": "os.spawnvpe(mode, file, args, env)", "intent": "Execute the program path in a new process . If `mode` is P_NOWAIT , this function returns the process id of the new process ; if mode is P_WAIT , returns the process \u2019 s exit code if it exits normally , or -signal , where signal is the signal that killed the process . The variants which include a second \u201c p \u201d near the end ( spawnlp ( ) , spawnlpe ( ) , spawnvp ( ) , and spawnvpe ( ) ) will use the PATH environment variable to locate the program `file` . The \u201c v \u201d variants are good when the number of parameters is variable , with the arguments being passed in a list or tuple as the `args` parameter . For spawnle ( ) , spawnlpe ( ) , spawnve ( ) , and spawnvpe ( ) ( note that these all end in \u201c e \u201d ) , the `env` parameter must be a mapping which is used to define the environment variables for the new process ( they are used instead of the current process \u2019 environment ) ; the functions spawnl ( ) , spawnlp ( ) , spawnv ( ) , and spawnvp ( ) all cause the new process to inherit the environment of the current process .", "question_id": 7060}
{"snippet": "os.P_NOWAIT", "intent": "Possible values for the mode parameter to the spawn* family of functions.", "question_id": 7061}
{"snippet": "os.P_NOWAITO", "intent": "Possible values for the mode parameter to the spawn* family of functions.", "question_id": 7062}
{"snippet": "os.P_WAIT", "intent": "Possible value for the mode parameter to the spawn* family of functions.", "question_id": 7063}
{"snippet": "os.P_DETACH", "intent": "Possible values for the mode parameter to the spawn* family of functions.", "question_id": 7064}
{"snippet": "os.P_OVERLAY", "intent": "Possible values for the mode parameter to the spawn* family of functions.", "question_id": 7065}
{"snippet": "os.startfile(path, operation)", "intent": "Start a file with its associated application . The `path` parameter is relative to the current directory . When `operation` is not specified or 'open ' , this acts like double-clicking the file in Windows Explorer , or giving the file name as an argument to the start command from the interactive command shell : the file is opened with whatever application ( if any ) its extension is associated .", "question_id": 7066}
{"snippet": "os.startfile(path)", "intent": "Start a file with its associated application . The `path` parameter is relative to the current directory .", "question_id": 7067}
{"snippet": "os.system(command)", "intent": "Execute the `command` ( a string ) in a subshell .", "question_id": 7068}
{"snippet": "os.times()", "intent": "Returns the current global process times .", "question_id": 7069}
{"snippet": "os.wait()", "intent": "Wait for completion of a child process , and return a tuple containing its pid and exit status indication : a 16-bit number , whose low byte is the signal number that killed the process , and whose high byte is the exit status ( if the signal number is zero ) ; the high bit of the low byte is set if a core file was produced .", "question_id": 7070}
{"snippet": "os.waitid(idtype, id, options)", "intent": "Wait for the completion of one or more child processes . `idtype` can be P_PID , P_PGID or P_ALL . `id` specifies the pid to wait on . `options` is constructed from the ORing of one or more of WEXITED , WSTOPPED or WCONTINUED and additionally may be ORed with WNOHANG or WNOWAIT .", "question_id": 7071}
{"snippet": "os.P_PID", "intent": "These are the possible values for idtype in waitid().", "question_id": 7072}
{"snippet": "os.P_PGID", "intent": "These are the possible values for idtype in waitid().", "question_id": 7073}
{"snippet": "os.P_ALL", "intent": "These are the possible values for idtype in waitid().", "question_id": 7074}
{"snippet": "os.WEXITED", "intent": "Flags that can be used in options in waitid() that specify what child signal to wait for.", "question_id": 7075}
{"snippet": "os.WSTOPPED", "intent": "Flags that can be used in options in waitid() that specify what child signal to wait for.", "question_id": 7076}
{"snippet": "os.WNOWAIT", "intent": "Flags that can be used in options in waitid() that specify what child signal to wait for.", "question_id": 7077}
{"snippet": "os.CLD_EXITED", "intent": "These are the possible values for si_code in the result returned by waitid().", "question_id": 7078}
{"snippet": "os.CLD_DUMPED", "intent": "These are the possible values for si_code in the result returned by waitid().", "question_id": 7079}
{"snippet": "os.CLD_TRAPPED", "intent": "These are the possible values for si_code in the result returned by waitid().", "question_id": 7080}
{"snippet": "os.CLD_CONTINUED", "intent": "These are the possible values for si_code in the result returned by waitid().", "question_id": 7081}
{"snippet": "os.waitpid(pid, options)", "intent": "The details of this function differ on Unix and Windows . On Unix : Wait for completion of a child process given by process id `pid` , and return a tuple containing its process id and exit status indication ( encoded as for wait ( ) ) . The semantics of the call are affected by the value of the integer `options` , which should be 0 for normal operation .", "question_id": 7082}
{"snippet": "os.wait3(options)", "intent": "Similar to waitpid ( ) , except no process id argument is given and a 3-element tuple containing the child \u2019 s process id , exit status indication , and resource usage information is returned . With arguments `options`.", "question_id": 7083}
{"snippet": "os.wait4(pid, options)", "intent": "Similar to waitpid ( ) , except a 3-element tuple , containing the child \u2019 s process id , exit status indication , and resource usage information is returned . With arguments `pid`, `options`.", "question_id": 7084}
{"snippet": "os.WNOHANG", "intent": "The option for waitpid() to return immediately if no child process status is available immediately.", "question_id": 7085}
{"snippet": "os.WCONTINUED", "intent": "This option causes child processes to be reported if they have been continued from a job control stop since their status was last reported.", "question_id": 7086}
{"snippet": "os.WUNTRACED", "intent": "This option causes child processes to be reported if they have been stopped but their current state has not been reported since they were stopped.", "question_id": 7087}
{"snippet": "os.WCOREDUMP(status)", "intent": "Return True if a core dump was generated for the process , otherwise return False . With arguments `status`.", "question_id": 7088}
{"snippet": "os.WIFCONTINUED(status)", "intent": "Return True if the process has been continued from a job control stop , otherwise return False . With arguments `status`.", "question_id": 7089}
{"snippet": "os.WIFSTOPPED(status)", "intent": "Return True if the process has been stopped , otherwise return False . With arguments `status`.", "question_id": 7090}
{"snippet": "os.WIFSIGNALED(status)", "intent": "Return True if the process exited due to a signal , otherwise return False . With arguments `status`.", "question_id": 7091}
{"snippet": "os.WIFEXITED(status)", "intent": "Return True if the process exited using the exit ( 2 ) system call , otherwise return False . With arguments `status`.", "question_id": 7092}
{"snippet": "os.WEXITSTATUS(status)", "intent": "If WIFEXITED ( `status` ) is true , return the integer parameter to the exit ( 2 ) system call .", "question_id": 7093}
{"snippet": "os.WSTOPSIG(status)", "intent": "Return the signal which caused the process to stop . With arguments `status`.", "question_id": 7094}
{"snippet": "os.WTERMSIG(status)", "intent": "Return the signal which caused the process to exit . With arguments `status`.", "question_id": 7095}
{"snippet": "os.SCHED_OTHER", "intent": "The default scheduling policy.", "question_id": 7096}
{"snippet": "os.SCHED_BATCH", "intent": "Scheduling policy for CPU-intensive processes that tries to preserve interactivity on the rest of the computer.", "question_id": 7097}
{"snippet": "os.SCHED_IDLE", "intent": "Scheduling policy for extremely low priority background tasks.", "question_id": 7098}
{"snippet": "os.SCHED_SPORADIC", "intent": "Scheduling policy for sporadic server programs.", "question_id": 7099}
{"snippet": "os.SCHED_FIFO", "intent": "A First In First Out scheduling policy.", "question_id": 7100}
{"snippet": "os.SCHED_RR", "intent": "A round-robin scheduling policy.", "question_id": 7101}
{"snippet": "os.SCHED_RESET_ON_FORK", "intent": "This flag can be OR\u2019ed with any other scheduling policy.", "question_id": 7102}
{"snippet": "os.sched_param(sched_priority)", "intent": "This class represents tunable scheduling parameters used in sched_setparam ( ) , sched_setscheduler ( ) , and sched_getparam ( ) . With arguments `sched_priority`.", "question_id": 7103}
{"snippet": "sched_param.sched_priority", "intent": "The scheduling priority for a scheduling policy.", "question_id": 7104}
{"snippet": "os.sched_get_priority_min(policy)", "intent": "Get the minimum priority value for `policy` .", "question_id": 7105}
{"snippet": "os.sched_get_priority_max(policy)", "intent": "Get the maximum priority value for `policy` .", "question_id": 7106}
{"snippet": "os.sched_setscheduler(pid, policy, param)", "intent": "Set the scheduling `policy` for the process with PID `pid` . `param` is a sched_param instance .", "question_id": 7107}
{"snippet": "os.sched_getscheduler(pid)", "intent": "Return the scheduling policy for the process with PID `pid` .", "question_id": 7108}
{"snippet": "os.sched_setparam(pid, param)", "intent": "Set a scheduling parameters for the process with PID `pid` . `param` is a sched_param instance .", "question_id": 7109}
{"snippet": "os.sched_getparam(pid)", "intent": "Return the scheduling parameters as a sched_param instance for the process with PID `pid` .", "question_id": 7110}
{"snippet": "os.sched_rr_get_interval(pid)", "intent": "Return the round-robin quantum in seconds for the process with PID `pid` .", "question_id": 7111}
{"snippet": "os.sched_yield()", "intent": "Voluntarily relinquish the CPU .", "question_id": 7112}
{"snippet": "os.sched_setaffinity(pid, mask)", "intent": "Restrict the process with PID `pid` ( or the current process if zero ) to a set of CPUs . `mask` is an iterable of integers representing the set of CPUs to which the process should be restricted .", "question_id": 7113}
{"snippet": "os.sched_getaffinity(pid)", "intent": "Return the set of CPUs the process with PID `pid` ( or the current process if zero ) is restricted to .", "question_id": 7114}
{"snippet": "os.confstr(name)", "intent": "Return string-valued system configuration values . `name` specifies the configuration value to retrieve ; it may be a string which is the name of a defined system value ; these names are specified in a number of standards ( POSIX , Unix 95 , Unix 98 , and others ) .", "question_id": 7115}
{"snippet": "os.confstr_names", "intent": "Dictionary mapping names accepted by confstr() to the integer values defined for those names by the host operating system.", "question_id": 7116}
{"snippet": "os.cpu_count()", "intent": "Return the number of CPUs in the system .", "question_id": 7117}
{"snippet": "os.getloadavg()", "intent": "Return the number of processes in the system run queue averaged over the last 1 , 5 , and 15 minutes or raises OSError if the load average was unobtainable .", "question_id": 7118}
{"snippet": "os.sysconf(name)", "intent": "Return integer-valued system configuration values . If the configuration value specified by `name` isn \u2019 t defined , -1 is returned .", "question_id": 7119}
{"snippet": "os.sysconf_names", "intent": "Dictionary mapping names accepted by sysconf() to the integer values defined for those names by the host operating system.", "question_id": 7120}
{"snippet": "os.curdir", "intent": "The constant string used by the operating system to refer to the current directory.", "question_id": 7121}
{"snippet": "os.pardir", "intent": "The constant string used by the operating system to refer to the parent directory.", "question_id": 7122}
{"snippet": "os.sep", "intent": "The character used by the operating system to separate pathname components.", "question_id": 7123}
{"snippet": "os.altsep", "intent": "An alternative character used by the operating system to separate pathname components, or None if only one separator character exists.", "question_id": 7124}
{"snippet": "os.extsep", "intent": "The character which separates the base filename from the extension; for example, the '.'", "question_id": 7125}
{"snippet": "os.pathsep", "intent": "The character conventionally used by the operating system to separate search path components (as in PATH), such as ':' for POSIX or ';' for Windows.", "question_id": 7126}
{"snippet": "os.defpath", "intent": "The default search path used by exec*p* and spawn*p* if the environment doesn\u2019t have a 'PATH' key.", "question_id": 7127}
{"snippet": "os.linesep", "intent": "The string used to separate (or, rather, terminate) lines on the current platform.", "question_id": 7128}
{"snippet": "os.devnull", "intent": "The file path of the null device.", "question_id": 7129}
{"snippet": "os.RTLD_LAZY", "intent": "Flags for use with the setdlopenflags() and getdlopenflags() functions.", "question_id": 7130}
{"snippet": "os.RTLD_NOW", "intent": "Flags for use with the setdlopenflags() and getdlopenflags() functions.", "question_id": 7131}
{"snippet": "os.RTLD_GLOBAL", "intent": "Flags for use with the setdlopenflags() and getdlopenflags() functions.", "question_id": 7132}
{"snippet": "os.RTLD_LOCAL", "intent": "Flags for use with the setdlopenflags() and getdlopenflags() functions.", "question_id": 7133}
{"snippet": "os.RTLD_NODELETE", "intent": "Flags for use with the setdlopenflags() and getdlopenflags() functions.", "question_id": 7134}
{"snippet": "os.RTLD_NOLOAD", "intent": "Flags for use with the setdlopenflags() and getdlopenflags() functions.", "question_id": 7135}
{"snippet": "os.RTLD_DEEPBIND", "intent": "Flags for use with the setdlopenflags() and getdlopenflags() functions.", "question_id": 7136}
{"snippet": "os.getrandom(size)", "intent": "Get up to `size` random bytes .", "question_id": 7137}
{"snippet": "os.getrandom(size, flags=0)", "intent": "Get up to `size` random bytes . The `flags` argument is a bit mask that can contain zero or more of the following values ORed together : os.GRND_RANDOM and GRND_NONBLOCK .", "question_id": 7138}
{"snippet": "os.urandom(size)", "intent": "Return a string of `size` random bytes suitable for cryptographic use .", "question_id": 7139}
{"snippet": "os.GRND_NONBLOCK", "intent": "By  default, when reading from /dev/random, getrandom() blocks if no random bytes are available, and when reading from /dev/urandom, it blocks if the entropy pool has not yet been initialized.", "question_id": 7140}
{"snippet": "os.GRND_RANDOM", "intent": "If  this  bit  is  set,  then  random bytes are drawn from the /dev/random pool instead of the /dev/urandom pool.", "question_id": 7141}
{"snippet": "os.path.abspath(path)", "intent": "Return a normalized absolutized version of the pathname `path` .", "question_id": 7142}
{"snippet": "os.path.basename(path)", "intent": "Return the base name of pathname `path` .", "question_id": 7143}
{"snippet": "os.path.commonpath(paths)", "intent": "Return the longest common sub-path of each pathname in the sequence `paths` .", "question_id": 7144}
{"snippet": "os.path.commonprefix(list)", "intent": "Return the longest path prefix ( taken character-by-character ) that is a prefix of all paths in `list` .", "question_id": 7145}
{"snippet": "os.path.dirname(path)", "intent": "Return the directory name of pathname `path` .", "question_id": 7146}
{"snippet": "os.path.exists(path)", "intent": "Return True if `path` refers to an existing path or an open file descriptor .", "question_id": 7147}
{"snippet": "os.path.lexists(path)", "intent": "Return True if `path` refers to an existing path .", "question_id": 7148}
{"snippet": "os.path.expanduser(path)", "intent": "On Unix and Windows , return the argument with an initial component of ~ or ~user replaced by that user \u2019 s home directory . An initial ~user is handled by stripping the last directory component from the created user `path` derived above .", "question_id": 7149}
{"snippet": "os.path.expandvars(path)", "intent": "Return the argument with environment variables expanded . With arguments `path`.", "question_id": 7150}
{"snippet": "os.path.getatime(path)", "intent": "Return the time of last access of `path` .", "question_id": 7151}
{"snippet": "os.path.getmtime(path)", "intent": "Return the time of last modification of `path` .", "question_id": 7152}
{"snippet": "os.path.getctime(path)", "intent": "Return the system \u2019 s ctime which , on some systems ( like Unix ) is the time of the last metadata change , and , on others ( like Windows ) , is the creation time for `path` .", "question_id": 7153}
{"snippet": "os.path.getsize(path)", "intent": "Return the size , in bytes , of `path` .", "question_id": 7154}
{"snippet": "os.path.isabs(path)", "intent": "Return True if `path` is an absolute pathname .", "question_id": 7155}
{"snippet": "os.path.isfile(path)", "intent": "Return True if `path` is an existing regular file .", "question_id": 7156}
{"snippet": "os.path.isdir(path)", "intent": "Return True if `path` is an existing directory .", "question_id": 7157}
{"snippet": "os.path.islink(path)", "intent": "Return True if `path` refers to an existing directory entry that is a symbolic link .", "question_id": 7158}
{"snippet": "os.path.ismount(path)", "intent": "Return True if pathname `path` is a mount point : a point in a file system where a different file system has been mounted .", "question_id": 7159}
{"snippet": "os.path.join(path, *paths)", "intent": "Join one or more `path` components intelligently . The return value is the concatenation of path and any members of `*paths` with exactly one directory separator ( os.sep ) following each non-empty part except the last , meaning that the result will only end in a separator if the last part is empty .", "question_id": 7160}
{"snippet": "os.path.normcase(path)", "intent": "Normalize the case of a pathname . On other operating systems , return the `path` unchanged .", "question_id": 7161}
{"snippet": "os.path.normpath(path)", "intent": "Normalize a pathname by collapsing redundant separators and up-level references so that A//B , A/B/ , A/./B and A/foo/../B all become A/B . This string manipulation may change the meaning of a `path` that contains symbolic links .", "question_id": 7162}
{"snippet": "os.path.realpath(path)", "intent": "Return the canonical `path` of the specified filename , eliminating any symbolic links encountered in the path ( if they are supported by the operating system ) .", "question_id": 7163}
{"snippet": "os.path.relpath(path)", "intent": "Return a relative filepath to `path` either from the current directory or from an optional `start` directory .", "question_id": 7164}
{"snippet": "os.path.relpath(path, start=os.curdir)", "intent": "Return a relative filepath to `path` either from the current directory or from an optional `start` directory .", "question_id": 7165}
{"snippet": "os.path.samefile(path1, path2)", "intent": "Return True if both pathname arguments refer to the same file or directory . With arguments `path1`, `path2`.", "question_id": 7166}
{"snippet": "os.path.sameopenfile(fp1, fp2)", "intent": "Return True if the file descriptors `fp1` and `fp2` refer to the same file .", "question_id": 7167}
{"snippet": "os.path.samestat(stat1, stat2)", "intent": "Return True if the stat tuples `stat1` and `stat2` refer to the same file .", "question_id": 7168}
{"snippet": "os.path.split(path)", "intent": "Split the pathname `path` into a pair , ( head , tail ) where tail is the last pathname component and head is everything leading up to that .", "question_id": 7169}
{"snippet": "os.path.splitdrive(path)", "intent": "Split the pathname `path` into a pair ( drive , tail ) where drive is either a mount point or the empty string .", "question_id": 7170}
{"snippet": "os.path.splitext(path)", "intent": "Split the pathname `path` into a pair ( root , ext ) such that root + ext == path , and ext is empty or begins with a period and contains at most one period .", "question_id": 7171}
{"snippet": "os.path.supports_unicode_filenames", "intent": "True if arbitrary Unicode strings can be used as file names (within limitations imposed by the file system).", "question_id": 7172}
{"snippet": "ossaudiodev.OSSAudioError", "intent": "This exception is raised on certain errors.", "question_id": 7173}
{"snippet": "ossaudiodev.open(mode)", "intent": "Open an audio device and return an OSS audio device object . `mode` is one of ' r ' for read-only ( record ) access , ' w ' for write-only ( playback ) access and 'rw ' for both .", "question_id": 7174}
{"snippet": "ossaudiodev.open(device, mode)", "intent": "Open an audio `device` and return an OSS audio device object . `mode` is one of ' r ' for read-only ( record ) access , ' w ' for write-only ( playback ) access and 'rw ' for both .", "question_id": 7175}
{"snippet": "ossaudiodev.openmixer(device)", "intent": "Open a mixer `device` and return an OSS mixer device object .", "question_id": 7176}
{"snippet": "ossaudiodev.openmixer()", "intent": "Open a mixer `device` and return an OSS mixer device object .", "question_id": 7177}
{"snippet": "oss_audio_device.close()", "intent": "Explicitly close the audio device .", "question_id": 7178}
{"snippet": "oss_audio_device.fileno()", "intent": "Return the file descriptor associated with the device .", "question_id": 7179}
{"snippet": "oss_audio_device.read(size)", "intent": "Read `size` bytes from the audio input and return them as a Python string .", "question_id": 7180}
{"snippet": "oss_audio_device.write(data)", "intent": "Write a bytes-like object `data` to the audio device and return the number of bytes written .", "question_id": 7181}
{"snippet": "oss_audio_device.writeall(data)", "intent": "Write a bytes-like object `data` to the audio device : waits until the audio device is able to accept data , writes as much data as it will accept , and repeats until data has been completely written .", "question_id": 7182}
{"snippet": "oss_audio_device.nonblock()", "intent": "Put the device into non-blocking mode .", "question_id": 7183}
{"snippet": "oss_audio_device.getfmts()", "intent": "Return a bitmask of the audio output formats supported by the soundcard .", "question_id": 7184}
{"snippet": "oss_audio_device.setfmt(format)", "intent": "Try to set the current audio `format` to format\u2014see getfmts ( ) for a list .", "question_id": 7185}
{"snippet": "oss_audio_device.channels(nchannels)", "intent": "Set the number of output channels to `nchannels` .", "question_id": 7186}
{"snippet": "oss_audio_device.speed(samplerate)", "intent": "Try to set the audio sampling rate to `samplerate` samples per second .", "question_id": 7187}
{"snippet": "oss_audio_device.sync()", "intent": "Wait until the sound device has played every byte in its buffer .", "question_id": 7188}
{"snippet": "oss_audio_device.reset()", "intent": "Immediately stop playing or recording and return the device to a state where it can accept commands .", "question_id": 7189}
{"snippet": "oss_audio_device.post()", "intent": "Tell the driver that there is likely to be a pause in the output , making it possible for the device to handle the pause more intelligently .", "question_id": 7190}
{"snippet": "oss_audio_device.setparameters(format, nchannels, samplerate)", "intent": "Set the key audio sampling parameters\u2014sample `format` , number of channels , and sampling rate\u2014in one method call . format , `nchannels` , and `samplerate` should be as specified in the setfmt ( ) , channels ( ) , and speed ( ) methods .", "question_id": 7191}
{"snippet": "oss_audio_device.setparameters(format, nchannels, samplerate, strict=False)", "intent": "Set the key audio sampling parameters\u2014sample `format` , number of channels , and sampling rate\u2014in one method call . format , `nchannels` , and `samplerate` should be as specified in the setfmt ( ) , channels ( ) , and speed ( ) methods . If `strict` is true , setparameters ( ) checks to see if each parameter was actually set to the requested value , and raises OSSAudioError if not .", "question_id": 7192}
{"snippet": "oss_audio_device.setparameters(format, nchannels)", "intent": "Set the key audio sampling parameters\u2014sample `format` , number of channels , and sampling rate\u2014in one method call . format , `nchannels` , and `samplerate` should be as specified in the setfmt ( ) , channels ( ) , and speed ( ) methods .", "question_id": 7193}
{"snippet": "oss_audio_device.setparameters(format, nchannels, strict=False)", "intent": "Set the key audio sampling parameters\u2014sample `format` , number of channels , and sampling rate\u2014in one method call . format , `nchannels` , and `samplerate` should be as specified in the setfmt ( ) , channels ( ) , and speed ( ) methods . If `strict` is true , setparameters ( ) checks to see if each parameter was actually set to the requested value , and raises OSSAudioError if not .", "question_id": 7194}
{"snippet": "oss_audio_device.bufsize()", "intent": "Returns the size of the hardware buffer , in samples .", "question_id": 7195}
{"snippet": "oss_audio_device.obufcount()", "intent": "Returns the number of samples that are in the hardware buffer yet to be played .", "question_id": 7196}
{"snippet": "oss_audio_device.obuffree()", "intent": "Returns the number of samples that could be queued into the hardware buffer to be played without blocking .", "question_id": 7197}
{"snippet": "oss_audio_device.closed", "intent": "Boolean indicating whether the device has been closed.", "question_id": 7198}
{"snippet": "oss_audio_device.name", "intent": "String containing the name of the device file.", "question_id": 7199}
{"snippet": "oss_audio_device.mode", "intent": "The I/O mode for the file, either \"r\", \"rw\", or \"w\".", "question_id": 7200}
{"snippet": "oss_mixer_device.close()", "intent": "This method closes the open mixer device file .", "question_id": 7201}
{"snippet": "oss_mixer_device.fileno()", "intent": "Returns the file handle number of the open mixer device file .", "question_id": 7202}
{"snippet": "oss_mixer_device.controls()", "intent": "This method returns a bitmask specifying the available mixer controls ( \u201c Control \u201d being a specific mixable \u201c channel \u201d , such as SOUND_MIXER_PCM or SOUND_MIXER_SYNTH ) .", "question_id": 7203}
{"snippet": "oss_mixer_device.stereocontrols()", "intent": "Returns a bitmask indicating stereo mixer controls .", "question_id": 7204}
{"snippet": "oss_mixer_device.reccontrols()", "intent": "Returns a bitmask specifying the mixer controls that may be used to record .", "question_id": 7205}
{"snippet": "oss_mixer_device.get(control)", "intent": "Returns the volume of a given mixer `control` .", "question_id": 7206}
{"snippet": "oss_mixer_device.set(control, (left, right))", "intent": "Sets the volume for a given mixer `control` to ( left , right ) . With arguments `(left`, `right)`.", "question_id": 7207}
{"snippet": "oss_mixer_device.get_recsrc()", "intent": "This method returns a bitmask indicating which control ( s ) are currently being used as a recording source .", "question_id": 7208}
{"snippet": "oss_mixer_device.set_recsrc(bitmask)", "intent": "Call this function to specify a recording source . Returns a `bitmask` indicating the new recording source ( or sources ) if successful ; raises OSError if an invalid source was specified .", "question_id": 7209}
{"snippet": "parser.expr(source)", "intent": "The expr ( ) function parses the parameter `source` as if it were an input to compile ( source , 'file.py ' , 'eval ' ) .", "question_id": 7210}
{"snippet": "parser.suite(source)", "intent": "The suite ( ) function parses the parameter `source` as if it were an input to compile ( source , 'file.py ' , 'exec ' ) .", "question_id": 7211}
{"snippet": "parser.sequence2st(sequence)", "intent": "This function accepts a parse tree represented as a `sequence` and builds an internal representation if possible .", "question_id": 7212}
{"snippet": "parser.tuple2st(sequence)", "intent": "This is the same function as sequence2st ( ) . With arguments `sequence`.", "question_id": 7213}
{"snippet": "parser.st2list(st)", "intent": "This function accepts an ST object from the caller in `st` and returns a Python list representing the equivalent parse tree .", "question_id": 7214}
{"snippet": "parser.st2list(st, line_info=False)", "intent": "This function accepts an ST object from the caller in `st` and returns a Python list representing the equivalent parse tree . If `line_info` is true , line number information will be included for all terminal tokens as a third element of the list representing the token .", "question_id": 7215}
{"snippet": "parser.st2list(st, col_info=False)", "intent": "This function accepts an ST object from the caller in `st` and returns a Python list representing the equivalent parse tree . With arguments `col_info`.", "question_id": 7216}
{"snippet": "parser.st2list(st, line_info=False, col_info=False)", "intent": "This function accepts an ST object from the caller in `st` and returns a Python list representing the equivalent parse tree . If `line_info` is true , line number information will be included for all terminal tokens as a third element of the list representing the token . With arguments `col_info`.", "question_id": 7217}
{"snippet": "parser.st2tuple(st)", "intent": "This function accepts an ST object from the caller in `st` and returns a Python tuple representing the equivalent parse tree .", "question_id": 7218}
{"snippet": "parser.st2tuple(st, line_info=False)", "intent": "This function accepts an ST object from the caller in `st` and returns a Python tuple representing the equivalent parse tree . If `line_info` is true , line number information will be included for all terminal tokens as a third element of the list representing the token .", "question_id": 7219}
{"snippet": "parser.st2tuple(st, col_info=False)", "intent": "This function accepts an ST object from the caller in `st` and returns a Python tuple representing the equivalent parse tree . With arguments `col_info`.", "question_id": 7220}
{"snippet": "parser.st2tuple(st, line_info=False, col_info=False)", "intent": "This function accepts an ST object from the caller in `st` and returns a Python tuple representing the equivalent parse tree . If `line_info` is true , line number information will be included for all terminal tokens as a third element of the list representing the token . With arguments `col_info`.", "question_id": 7221}
{"snippet": "parser.compilest(st)", "intent": "The Python byte compiler can be invoked on an ST object to produce code objects which can be used as part of a call to the built-in exec ( ) or eval ( ) functions . This function provides the interface to the compiler , passing the internal parse tree from `st` to the parser , using the source file name specified by the `filename` parameter .", "question_id": 7222}
{"snippet": "parser.compilest(st, filename='<syntax-tree>')", "intent": "The Python byte compiler can be invoked on an ST object to produce code objects which can be used as part of a call to the built-in exec ( ) or eval ( ) functions . This function provides the interface to the compiler , passing the internal parse tree from `st` to the parser , using the source file name specified by the `filename` parameter .", "question_id": 7223}
{"snippet": "parser.isexpr(st)", "intent": "When `st` represents an 'eval ' form , this function returns true , otherwise it returns false .", "question_id": 7224}
{"snippet": "parser.issuite(st)", "intent": "This function mirrors isexpr ( ) in that it reports whether an ST object represents an 'exec ' form , commonly known as a \u201c suite. \u201d It is not safe to assume that this function is equivalent to not isexpr ( `st` ) , as additional syntactic fragments may be supported in the future .", "question_id": 7225}
{"snippet": "parser.ParserError", "intent": "Exception raised when a failure occurs within the parser module.", "question_id": 7226}
{"snippet": "parser.STType", "intent": "The type of the objects returned by expr(), suite() and sequence2st().", "question_id": 7227}
{"snippet": "ST.compile()", "intent": "Same as compilest ( st , `filename` ) .", "question_id": 7228}
{"snippet": "ST.compile(filename='<syntax-tree>')", "intent": "Same as compilest ( st , `filename` ) .", "question_id": 7229}
{"snippet": "ST.isexpr()", "intent": "Same as isexpr ( st ) .", "question_id": 7230}
{"snippet": "ST.issuite()", "intent": "Same as issuite ( st ) .", "question_id": 7231}
{"snippet": "ST.tolist()", "intent": "Same as st2list ( st , `line_info` , `col_info` ) .", "question_id": 7232}
{"snippet": "ST.tolist(line_info=False)", "intent": "Same as st2list ( st , `line_info` , `col_info` ) .", "question_id": 7233}
{"snippet": "ST.tolist(col_info=False)", "intent": "Same as st2list ( st , `line_info` , `col_info` ) .", "question_id": 7234}
{"snippet": "ST.tolist(line_info=False, col_info=False)", "intent": "Same as st2list ( st , `line_info` , `col_info` ) .", "question_id": 7235}
{"snippet": "ST.totuple()", "intent": "Same as st2tuple ( st , `line_info` , `col_info` ) .", "question_id": 7236}
{"snippet": "ST.totuple(line_info=False)", "intent": "Same as st2tuple ( st , `line_info` , `col_info` ) .", "question_id": 7237}
{"snippet": "ST.totuple(col_info=False)", "intent": "Same as st2tuple ( st , `line_info` , `col_info` ) .", "question_id": 7238}
{"snippet": "ST.totuple(line_info=False, col_info=False)", "intent": "Same as st2tuple ( st , `line_info` , `col_info` ) .", "question_id": 7239}
{"snippet": "pathlib.PurePath(*pathsegments)", "intent": "A generic class that represents the system \u2019 s path flavour ( instantiating it creates either a PurePosixPath or a PureWindowsPath ) : With arguments `*pathsegments`.", "question_id": 7240}
{"snippet": "pathlib.PurePosixPath(*pathsegments)", "intent": "A subclass of PurePath , this path flavour represents non-Windows filesystem paths : With arguments `*pathsegments`.", "question_id": 7241}
{"snippet": "pathlib.PureWindowsPath(*pathsegments)", "intent": "A subclass of PurePath , this path flavour represents Windows filesystem paths : With arguments `*pathsegments`.", "question_id": 7242}
{"snippet": "PurePath.parts", "intent": "A tuple giving access to the path\u2019s various components:", "question_id": 7243}
{"snippet": "PurePath.drive", "intent": "A string representing the drive letter or name, if any:", "question_id": 7244}
{"snippet": "PurePath.root", "intent": "A string representing the (local or global) root, if any:", "question_id": 7245}
{"snippet": "PurePath.anchor", "intent": "The concatenation of the drive and root:", "question_id": 7246}
{"snippet": "PurePath.parents", "intent": "An immutable sequence providing access to the logical ancestors of the path:", "question_id": 7247}
{"snippet": "PurePath.parent", "intent": "The logical parent of the path:", "question_id": 7248}
{"snippet": "PurePath.name", "intent": "A string representing the final path component, excluding the drive and root, if any:", "question_id": 7249}
{"snippet": "PurePath.suffix", "intent": "The file extension of the final component, if any:", "question_id": 7250}
{"snippet": "PurePath.suffixes", "intent": "A list of the path\u2019s file extensions:", "question_id": 7251}
{"snippet": "PurePath.stem", "intent": "The final path component, without its suffix:", "question_id": 7252}
{"snippet": "PurePath.as_posix()", "intent": "Return a string representation of the path with forward slashes ( / ) :", "question_id": 7253}
{"snippet": "PurePath.as_uri()", "intent": "Represent the path as a file URI .", "question_id": 7254}
{"snippet": "PurePath.is_absolute()", "intent": "Return whether the path is absolute or not .", "question_id": 7255}
{"snippet": "PurePath.is_reserved()", "intent": "With PureWindowsPath , return True if the path is considered reserved under Windows , False otherwise .", "question_id": 7256}
{"snippet": "PurePath.joinpath(*other)", "intent": "Calling this method is equivalent to combining the path with each of the other arguments in turn : With arguments `*other`.", "question_id": 7257}
{"snippet": "PurePath.match(pattern)", "intent": "Match this path against the provided glob-style `pattern` .", "question_id": 7258}
{"snippet": "PurePath.relative_to(*other)", "intent": "Compute a version of this path relative to the path represented by other . With arguments `*other`.", "question_id": 7259}
{"snippet": "PurePath.with_name(name)", "intent": "Return a new path with the `name` changed .", "question_id": 7260}
{"snippet": "PurePath.with_suffix(suffix)", "intent": "Return a new path with the `suffix` changed .", "question_id": 7261}
{"snippet": "pathlib.Path(*pathsegments)", "intent": "A subclass of PurePath , this class represents concrete paths of the system \u2019 s path flavour ( instantiating it creates either a PosixPath or a WindowsPath ) : With arguments `*pathsegments`.", "question_id": 7262}
{"snippet": "pathlib.PosixPath(*pathsegments)", "intent": "A subclass of Path and PurePosixPath , this class represents concrete non-Windows filesystem paths : With arguments `*pathsegments`.", "question_id": 7263}
{"snippet": "pathlib.WindowsPath(*pathsegments)", "intent": "A subclass of Path and PureWindowsPath , this class represents concrete Windows filesystem paths : With arguments `*pathsegments`.", "question_id": 7264}
{"snippet": "Path.cwd()", "intent": "Return a new path object representing the current directory ( as returned by os.getcwd ( ) ) :", "question_id": 7265}
{"snippet": "Path.home()", "intent": "Return a new path object representing the user \u2019 s home directory ( as returned by os.path.expanduser ( ) with ~ construct ) :", "question_id": 7266}
{"snippet": "Path.stat()", "intent": "Return information about this path ( similarly to os.stat ( ) ) .", "question_id": 7267}
{"snippet": "Path.chmod(mode)", "intent": "Change the file `mode` and permissions , like os.chmod ( ) :", "question_id": 7268}
{"snippet": "Path.exists()", "intent": "Whether the path points to an existing file or directory :", "question_id": 7269}
{"snippet": "Path.expanduser()", "intent": "Return a new path with expanded ~ and ~user constructs , as returned by os.path.expanduser ( ) :", "question_id": 7270}
{"snippet": "Path.glob(pattern)", "intent": "Glob the given relative `pattern` in the directory represented by this path , yielding all matching files ( of any kind ) :", "question_id": 7271}
{"snippet": "Path.group()", "intent": "Return the name of the group owning the file .", "question_id": 7272}
{"snippet": "Path.is_dir()", "intent": "Return True if the path points to a directory ( or a symbolic link pointing to a directory ) , False if it points to another kind of file .", "question_id": 7273}
{"snippet": "Path.is_file()", "intent": "Return True if the path points to a regular file ( or a symbolic link pointing to a regular file ) , False if it points to another kind of file .", "question_id": 7274}
{"snippet": "Path.is_mount()", "intent": "Return True if the path is a mount point : a point in a file system where a different file system has been mounted .", "question_id": 7275}
{"snippet": "Path.is_symlink()", "intent": "Return True if the path points to a symbolic link , False otherwise .", "question_id": 7276}
{"snippet": "Path.is_socket()", "intent": "Return True if the path points to a Unix socket ( or a symbolic link pointing to a Unix socket ) , False if it points to another kind of file .", "question_id": 7277}
{"snippet": "Path.is_fifo()", "intent": "Return True if the path points to a FIFO ( or a symbolic link pointing to a FIFO ) , False if it points to another kind of file .", "question_id": 7278}
{"snippet": "Path.is_block_device()", "intent": "Return True if the path points to a block device ( or a symbolic link pointing to a block device ) , False if it points to another kind of file .", "question_id": 7279}
{"snippet": "Path.is_char_device()", "intent": "Return True if the path points to a character device ( or a symbolic link pointing to a character device ) , False if it points to another kind of file .", "question_id": 7280}
{"snippet": "Path.iterdir()", "intent": "When the path points to a directory , yield path objects of the directory contents :", "question_id": 7281}
{"snippet": "Path.lchmod(mode)", "intent": "Like Path.chmod ( ) but , if the path points to a symbolic link , the symbolic link \u2019 s `mode` is changed rather than its target \u2019 s .", "question_id": 7282}
{"snippet": "Path.lstat()", "intent": "Like Path.stat ( ) but , if the path points to a symbolic link , return the symbolic link \u2019 s information rather than its target \u2019 s .", "question_id": 7283}
{"snippet": "Path.mkdir()", "intent": "Create a new directory at this given path .", "question_id": 7284}
{"snippet": "Path.mkdir(mode=0o777)", "intent": "Create a new directory at this given path . If `mode` is given , it is combined with the process \u2019 umask value to determine the file mode and access flags .", "question_id": 7285}
{"snippet": "Path.mkdir(parents=False)", "intent": "Create a new directory at this given path . If `parents` is true , any missing parents of this path are created as needed ; they are created with the default permissions without taking mode into account ( mimicking the POSIX mkdir -p command ) .", "question_id": 7286}
{"snippet": "Path.mkdir(exist_ok=False)", "intent": "Create a new directory at this given path . If `exist_ok` is false ( the default ) , FileExistsError is raised if the target directory already exists .", "question_id": 7287}
{"snippet": "Path.mkdir(mode=0o777, parents=False)", "intent": "Create a new directory at this given path . If `mode` is given , it is combined with the process \u2019 umask value to determine the file mode and access flags . If `parents` is true , any missing parents of this path are created as needed ; they are created with the default permissions without taking mode into account ( mimicking the POSIX mkdir -p command ) .", "question_id": 7288}
{"snippet": "Path.mkdir(mode=0o777, exist_ok=False)", "intent": "Create a new directory at this given path . If `mode` is given , it is combined with the process \u2019 umask value to determine the file mode and access flags . If `exist_ok` is false ( the default ) , FileExistsError is raised if the target directory already exists .", "question_id": 7289}
{"snippet": "Path.mkdir(parents=False, exist_ok=False)", "intent": "Create a new directory at this given path . If `parents` is true , any missing parents of this path are created as needed ; they are created with the default permissions without taking mode into account ( mimicking the POSIX mkdir -p command ) . If `exist_ok` is false ( the default ) , FileExistsError is raised if the target directory already exists .", "question_id": 7290}
{"snippet": "Path.mkdir(mode=0o777, parents=False, exist_ok=False)", "intent": "Create a new directory at this given path . If `mode` is given , it is combined with the process \u2019 umask value to determine the file mode and access flags . If `parents` is true , any missing parents of this path are created as needed ; they are created with the default permissions without taking mode into account ( mimicking the POSIX mkdir -p command ) . If `exist_ok` is false ( the default ) , FileExistsError is raised if the target directory already exists .", "question_id": 7291}
{"snippet": "Path.open()", "intent": "Open the file pointed to by the path , like the built-in open ( ) function does :", "question_id": 7292}
{"snippet": "Path.open(mode='r')", "intent": "Open the file pointed to by the path , like the built-in open ( ) function does : With arguments `mode`.", "question_id": 7293}
{"snippet": "Path.open(buffering=-1)", "intent": "Open the file pointed to by the path , like the built-in open ( ) function does : With arguments `buffering`.", "question_id": 7294}
{"snippet": "Path.open(encoding=None)", "intent": "Open the file pointed to by the path , like the built-in open ( ) function does : With arguments `encoding`.", "question_id": 7295}
{"snippet": "Path.open(errors=None)", "intent": "Open the file pointed to by the path , like the built-in open ( ) function does : With arguments `errors`.", "question_id": 7296}
{"snippet": "Path.open(newline=None)", "intent": "Open the file pointed to by the path , like the built-in open ( ) function does : With arguments `newline`.", "question_id": 7297}
{"snippet": "Path.open(mode='r', buffering=-1)", "intent": "Open the file pointed to by the path , like the built-in open ( ) function does : With arguments `mode`, `buffering`.", "question_id": 7298}
{"snippet": "Path.open(mode='r', encoding=None)", "intent": "Open the file pointed to by the path , like the built-in open ( ) function does : With arguments `mode`, `encoding`.", "question_id": 7299}
{"snippet": "Path.open(mode='r', errors=None)", "intent": "Open the file pointed to by the path , like the built-in open ( ) function does : With arguments `mode`, `errors`.", "question_id": 7300}
{"snippet": "Path.open(mode='r', newline=None)", "intent": "Open the file pointed to by the path , like the built-in open ( ) function does : With arguments `mode`, `newline`.", "question_id": 7301}
{"snippet": "Path.owner()", "intent": "Return the name of the user owning the file .", "question_id": 7302}
{"snippet": "Path.read_bytes()", "intent": "Return the binary contents of the pointed-to file as a bytes object :", "question_id": 7303}
{"snippet": "Path.read_text()", "intent": "Return the decoded contents of the pointed-to file as a string :", "question_id": 7304}
{"snippet": "Path.read_text(encoding=None)", "intent": "Return the decoded contents of the pointed-to file as a string : With arguments `encoding`.", "question_id": 7305}
{"snippet": "Path.read_text(errors=None)", "intent": "Return the decoded contents of the pointed-to file as a string : With arguments `errors`.", "question_id": 7306}
{"snippet": "Path.read_text(encoding=None, errors=None)", "intent": "Return the decoded contents of the pointed-to file as a string : With arguments `encoding`, `errors`.", "question_id": 7307}
{"snippet": "Path.rename(target)", "intent": "Rename this file or directory to the given `target` .", "question_id": 7308}
{"snippet": "Path.replace(target)", "intent": "Rename this file or directory to the given `target` .", "question_id": 7309}
{"snippet": "Path.resolve()", "intent": "Make the path absolute , resolving any symlinks .", "question_id": 7310}
{"snippet": "Path.resolve(strict=False)", "intent": "Make the path absolute , resolving any symlinks . If the path doesn \u2019 t exist and `strict` is True , FileNotFoundError is raised .", "question_id": 7311}
{"snippet": "Path.rglob(pattern)", "intent": "This is like calling Path.glob ( ) with \u201c **/ \u201d added in front of the given relative `pattern` :", "question_id": 7312}
{"snippet": "Path.rmdir()", "intent": "Remove this directory .", "question_id": 7313}
{"snippet": "Path.samefile(other_path)", "intent": "Return whether this path points to the same file as `other_path` , which can be either a Path object , or a string .", "question_id": 7314}
{"snippet": "Path.symlink_to(target)", "intent": "Make this path a symbolic link to `target` .", "question_id": 7315}
{"snippet": "Path.symlink_to(target, target_is_directory=False)", "intent": "Make this path a symbolic link to `target` . Under Windows , `target_is_directory` must be true ( default False ) if the link \u2019 s target is a directory .", "question_id": 7316}
{"snippet": "Path.touch()", "intent": "Create a file at this given path .", "question_id": 7317}
{"snippet": "Path.touch(mode=0o666)", "intent": "Create a file at this given path . If `mode` is given , it is combined with the process \u2019 umask value to determine the file mode and access flags .", "question_id": 7318}
{"snippet": "Path.touch(exist_ok=True)", "intent": "Create a file at this given path . If the file already exists , the function succeeds if `exist_ok` is true ( and its modification time is updated to the current time ) , otherwise FileExistsError is raised .", "question_id": 7319}
{"snippet": "Path.touch(mode=0o666, exist_ok=True)", "intent": "Create a file at this given path . If `mode` is given , it is combined with the process \u2019 umask value to determine the file mode and access flags . If the file already exists , the function succeeds if `exist_ok` is true ( and its modification time is updated to the current time ) , otherwise FileExistsError is raised .", "question_id": 7320}
{"snippet": "Path.unlink()", "intent": "Remove this file or symbolic link .", "question_id": 7321}
{"snippet": "Path.write_bytes(data)", "intent": "Open the file pointed to in bytes mode , write `data` to it , and close the file :", "question_id": 7322}
{"snippet": "Path.write_text(data)", "intent": "Open the file pointed to in text mode , write `data` to it , and close the file :", "question_id": 7323}
{"snippet": "Path.write_text(data, encoding=None)", "intent": "Open the file pointed to in text mode , write `data` to it , and close the file : With arguments `encoding`.", "question_id": 7324}
{"snippet": "Path.write_text(data, errors=None)", "intent": "Open the file pointed to in text mode , write `data` to it , and close the file : With arguments `errors`.", "question_id": 7325}
{"snippet": "Path.write_text(data, encoding=None, errors=None)", "intent": "Open the file pointed to in text mode , write `data` to it , and close the file : With arguments `encoding`, `errors`.", "question_id": 7326}
{"snippet": "pdb.run(statement)", "intent": "Execute the `statement` ( given as a string or a code object ) under debugger control .", "question_id": 7327}
{"snippet": "pdb.run(statement, globals=None)", "intent": "Execute the `statement` ( given as a string or a code object ) under debugger control . The optional `globals` and `locals` arguments specify the environment in which the code is executed ; by default the dictionary of the module __main__ is used .", "question_id": 7328}
{"snippet": "pdb.run(statement, locals=None)", "intent": "Execute the `statement` ( given as a string or a code object ) under debugger control . The optional `globals` and `locals` arguments specify the environment in which the code is executed ; by default the dictionary of the module __main__ is used .", "question_id": 7329}
{"snippet": "pdb.run(statement, globals=None, locals=None)", "intent": "Execute the `statement` ( given as a string or a code object ) under debugger control . The optional `globals` and `locals` arguments specify the environment in which the code is executed ; by default the dictionary of the module __main__ is used .", "question_id": 7330}
{"snippet": "pdb.runeval(expression)", "intent": "Evaluate the `expression` ( given as a string or a code object ) under debugger control .", "question_id": 7331}
{"snippet": "pdb.runeval(expression, globals=None)", "intent": "Evaluate the `expression` ( given as a string or a code object ) under debugger control . With arguments `globals`.", "question_id": 7332}
{"snippet": "pdb.runeval(expression, locals=None)", "intent": "Evaluate the `expression` ( given as a string or a code object ) under debugger control . With arguments `locals`.", "question_id": 7333}
{"snippet": "pdb.runeval(expression, globals=None, locals=None)", "intent": "Evaluate the `expression` ( given as a string or a code object ) under debugger control . With arguments `globals`, `locals`.", "question_id": 7334}
{"snippet": "pdb.runcall(function, *args, **kwds)", "intent": "Call the `function` ( a function or method object , not a string ) with the given arguments . With arguments `*args`, `**kwds`.", "question_id": 7335}
{"snippet": "pdb.set_trace()", "intent": "Enter the debugger at the calling stack frame .", "question_id": 7336}
{"snippet": "pdb.set_trace(header=None)", "intent": "Enter the debugger at the calling stack frame . If given , `header` is printed to the console just before debugging begins .", "question_id": 7337}
{"snippet": "pdb.post_mortem()", "intent": "Enter post-mortem debugging of the given `traceback` object .", "question_id": 7338}
{"snippet": "pdb.post_mortem(traceback=None)", "intent": "Enter post-mortem debugging of the given `traceback` object .", "question_id": 7339}
{"snippet": "pdb.pm()", "intent": "Enter post-mortem debugging of the traceback found in sys.last_traceback .", "question_id": 7340}
{"snippet": "pdb.Pdb()", "intent": "Pdb is the debugger class .", "question_id": 7341}
{"snippet": "pdb.Pdb(completekey='tab')", "intent": "Pdb is the debugger class . The `completekey` , `stdin` and `stdout` arguments are passed to the underlying cmd.Cmd class ; see the description there .", "question_id": 7342}
{"snippet": "pdb.Pdb(stdin=None)", "intent": "Pdb is the debugger class . The `completekey` , `stdin` and `stdout` arguments are passed to the underlying cmd.Cmd class ; see the description there .", "question_id": 7343}
{"snippet": "pdb.Pdb(stdout=None)", "intent": "Pdb is the debugger class . The `completekey` , `stdin` and `stdout` arguments are passed to the underlying cmd.Cmd class ; see the description there .", "question_id": 7344}
{"snippet": "pdb.Pdb(skip=None)", "intent": "Pdb is the debugger class . The `skip` argument , if given , must be an iterable of glob-style module name patterns .", "question_id": 7345}
{"snippet": "pdb.Pdb(nosigint=False)", "intent": "Pdb is the debugger class . If you want Pdb not to touch the SIGINT handler , set `nosigint` to true .", "question_id": 7346}
{"snippet": "pdb.Pdb(readrc=True)", "intent": "Pdb is the debugger class . The `readrc` argument defaults to true and controls whether Pdb will load .pdbrc files from the filesystem .", "question_id": 7347}
{"snippet": "pdb.Pdb(completekey='tab', stdin=None)", "intent": "Pdb is the debugger class . The `completekey` , `stdin` and `stdout` arguments are passed to the underlying cmd.Cmd class ; see the description there .", "question_id": 7348}
{"snippet": "pdb.Pdb(completekey='tab', stdout=None)", "intent": "Pdb is the debugger class . The `completekey` , `stdin` and `stdout` arguments are passed to the underlying cmd.Cmd class ; see the description there .", "question_id": 7349}
{"snippet": "pdb.Pdb(completekey='tab', skip=None)", "intent": "Pdb is the debugger class . The `completekey` , `stdin` and `stdout` arguments are passed to the underlying cmd.Cmd class ; see the description there . The `skip` argument , if given , must be an iterable of glob-style module name patterns .", "question_id": 7350}
{"snippet": "pdb.run(statement)", "intent": "See the documentation for the functions explained above . With arguments `statement`.", "question_id": 7351}
{"snippet": "pdb.run(statement, globals=None)", "intent": "See the documentation for the functions explained above . With arguments `statement`, `globals`.", "question_id": 7352}
{"snippet": "pdb.run(statement, locals=None)", "intent": "See the documentation for the functions explained above . With arguments `statement`, `locals`.", "question_id": 7353}
{"snippet": "pdb.run(statement, globals=None, locals=None)", "intent": "See the documentation for the functions explained above . With arguments `statement`, `globals`, `locals`.", "question_id": 7354}
{"snippet": "pdb.runeval(expression)", "intent": "See the documentation for the functions explained above . With arguments `expression`.", "question_id": 7355}
{"snippet": "pdb.runeval(expression, globals=None)", "intent": "See the documentation for the functions explained above . With arguments `expression`, `globals`.", "question_id": 7356}
{"snippet": "pdb.runeval(expression, locals=None)", "intent": "See the documentation for the functions explained above . With arguments `expression`, `locals`.", "question_id": 7357}
{"snippet": "pdb.runeval(expression, globals=None, locals=None)", "intent": "See the documentation for the functions explained above . With arguments `expression`, `globals`, `locals`.", "question_id": 7358}
{"snippet": "pdb.runcall(function, *args, **kwds)", "intent": "See the documentation for the functions explained above . With arguments `function`, `*args`, `**kwds`.", "question_id": 7359}
{"snippet": "pdb.set_trace()", "intent": "See the documentation for the functions explained above .", "question_id": 7360}
{"snippet": "pickle.HIGHEST_PROTOCOL", "intent": "An integer, the highest protocol version available.", "question_id": 7361}
{"snippet": "pickle.DEFAULT_PROTOCOL", "intent": "An integer, the default protocol version used for pickling.", "question_id": 7362}
{"snippet": "pickle.dump(obj, file)", "intent": "Write the pickled representation of the object `obj` to the open `file` object file .", "question_id": 7363}
{"snippet": "pickle.dump(obj, file, protocol=None)", "intent": "Write the pickled representation of the object `obj` to the open `file` object file . This is equivalent to Pickler ( file , `protocol` ) .dump ( obj ) .", "question_id": 7364}
{"snippet": "pickle.dump(obj, file, fix_imports=True)", "intent": "Write the pickled representation of the object `obj` to the open `file` object file . If `fix_imports` is true and protocol is less than 3 , pickle will try to map the new Python 3 names to the old module names used in Python 2 , so that the pickle data stream is readable with Python 2 .", "question_id": 7365}
{"snippet": "pickle.dump(obj, file, protocol=None, fix_imports=True)", "intent": "Write the pickled representation of the object `obj` to the open `file` object file . This is equivalent to Pickler ( file , `protocol` ) .dump ( obj ) . If `fix_imports` is true and protocol is less than 3 , pickle will try to map the new Python 3 names to the old module names used in Python 2 , so that the pickle data stream is readable with Python 2 .", "question_id": 7366}
{"snippet": "pickle.dumps(obj)", "intent": "Return the pickled representation of the object `obj` as a bytes object , instead of writing it to a file .", "question_id": 7367}
{"snippet": "pickle.dumps(obj, protocol=None)", "intent": "Return the pickled representation of the object `obj` as a bytes object , instead of writing it to a file . Arguments `protocol` and `fix_imports` have the same meaning as in dump ( ) .", "question_id": 7368}
{"snippet": "pickle.dumps(obj, fix_imports=True)", "intent": "Return the pickled representation of the object `obj` as a bytes object , instead of writing it to a file . Arguments `protocol` and `fix_imports` have the same meaning as in dump ( ) .", "question_id": 7369}
{"snippet": "pickle.dumps(obj, protocol=None, fix_imports=True)", "intent": "Return the pickled representation of the object `obj` as a bytes object , instead of writing it to a file . Arguments `protocol` and `fix_imports` have the same meaning as in dump ( ) .", "question_id": 7370}
{"snippet": "pickle.load(file)", "intent": "Read the pickled representation of an object from the open `file` object file and return the reconstituted object hierarchy specified therein .", "question_id": 7371}
{"snippet": "pickle.load(file, fix_imports=True)", "intent": "Read the pickled representation of an object from the open `file` object file and return the reconstituted object hierarchy specified therein . Optional keyword arguments are `fix_imports` , `encoding` and `errors` , which are used to control compatibility support for pickle stream generated by Python 2 .", "question_id": 7372}
{"snippet": "pickle.load(file, encoding=\"ASCII\")", "intent": "Read the pickled representation of an object from the open `file` object file and return the reconstituted object hierarchy specified therein . Optional keyword arguments are `fix_imports` , `encoding` and `errors` , which are used to control compatibility support for pickle stream generated by Python 2 .", "question_id": 7373}
{"snippet": "pickle.load(file, errors=\"strict\")", "intent": "Read the pickled representation of an object from the open `file` object file and return the reconstituted object hierarchy specified therein . Optional keyword arguments are `fix_imports` , `encoding` and `errors` , which are used to control compatibility support for pickle stream generated by Python 2 .", "question_id": 7374}
{"snippet": "pickle.load(file, fix_imports=True, encoding=\"ASCII\")", "intent": "Read the pickled representation of an object from the open `file` object file and return the reconstituted object hierarchy specified therein . Optional keyword arguments are `fix_imports` , `encoding` and `errors` , which are used to control compatibility support for pickle stream generated by Python 2 .", "question_id": 7375}
{"snippet": "pickle.load(file, fix_imports=True, errors=\"strict\")", "intent": "Read the pickled representation of an object from the open `file` object file and return the reconstituted object hierarchy specified therein . Optional keyword arguments are `fix_imports` , `encoding` and `errors` , which are used to control compatibility support for pickle stream generated by Python 2 .", "question_id": 7376}
{"snippet": "pickle.load(file, encoding=\"ASCII\", errors=\"strict\")", "intent": "Read the pickled representation of an object from the open `file` object file and return the reconstituted object hierarchy specified therein . Optional keyword arguments are `fix_imports` , `encoding` and `errors` , which are used to control compatibility support for pickle stream generated by Python 2 .", "question_id": 7377}
{"snippet": "pickle.load(file, fix_imports=True, encoding=\"ASCII\", errors=\"strict\")", "intent": "Read the pickled representation of an object from the open `file` object file and return the reconstituted object hierarchy specified therein . Optional keyword arguments are `fix_imports` , `encoding` and `errors` , which are used to control compatibility support for pickle stream generated by Python 2 .", "question_id": 7378}
{"snippet": "pickle.loads(bytes_object)", "intent": "Return the reconstituted object hierarchy of the pickled representation `bytes_object` of an object .", "question_id": 7379}
{"snippet": "pickle.loads(bytes_object, fix_imports=True)", "intent": "Return the reconstituted object hierarchy of the pickled representation `bytes_object` of an object . Optional keyword arguments are `fix_imports` , `encoding` and `errors` , which are used to control compatibility support for pickle stream generated by Python 2 .", "question_id": 7380}
{"snippet": "pickle.loads(bytes_object, encoding=\"ASCII\")", "intent": "Return the reconstituted object hierarchy of the pickled representation `bytes_object` of an object . Optional keyword arguments are `fix_imports` , `encoding` and `errors` , which are used to control compatibility support for pickle stream generated by Python 2 .", "question_id": 7381}
{"snippet": "pickle.loads(bytes_object, errors=\"strict\")", "intent": "Return the reconstituted object hierarchy of the pickled representation `bytes_object` of an object . Optional keyword arguments are `fix_imports` , `encoding` and `errors` , which are used to control compatibility support for pickle stream generated by Python 2 .", "question_id": 7382}
{"snippet": "pickle.loads(bytes_object, fix_imports=True, encoding=\"ASCII\")", "intent": "Return the reconstituted object hierarchy of the pickled representation `bytes_object` of an object . Optional keyword arguments are `fix_imports` , `encoding` and `errors` , which are used to control compatibility support for pickle stream generated by Python 2 .", "question_id": 7383}
{"snippet": "pickle.loads(bytes_object, fix_imports=True, errors=\"strict\")", "intent": "Return the reconstituted object hierarchy of the pickled representation `bytes_object` of an object . Optional keyword arguments are `fix_imports` , `encoding` and `errors` , which are used to control compatibility support for pickle stream generated by Python 2 .", "question_id": 7384}
{"snippet": "pickle.loads(bytes_object, encoding=\"ASCII\", errors=\"strict\")", "intent": "Return the reconstituted object hierarchy of the pickled representation `bytes_object` of an object . Optional keyword arguments are `fix_imports` , `encoding` and `errors` , which are used to control compatibility support for pickle stream generated by Python 2 .", "question_id": 7385}
{"snippet": "pickle.loads(bytes_object, fix_imports=True, encoding=\"ASCII\", errors=\"strict\")", "intent": "Return the reconstituted object hierarchy of the pickled representation `bytes_object` of an object . Optional keyword arguments are `fix_imports` , `encoding` and `errors` , which are used to control compatibility support for pickle stream generated by Python 2 .", "question_id": 7386}
{"snippet": "pickle.PickleError", "intent": "Common base class for the other pickling exceptions.", "question_id": 7387}
{"snippet": "pickle.PicklingError", "intent": "Error raised when an unpicklable object is encountered by Pickler.", "question_id": 7388}
{"snippet": "pickle.UnpicklingError", "intent": "Error raised when there is a problem unpickling an object, such as a data corruption or a security violation.", "question_id": 7389}
{"snippet": "pickle.Pickler(file)", "intent": "This takes a binary `file` for writing a pickle data stream .", "question_id": 7390}
{"snippet": "pickle.Pickler(file, protocol=None)", "intent": "This takes a binary `file` for writing a pickle data stream . The optional `protocol` argument , an integer , tells the pickler to use the given protocol ; supported protocols are 0 to HIGHEST_PROTOCOL .", "question_id": 7391}
{"snippet": "pickle.Pickler(file, fix_imports=True)", "intent": "This takes a binary `file` for writing a pickle data stream . If `fix_imports` is true and protocol is less than 3 , pickle will try to map the new Python 3 names to the old module names used in Python 2 , so that the pickle data stream is readable with Python 2 .", "question_id": 7392}
{"snippet": "pickle.Pickler(file, protocol=None, fix_imports=True)", "intent": "This takes a binary `file` for writing a pickle data stream . The optional `protocol` argument , an integer , tells the pickler to use the given protocol ; supported protocols are 0 to HIGHEST_PROTOCOL . If `fix_imports` is true and protocol is less than 3 , pickle will try to map the new Python 3 names to the old module names used in Python 2 , so that the pickle data stream is readable with Python 2 .", "question_id": 7393}
{"snippet": "pickler.dump(obj)", "intent": "Write the pickled representation of `obj` to the open file object given in the constructor .", "question_id": 7394}
{"snippet": "pickler.persistent_id(obj)", "intent": "Do nothing by default . If persistent_id ( ) returns None , `obj` is pickled as usual .", "question_id": 7395}
{"snippet": "pickler.dispatch_table", "intent": "A pickler object\u2019s dispatch table is a registry of reduction functions of the kind which can be declared using copyreg.pickle().", "question_id": 7396}
{"snippet": "pickler.fast", "intent": "Deprecated.", "question_id": 7397}
{"snippet": "pickle.Unpickler(file)", "intent": "This takes a binary `file` for reading a pickle data stream .", "question_id": 7398}
{"snippet": "pickle.Unpickler(file, fix_imports=True)", "intent": "This takes a binary `file` for reading a pickle data stream . Optional keyword arguments are `fix_imports` , `encoding` and `errors` , which are used to control compatibility support for pickle stream generated by Python 2 .", "question_id": 7399}
{"snippet": "pickle.Unpickler(file, encoding=\"ASCII\")", "intent": "This takes a binary `file` for reading a pickle data stream . Optional keyword arguments are `fix_imports` , `encoding` and `errors` , which are used to control compatibility support for pickle stream generated by Python 2 .", "question_id": 7400}
{"snippet": "pickle.Unpickler(file, errors=\"strict\")", "intent": "This takes a binary `file` for reading a pickle data stream . Optional keyword arguments are `fix_imports` , `encoding` and `errors` , which are used to control compatibility support for pickle stream generated by Python 2 .", "question_id": 7401}
{"snippet": "pickle.Unpickler(file, fix_imports=True, encoding=\"ASCII\")", "intent": "This takes a binary `file` for reading a pickle data stream . Optional keyword arguments are `fix_imports` , `encoding` and `errors` , which are used to control compatibility support for pickle stream generated by Python 2 .", "question_id": 7402}
{"snippet": "pickle.Unpickler(file, fix_imports=True, errors=\"strict\")", "intent": "This takes a binary `file` for reading a pickle data stream . Optional keyword arguments are `fix_imports` , `encoding` and `errors` , which are used to control compatibility support for pickle stream generated by Python 2 .", "question_id": 7403}
{"snippet": "pickle.Unpickler(file, encoding=\"ASCII\", errors=\"strict\")", "intent": "This takes a binary `file` for reading a pickle data stream . Optional keyword arguments are `fix_imports` , `encoding` and `errors` , which are used to control compatibility support for pickle stream generated by Python 2 .", "question_id": 7404}
{"snippet": "pickle.Unpickler(file, fix_imports=True, encoding=\"ASCII\", errors=\"strict\")", "intent": "This takes a binary `file` for reading a pickle data stream . Optional keyword arguments are `fix_imports` , `encoding` and `errors` , which are used to control compatibility support for pickle stream generated by Python 2 .", "question_id": 7405}
{"snippet": "unpickler.load()", "intent": "Read the pickled representation of an object from the open file object given in the constructor , and return the reconstituted object hierarchy specified therein .", "question_id": 7406}
{"snippet": "unpickler.persistent_load(pid)", "intent": "Raise an UnpicklingError by default . If defined , persistent_load ( ) should return the object specified by the persistent ID `pid` .", "question_id": 7407}
{"snippet": "unpickler.find_class(module, name)", "intent": "Import `module` if necessary and return the object called `name` from it , where the module and name arguments are str objects .", "question_id": 7408}
{"snippet": "object.__getnewargs_ex__()", "intent": "In protocols 2 and newer , classes that implements the __getnewargs_ex__ ( ) method can dictate the values passed to the __new__ ( ) method upon unpickling .", "question_id": 7409}
{"snippet": "object.__getnewargs__()", "intent": "This method serves a similar purpose as __getnewargs_ex__ ( ) , but supports only positional arguments .", "question_id": 7410}
{"snippet": "object.__getstate__()", "intent": "Classes can further influence how their instances are pickled ; if the class defines the method __getstate__ ( ) , it is called and the returned object is pickled as the contents for the instance , instead of the contents of the instance \u2019 s dictionary .", "question_id": 7411}
{"snippet": "object.__setstate__(state)", "intent": "Upon unpickling , if the class defines __setstate__ ( ) , it is called with the unpickled `state` .", "question_id": 7412}
{"snippet": "object.__reduce__()", "intent": "The interface is currently defined as follows .", "question_id": 7413}
{"snippet": "object.__reduce_ex__(protocol)", "intent": "Alternatively , a __reduce_ex__ ( ) method may be defined . The only difference is this method should take a single integer argument , the `protocol` version .", "question_id": 7414}
{"snippet": "pickletools.dis(pickle)", "intent": "Outputs a symbolic disassembly of the `pickle` to the file-like object `out` , defaulting to sys.stdout .", "question_id": 7415}
{"snippet": "pickletools.dis(pickle, out=None)", "intent": "Outputs a symbolic disassembly of the `pickle` to the file-like object `out` , defaulting to sys.stdout .", "question_id": 7416}
{"snippet": "pickletools.dis(pickle, memo=None)", "intent": "Outputs a symbolic disassembly of the `pickle` to the file-like object `out` , defaulting to sys.stdout . `memo` can be a Python dictionary that will be used as the pickle \u2019 s memo ; it can be used to perform disassemblies across multiple pickles created by the same pickler .", "question_id": 7417}
{"snippet": "pickletools.dis(pickle, indentlevel=4)", "intent": "Outputs a symbolic disassembly of the `pickle` to the file-like object `out` , defaulting to sys.stdout . Successive levels , indicated by MARK opcodes in the stream , are indented by `indentlevel` spaces .", "question_id": 7418}
{"snippet": "pickletools.dis(pickle, annotate=0)", "intent": "Outputs a symbolic disassembly of the `pickle` to the file-like object `out` , defaulting to sys.stdout . If a nonzero value is given to `annotate` , each opcode in the output is annotated with a short description .", "question_id": 7419}
{"snippet": "pickletools.dis(pickle, out=None, memo=None)", "intent": "Outputs a symbolic disassembly of the `pickle` to the file-like object `out` , defaulting to sys.stdout . `memo` can be a Python dictionary that will be used as the pickle \u2019 s memo ; it can be used to perform disassemblies across multiple pickles created by the same pickler .", "question_id": 7420}
{"snippet": "pickletools.dis(pickle, out=None, indentlevel=4)", "intent": "Outputs a symbolic disassembly of the `pickle` to the file-like object `out` , defaulting to sys.stdout . Successive levels , indicated by MARK opcodes in the stream , are indented by `indentlevel` spaces .", "question_id": 7421}
{"snippet": "pickletools.dis(pickle, out=None, annotate=0)", "intent": "Outputs a symbolic disassembly of the `pickle` to the file-like object `out` , defaulting to sys.stdout . If a nonzero value is given to `annotate` , each opcode in the output is annotated with a short description .", "question_id": 7422}
{"snippet": "pickletools.dis(pickle, memo=None, indentlevel=4)", "intent": "Outputs a symbolic disassembly of the `pickle` to the file-like object `out` , defaulting to sys.stdout . `memo` can be a Python dictionary that will be used as the pickle \u2019 s memo ; it can be used to perform disassemblies across multiple pickles created by the same pickler . Successive levels , indicated by MARK opcodes in the stream , are indented by `indentlevel` spaces .", "question_id": 7423}
{"snippet": "pickletools.dis(pickle, memo=None, annotate=0)", "intent": "Outputs a symbolic disassembly of the `pickle` to the file-like object `out` , defaulting to sys.stdout . `memo` can be a Python dictionary that will be used as the pickle \u2019 s memo ; it can be used to perform disassemblies across multiple pickles created by the same pickler . If a nonzero value is given to `annotate` , each opcode in the output is annotated with a short description .", "question_id": 7424}
{"snippet": "pickletools.genops(pickle)", "intent": "Provides an iterator over all of the opcodes in a `pickle` , returning a sequence of ( opcode , arg , pos ) triples .", "question_id": 7425}
{"snippet": "pickletools.optimize(picklestring)", "intent": "Returns a new equivalent pickle string after eliminating unused PUT opcodes . With arguments `picklestring`.", "question_id": 7426}
{"snippet": "pipes.Template", "intent": "An abstraction of a pipeline.", "question_id": 7427}
{"snippet": "Template.reset()", "intent": "Restore a pipeline template to its initial state .", "question_id": 7428}
{"snippet": "Template.clone()", "intent": "Return a new , equivalent , pipeline template .", "question_id": 7429}
{"snippet": "Template.debug(flag)", "intent": "If `flag` is true , turn debugging on .", "question_id": 7430}
{"snippet": "Template.append(cmd, kind)", "intent": "Append a new action at the end . The `cmd` variable must be a valid bourne shell command . The `kind` variable consists of two letters .", "question_id": 7431}
{"snippet": "Template.prepend(cmd, kind)", "intent": "Add a new action at the beginning . With arguments `cmd`, `kind`.", "question_id": 7432}
{"snippet": "Template.open(file, mode)", "intent": "Return a file-like object , open to `file` , but read from or written to by the pipeline . With arguments `mode`.", "question_id": 7433}
{"snippet": "Template.copy(infile, outfile)", "intent": "Copy `infile` to `outfile` through the pipe .", "question_id": 7434}
{"snippet": "pkgutil.ModuleInfo(module_finder, name, ispkg)", "intent": "A namedtuple that holds a brief summary of a module \u2019 s info . With arguments `module_finder`, `name`, `ispkg`.", "question_id": 7435}
{"snippet": "pkgutil.extend_path(path, name)", "intent": "Extend the search `path` for the modules which comprise a package . It also looks for *.pkg files beginning where * matches the `name` argument .", "question_id": 7436}
{"snippet": "pkgutil.ImpImporter()", "intent": "PEP 302 Finder that wraps Python \u2019 s \u201c classic \u201d import algorithm .", "question_id": 7437}
{"snippet": "pkgutil.ImpImporter(dirname=None)", "intent": "PEP 302 Finder that wraps Python \u2019 s \u201c classic \u201d import algorithm . If `dirname` is a string , a PEP 302 finder is created that searches that directory .", "question_id": 7438}
{"snippet": "pkgutil.ImpLoader(fullname, file, filename, etc)", "intent": "Loader that wraps Python \u2019 s \u201c classic \u201d import algorithm . With arguments `fullname`, `file`, `filename`, `etc`.", "question_id": 7439}
{"snippet": "pkgutil.find_loader(fullname)", "intent": "Retrieve a module loader for the given `fullname` .", "question_id": 7440}
{"snippet": "pkgutil.get_importer(path_item)", "intent": "Retrieve a finder for the given `path_item` .", "question_id": 7441}
{"snippet": "pkgutil.get_loader(module_or_name)", "intent": "Get a loader object for `module_or_name` .", "question_id": 7442}
{"snippet": "pkgutil.iter_importers()", "intent": "Yield finder objects for the given module name .", "question_id": 7443}
{"snippet": "pkgutil.iter_importers(fullname='')", "intent": "Yield finder objects for the given module name . If `fullname` contains a \u2018 . \u2019 , the finders will be for the package containing fullname , otherwise they will be all registered top level finders ( i.e .", "question_id": 7444}
{"snippet": "pkgutil.iter_modules()", "intent": "Yields ModuleInfo for all submodules on `path` , or , if path is None , all top-level modules on sys.path .", "question_id": 7445}
{"snippet": "pkgutil.iter_modules(path=None)", "intent": "Yields ModuleInfo for all submodules on `path` , or , if path is None , all top-level modules on sys.path .", "question_id": 7446}
{"snippet": "pkgutil.iter_modules(prefix='')", "intent": "Yields ModuleInfo for all submodules on `path` , or , if path is None , all top-level modules on sys.path . `prefix` is a string to output on the front of every module name on output .", "question_id": 7447}
{"snippet": "pkgutil.iter_modules(path=None, prefix='')", "intent": "Yields ModuleInfo for all submodules on `path` , or , if path is None , all top-level modules on sys.path . `prefix` is a string to output on the front of every module name on output .", "question_id": 7448}
{"snippet": "pkgutil.walk_packages()", "intent": "Yields ModuleInfo for all modules recursively on `path` , or , if path is None , all accessible modules .", "question_id": 7449}
{"snippet": "pkgutil.walk_packages(path=None)", "intent": "Yields ModuleInfo for all modules recursively on `path` , or , if path is None , all accessible modules .", "question_id": 7450}
{"snippet": "pkgutil.walk_packages(prefix='')", "intent": "Yields ModuleInfo for all modules recursively on `path` , or , if path is None , all accessible modules . `prefix` is a string to output on the front of every module name on output .", "question_id": 7451}
{"snippet": "pkgutil.walk_packages(onerror=None)", "intent": "Yields ModuleInfo for all modules recursively on `path` , or , if path is None , all accessible modules . `onerror` is a function which gets called with one argument ( the name of the package which was being imported ) if any exception occurs while trying to import a package .", "question_id": 7452}
{"snippet": "pkgutil.walk_packages(path=None, prefix='')", "intent": "Yields ModuleInfo for all modules recursively on `path` , or , if path is None , all accessible modules . `prefix` is a string to output on the front of every module name on output .", "question_id": 7453}
{"snippet": "pkgutil.walk_packages(path=None, onerror=None)", "intent": "Yields ModuleInfo for all modules recursively on `path` , or , if path is None , all accessible modules . `onerror` is a function which gets called with one argument ( the name of the package which was being imported ) if any exception occurs while trying to import a package .", "question_id": 7454}
{"snippet": "pkgutil.walk_packages(prefix='', onerror=None)", "intent": "Yields ModuleInfo for all modules recursively on `path` , or , if path is None , all accessible modules . `prefix` is a string to output on the front of every module name on output . `onerror` is a function which gets called with one argument ( the name of the package which was being imported ) if any exception occurs while trying to import a package .", "question_id": 7455}
{"snippet": "pkgutil.walk_packages(path=None, prefix='', onerror=None)", "intent": "Yields ModuleInfo for all modules recursively on `path` , or , if path is None , all accessible modules . `prefix` is a string to output on the front of every module name on output . `onerror` is a function which gets called with one argument ( the name of the package which was being imported ) if any exception occurs while trying to import a package .", "question_id": 7456}
{"snippet": "pkgutil.get_data(package, resource)", "intent": "Get a `resource` from a `package` .", "question_id": 7457}
{"snippet": "platform.architecture()", "intent": "Queries the given `executable` ( defaults to the Python interpreter binary ) for various architecture information .", "question_id": 7458}
{"snippet": "platform.architecture(executable=sys.executable)", "intent": "Queries the given `executable` ( defaults to the Python interpreter binary ) for various architecture information .", "question_id": 7459}
{"snippet": "platform.architecture(bits='')", "intent": "Queries the given `executable` ( defaults to the Python interpreter binary ) for various architecture information . Returns a tuple ( `bits` , `linkage` ) which contain information about the bit architecture and the linkage format used for the executable .", "question_id": 7460}
{"snippet": "platform.architecture(linkage='')", "intent": "Queries the given `executable` ( defaults to the Python interpreter binary ) for various architecture information . Returns a tuple ( `bits` , `linkage` ) which contain information about the bit architecture and the linkage format used for the executable .", "question_id": 7461}
{"snippet": "platform.architecture(executable=sys.executable, bits='')", "intent": "Queries the given `executable` ( defaults to the Python interpreter binary ) for various architecture information . Returns a tuple ( `bits` , `linkage` ) which contain information about the bit architecture and the linkage format used for the executable .", "question_id": 7462}
{"snippet": "platform.architecture(executable=sys.executable, linkage='')", "intent": "Queries the given `executable` ( defaults to the Python interpreter binary ) for various architecture information . Returns a tuple ( `bits` , `linkage` ) which contain information about the bit architecture and the linkage format used for the executable .", "question_id": 7463}
{"snippet": "platform.architecture(bits='', linkage='')", "intent": "Queries the given `executable` ( defaults to the Python interpreter binary ) for various architecture information . Returns a tuple ( `bits` , `linkage` ) which contain information about the bit architecture and the linkage format used for the executable .", "question_id": 7464}
{"snippet": "platform.architecture(executable=sys.executable, bits='', linkage='')", "intent": "Queries the given `executable` ( defaults to the Python interpreter binary ) for various architecture information . Returns a tuple ( `bits` , `linkage` ) which contain information about the bit architecture and the linkage format used for the executable .", "question_id": 7465}
{"snippet": "platform.machine()", "intent": "Returns the machine type , e.g .", "question_id": 7466}
{"snippet": "platform.node()", "intent": "Returns the computer \u2019 s network name ( may not be fully qualified ! ) .", "question_id": 7467}
{"snippet": "platform.platform()", "intent": "Returns a single string identifying the underlying platform with as much useful information as possible .", "question_id": 7468}
{"snippet": "platform.platform(aliased=0)", "intent": "Returns a single string identifying the underlying platform with as much useful information as possible . If `aliased` is true , the function will use aliases for various platforms that report system names which differ from their common names , for example SunOS will be reported as Solaris .", "question_id": 7469}
{"snippet": "platform.platform(terse=0)", "intent": "Returns a single string identifying the underlying platform with as much useful information as possible . Setting `terse` to true causes the function to return only the absolute minimum information needed to identify the platform .", "question_id": 7470}
{"snippet": "platform.platform(aliased=0, terse=0)", "intent": "Returns a single string identifying the underlying platform with as much useful information as possible . If `aliased` is true , the function will use aliases for various platforms that report system names which differ from their common names , for example SunOS will be reported as Solaris . Setting `terse` to true causes the function to return only the absolute minimum information needed to identify the platform .", "question_id": 7471}
{"snippet": "platform.processor()", "intent": "Returns the ( real ) processor name , e.g .", "question_id": 7472}
{"snippet": "platform.python_build()", "intent": "Returns a tuple ( buildno , builddate ) stating the Python build number and date as strings .", "question_id": 7473}
{"snippet": "platform.python_compiler()", "intent": "Returns a string identifying the compiler used for compiling Python .", "question_id": 7474}
{"snippet": "platform.python_branch()", "intent": "Returns a string identifying the Python implementation SCM branch .", "question_id": 7475}
{"snippet": "platform.python_implementation()", "intent": "Returns a string identifying the Python implementation .", "question_id": 7476}
{"snippet": "platform.python_revision()", "intent": "Returns a string identifying the Python implementation SCM revision .", "question_id": 7477}
{"snippet": "platform.python_version()", "intent": "Returns the Python version as string 'major.minor.patchlevel ' .", "question_id": 7478}
{"snippet": "platform.python_version_tuple()", "intent": "Returns the Python version as tuple ( major , minor , patchlevel ) of strings .", "question_id": 7479}
{"snippet": "platform.release()", "intent": "Returns the system \u2019 s release , e.g .", "question_id": 7480}
{"snippet": "platform.system()", "intent": "Returns the system/OS name , e.g .", "question_id": 7481}
{"snippet": "platform.system_alias(system, release, version)", "intent": "Returns ( `system` , `release` , `version` ) aliased to common marketing names used for some systems .", "question_id": 7482}
{"snippet": "platform.version()", "intent": "Returns the system \u2019 s release version , e.g .", "question_id": 7483}
{"snippet": "platform.uname()", "intent": "Fairly portable uname interface .", "question_id": 7484}
{"snippet": "platform.java_ver('', ''), '', ''))", "intent": "Version interface for Jython . With arguments `''`, `'')`, `''`, `'')`.", "question_id": 7485}
{"snippet": "platform.java_ver('', ''), '', ''), release='')", "intent": "Version interface for Jython . Returns a tuple ( `release` , `vendor` , `vminfo` , `osinfo` ) with vminfo being a tuple ( vm_name , vm_release , vm_vendor ) and osinfo being a tuple ( os_name , os_version , os_arch ) . With arguments `''`, `'')`, `''`, `'')`.", "question_id": 7486}
{"snippet": "platform.java_ver('', ''), '', ''), vendor='')", "intent": "Version interface for Jython . Returns a tuple ( `release` , `vendor` , `vminfo` , `osinfo` ) with vminfo being a tuple ( vm_name , vm_release , vm_vendor ) and osinfo being a tuple ( os_name , os_version , os_arch ) . With arguments `''`, `'')`, `''`, `'')`.", "question_id": 7487}
{"snippet": "platform.java_ver('', ''), '', ''), vminfo=('')", "intent": "Version interface for Jython . Returns a tuple ( `release` , `vendor` , `vminfo` , `osinfo` ) with vminfo being a tuple ( vm_name , vm_release , vm_vendor ) and osinfo being a tuple ( os_name , os_version , os_arch ) . With arguments `''`, `'')`, `''`, `'')`.", "question_id": 7488}
{"snippet": "platform.java_ver('', ''), '', ''), osinfo=('')", "intent": "Version interface for Jython . Returns a tuple ( `release` , `vendor` , `vminfo` , `osinfo` ) with vminfo being a tuple ( vm_name , vm_release , vm_vendor ) and osinfo being a tuple ( os_name , os_version , os_arch ) . With arguments `''`, `'')`, `''`, `'')`.", "question_id": 7489}
{"snippet": "platform.java_ver('', ''), '', ''), release='', vendor='')", "intent": "Version interface for Jython . Returns a tuple ( `release` , `vendor` , `vminfo` , `osinfo` ) with vminfo being a tuple ( vm_name , vm_release , vm_vendor ) and osinfo being a tuple ( os_name , os_version , os_arch ) . With arguments `''`, `'')`, `''`, `'')`.", "question_id": 7490}
{"snippet": "platform.java_ver('', ''), '', ''), release='', vminfo=('')", "intent": "Version interface for Jython . Returns a tuple ( `release` , `vendor` , `vminfo` , `osinfo` ) with vminfo being a tuple ( vm_name , vm_release , vm_vendor ) and osinfo being a tuple ( os_name , os_version , os_arch ) . With arguments `''`, `'')`, `''`, `'')`.", "question_id": 7491}
{"snippet": "platform.java_ver('', ''), '', ''), release='', osinfo=('')", "intent": "Version interface for Jython . Returns a tuple ( `release` , `vendor` , `vminfo` , `osinfo` ) with vminfo being a tuple ( vm_name , vm_release , vm_vendor ) and osinfo being a tuple ( os_name , os_version , os_arch ) . With arguments `''`, `'')`, `''`, `'')`.", "question_id": 7492}
{"snippet": "platform.java_ver('', ''), '', ''), vendor='', vminfo=('')", "intent": "Version interface for Jython . Returns a tuple ( `release` , `vendor` , `vminfo` , `osinfo` ) with vminfo being a tuple ( vm_name , vm_release , vm_vendor ) and osinfo being a tuple ( os_name , os_version , os_arch ) . With arguments `''`, `'')`, `''`, `'')`.", "question_id": 7493}
{"snippet": "platform.java_ver('', ''), '', ''), vendor='', osinfo=('')", "intent": "Version interface for Jython . Returns a tuple ( `release` , `vendor` , `vminfo` , `osinfo` ) with vminfo being a tuple ( vm_name , vm_release , vm_vendor ) and osinfo being a tuple ( os_name , os_version , os_arch ) . With arguments `''`, `'')`, `''`, `'')`.", "question_id": 7494}
{"snippet": "platform.win32_ver()", "intent": "Get additional `version` information from the Windows Registry and return a tuple ( `release` , version , `csd` , `ptype` ) referring to OS release , version number , CSD level ( service pack ) and OS type ( multi/single processor ) .", "question_id": 7495}
{"snippet": "platform.win32_ver(release='')", "intent": "Get additional `version` information from the Windows Registry and return a tuple ( `release` , version , `csd` , `ptype` ) referring to OS release , version number , CSD level ( service pack ) and OS type ( multi/single processor ) .", "question_id": 7496}
{"snippet": "platform.win32_ver(version='')", "intent": "Get additional `version` information from the Windows Registry and return a tuple ( `release` , version , `csd` , `ptype` ) referring to OS release , version number , CSD level ( service pack ) and OS type ( multi/single processor ) .", "question_id": 7497}
{"snippet": "platform.win32_ver(csd='')", "intent": "Get additional `version` information from the Windows Registry and return a tuple ( `release` , version , `csd` , `ptype` ) referring to OS release , version number , CSD level ( service pack ) and OS type ( multi/single processor ) .", "question_id": 7498}
{"snippet": "platform.win32_ver(ptype='')", "intent": "Get additional `version` information from the Windows Registry and return a tuple ( `release` , version , `csd` , `ptype` ) referring to OS release , version number , CSD level ( service pack ) and OS type ( multi/single processor ) .", "question_id": 7499}
{"snippet": "platform.win32_ver(release='', version='')", "intent": "Get additional `version` information from the Windows Registry and return a tuple ( `release` , version , `csd` , `ptype` ) referring to OS release , version number , CSD level ( service pack ) and OS type ( multi/single processor ) .", "question_id": 7500}
{"snippet": "platform.win32_ver(release='', csd='')", "intent": "Get additional `version` information from the Windows Registry and return a tuple ( `release` , version , `csd` , `ptype` ) referring to OS release , version number , CSD level ( service pack ) and OS type ( multi/single processor ) .", "question_id": 7501}
{"snippet": "platform.win32_ver(release='', ptype='')", "intent": "Get additional `version` information from the Windows Registry and return a tuple ( `release` , version , `csd` , `ptype` ) referring to OS release , version number , CSD level ( service pack ) and OS type ( multi/single processor ) .", "question_id": 7502}
{"snippet": "platform.win32_ver(version='', csd='')", "intent": "Get additional `version` information from the Windows Registry and return a tuple ( `release` , version , `csd` , `ptype` ) referring to OS release , version number , CSD level ( service pack ) and OS type ( multi/single processor ) .", "question_id": 7503}
{"snippet": "platform.win32_ver(version='', ptype='')", "intent": "Get additional `version` information from the Windows Registry and return a tuple ( `release` , version , `csd` , `ptype` ) referring to OS release , version number , CSD level ( service pack ) and OS type ( multi/single processor ) .", "question_id": 7504}
{"snippet": "platform.popen(cmd)", "intent": "Portable popen ( ) interface . With arguments `cmd`.", "question_id": 7505}
{"snippet": "platform.popen(cmd, mode='r')", "intent": "Portable popen ( ) interface . With arguments `cmd`, `mode`.", "question_id": 7506}
{"snippet": "platform.popen(cmd, bufsize=-1)", "intent": "Portable popen ( ) interface . With arguments `cmd`, `bufsize`.", "question_id": 7507}
{"snippet": "platform.popen(cmd, mode='r', bufsize=-1)", "intent": "Portable popen ( ) interface . With arguments `cmd`, `mode`, `bufsize`.", "question_id": 7508}
{"snippet": "platform.mac_ver('', ''))", "intent": "Get Mac OS version information and return it as tuple ( `release` , `versioninfo` , `machine` ) with versioninfo being a tuple ( version , dev_stage , non_release_version ) . With arguments `''`, `'')`.", "question_id": 7509}
{"snippet": "platform.mac_ver('', ''), release='')", "intent": "Get Mac OS version information and return it as tuple ( `release` , `versioninfo` , `machine` ) with versioninfo being a tuple ( version , dev_stage , non_release_version ) . With arguments `''`, `'')`.", "question_id": 7510}
{"snippet": "platform.mac_ver('', ''), versioninfo=('')", "intent": "Get Mac OS version information and return it as tuple ( `release` , `versioninfo` , `machine` ) with versioninfo being a tuple ( version , dev_stage , non_release_version ) . With arguments `''`, `'')`.", "question_id": 7511}
{"snippet": "platform.mac_ver('', ''), machine='')", "intent": "Get Mac OS version information and return it as tuple ( `release` , `versioninfo` , `machine` ) with versioninfo being a tuple ( version , dev_stage , non_release_version ) . With arguments `''`, `'')`.", "question_id": 7512}
{"snippet": "platform.mac_ver('', ''), release='', versioninfo=('')", "intent": "Get Mac OS version information and return it as tuple ( `release` , `versioninfo` , `machine` ) with versioninfo being a tuple ( version , dev_stage , non_release_version ) . With arguments `''`, `'')`.", "question_id": 7513}
{"snippet": "platform.mac_ver('', ''), release='', machine='')", "intent": "Get Mac OS version information and return it as tuple ( `release` , `versioninfo` , `machine` ) with versioninfo being a tuple ( version , dev_stage , non_release_version ) . With arguments `''`, `'')`.", "question_id": 7514}
{"snippet": "platform.mac_ver('', ''), versioninfo=('', machine='')", "intent": "Get Mac OS version information and return it as tuple ( `release` , `versioninfo` , `machine` ) with versioninfo being a tuple ( version , dev_stage , non_release_version ) . With arguments `''`, `'')`.", "question_id": 7515}
{"snippet": "platform.mac_ver('', ''), release='', versioninfo=('', machine='')", "intent": "Get Mac OS version information and return it as tuple ( `release` , `versioninfo` , `machine` ) with versioninfo being a tuple ( version , dev_stage , non_release_version ) . With arguments `''`, `'')`.", "question_id": 7516}
{"snippet": "platform.dist('debian', 'redhat', 'mandrake', ...))", "intent": "This is another name for linux_distribution ( ) . With arguments `'debian'`, `'redhat'`, `'mandrake'`, `...)`.", "question_id": 7517}
{"snippet": "platform.dist('debian', 'redhat', 'mandrake', ...), distname='')", "intent": "This is another name for linux_distribution ( ) . With arguments `'debian'`, `'redhat'`, `'mandrake'`, `...)`, `distname`.", "question_id": 7518}
{"snippet": "platform.dist('debian', 'redhat', 'mandrake', ...), version='')", "intent": "This is another name for linux_distribution ( ) . With arguments `'debian'`, `'redhat'`, `'mandrake'`, `...)`, `version`.", "question_id": 7519}
{"snippet": "platform.dist('debian', 'redhat', 'mandrake', ...), id='')", "intent": "This is another name for linux_distribution ( ) . With arguments `'debian'`, `'redhat'`, `'mandrake'`, `...)`, `id`.", "question_id": 7520}
{"snippet": "platform.dist('debian', 'redhat', 'mandrake', ...), supported_dists=('SuSE')", "intent": "This is another name for linux_distribution ( ) . With arguments `'debian'`, `'redhat'`, `'mandrake'`, `...)`, `supported_dists`.", "question_id": 7521}
{"snippet": "platform.dist('debian', 'redhat', 'mandrake', ...), distname='', version='')", "intent": "This is another name for linux_distribution ( ) . With arguments `'debian'`, `'redhat'`, `'mandrake'`, `...)`, `distname`, `version`.", "question_id": 7522}
{"snippet": "platform.dist('debian', 'redhat', 'mandrake', ...), distname='', id='')", "intent": "This is another name for linux_distribution ( ) . With arguments `'debian'`, `'redhat'`, `'mandrake'`, `...)`, `distname`, `id`.", "question_id": 7523}
{"snippet": "platform.dist('debian', 'redhat', 'mandrake', ...), distname='', supported_dists=('SuSE')", "intent": "This is another name for linux_distribution ( ) . With arguments `'debian'`, `'redhat'`, `'mandrake'`, `...)`, `distname`, `supported_dists`.", "question_id": 7524}
{"snippet": "platform.dist('debian', 'redhat', 'mandrake', ...), version='', id='')", "intent": "This is another name for linux_distribution ( ) . With arguments `'debian'`, `'redhat'`, `'mandrake'`, `...)`, `version`, `id`.", "question_id": 7525}
{"snippet": "platform.dist('debian', 'redhat', 'mandrake', ...), version='', supported_dists=('SuSE')", "intent": "This is another name for linux_distribution ( ) . With arguments `'debian'`, `'redhat'`, `'mandrake'`, `...)`, `version`, `supported_dists`.", "question_id": 7526}
{"snippet": "platform.linux_distribution('debian', 'redhat', 'mandrake', ...))", "intent": "Tries to determine the name of the Linux OS distribution name . With arguments `'debian'`, `'redhat'`, `'mandrake'`, `...)`.", "question_id": 7527}
{"snippet": "platform.linux_distribution('debian', 'redhat', 'mandrake', ...), distname='')", "intent": "Tries to determine the name of the Linux OS distribution name . Returns a tuple ( `distname` , `version` , `id` ) which defaults to the args given as parameters . With arguments `'debian'`, `'redhat'`, `'mandrake'`, `...)`.", "question_id": 7528}
{"snippet": "platform.linux_distribution('debian', 'redhat', 'mandrake', ...), version='')", "intent": "Tries to determine the name of the Linux OS distribution name . Returns a tuple ( `distname` , `version` , `id` ) which defaults to the args given as parameters . With arguments `'debian'`, `'redhat'`, `'mandrake'`, `...)`.", "question_id": 7529}
{"snippet": "platform.linux_distribution('debian', 'redhat', 'mandrake', ...), id='')", "intent": "Tries to determine the name of the Linux OS distribution name . Returns a tuple ( `distname` , `version` , `id` ) which defaults to the args given as parameters . With arguments `'debian'`, `'redhat'`, `'mandrake'`, `...)`.", "question_id": 7530}
{"snippet": "platform.linux_distribution('debian', 'redhat', 'mandrake', ...), supported_dists=('SuSE')", "intent": "Tries to determine the name of the Linux OS distribution name . `supported_dists` may be given to define the set of Linux distributions to look for . With arguments `'debian'`, `'redhat'`, `'mandrake'`, `...)`.", "question_id": 7531}
{"snippet": "platform.linux_distribution('debian', 'redhat', 'mandrake', ...), full_distribution_name=1)", "intent": "Tries to determine the name of the Linux OS distribution name . If `full_distribution_name` is true ( default ) , the full distribution read from the OS is returned . With arguments `'debian'`, `'redhat'`, `'mandrake'`, `...)`.", "question_id": 7532}
{"snippet": "platform.linux_distribution('debian', 'redhat', 'mandrake', ...), distname='', version='')", "intent": "Tries to determine the name of the Linux OS distribution name . Returns a tuple ( `distname` , `version` , `id` ) which defaults to the args given as parameters . With arguments `'debian'`, `'redhat'`, `'mandrake'`, `...)`.", "question_id": 7533}
{"snippet": "platform.linux_distribution('debian', 'redhat', 'mandrake', ...), distname='', id='')", "intent": "Tries to determine the name of the Linux OS distribution name . Returns a tuple ( `distname` , `version` , `id` ) which defaults to the args given as parameters . With arguments `'debian'`, `'redhat'`, `'mandrake'`, `...)`.", "question_id": 7534}
{"snippet": "platform.linux_distribution('debian', 'redhat', 'mandrake', ...), distname='', supported_dists=('SuSE')", "intent": "Tries to determine the name of the Linux OS distribution name . Returns a tuple ( `distname` , `version` , `id` ) which defaults to the args given as parameters . `supported_dists` may be given to define the set of Linux distributions to look for . With arguments `'debian'`, `'redhat'`, `'mandrake'`, `...)`.", "question_id": 7535}
{"snippet": "platform.linux_distribution('debian', 'redhat', 'mandrake', ...), distname='', full_distribution_name=1)", "intent": "Tries to determine the name of the Linux OS distribution name . Returns a tuple ( `distname` , `version` , `id` ) which defaults to the args given as parameters . If `full_distribution_name` is true ( default ) , the full distribution read from the OS is returned . With arguments `'debian'`, `'redhat'`, `'mandrake'`, `...)`.", "question_id": 7536}
{"snippet": "platform.libc_ver()", "intent": "Tries to determine the libc `version` against which the file `executable` ( defaults to the Python interpreter ) is linked .", "question_id": 7537}
{"snippet": "platform.libc_ver(executable=sys.executable)", "intent": "Tries to determine the libc `version` against which the file `executable` ( defaults to the Python interpreter ) is linked .", "question_id": 7538}
{"snippet": "platform.libc_ver(lib='')", "intent": "Tries to determine the libc `version` against which the file `executable` ( defaults to the Python interpreter ) is linked . Returns a tuple of strings ( `lib` , version ) which default to the given parameters in case the lookup fails .", "question_id": 7539}
{"snippet": "platform.libc_ver(version='')", "intent": "Tries to determine the libc `version` against which the file `executable` ( defaults to the Python interpreter ) is linked .", "question_id": 7540}
{"snippet": "platform.libc_ver(chunksize=16384)", "intent": "Tries to determine the libc `version` against which the file `executable` ( defaults to the Python interpreter ) is linked . The file is read and scanned in chunks of `chunksize` bytes .", "question_id": 7541}
{"snippet": "platform.libc_ver(executable=sys.executable, lib='')", "intent": "Tries to determine the libc `version` against which the file `executable` ( defaults to the Python interpreter ) is linked . Returns a tuple of strings ( `lib` , version ) which default to the given parameters in case the lookup fails .", "question_id": 7542}
{"snippet": "platform.libc_ver(executable=sys.executable, version='')", "intent": "Tries to determine the libc `version` against which the file `executable` ( defaults to the Python interpreter ) is linked .", "question_id": 7543}
{"snippet": "platform.libc_ver(executable=sys.executable, chunksize=16384)", "intent": "Tries to determine the libc `version` against which the file `executable` ( defaults to the Python interpreter ) is linked . The file is read and scanned in chunks of `chunksize` bytes .", "question_id": 7544}
{"snippet": "platform.libc_ver(lib='', version='')", "intent": "Tries to determine the libc `version` against which the file `executable` ( defaults to the Python interpreter ) is linked . Returns a tuple of strings ( `lib` , version ) which default to the given parameters in case the lookup fails .", "question_id": 7545}
{"snippet": "platform.libc_ver(lib='', chunksize=16384)", "intent": "Tries to determine the libc `version` against which the file `executable` ( defaults to the Python interpreter ) is linked . Returns a tuple of strings ( `lib` , version ) which default to the given parameters in case the lookup fails . The file is read and scanned in chunks of `chunksize` bytes .", "question_id": 7546}
{"snippet": "plistlib.load(fp)", "intent": "Read a plist file . `fp` should be a readable and binary file object .", "question_id": 7547}
{"snippet": "plistlib.load(fp, fmt=None)", "intent": "Read a plist file . `fp` should be a readable and binary file object . The `fmt` is the format of the file and the following values are valid :", "question_id": 7548}
{"snippet": "plistlib.load(fp, use_builtin_types=True)", "intent": "Read a plist file . `fp` should be a readable and binary file object . If `use_builtin_types` is true ( the default ) binary data will be returned as instances of bytes , otherwise it is returned as instances of Data .", "question_id": 7549}
{"snippet": "plistlib.load(fp, dict_type=dict)", "intent": "Read a plist file . `fp` should be a readable and binary file object . The `dict_type` is the type used for dictionaries that are read from the plist file .", "question_id": 7550}
{"snippet": "plistlib.load(fp, fmt=None, use_builtin_types=True)", "intent": "Read a plist file . `fp` should be a readable and binary file object . The `fmt` is the format of the file and the following values are valid : If `use_builtin_types` is true ( the default ) binary data will be returned as instances of bytes , otherwise it is returned as instances of Data .", "question_id": 7551}
{"snippet": "plistlib.load(fp, fmt=None, dict_type=dict)", "intent": "Read a plist file . `fp` should be a readable and binary file object . The `fmt` is the format of the file and the following values are valid : The `dict_type` is the type used for dictionaries that are read from the plist file .", "question_id": 7552}
{"snippet": "plistlib.load(fp, use_builtin_types=True, dict_type=dict)", "intent": "Read a plist file . `fp` should be a readable and binary file object . If `use_builtin_types` is true ( the default ) binary data will be returned as instances of bytes , otherwise it is returned as instances of Data . The `dict_type` is the type used for dictionaries that are read from the plist file .", "question_id": 7553}
{"snippet": "plistlib.load(fp, fmt=None, use_builtin_types=True, dict_type=dict)", "intent": "Read a plist file . `fp` should be a readable and binary file object . The `fmt` is the format of the file and the following values are valid : If `use_builtin_types` is true ( the default ) binary data will be returned as instances of bytes , otherwise it is returned as instances of Data . The `dict_type` is the type used for dictionaries that are read from the plist file .", "question_id": 7554}
{"snippet": "plistlib.loads(data)", "intent": "Load a plist from a bytes object . With arguments `data`.", "question_id": 7555}
{"snippet": "plistlib.loads(data, fmt=None)", "intent": "Load a plist from a bytes object . With arguments `data`, `fmt`.", "question_id": 7556}
{"snippet": "plistlib.loads(data, use_builtin_types=True)", "intent": "Load a plist from a bytes object . With arguments `data`, `use_builtin_types`.", "question_id": 7557}
{"snippet": "plistlib.loads(data, dict_type=dict)", "intent": "Load a plist from a bytes object . With arguments `data`, `dict_type`.", "question_id": 7558}
{"snippet": "plistlib.loads(data, fmt=None, use_builtin_types=True)", "intent": "Load a plist from a bytes object . With arguments `data`, `fmt`, `use_builtin_types`.", "question_id": 7559}
{"snippet": "plistlib.loads(data, fmt=None, dict_type=dict)", "intent": "Load a plist from a bytes object . With arguments `data`, `fmt`, `dict_type`.", "question_id": 7560}
{"snippet": "plistlib.loads(data, use_builtin_types=True, dict_type=dict)", "intent": "Load a plist from a bytes object . With arguments `data`, `use_builtin_types`, `dict_type`.", "question_id": 7561}
{"snippet": "plistlib.loads(data, fmt=None, use_builtin_types=True, dict_type=dict)", "intent": "Load a plist from a bytes object . With arguments `data`, `fmt`, `use_builtin_types`, `dict_type`.", "question_id": 7562}
{"snippet": "plistlib.dump(value, fp)", "intent": "Write `value` to a plist file . With arguments `fp`.", "question_id": 7563}
{"snippet": "plistlib.dump(value, fp, fmt=FMT_XML)", "intent": "Write `value` to a plist file . The `fmt` argument specifies the format of the plist file and can be one of the following values : With arguments `fp`.", "question_id": 7564}
{"snippet": "plistlib.dump(value, fp, sort_keys=True)", "intent": "Write `value` to a plist file . When `sort_keys` is true ( the default ) the keys for dictionaries will be written to the plist in sorted order , otherwise they will be written in the iteration order of the dictionary . With arguments `fp`.", "question_id": 7565}
{"snippet": "plistlib.dump(value, fp, skipkeys=False)", "intent": "Write `value` to a plist file . When `skipkeys` is false ( the default ) the function raises TypeError when a key of a dictionary is not a string , otherwise such keys are skipped . With arguments `fp`.", "question_id": 7566}
{"snippet": "plistlib.dump(value, fp, fmt=FMT_XML, sort_keys=True)", "intent": "Write `value` to a plist file . The `fmt` argument specifies the format of the plist file and can be one of the following values : When `sort_keys` is true ( the default ) the keys for dictionaries will be written to the plist in sorted order , otherwise they will be written in the iteration order of the dictionary . With arguments `fp`.", "question_id": 7567}
{"snippet": "plistlib.dump(value, fp, fmt=FMT_XML, skipkeys=False)", "intent": "Write `value` to a plist file . The `fmt` argument specifies the format of the plist file and can be one of the following values : When `skipkeys` is false ( the default ) the function raises TypeError when a key of a dictionary is not a string , otherwise such keys are skipped . With arguments `fp`.", "question_id": 7568}
{"snippet": "plistlib.dump(value, fp, sort_keys=True, skipkeys=False)", "intent": "Write `value` to a plist file . When `sort_keys` is true ( the default ) the keys for dictionaries will be written to the plist in sorted order , otherwise they will be written in the iteration order of the dictionary . When `skipkeys` is false ( the default ) the function raises TypeError when a key of a dictionary is not a string , otherwise such keys are skipped . With arguments `fp`.", "question_id": 7569}
{"snippet": "plistlib.dump(value, fp, fmt=FMT_XML, sort_keys=True, skipkeys=False)", "intent": "Write `value` to a plist file . The `fmt` argument specifies the format of the plist file and can be one of the following values : When `sort_keys` is true ( the default ) the keys for dictionaries will be written to the plist in sorted order , otherwise they will be written in the iteration order of the dictionary . When `skipkeys` is false ( the default ) the function raises TypeError when a key of a dictionary is not a string , otherwise such keys are skipped . With arguments `fp`.", "question_id": 7570}
{"snippet": "plistlib.dumps(value)", "intent": "Return `value` as a plist-formatted bytes object .", "question_id": 7571}
{"snippet": "plistlib.dumps(value, fmt=FMT_XML)", "intent": "Return `value` as a plist-formatted bytes object . With arguments `fmt`.", "question_id": 7572}
{"snippet": "plistlib.dumps(value, sort_keys=True)", "intent": "Return `value` as a plist-formatted bytes object . With arguments `sort_keys`.", "question_id": 7573}
{"snippet": "plistlib.dumps(value, skipkeys=False)", "intent": "Return `value` as a plist-formatted bytes object . With arguments `skipkeys`.", "question_id": 7574}
{"snippet": "plistlib.dumps(value, fmt=FMT_XML, sort_keys=True)", "intent": "Return `value` as a plist-formatted bytes object . With arguments `fmt`, `sort_keys`.", "question_id": 7575}
{"snippet": "plistlib.dumps(value, fmt=FMT_XML, skipkeys=False)", "intent": "Return `value` as a plist-formatted bytes object . With arguments `fmt`, `skipkeys`.", "question_id": 7576}
{"snippet": "plistlib.dumps(value, sort_keys=True, skipkeys=False)", "intent": "Return `value` as a plist-formatted bytes object . With arguments `sort_keys`, `skipkeys`.", "question_id": 7577}
{"snippet": "plistlib.dumps(value, fmt=FMT_XML, sort_keys=True, skipkeys=False)", "intent": "Return `value` as a plist-formatted bytes object . With arguments `fmt`, `sort_keys`, `skipkeys`.", "question_id": 7578}
{"snippet": "plistlib.readPlist(pathOrFile)", "intent": "Read a plist file . `pathOrFile` may be either a file name or a ( readable and binary ) file object .", "question_id": 7579}
{"snippet": "plistlib.writePlist(rootObject, pathOrFile)", "intent": "Write `rootObject` to an XML plist file . `pathOrFile` may be either a file name or a ( writable and binary ) file object", "question_id": 7580}
{"snippet": "plistlib.readPlistFromBytes(data)", "intent": "Read a plist `data` from a bytes object .", "question_id": 7581}
{"snippet": "plistlib.writePlistToBytes(rootObject)", "intent": "Return `rootObject` as an XML plist-formatted bytes object .", "question_id": 7582}
{"snippet": "plistlib.Data(data)", "intent": "Return a \u201c `data` \u201d wrapper object around the bytes object data .", "question_id": 7583}
{"snippet": "plistlib.FMT_XML", "intent": "The XML format for plist files.", "question_id": 7584}
{"snippet": "plistlib.FMT_BINARY", "intent": "The binary format for plist files", "question_id": 7585}
{"snippet": "poplib.POP3(host, timeout)", "intent": "This class implements the actual POP3 protocol . The optional `timeout` parameter specifies a timeout in seconds for the connection attempt ( if not specified , the global default timeout setting will be used ) . With arguments `host`.", "question_id": 7586}
{"snippet": "poplib.POP3(host, timeout, port=POP3_PORT)", "intent": "This class implements the actual POP3 protocol . The optional `timeout` parameter specifies a timeout in seconds for the connection attempt ( if not specified , the global default timeout setting will be used ) . If `port` is omitted , the standard POP3 port ( 110 ) is used . With arguments `host`.", "question_id": 7587}
{"snippet": "poplib.POP3(host)", "intent": "This class implements the actual POP3 protocol . With arguments `host`.", "question_id": 7588}
{"snippet": "poplib.POP3(host, port=POP3_PORT)", "intent": "This class implements the actual POP3 protocol . If `port` is omitted , the standard POP3 port ( 110 ) is used . With arguments `host`.", "question_id": 7589}
{"snippet": "poplib.POP3_SSL(host)", "intent": "This is a subclass of POP3 that connects to the server over an SSL encrypted socket . With arguments `host`.", "question_id": 7590}
{"snippet": "poplib.POP3_SSL(host, port=POP3_SSL_PORT)", "intent": "This is a subclass of POP3 that connects to the server over an SSL encrypted socket . If `port` is not specified , 995 , the standard POP3-over-SSL port is used . With arguments `host`.", "question_id": 7591}
{"snippet": "poplib.POP3_SSL(host, keyfile=None)", "intent": "This is a subclass of POP3 that connects to the server over an SSL encrypted socket . `keyfile` and `certfile` are a legacy alternative to context - they can point to PEM-formatted private key and certificate chain files , respectively , for the SSL connection . With arguments `host`.", "question_id": 7592}
{"snippet": "poplib.POP3_SSL(host, certfile=None)", "intent": "This is a subclass of POP3 that connects to the server over an SSL encrypted socket . `keyfile` and `certfile` are a legacy alternative to context - they can point to PEM-formatted private key and certificate chain files , respectively , for the SSL connection . With arguments `host`.", "question_id": 7593}
{"snippet": "poplib.POP3_SSL(host, timeout=None)", "intent": "This is a subclass of POP3 that connects to the server over an SSL encrypted socket . `timeout` works as in the POP3 constructor . With arguments `host`.", "question_id": 7594}
{"snippet": "poplib.POP3_SSL(host, context=None)", "intent": "This is a subclass of POP3 that connects to the server over an SSL encrypted socket . `context` is an optional ssl.SSLContext object which allows bundling SSL configuration options , certificates and private keys into a single ( potentially long-lived ) structure . With arguments `host`.", "question_id": 7595}
{"snippet": "poplib.POP3_SSL(host, port=POP3_SSL_PORT, keyfile=None)", "intent": "This is a subclass of POP3 that connects to the server over an SSL encrypted socket . If `port` is not specified , 995 , the standard POP3-over-SSL port is used . `keyfile` and `certfile` are a legacy alternative to context - they can point to PEM-formatted private key and certificate chain files , respectively , for the SSL connection . With arguments `host`.", "question_id": 7596}
{"snippet": "poplib.POP3_SSL(host, port=POP3_SSL_PORT, certfile=None)", "intent": "This is a subclass of POP3 that connects to the server over an SSL encrypted socket . If `port` is not specified , 995 , the standard POP3-over-SSL port is used . `keyfile` and `certfile` are a legacy alternative to context - they can point to PEM-formatted private key and certificate chain files , respectively , for the SSL connection . With arguments `host`.", "question_id": 7597}
{"snippet": "poplib.POP3_SSL(host, port=POP3_SSL_PORT, timeout=None)", "intent": "This is a subclass of POP3 that connects to the server over an SSL encrypted socket . If `port` is not specified , 995 , the standard POP3-over-SSL port is used . `timeout` works as in the POP3 constructor . With arguments `host`.", "question_id": 7598}
{"snippet": "poplib.POP3_SSL(host, port=POP3_SSL_PORT, context=None)", "intent": "This is a subclass of POP3 that connects to the server over an SSL encrypted socket . If `port` is not specified , 995 , the standard POP3-over-SSL port is used . `context` is an optional ssl.SSLContext object which allows bundling SSL configuration options , certificates and private keys into a single ( potentially long-lived ) structure . With arguments `host`.", "question_id": 7599}
{"snippet": "poplib.error_proto", "intent": "Exception raised on any errors from this module (errors from socket module are not caught).", "question_id": 7600}
{"snippet": "POP3.set_debuglevel(level)", "intent": "Set the instance \u2019 s debugging `level` .", "question_id": 7601}
{"snippet": "POP3.getwelcome()", "intent": "Returns the greeting string sent by the POP3 server .", "question_id": 7602}
{"snippet": "POP3.capa()", "intent": "Query the server \u2019 s capabilities as specified in RFC 2449 .", "question_id": 7603}
{"snippet": "POP3.user(username)", "intent": "Send user command , response should indicate that a password is required . With arguments `username`.", "question_id": 7604}
{"snippet": "POP3.pass_(password)", "intent": "Send `password` , response includes message count and mailbox size .", "question_id": 7605}
{"snippet": "POP3.apop(user, secret)", "intent": "Use the more secure APOP authentication to log into the POP3 server . With arguments `user`, `secret`.", "question_id": 7606}
{"snippet": "POP3.rpop(user)", "intent": "Use RPOP authentication ( similar to UNIX r-commands ) to log into POP3 server . With arguments `user`.", "question_id": 7607}
{"snippet": "POP3.stat()", "intent": "Get mailbox status .", "question_id": 7608}
{"snippet": "POP3.list(which)", "intent": "Request message list , result is in the form ( response , [ 'mesg_num octets ' , ... ] , octets ) . If `which` is set , it is the message to list .", "question_id": 7609}
{"snippet": "POP3.list()", "intent": "Request message list , result is in the form ( response , [ 'mesg_num octets ' , ... ] , octets ) .", "question_id": 7610}
{"snippet": "POP3.retr(which)", "intent": "Retrieve whole message number `which` , and set its seen flag .", "question_id": 7611}
{"snippet": "POP3.dele(which)", "intent": "Flag message number `which` for deletion .", "question_id": 7612}
{"snippet": "POP3.rset()", "intent": "Remove any deletion marks for the mailbox .", "question_id": 7613}
{"snippet": "POP3.noop()", "intent": "Do nothing .", "question_id": 7614}
{"snippet": "POP3.quit()", "intent": "Signoff : commit changes , unlock mailbox , drop connection .", "question_id": 7615}
{"snippet": "POP3.top(which, howmuch)", "intent": "Retrieves the message header plus `howmuch` lines of the message after the header of message number `which` .", "question_id": 7616}
{"snippet": "POP3.uidl()", "intent": "Return message digest ( unique id ) list .", "question_id": 7617}
{"snippet": "POP3.uidl(which=None)", "intent": "Return message digest ( unique id ) list . If `which` is specified , result contains the unique id for that message in the form 'response mesgnum uid , otherwise result is list ( response , [ 'mesgnum uid ' , ... ] , octets ) .", "question_id": 7618}
{"snippet": "POP3.utf8()", "intent": "Try to switch to UTF-8 mode .", "question_id": 7619}
{"snippet": "POP3.stls()", "intent": "Start a TLS session on the active connection as specified in RFC 2595 .", "question_id": 7620}
{"snippet": "POP3.stls(context=None)", "intent": "Start a TLS session on the active connection as specified in RFC 2595 . `context` parameter is a ssl.SSLContext object which allows bundling SSL configuration options , certificates and private keys into a single ( potentially long-lived ) structure .", "question_id": 7621}
{"snippet": "posix.environ", "intent": "A dictionary representing the string environment at the time the interpreter was started.", "question_id": 7622}
{"snippet": "pprint.PrettyPrinter()", "intent": "Construct a PrettyPrinter instance .", "question_id": 7623}
{"snippet": "pprint.PrettyPrinter(indent=1)", "intent": "Construct a PrettyPrinter instance . The amount of indentation added for each recursive level is specified by `indent` ; the default is one .", "question_id": 7624}
{"snippet": "pprint.PrettyPrinter(width=80)", "intent": "Construct a PrettyPrinter instance . The desired output `width` is constrained using the width parameter ; the default is 80 characters .", "question_id": 7625}
{"snippet": "pprint.PrettyPrinter(depth=None)", "intent": "Construct a PrettyPrinter instance . The number of levels which may be printed is controlled by `depth` ; if the data structure being printed is too deep , the next contained level is replaced by ... . By default , there is no constraint on the depth of the objects being formatted .", "question_id": 7626}
{"snippet": "pprint.PrettyPrinter(stream=None)", "intent": "Construct a PrettyPrinter instance . An output `stream` may be set using the stream keyword ; the only method used on the stream object is the file protocol \u2019 s write ( ) method .", "question_id": 7627}
{"snippet": "pprint.PrettyPrinter(compact=False)", "intent": "Construct a PrettyPrinter instance . If `compact` is false ( the default ) each item of a long sequence will be formatted on a separate line .", "question_id": 7628}
{"snippet": "pprint.PrettyPrinter(indent=1, width=80)", "intent": "Construct a PrettyPrinter instance . The amount of indentation added for each recursive level is specified by `indent` ; the default is one . The desired output `width` is constrained using the width parameter ; the default is 80 characters .", "question_id": 7629}
{"snippet": "pprint.PrettyPrinter(indent=1, depth=None)", "intent": "Construct a PrettyPrinter instance . The amount of indentation added for each recursive level is specified by `indent` ; the default is one . The number of levels which may be printed is controlled by `depth` ; if the data structure being printed is too deep , the next contained level is replaced by ... . By default , there is no constraint on the depth of the objects being formatted .", "question_id": 7630}
{"snippet": "pprint.PrettyPrinter(indent=1, stream=None)", "intent": "Construct a PrettyPrinter instance . The amount of indentation added for each recursive level is specified by `indent` ; the default is one . An output `stream` may be set using the stream keyword ; the only method used on the stream object is the file protocol \u2019 s write ( ) method .", "question_id": 7631}
{"snippet": "pprint.PrettyPrinter(indent=1, compact=False)", "intent": "Construct a PrettyPrinter instance . The amount of indentation added for each recursive level is specified by `indent` ; the default is one . If `compact` is false ( the default ) each item of a long sequence will be formatted on a separate line .", "question_id": 7632}
{"snippet": "pprint.pformat(object)", "intent": "Return the formatted representation of `object` as a string .", "question_id": 7633}
{"snippet": "pprint.pformat(object, indent=1)", "intent": "Return the formatted representation of `object` as a string . `indent` , `width` , `depth` and `compact` will be passed to the PrettyPrinter constructor as formatting parameters .", "question_id": 7634}
{"snippet": "pprint.pformat(object, width=80)", "intent": "Return the formatted representation of `object` as a string . `indent` , `width` , `depth` and `compact` will be passed to the PrettyPrinter constructor as formatting parameters .", "question_id": 7635}
{"snippet": "pprint.pformat(object, depth=None)", "intent": "Return the formatted representation of `object` as a string . `indent` , `width` , `depth` and `compact` will be passed to the PrettyPrinter constructor as formatting parameters .", "question_id": 7636}
{"snippet": "pprint.pformat(object, compact=False)", "intent": "Return the formatted representation of `object` as a string . `indent` , `width` , `depth` and `compact` will be passed to the PrettyPrinter constructor as formatting parameters .", "question_id": 7637}
{"snippet": "pprint.pformat(object, indent=1, width=80)", "intent": "Return the formatted representation of `object` as a string . `indent` , `width` , `depth` and `compact` will be passed to the PrettyPrinter constructor as formatting parameters .", "question_id": 7638}
{"snippet": "pprint.pformat(object, indent=1, depth=None)", "intent": "Return the formatted representation of `object` as a string . `indent` , `width` , `depth` and `compact` will be passed to the PrettyPrinter constructor as formatting parameters .", "question_id": 7639}
{"snippet": "pprint.pformat(object, indent=1, compact=False)", "intent": "Return the formatted representation of `object` as a string . `indent` , `width` , `depth` and `compact` will be passed to the PrettyPrinter constructor as formatting parameters .", "question_id": 7640}
{"snippet": "pprint.pformat(object, width=80, depth=None)", "intent": "Return the formatted representation of `object` as a string . `indent` , `width` , `depth` and `compact` will be passed to the PrettyPrinter constructor as formatting parameters .", "question_id": 7641}
{"snippet": "pprint.pformat(object, width=80, compact=False)", "intent": "Return the formatted representation of `object` as a string . `indent` , `width` , `depth` and `compact` will be passed to the PrettyPrinter constructor as formatting parameters .", "question_id": 7642}
{"snippet": "pprint.pprint(object)", "intent": "Prints the formatted representation of `object` on `stream` , followed by a newline .", "question_id": 7643}
{"snippet": "pprint.pprint(object, stream=None)", "intent": "Prints the formatted representation of `object` on `stream` , followed by a newline .", "question_id": 7644}
{"snippet": "pprint.pprint(object, indent=1)", "intent": "Prints the formatted representation of `object` on `stream` , followed by a newline . `indent` , `width` , `depth` and `compact` will be passed to the PrettyPrinter constructor as formatting parameters .", "question_id": 7645}
{"snippet": "pprint.pprint(object, width=80)", "intent": "Prints the formatted representation of `object` on `stream` , followed by a newline . `indent` , `width` , `depth` and `compact` will be passed to the PrettyPrinter constructor as formatting parameters .", "question_id": 7646}
{"snippet": "pprint.pprint(object, depth=None)", "intent": "Prints the formatted representation of `object` on `stream` , followed by a newline . `indent` , `width` , `depth` and `compact` will be passed to the PrettyPrinter constructor as formatting parameters .", "question_id": 7647}
{"snippet": "pprint.pprint(object, compact=False)", "intent": "Prints the formatted representation of `object` on `stream` , followed by a newline . `indent` , `width` , `depth` and `compact` will be passed to the PrettyPrinter constructor as formatting parameters .", "question_id": 7648}
{"snippet": "pprint.pprint(object, stream=None, indent=1)", "intent": "Prints the formatted representation of `object` on `stream` , followed by a newline . `indent` , `width` , `depth` and `compact` will be passed to the PrettyPrinter constructor as formatting parameters .", "question_id": 7649}
{"snippet": "pprint.pprint(object, stream=None, width=80)", "intent": "Prints the formatted representation of `object` on `stream` , followed by a newline . `indent` , `width` , `depth` and `compact` will be passed to the PrettyPrinter constructor as formatting parameters .", "question_id": 7650}
{"snippet": "pprint.pprint(object, stream=None, depth=None)", "intent": "Prints the formatted representation of `object` on `stream` , followed by a newline . `indent` , `width` , `depth` and `compact` will be passed to the PrettyPrinter constructor as formatting parameters .", "question_id": 7651}
{"snippet": "pprint.pprint(object, stream=None, compact=False)", "intent": "Prints the formatted representation of `object` on `stream` , followed by a newline . `indent` , `width` , `depth` and `compact` will be passed to the PrettyPrinter constructor as formatting parameters .", "question_id": 7652}
{"snippet": "pprint.isreadable(object)", "intent": "Determine if the formatted representation of `object` is \u201c readable , \u201d or can be used to reconstruct the value using eval ( ) .", "question_id": 7653}
{"snippet": "pprint.isrecursive(object)", "intent": "Determine if `object` requires a recursive representation .", "question_id": 7654}
{"snippet": "pprint.saferepr(object)", "intent": "Return a string representation of `object` , protected against recursive data structures .", "question_id": 7655}
{"snippet": "PrettyPrinter.pformat(object)", "intent": "Return the formatted representation of `object` .", "question_id": 7656}
{"snippet": "PrettyPrinter.pprint(object)", "intent": "Print the formatted representation of `object` on the configured stream , followed by a newline .", "question_id": 7657}
{"snippet": "PrettyPrinter.isreadable(object)", "intent": "Determine if the formatted representation of the `object` is \u201c readable , \u201d or can be used to reconstruct the value using eval ( ) .", "question_id": 7658}
{"snippet": "PrettyPrinter.isrecursive(object)", "intent": "Determine if the `object` requires a recursive representation .", "question_id": 7659}
{"snippet": "PrettyPrinter.format(object, context, maxlevels, level)", "intent": "Returns three values : the formatted version of `object` as a string , a flag indicating whether the result is readable , and a flag indicating whether recursion was detected . The second is a dictionary which contains the id ( ) of objects that are part of the current presentation `context` ( direct and indirect containers for object that are affecting the presentation ) as the keys ; if an object needs to be presented which is already represented in context , the third return value should be True . The third argument , `maxlevels` , gives the requested limit to recursion ; this will be 0 if there is no requested limit . The fourth argument , `level` , gives the current level ; recursive calls should be passed a value less than that of the current call .", "question_id": 7660}
{"snippet": "profile.run(command)", "intent": "This function takes a single argument that can be passed to the exec ( ) function , and an optional file name . With arguments `command`.", "question_id": 7661}
{"snippet": "profile.run(command, filename=None)", "intent": "This function takes a single argument that can be passed to the exec ( ) function , and an optional file name . With arguments `command`, `filename`.", "question_id": 7662}
{"snippet": "profile.run(command, sort=-1)", "intent": "This function takes a single argument that can be passed to the exec ( ) function , and an optional file name . If the `sort` value is specified , it is passed to this Stats instance to control how the results are sorted . With arguments `command`.", "question_id": 7663}
{"snippet": "profile.run(command, filename=None, sort=-1)", "intent": "This function takes a single argument that can be passed to the exec ( ) function , and an optional file name . If the `sort` value is specified , it is passed to this Stats instance to control how the results are sorted . With arguments `command`, `filename`.", "question_id": 7664}
{"snippet": "profile.runctx(command, globals, locals)", "intent": "This function is similar to run ( ) , with added arguments to supply the `globals` and `locals` dictionaries for the `command` string .", "question_id": 7665}
{"snippet": "profile.runctx(command, globals, locals, filename=None)", "intent": "This function is similar to run ( ) , with added arguments to supply the `globals` and `locals` dictionaries for the `command` string . With arguments `filename`.", "question_id": 7666}
{"snippet": "profile.runctx(command, globals, locals, sort=-1)", "intent": "This function is similar to run ( ) , with added arguments to supply the `globals` and `locals` dictionaries for the `command` string . With arguments `sort`.", "question_id": 7667}
{"snippet": "profile.runctx(command, globals, locals, filename=None, sort=-1)", "intent": "This function is similar to run ( ) , with added arguments to supply the `globals` and `locals` dictionaries for the `command` string . With arguments `filename`, `sort`.", "question_id": 7668}
{"snippet": "profile.Profile()", "intent": "This class is normally only used if more precise control over profiling is needed than what the cProfile.run ( ) function provides .", "question_id": 7669}
{"snippet": "profile.Profile(timer=None)", "intent": "This class is normally only used if more precise control over profiling is needed than what the cProfile.run ( ) function provides . A custom `timer` can be supplied for measuring how long code takes to run via the timer argument .", "question_id": 7670}
{"snippet": "profile.Profile(timeunit=0.0)", "intent": "This class is normally only used if more precise control over profiling is needed than what the cProfile.run ( ) function provides . If the number is an integer , the `timeunit` specifies a multiplier that specifies the duration of each unit of time .", "question_id": 7671}
{"snippet": "profile.Profile(subcalls=True)", "intent": "This class is normally only used if more precise control over profiling is needed than what the cProfile.run ( ) function provides . With arguments `subcalls`.", "question_id": 7672}
{"snippet": "profile.Profile(builtins=True)", "intent": "This class is normally only used if more precise control over profiling is needed than what the cProfile.run ( ) function provides . With arguments `builtins`.", "question_id": 7673}
{"snippet": "profile.Profile(timer=None, timeunit=0.0)", "intent": "This class is normally only used if more precise control over profiling is needed than what the cProfile.run ( ) function provides . A custom `timer` can be supplied for measuring how long code takes to run via the timer argument . If the number is an integer , the `timeunit` specifies a multiplier that specifies the duration of each unit of time .", "question_id": 7674}
{"snippet": "profile.Profile(timer=None, subcalls=True)", "intent": "This class is normally only used if more precise control over profiling is needed than what the cProfile.run ( ) function provides . A custom `timer` can be supplied for measuring how long code takes to run via the timer argument . With arguments `subcalls`.", "question_id": 7675}
{"snippet": "profile.Profile(timer=None, builtins=True)", "intent": "This class is normally only used if more precise control over profiling is needed than what the cProfile.run ( ) function provides . A custom `timer` can be supplied for measuring how long code takes to run via the timer argument . With arguments `builtins`.", "question_id": 7676}
{"snippet": "profile.Profile(timeunit=0.0, subcalls=True)", "intent": "This class is normally only used if more precise control over profiling is needed than what the cProfile.run ( ) function provides . If the number is an integer , the `timeunit` specifies a multiplier that specifies the duration of each unit of time . With arguments `subcalls`.", "question_id": 7677}
{"snippet": "profile.Profile(timeunit=0.0, builtins=True)", "intent": "This class is normally only used if more precise control over profiling is needed than what the cProfile.run ( ) function provides . If the number is an integer , the `timeunit` specifies a multiplier that specifies the duration of each unit of time . With arguments `builtins`.", "question_id": 7678}
{"snippet": "profile.enable()", "intent": "Start collecting profiling data .", "question_id": 7679}
{"snippet": "profile.disable()", "intent": "Stop collecting profiling data .", "question_id": 7680}
{"snippet": "profile.create_stats()", "intent": "Stop collecting profiling data and record the results internally as the current profile .", "question_id": 7681}
{"snippet": "profile.print_stats()", "intent": "Create a Stats object based on the current profile and print the results to stdout .", "question_id": 7682}
{"snippet": "profile.print_stats(sort=-1)", "intent": "Create a Stats object based on the current profile and print the results to stdout . With arguments `sort`.", "question_id": 7683}
{"snippet": "profile.dump_stats(filename)", "intent": "Write the results of the current profile to `filename` .", "question_id": 7684}
{"snippet": "profile.run(cmd)", "intent": "Profile the `cmd` via exec ( ) .", "question_id": 7685}
{"snippet": "profile.runctx(cmd, globals, locals)", "intent": "Profile the `cmd` via exec ( ) with the specified global and local environment . With arguments `globals`, `locals`.", "question_id": 7686}
{"snippet": "profile.runcall(func, *args, **kwargs)", "intent": "Profile `func` ( `*args` , `**kwargs` )", "question_id": 7687}
{"snippet": "pstats.Stats(*filenames or profile)", "intent": "This class constructor creates an instance of a \u201c statistics object \u201d from a filename ( or list of filenames ) or from a Profile instance . With arguments `*filenames or profile`.", "question_id": 7688}
{"snippet": "pstats.Stats(*filenames or profile, stream=sys.stdout)", "intent": "This class constructor creates an instance of a \u201c statistics object \u201d from a filename ( or list of filenames ) or from a Profile instance . Output will be printed to the `stream` specified by stream . With arguments `*filenames or profile`.", "question_id": 7689}
{"snippet": "stats.strip_dirs()", "intent": "This method for the Stats class removes all leading path information from file names .", "question_id": 7690}
{"snippet": "stats.add(*filenames)", "intent": "This method of the Stats class accumulates additional profiling information into the current profiling object . With arguments `*filenames`.", "question_id": 7691}
{"snippet": "stats.dump_stats(filename)", "intent": "Save the data loaded into the Stats object to a file named `filename` .", "question_id": 7692}
{"snippet": "stats.sort_stats(*keys)", "intent": "This method modifies the Stats object by sorting it according to the supplied criteria . With arguments `*keys`.", "question_id": 7693}
{"snippet": "stats.reverse_order()", "intent": "This method for the Stats class reverses the ordering of the basic list within the object .", "question_id": 7694}
{"snippet": "stats.print_stats(*restrictions)", "intent": "This method for the Stats class prints out a report as described in the profile.run ( ) definition . With arguments `*restrictions`.", "question_id": 7695}
{"snippet": "stats.print_callers(*restrictions)", "intent": "This method for the Stats class prints a list of all functions that called each function in the profiled database . With arguments `*restrictions`.", "question_id": 7696}
{"snippet": "stats.print_callees(*restrictions)", "intent": "This method for the Stats class prints a list of all function that were called by the indicated function . With arguments `*restrictions`.", "question_id": 7697}
{"snippet": "pty.fork()", "intent": "Fork .", "question_id": 7698}
{"snippet": "pty.openpty()", "intent": "Open a new pseudo-terminal pair , using os.openpty ( ) if possible , or emulation code for generic Unix systems .", "question_id": 7699}
{"snippet": "pty.spawn(argv, master_read, stdin_read)", "intent": "Spawn a process , and connect its controlling terminal with the current process \u2019 s standard io . The functions `master_read` and `stdin_read` are passed a file descriptor which they should read from , and they should always return a byte string . With arguments `argv`.", "question_id": 7700}
{"snippet": "pty.spawn(argv, master_read)", "intent": "Spawn a process , and connect its controlling terminal with the current process \u2019 s standard io . The functions `master_read` and `stdin_read` are passed a file descriptor which they should read from , and they should always return a byte string . With arguments `argv`.", "question_id": 7701}
{"snippet": "pty.spawn(argv)", "intent": "Spawn a process , and connect its controlling terminal with the current process \u2019 s standard io . With arguments `argv`.", "question_id": 7702}
{"snippet": "pwd.getpwuid(uid)", "intent": "Return the password database entry for the given numeric user ID . With arguments `uid`.", "question_id": 7703}
{"snippet": "pwd.getpwnam(name)", "intent": "Return the password database entry for the given user `name` .", "question_id": 7704}
{"snippet": "pwd.getpwall()", "intent": "Return a list of all available password database entries , in arbitrary order .", "question_id": 7705}
{"snippet": "pyclbr.readmodule(module)", "intent": "Return a dictionary mapping module-level class names to class descriptors . Parameter `module` is a string with the name of the module to read ; it may be the name of a module within a package .", "question_id": 7706}
{"snippet": "pyclbr.readmodule(module, path=None)", "intent": "Return a dictionary mapping module-level class names to class descriptors . Parameter `module` is a string with the name of the module to read ; it may be the name of a module within a package . If given , `path` is a sequence of directory paths prepended to sys.path , which is used to locate the module source code .", "question_id": 7707}
{"snippet": "pyclbr.readmodule_ex(module)", "intent": "Return a dictionary-based tree containing a function or class descriptors for each function and class defined in the `module` with a def or class statement .", "question_id": 7708}
{"snippet": "pyclbr.readmodule_ex(module, path=None)", "intent": "Return a dictionary-based tree containing a function or class descriptors for each function and class defined in the `module` with a def or class statement . As with readmodule , module names the module to be read and `path` is prepended to sys.path .", "question_id": 7709}
{"snippet": "Function.file", "intent": "Name of the file in which the function is defined.", "question_id": 7710}
{"snippet": "Function.module", "intent": "The name of the module defining the function described.", "question_id": 7711}
{"snippet": "Function.name", "intent": "The name of the function.", "question_id": 7712}
{"snippet": "Function.lineno", "intent": "The line number in the file where the definition starts.", "question_id": 7713}
{"snippet": "Function.parent", "intent": "For top-level functions, None.", "question_id": 7714}
{"snippet": "Function.children", "intent": "A dictionary mapping names to descriptors for nested functions and classes.", "question_id": 7715}
{"snippet": "Class.file", "intent": "Name of the file in which the class is defined.", "question_id": 7716}
{"snippet": "Class.module", "intent": "The name of the module defining the class described.", "question_id": 7717}
{"snippet": "Class.name", "intent": "The name of the class.", "question_id": 7718}
{"snippet": "Class.lineno", "intent": "The line number in the file where the definition starts.", "question_id": 7719}
{"snippet": "Class.parent", "intent": "For top-level classes, None.", "question_id": 7720}
{"snippet": "Class.children", "intent": "A dictionary mapping names to descriptors for nested functions and classes.", "question_id": 7721}
{"snippet": "Class.super", "intent": "A list of Class objects which describe the immediate base classes of the class being described.", "question_id": 7722}
{"snippet": "Class.methods", "intent": "A dictionary mapping method names to line numbers.", "question_id": 7723}
{"snippet": "xml.parsers.expat.ExpatError", "intent": "The exception raised when Expat reports an error.", "question_id": 7724}
{"snippet": "xml.parsers.expat.error", "intent": "Alias for ExpatError.", "question_id": 7725}
{"snippet": "xml.parsers.expat.XMLParserType", "intent": "The type of the return values from the ParserCreate() function.", "question_id": 7726}
{"snippet": "xml.parsers.expat.ErrorString(errno)", "intent": "Returns an explanatory string for a given error number `errno` .", "question_id": 7727}
{"snippet": "xml.parsers.expat.ParserCreate()", "intent": "Creates and returns a new xmlparser object .", "question_id": 7728}
{"snippet": "xml.parsers.expat.ParserCreate(encoding=None)", "intent": "Creates and returns a new xmlparser object . `encoding` , if specified , must be a string naming the encoding used by the XML data .", "question_id": 7729}
{"snippet": "xml.parsers.expat.ParserCreate(namespace_separator=None)", "intent": "Creates and returns a new xmlparser object . Expat can optionally do XML namespace processing for you , enabled by providing a value for `namespace_separator` .", "question_id": 7730}
{"snippet": "xml.parsers.expat.ParserCreate(encoding=None, namespace_separator=None)", "intent": "Creates and returns a new xmlparser object . `encoding` , if specified , must be a string naming the encoding used by the XML data . Expat can optionally do XML namespace processing for you , enabled by providing a value for `namespace_separator` .", "question_id": 7731}
{"snippet": "xmlparser.Parse(data, isfinal)", "intent": "Parses the contents of the string `data` , calling the appropriate handler functions to process the parsed data . `isfinal` must be true on the final call to this method ; it allows the parsing of a single file in fragments , not the submission of multiple files .", "question_id": 7732}
{"snippet": "xmlparser.Parse(data)", "intent": "Parses the contents of the string `data` , calling the appropriate handler functions to process the parsed data .", "question_id": 7733}
{"snippet": "xmlparser.ParseFile(file)", "intent": "Parse XML data reading from the object `file` .", "question_id": 7734}
{"snippet": "xmlparser.SetBase(base)", "intent": "Sets the `base` to be used for resolving relative URIs in system identifiers in declarations .", "question_id": 7735}
{"snippet": "xmlparser.GetBase()", "intent": "Returns a string containing the base set by a previous call to SetBase ( ) , or None if SetBase ( ) hasn \u2019 t been called .", "question_id": 7736}
{"snippet": "xmlparser.GetInputContext()", "intent": "Returns the input data that generated the current event as a string .", "question_id": 7737}
{"snippet": "xmlparser.ExternalEntityParserCreate(context, encoding)", "intent": "Create a \u201c child \u201d parser which can be used to parse an external parsed entity referred to by content parsed by the parent parser . The `context` parameter should be the string passed to the ExternalEntityRefHandler ( ) handler function , described below . With arguments `encoding`.", "question_id": 7738}
{"snippet": "xmlparser.ExternalEntityParserCreate(context)", "intent": "Create a \u201c child \u201d parser which can be used to parse an external parsed entity referred to by content parsed by the parent parser . The `context` parameter should be the string passed to the ExternalEntityRefHandler ( ) handler function , described below .", "question_id": 7739}
{"snippet": "xmlparser.SetParamEntityParsing(flag)", "intent": "Control parsing of parameter entities ( including the external DTD subset ) . Possible `flag` values are XML_PARAM_ENTITY_PARSING_NEVER , XML_PARAM_ENTITY_PARSING_UNLESS_STANDALONE and XML_PARAM_ENTITY_PARSING_ALWAYS .", "question_id": 7740}
{"snippet": "xmlparser.UseForeignDTD(flag)", "intent": "Calling this with a true value for `flag` ( the default ) will cause Expat to call the ExternalEntityRefHandler with None for all arguments to allow an alternate DTD to be loaded .", "question_id": 7741}
{"snippet": "xmlparser.UseForeignDTD()", "intent": "Calling this with a true value for `flag` ( the default ) will cause Expat to call the ExternalEntityRefHandler with None for all arguments to allow an alternate DTD to be loaded .", "question_id": 7742}
{"snippet": "xmlparser.buffer_size", "intent": "The size of the buffer used when buffer_text is true.", "question_id": 7743}
{"snippet": "xmlparser.buffer_text", "intent": "Setting this to true causes the xmlparser object to buffer textual content returned by Expat to avoid multiple calls to the CharacterDataHandler() callback whenever possible.", "question_id": 7744}
{"snippet": "xmlparser.buffer_used", "intent": "If buffer_text is enabled, the number of bytes stored in the buffer.", "question_id": 7745}
{"snippet": "xmlparser.ordered_attributes", "intent": "Setting this attribute to a non-zero integer causes the attributes to be reported as a list rather than a dictionary.", "question_id": 7746}
{"snippet": "xmlparser.specified_attributes", "intent": "If set to a non-zero integer, the parser will report only those attributes which were specified in the document instance and not those which were derived from attribute declarations.", "question_id": 7747}
{"snippet": "xmlparser.ErrorByteIndex", "intent": "Byte index at which an error occurred.", "question_id": 7748}
{"snippet": "xmlparser.ErrorCode", "intent": "Numeric code specifying the problem.", "question_id": 7749}
{"snippet": "xmlparser.ErrorColumnNumber", "intent": "Column number at which an error occurred.", "question_id": 7750}
{"snippet": "xmlparser.ErrorLineNumber", "intent": "Line number at which an error occurred.", "question_id": 7751}
{"snippet": "xmlparser.CurrentByteIndex", "intent": "Current byte index in the parser input.", "question_id": 7752}
{"snippet": "xmlparser.CurrentColumnNumber", "intent": "Current column number in the parser input.", "question_id": 7753}
{"snippet": "xmlparser.CurrentLineNumber", "intent": "Current line number in the parser input.", "question_id": 7754}
{"snippet": "xmlparser.XmlDeclHandler(version, encoding, standalone)", "intent": "Called when the XML declaration is parsed . The XML declaration is the ( optional ) declaration of the applicable `version` of the XML recommendation , the `encoding` of the document text , and an optional \u201c `standalone` \u201d declaration .", "question_id": 7755}
{"snippet": "xmlparser.StartDoctypeDeclHandler(doctypeName, systemId, publicId, has_internal_subset)", "intent": "Called when Expat begins parsing the document type declaration ( < ! DOCTYPE ... ) . The `doctypeName` is provided exactly as presented . The `systemId` and `publicId` parameters give the system and public identifiers if specified , or None if omitted . `has_internal_subset` will be true if the document contains and internal document declaration subset .", "question_id": 7756}
{"snippet": "xmlparser.EndDoctypeDeclHandler()", "intent": "Called when Expat is done parsing the document type declaration .", "question_id": 7757}
{"snippet": "xmlparser.ElementDeclHandler(name, model)", "intent": "Called once for each element type declaration . `name` is the name of the element type , and `model` is a representation of the content model .", "question_id": 7758}
{"snippet": "xmlparser.AttlistDeclHandler(elname, attname, type, default, required)", "intent": "Called for each declared attribute for an element `type` . `elname` is the name of the element to which the declaration applies and `attname` is the name of the attribute declared . The attribute type is a string passed as type ; the possible values are 'CDATA ' , 'ID ' , 'IDREF ' , \u2026 `default` gives the default value for the attribute used when the attribute is not specified by the document instance , or None if there is no default value ( # IMPLIED values ) . If the attribute is `required` to be given in the document instance , required will be true .", "question_id": 7759}
{"snippet": "xmlparser.StartElementHandler(name, attributes)", "intent": "Called for the start of every element . `name` is a string containing the element name , and `attributes` is the element attributes .", "question_id": 7760}
{"snippet": "xmlparser.EndElementHandler(name)", "intent": "Called for the end of every element . With arguments `name`.", "question_id": 7761}
{"snippet": "xmlparser.ProcessingInstructionHandler(target, data)", "intent": "Called for every processing instruction . With arguments `target`, `data`.", "question_id": 7762}
{"snippet": "xmlparser.CharacterDataHandler(data)", "intent": "Called for character `data` .", "question_id": 7763}
{"snippet": "xmlparser.UnparsedEntityDeclHandler(entityName, base, systemId, publicId, notationName)", "intent": "Called for unparsed ( NDATA ) entity declarations . With arguments `entityName`, `base`, `systemId`, `publicId`, `notationName`.", "question_id": 7764}
{"snippet": "xmlparser.EntityDeclHandler(entityName, is_parameter_entity, value, base, systemId, publicId, notationName)", "intent": "Called for all entity declarations . `is_parameter_entity` will be true if the entity is a parameter entity or false for general entities ( most applications only need to be concerned with general entities ) . For parameter and internal entities , `value` will be a string giving the declared contents of the entity ; this will be None for external entities . The `notationName` parameter will be None for parsed entities , and the name of the notation for unparsed entities . With arguments `entityName`, `base`, `systemId`, `publicId`.", "question_id": 7765}
{"snippet": "xmlparser.NotationDeclHandler(notationName, base, systemId, publicId)", "intent": "Called for notation declarations . `notationName` , `base` , and `systemId` , and `publicId` are strings if given .", "question_id": 7766}
{"snippet": "xmlparser.StartNamespaceDeclHandler(prefix, uri)", "intent": "Called when an element contains a namespace declaration . With arguments `prefix`, `uri`.", "question_id": 7767}
{"snippet": "xmlparser.EndNamespaceDeclHandler(prefix)", "intent": "Called when the closing tag is reached for an element that contained a namespace declaration . With arguments `prefix`.", "question_id": 7768}
{"snippet": "xmlparser.CommentHandler(data)", "intent": "Called for comments . `data` is the text of the comment , excluding the leading ' < ! -- ' and trailing ' -- > ' .", "question_id": 7769}
{"snippet": "xmlparser.StartCdataSectionHandler()", "intent": "Called at the start of a CDATA section .", "question_id": 7770}
{"snippet": "xmlparser.EndCdataSectionHandler()", "intent": "Called at the end of a CDATA section .", "question_id": 7771}
{"snippet": "xmlparser.DefaultHandler(data)", "intent": "Called for any characters in the XML document for which no applicable handler has been specified . With arguments `data`.", "question_id": 7772}
{"snippet": "xmlparser.DefaultHandlerExpand(data)", "intent": "This is the same as the DefaultHandler ( ) , but doesn \u2019 t inhibit expansion of internal entities . With arguments `data`.", "question_id": 7773}
{"snippet": "xmlparser.NotStandaloneHandler()", "intent": "Called if the XML document hasn \u2019 t been declared as being a standalone document .", "question_id": 7774}
{"snippet": "xmlparser.ExternalEntityRefHandler(context, base, systemId, publicId)", "intent": "Called for references to external entities . The `context` value is opaque and should only be used as described below . `base` is the current base , as set by a previous call to SetBase ( ) . The public and system identifiers , `systemId` and `publicId` , are strings if given ; if the public identifier is not given , publicId will be None .", "question_id": 7775}
{"snippet": "ExpatError.code", "intent": "Expat\u2019s internal error number for the specific error.", "question_id": 7776}
{"snippet": "ExpatError.lineno", "intent": "Line number on which the error was detected.", "question_id": 7777}
{"snippet": "ExpatError.offset", "intent": "Character offset into the line where the error occurred.", "question_id": 7778}
{"snippet": "xml.parsers.expat.model.XML_CTYPE_ANY", "intent": "The element named by the model name was declared to have a content model of ANY.", "question_id": 7779}
{"snippet": "xml.parsers.expat.model.XML_CTYPE_CHOICE", "intent": "The named element allows a choice from a number of options; this is used for content models such as (A | B | C).", "question_id": 7780}
{"snippet": "xml.parsers.expat.model.XML_CTYPE_EMPTY", "intent": "Elements which are declared to be EMPTY have this model type.", "question_id": 7781}
{"snippet": "xml.parsers.expat.model.XML_CTYPE_SEQ", "intent": "Models which represent a series of models which follow one after the other are indicated with this model type.", "question_id": 7782}
{"snippet": "xml.parsers.expat.model.XML_CQUANT_NONE", "intent": "No modifier is given, so it can appear exactly once, as for A.", "question_id": 7783}
{"snippet": "xml.parsers.expat.model.XML_CQUANT_OPT", "intent": "The model is optional: it can appear once or not at all, as for A?.", "question_id": 7784}
{"snippet": "xml.parsers.expat.model.XML_CQUANT_PLUS", "intent": "The model must occur one or more times (like A+).", "question_id": 7785}
{"snippet": "xml.parsers.expat.model.XML_CQUANT_REP", "intent": "The model must occur zero or more times, as for A*.", "question_id": 7786}
{"snippet": "xml.parsers.expat.errors.codes", "intent": "A dictionary mapping numeric error codes to their string descriptions.", "question_id": 7787}
{"snippet": "xml.parsers.expat.errors.messages", "intent": "A dictionary mapping string descriptions to their error codes.", "question_id": 7788}
{"snippet": "xml.parsers.expat.errors.XML_ERROR_ATTRIBUTE_EXTERNAL_ENTITY_REF", "intent": "An entity reference in an attribute value referred to an external entity instead of an internal entity.", "question_id": 7789}
{"snippet": "xml.parsers.expat.errors.XML_ERROR_BAD_CHAR_REF", "intent": "A character reference referred to a character which is illegal in XML (for example, character 0, or \u2018&#0;\u2019).", "question_id": 7790}
{"snippet": "xml.parsers.expat.errors.XML_ERROR_BINARY_ENTITY_REF", "intent": "An entity reference referred to an entity which was declared with a notation, so cannot be parsed.", "question_id": 7791}
{"snippet": "xml.parsers.expat.errors.XML_ERROR_DUPLICATE_ATTRIBUTE", "intent": "An attribute was used more than once in a start tag.", "question_id": 7792}
{"snippet": "xml.parsers.expat.errors.XML_ERROR_INVALID_TOKEN", "intent": "Raised when an input byte could not properly be assigned to a character; for example, a NUL byte (value 0) in a UTF-8 input stream.", "question_id": 7793}
{"snippet": "xml.parsers.expat.errors.XML_ERROR_JUNK_AFTER_DOC_ELEMENT", "intent": "Something other than whitespace occurred after the document element.", "question_id": 7794}
{"snippet": "xml.parsers.expat.errors.XML_ERROR_MISPLACED_XML_PI", "intent": "An XML declaration was found somewhere other than the start of the input data.", "question_id": 7795}
{"snippet": "xml.parsers.expat.errors.XML_ERROR_NO_ELEMENTS", "intent": "The document contains no elements (XML requires all documents to contain exactly one top-level element)..", "question_id": 7796}
{"snippet": "xml.parsers.expat.errors.XML_ERROR_NO_MEMORY", "intent": "Expat was not able to allocate memory internally.", "question_id": 7797}
{"snippet": "xml.parsers.expat.errors.XML_ERROR_PARAM_ENTITY_REF", "intent": "A parameter entity reference was found where it was not allowed.", "question_id": 7798}
{"snippet": "xml.parsers.expat.errors.XML_ERROR_PARTIAL_CHAR", "intent": "An incomplete character was found in the input.", "question_id": 7799}
{"snippet": "xml.parsers.expat.errors.XML_ERROR_RECURSIVE_ENTITY_REF", "intent": "An entity reference contained another reference to the same entity; possibly via a different name, and possibly indirectly.", "question_id": 7800}
{"snippet": "xml.parsers.expat.errors.XML_ERROR_SYNTAX", "intent": "Some unspecified syntax error was encountered.", "question_id": 7801}
{"snippet": "xml.parsers.expat.errors.XML_ERROR_TAG_MISMATCH", "intent": "An end tag did not match the innermost open start tag.", "question_id": 7802}
{"snippet": "xml.parsers.expat.errors.XML_ERROR_UNCLOSED_TOKEN", "intent": "Some token (such as a start tag) was not closed before the end of the stream or the next token was encountered.", "question_id": 7803}
{"snippet": "xml.parsers.expat.errors.XML_ERROR_UNDEFINED_ENTITY", "intent": "A reference was made to an entity which was not defined.", "question_id": 7804}
{"snippet": "xml.parsers.expat.errors.XML_ERROR_UNKNOWN_ENCODING", "intent": "The document encoding is not supported by Expat.", "question_id": 7805}
{"snippet": "xml.parsers.expat.errors.XML_ERROR_UNCLOSED_CDATA_SECTION", "intent": "A CDATA marked section was not closed.", "question_id": 7806}
{"snippet": "xml.parsers.expat.errors.XML_ERROR_NOT_STANDALONE", "intent": "The parser determined that the document was not \u201cstandalone\u201d though it declared itself to be in the XML declaration, and the NotStandaloneHandler was set and returned 0.", "question_id": 7807}
{"snippet": "xml.parsers.expat.errors.XML_ERROR_FEATURE_REQUIRES_XML_DTD", "intent": "An operation was requested that requires DTD support to be compiled in, but Expat was configured without DTD support.", "question_id": 7808}
{"snippet": "xml.parsers.expat.errors.XML_ERROR_CANT_CHANGE_FEATURE_ONCE_PARSING", "intent": "A behavioral change was requested after parsing started that can only be changed before parsing has started.", "question_id": 7809}
{"snippet": "xml.parsers.expat.errors.XML_ERROR_UNBOUND_PREFIX", "intent": "An undeclared prefix was found when namespace processing was enabled.", "question_id": 7810}
{"snippet": "xml.parsers.expat.errors.XML_ERROR_UNDECLARING_PREFIX", "intent": "The document attempted to remove the namespace declaration associated with a prefix.", "question_id": 7811}
{"snippet": "xml.parsers.expat.errors.XML_ERROR_INCOMPLETE_PE", "intent": "A parameter entity contained incomplete markup.", "question_id": 7812}
{"snippet": "xml.parsers.expat.errors.XML_ERROR_XML_DECL", "intent": "The document contained no document element at all.", "question_id": 7813}
{"snippet": "xml.parsers.expat.errors.XML_ERROR_TEXT_DECL", "intent": "There was an error parsing a text declaration in an external entity.", "question_id": 7814}
{"snippet": "xml.parsers.expat.errors.XML_ERROR_PUBLICID", "intent": "Characters were found in the public id that are not allowed.", "question_id": 7815}
{"snippet": "xml.parsers.expat.errors.XML_ERROR_SUSPENDED", "intent": "The requested operation was made on a suspended parser, but isn\u2019t allowed.", "question_id": 7816}
{"snippet": "xml.parsers.expat.errors.XML_ERROR_NOT_SUSPENDED", "intent": "An attempt to resume the parser was made when the parser had not been suspended.", "question_id": 7817}
{"snippet": "xml.parsers.expat.errors.XML_ERROR_ABORTED", "intent": "This should not be reported to Python applications.", "question_id": 7818}
{"snippet": "xml.parsers.expat.errors.XML_ERROR_FINISHED", "intent": "The requested operation was made on a parser which was finished parsing input, but isn\u2019t allowed.", "question_id": 7819}
{"snippet": "py_compile.PyCompileError", "intent": "Exception raised when an error occurs while attempting to compile the file.", "question_id": 7820}
{"snippet": "py_compile.compile(file)", "intent": "Compile a source `file` to byte-code and write out the byte-code cache file .", "question_id": 7821}
{"snippet": "py_compile.compile(file, cfile=None)", "intent": "Compile a source `file` to byte-code and write out the byte-code cache file . The byte-code is written to `cfile` , which defaults to the PEP 3147/PEP 488 path , ending in .pyc .", "question_id": 7822}
{"snippet": "py_compile.compile(file, dfile=None)", "intent": "Compile a source `file` to byte-code and write out the byte-code cache file . If `dfile` is specified , it is used as the name of the source file in error messages when instead of file .", "question_id": 7823}
{"snippet": "py_compile.compile(file, doraise=False)", "intent": "Compile a source `file` to byte-code and write out the byte-code cache file . If `doraise` is true , a PyCompileError is raised when an error is encountered while compiling file .", "question_id": 7824}
{"snippet": "py_compile.compile(file, optimize=-1)", "intent": "Compile a source `file` to byte-code and write out the byte-code cache file . `optimize` controls the optimization level and is passed to the built-in compile ( ) function .", "question_id": 7825}
{"snippet": "py_compile.compile(file, invalidation_mode=PycInvalidationMode.TIMESTAMP)", "intent": "Compile a source `file` to byte-code and write out the byte-code cache file . `invalidation_mode` should be a member of the PycInvalidationMode enum and controls how the generated bytecode cache is invalidated at runtime .", "question_id": 7826}
{"snippet": "py_compile.compile(file, cfile=None, dfile=None)", "intent": "Compile a source `file` to byte-code and write out the byte-code cache file . The byte-code is written to `cfile` , which defaults to the PEP 3147/PEP 488 path , ending in .pyc . If `dfile` is specified , it is used as the name of the source file in error messages when instead of file .", "question_id": 7827}
{"snippet": "py_compile.compile(file, cfile=None, doraise=False)", "intent": "Compile a source `file` to byte-code and write out the byte-code cache file . The byte-code is written to `cfile` , which defaults to the PEP 3147/PEP 488 path , ending in .pyc . If `doraise` is true , a PyCompileError is raised when an error is encountered while compiling file .", "question_id": 7828}
{"snippet": "py_compile.compile(file, cfile=None, optimize=-1)", "intent": "Compile a source `file` to byte-code and write out the byte-code cache file . The byte-code is written to `cfile` , which defaults to the PEP 3147/PEP 488 path , ending in .pyc . `optimize` controls the optimization level and is passed to the built-in compile ( ) function .", "question_id": 7829}
{"snippet": "py_compile.compile(file, cfile=None, invalidation_mode=PycInvalidationMode.TIMESTAMP)", "intent": "Compile a source `file` to byte-code and write out the byte-code cache file . The byte-code is written to `cfile` , which defaults to the PEP 3147/PEP 488 path , ending in .pyc . `invalidation_mode` should be a member of the PycInvalidationMode enum and controls how the generated bytecode cache is invalidated at runtime .", "question_id": 7830}
{"snippet": "py_compile.PycInvalidationMode", "intent": "A enumeration of possible methods the interpreter can use to determine whether a bytecode file is up to date with a source file.", "question_id": 7831}
{"snippet": "pyc_invalidation_mode.TIMESTAMP", "intent": "The .pyc file includes the timestamp and size of the source file, which Python will compare against the metadata of the source file at runtime to determine if the .pyc file needs to be regenerated.", "question_id": 7832}
{"snippet": "pyc_invalidation_mode.CHECKED_HASH", "intent": "The .pyc file includes a hash of the source file content, which Python will compare against the source at runtime to determine if the .pyc file needs to be regenerated.", "question_id": 7833}
{"snippet": "pyc_invalidation_mode.UNCHECKED_HASH", "intent": "Like CHECKED_HASH, the .pyc file includes a hash of the source file content.", "question_id": 7834}
{"snippet": "py_compile.main()", "intent": "Compile several source files .", "question_id": 7835}
{"snippet": "py_compile.main(args=None)", "intent": "Compile several source files . The files named in `args` ( or on the command line , if args is None ) are compiled and the resulting byte-code is cached in the normal manner .", "question_id": 7836}
{"snippet": "queue.Queue()", "intent": "Constructor for a FIFO queue .", "question_id": 7837}
{"snippet": "queue.Queue(maxsize=0)", "intent": "Constructor for a FIFO queue . `maxsize` is an integer that sets the upperbound limit on the number of items that can be placed in the queue .", "question_id": 7838}
{"snippet": "queue.LifoQueue()", "intent": "Constructor for a LIFO queue .", "question_id": 7839}
{"snippet": "queue.LifoQueue(maxsize=0)", "intent": "Constructor for a LIFO queue . `maxsize` is an integer that sets the upperbound limit on the number of items that can be placed in the queue .", "question_id": 7840}
{"snippet": "queue.PriorityQueue()", "intent": "Constructor for a priority queue .", "question_id": 7841}
{"snippet": "queue.PriorityQueue(maxsize=0)", "intent": "Constructor for a priority queue . `maxsize` is an integer that sets the upperbound limit on the number of items that can be placed in the queue .", "question_id": 7842}
{"snippet": "queue.SimpleQueue", "intent": "Constructor for an unbounded FIFO queue.", "question_id": 7843}
{"snippet": "queue.Empty", "intent": "Exception raised when non-blocking get() (or get_nowait()) is called on a Queue object which is empty.", "question_id": 7844}
{"snippet": "queue.Full", "intent": "Exception raised when non-blocking put() (or put_nowait()) is called on a Queue object which is full.", "question_id": 7845}
{"snippet": "Queue.qsize()", "intent": "Return the approximate size of the queue .", "question_id": 7846}
{"snippet": "Queue.empty()", "intent": "Return True if the queue is empty , False otherwise .", "question_id": 7847}
{"snippet": "Queue.full()", "intent": "Return True if the queue is full , False otherwise .", "question_id": 7848}
{"snippet": "Queue.put(item)", "intent": "Put `item` into the queue .", "question_id": 7849}
{"snippet": "Queue.put(item, block=True)", "intent": "Put `item` into the queue . If optional args `block` is true and `timeout` is None ( the default ) , block if necessary until a free slot is available .", "question_id": 7850}
{"snippet": "Queue.put(item, timeout=None)", "intent": "Put `item` into the queue . If optional args `block` is true and `timeout` is None ( the default ) , block if necessary until a free slot is available .", "question_id": 7851}
{"snippet": "Queue.put(item, block=True, timeout=None)", "intent": "Put `item` into the queue . If optional args `block` is true and `timeout` is None ( the default ) , block if necessary until a free slot is available .", "question_id": 7852}
{"snippet": "Queue.put_nowait(item)", "intent": "Equivalent to put ( `item` , False ) .", "question_id": 7853}
{"snippet": "Queue.get()", "intent": "Remove and return an item from the queue .", "question_id": 7854}
{"snippet": "Queue.get(block=True)", "intent": "Remove and return an item from the queue . If optional args `block` is true and `timeout` is None ( the default ) , block if necessary until an item is available .", "question_id": 7855}
{"snippet": "Queue.get(timeout=None)", "intent": "Remove and return an item from the queue . If optional args `block` is true and `timeout` is None ( the default ) , block if necessary until an item is available .", "question_id": 7856}
{"snippet": "Queue.get(block=True, timeout=None)", "intent": "Remove and return an item from the queue . If optional args `block` is true and `timeout` is None ( the default ) , block if necessary until an item is available .", "question_id": 7857}
{"snippet": "Queue.get_nowait()", "intent": "Equivalent to get ( False ) .", "question_id": 7858}
{"snippet": "Queue.task_done()", "intent": "Indicate that a formerly enqueued task is complete .", "question_id": 7859}
{"snippet": "Queue.join()", "intent": "Blocks until all items in the queue have been gotten and processed .", "question_id": 7860}
{"snippet": "SimpleQueue.qsize()", "intent": "Return the approximate size of the queue .", "question_id": 7861}
{"snippet": "SimpleQueue.empty()", "intent": "Return True if the queue is empty , False otherwise .", "question_id": 7862}
{"snippet": "SimpleQueue.put(item)", "intent": "Put `item` into the queue .", "question_id": 7863}
{"snippet": "SimpleQueue.put(item, block=True)", "intent": "Put `item` into the queue . The optional args `block` and `timeout` are ignored and only provided for compatibility with Queue.put ( ) .", "question_id": 7864}
{"snippet": "SimpleQueue.put(item, timeout=None)", "intent": "Put `item` into the queue . The optional args `block` and `timeout` are ignored and only provided for compatibility with Queue.put ( ) .", "question_id": 7865}
{"snippet": "SimpleQueue.put(item, block=True, timeout=None)", "intent": "Put `item` into the queue . The optional args `block` and `timeout` are ignored and only provided for compatibility with Queue.put ( ) .", "question_id": 7866}
{"snippet": "SimpleQueue.put_nowait(item)", "intent": "Equivalent to put ( `item` ) , provided for compatibility with Queue.put_nowait ( ) .", "question_id": 7867}
{"snippet": "SimpleQueue.get()", "intent": "Remove and return an item from the queue .", "question_id": 7868}
{"snippet": "SimpleQueue.get(block=True)", "intent": "Remove and return an item from the queue . If optional args `block` is true and `timeout` is None ( the default ) , block if necessary until an item is available .", "question_id": 7869}
{"snippet": "SimpleQueue.get(timeout=None)", "intent": "Remove and return an item from the queue . If optional args `block` is true and `timeout` is None ( the default ) , block if necessary until an item is available .", "question_id": 7870}
{"snippet": "SimpleQueue.get(block=True, timeout=None)", "intent": "Remove and return an item from the queue . If optional args `block` is true and `timeout` is None ( the default ) , block if necessary until an item is available .", "question_id": 7871}
{"snippet": "SimpleQueue.get_nowait()", "intent": "Equivalent to get ( False ) .", "question_id": 7872}
{"snippet": "quopri.decode(input, output)", "intent": "Decode the contents of the `input` file and write the resulting decoded binary data to the `output` file .", "question_id": 7873}
{"snippet": "quopri.decode(input, output, header=False)", "intent": "Decode the contents of the `input` file and write the resulting decoded binary data to the `output` file . If the optional argument `header` is present and true , underscore will be decoded as space .", "question_id": 7874}
{"snippet": "quopri.encode(input, output, quotetabs)", "intent": "Encode the contents of the `input` file and write the resulting quoted-printable data to the `output` file . `quotetabs` , a non-optional flag which controls whether to encode embedded spaces and tabs ; when true it encodes such embedded whitespace , and when false it leaves them unencoded .", "question_id": 7875}
{"snippet": "quopri.encode(input, output, quotetabs, header=False)", "intent": "Encode the contents of the `input` file and write the resulting quoted-printable data to the `output` file . `quotetabs` , a non-optional flag which controls whether to encode embedded spaces and tabs ; when true it encodes such embedded whitespace , and when false it leaves them unencoded . Note that spaces and tabs appearing at the end of lines are always encoded , as per RFC 1521. `header` is a flag which controls if spaces are encoded as underscores as per RFC 1522 .", "question_id": 7876}
{"snippet": "quopri.decodestring(s)", "intent": "Like decode ( ) , except that it accepts a source bytes and returns the corresponding decoded bytes . With arguments `s`.", "question_id": 7877}
{"snippet": "quopri.decodestring(s, header=False)", "intent": "Like decode ( ) , except that it accepts a source bytes and returns the corresponding decoded bytes . With arguments `s`, `header`.", "question_id": 7878}
{"snippet": "quopri.encodestring(s)", "intent": "Like encode ( ) , except that it accepts a source bytes and returns the corresponding encoded bytes . With arguments `s`.", "question_id": 7879}
{"snippet": "quopri.encodestring(s, quotetabs=False)", "intent": "Like encode ( ) , except that it accepts a source bytes and returns the corresponding encoded bytes . By default , it sends a False value to `quotetabs` parameter of the encode ( ) function . With arguments `s`.", "question_id": 7880}
{"snippet": "quopri.encodestring(s, header=False)", "intent": "Like encode ( ) , except that it accepts a source bytes and returns the corresponding encoded bytes . With arguments `s`, `header`.", "question_id": 7881}
{"snippet": "quopri.encodestring(s, quotetabs=False, header=False)", "intent": "Like encode ( ) , except that it accepts a source bytes and returns the corresponding encoded bytes . By default , it sends a False value to `quotetabs` parameter of the encode ( ) function . With arguments `s`, `header`.", "question_id": 7882}
{"snippet": "random.seed()", "intent": "Initialize the random number generator .", "question_id": 7883}
{"snippet": "random.seed(a=None)", "intent": "Initialize the random number generator . If `a` is omitted or None , the current system time is used .", "question_id": 7884}
{"snippet": "random.seed(version=2)", "intent": "Initialize the random number generator . With `version` 2 ( the default ) , a str , bytes , or bytearray object gets converted to an int and all of its bits are used .", "question_id": 7885}
{"snippet": "random.seed(a=None, version=2)", "intent": "Initialize the random number generator . If `a` is omitted or None , the current system time is used . With `version` 2 ( the default ) , a str , bytes , or bytearray object gets converted to an int and all of its bits are used .", "question_id": 7886}
{"snippet": "random.getstate()", "intent": "Return an object capturing the current internal state of the generator .", "question_id": 7887}
{"snippet": "random.setstate(state)", "intent": "`state` should have been obtained from a previous call to getstate ( ) , and setstate ( ) restores the internal state of the generator to what it was at the time getstate ( ) was called .", "question_id": 7888}
{"snippet": "random.getrandbits(k)", "intent": "Returns a Python integer with `k` random bits .", "question_id": 7889}
{"snippet": "random.randrange(stop)", "intent": "Return a randomly selected element from range ( start , `stop` , step ) .", "question_id": 7890}
{"snippet": "random.randrange(start, stop, step)", "intent": "Return a randomly selected element from range ( `start` , `stop` , `step` ) .", "question_id": 7891}
{"snippet": "random.randrange(start, stop)", "intent": "Return a randomly selected element from range ( `start` , `stop` , `step` ) .", "question_id": 7892}
{"snippet": "random.randint(a, b)", "intent": "Return `a` random integer N such that a < = N < = b. Alias for randrange ( a , b+1 ) . With arguments `b`.", "question_id": 7893}
{"snippet": "random.choice(seq)", "intent": "Return a random element from the non-empty sequence `seq` .", "question_id": 7894}
{"snippet": "random.choices(population)", "intent": "Return a `k` sized list of elements chosen from the `population` with replacement .", "question_id": 7895}
{"snippet": "random.choices(population, weights=None)", "intent": "Return a `k` sized list of elements chosen from the `population` with replacement . If a `weights` sequence is specified , selections are made according to the relative weights .", "question_id": 7896}
{"snippet": "random.choices(population, cum_weights=None)", "intent": "Return a `k` sized list of elements chosen from the `population` with replacement . Alternatively , if a `cum_weights` sequence is given , the selections are made according to the cumulative weights ( perhaps computed using itertools.accumulate ( ) ) .", "question_id": 7897}
{"snippet": "random.choices(population, k=1)", "intent": "Return a `k` sized list of elements chosen from the `population` with replacement .", "question_id": 7898}
{"snippet": "random.choices(population, weights=None, cum_weights=None)", "intent": "Return a `k` sized list of elements chosen from the `population` with replacement . If a `weights` sequence is specified , selections are made according to the relative weights . Alternatively , if a `cum_weights` sequence is given , the selections are made according to the cumulative weights ( perhaps computed using itertools.accumulate ( ) ) .", "question_id": 7899}
{"snippet": "random.choices(population, weights=None, k=1)", "intent": "Return a `k` sized list of elements chosen from the `population` with replacement . If a `weights` sequence is specified , selections are made according to the relative weights .", "question_id": 7900}
{"snippet": "random.choices(population, cum_weights=None, k=1)", "intent": "Return a `k` sized list of elements chosen from the `population` with replacement . Alternatively , if a `cum_weights` sequence is given , the selections are made according to the cumulative weights ( perhaps computed using itertools.accumulate ( ) ) .", "question_id": 7901}
{"snippet": "random.choices(population, weights=None, cum_weights=None, k=1)", "intent": "Return a `k` sized list of elements chosen from the `population` with replacement . If a `weights` sequence is specified , selections are made according to the relative weights . Alternatively , if a `cum_weights` sequence is given , the selections are made according to the cumulative weights ( perhaps computed using itertools.accumulate ( ) ) .", "question_id": 7902}
{"snippet": "random.shuffle(x, random)", "intent": "Shuffle the sequence `x` in place . The optional argument `random` is a 0-argument function returning a random float in [ 0.0 , 1.0 ) ; by default , this is the function random ( ) .", "question_id": 7903}
{"snippet": "random.shuffle(x)", "intent": "Shuffle the sequence `x` in place .", "question_id": 7904}
{"snippet": "random.sample(population, k)", "intent": "Return a `k` length list of unique elements chosen from the `population` sequence or set .", "question_id": 7905}
{"snippet": "random.random()", "intent": "Return the next random floating point number in the range [ 0.0 , 1.0 ) .", "question_id": 7906}
{"snippet": "random.uniform(a, b)", "intent": "Return `a` random floating point number N such that a < = N < = `b` for a < = b and b < = N < = a for b < a .", "question_id": 7907}
{"snippet": "random.triangular(low, high, mode)", "intent": "Return a random floating point number N such that `low` < = N < = `high` and with the specified `mode` between those bounds .", "question_id": 7908}
{"snippet": "random.betavariate(alpha, beta)", "intent": "Beta distribution . Conditions on the parameters are `alpha` > 0 and `beta` > 0 .", "question_id": 7909}
{"snippet": "random.expovariate(lambd)", "intent": "Exponential distribution . `lambd` is 1.0 divided by the desired mean .", "question_id": 7910}
{"snippet": "random.gammavariate(alpha, beta)", "intent": "Gamma distribution . Conditions on the parameters are `alpha` > 0 and `beta` > 0 .", "question_id": 7911}
{"snippet": "random.gauss(mu, sigma)", "intent": "Gaussian distribution . `mu` is the mean , and `sigma` is the standard deviation .", "question_id": 7912}
{"snippet": "random.lognormvariate(mu, sigma)", "intent": "Log normal distribution . If you take the natural logarithm of this distribution , you \u2019 ll get a normal distribution with mean `mu` and standard deviation `sigma` .", "question_id": 7913}
{"snippet": "random.normalvariate(mu, sigma)", "intent": "Normal distribution . `mu` is the mean , and `sigma` is the standard deviation .", "question_id": 7914}
{"snippet": "random.vonmisesvariate(mu, kappa)", "intent": "`mu` is the mean angle , expressed in radians between 0 and 2*pi , and `kappa` is the concentration parameter , which must be greater than or equal to zero .", "question_id": 7915}
{"snippet": "random.paretovariate(alpha)", "intent": "Pareto distribution . `alpha` is the shape parameter .", "question_id": 7916}
{"snippet": "random.weibullvariate(alpha, beta)", "intent": "Weibull distribution . `alpha` is the scale parameter and `beta` is the shape parameter .", "question_id": 7917}
{"snippet": "random.Random(seed)", "intent": "Class that implements the default pseudo-random number generator used by the random module . With arguments `seed`.", "question_id": 7918}
{"snippet": "random.Random()", "intent": "Class that implements the default pseudo-random number generator used by the random module .", "question_id": 7919}
{"snippet": "random.SystemRandom(seed)", "intent": "Class that uses the os.urandom ( ) function for generating random numbers from sources provided by the operating system . Accordingly , the `seed` ( ) method has no effect and is ignored .", "question_id": 7920}
{"snippet": "random.SystemRandom()", "intent": "Class that uses the os.urandom ( ) function for generating random numbers from sources provided by the operating system .", "question_id": 7921}
{"snippet": "re.compile(pattern)", "intent": "Compile a regular expression `pattern` into a regular expression object , which can be used for matching using its match ( ) , search ( ) and other methods , described below .", "question_id": 7922}
{"snippet": "re.compile(pattern, flags=0)", "intent": "Compile a regular expression `pattern` into a regular expression object , which can be used for matching using its match ( ) , search ( ) and other methods , described below . The expression \u2019 s behaviour can be modified by specifying a `flags` value .", "question_id": 7923}
{"snippet": "re.A", "intent": "Make \\w, \\W, \\b, \\B, \\d, \\D, \\s and \\S perform ASCII-only matching instead of full Unicode matching.", "question_id": 7924}
{"snippet": "re.ASCII", "intent": "Make \\w, \\W, \\b, \\B, \\d, \\D, \\s and \\S perform ASCII-only matching instead of full Unicode matching.", "question_id": 7925}
{"snippet": "re.DEBUG", "intent": "Display debug information about compiled expression.", "question_id": 7926}
{"snippet": "re.I", "intent": "Perform case-insensitive matching; expressions like [A-Z] will also match lowercase letters.", "question_id": 7927}
{"snippet": "re.IGNORECASE", "intent": "Perform case-insensitive matching; expressions like [A-Z] will also match lowercase letters.", "question_id": 7928}
{"snippet": "re.L", "intent": "Make \\w, \\W, \\b, \\B and case-insensitive matching dependent on the current locale.", "question_id": 7929}
{"snippet": "re.LOCALE", "intent": "Make \\w, \\W, \\b, \\B and case-insensitive matching dependent on the current locale.", "question_id": 7930}
{"snippet": "re.M", "intent": "When specified, the pattern character '^' matches at the beginning of the string and at the beginning of each line (immediately following each newline); and the pattern character '$' matches at the end of the string and at the end of each line (immediately preceding each newline).", "question_id": 7931}
{"snippet": "re.MULTILINE", "intent": "When specified, the pattern character '^' matches at the beginning of the string and at the beginning of each line (immediately following each newline); and the pattern character '$' matches at the end of the string and at the end of each line (immediately preceding each newline).", "question_id": 7932}
{"snippet": "re.S", "intent": "Make the '.'", "question_id": 7933}
{"snippet": "re.DOTALL", "intent": "Make the '.'", "question_id": 7934}
{"snippet": "re.X", "intent": "This flag allows you to write regular expressions that look nicer and are more readable by allowing you to visually separate logical sections of the pattern and add comments.", "question_id": 7935}
{"snippet": "re.VERBOSE", "intent": "This flag allows you to write regular expressions that look nicer and are more readable by allowing you to visually separate logical sections of the pattern and add comments.", "question_id": 7936}
{"snippet": "re.search(pattern, string)", "intent": "Scan through `string` looking for the first location where the regular expression `pattern` produces a match , and return a corresponding match object .", "question_id": 7937}
{"snippet": "re.search(pattern, string, flags=0)", "intent": "Scan through `string` looking for the first location where the regular expression `pattern` produces a match , and return a corresponding match object . With arguments `flags`.", "question_id": 7938}
{"snippet": "re.match(pattern, string)", "intent": "If zero or more characters at the beginning of `string` match the regular expression `pattern` , return a corresponding match object .", "question_id": 7939}
{"snippet": "re.match(pattern, string, flags=0)", "intent": "If zero or more characters at the beginning of `string` match the regular expression `pattern` , return a corresponding match object . With arguments `flags`.", "question_id": 7940}
{"snippet": "re.fullmatch(pattern, string)", "intent": "If the whole `string` matches the regular expression `pattern` , return a corresponding match object .", "question_id": 7941}
{"snippet": "re.fullmatch(pattern, string, flags=0)", "intent": "If the whole `string` matches the regular expression `pattern` , return a corresponding match object . With arguments `flags`.", "question_id": 7942}
{"snippet": "re.split(pattern, string)", "intent": "Split `string` by the occurrences of `pattern` .", "question_id": 7943}
{"snippet": "re.split(pattern, string, maxsplit=0)", "intent": "Split `string` by the occurrences of `pattern` . If `maxsplit` is nonzero , at most maxsplit splits occur , and the remainder of the string is returned as the final element of the list .", "question_id": 7944}
{"snippet": "re.split(pattern, string, flags=0)", "intent": "Split `string` by the occurrences of `pattern` . With arguments `flags`.", "question_id": 7945}
{"snippet": "re.split(pattern, string, maxsplit=0, flags=0)", "intent": "Split `string` by the occurrences of `pattern` . If `maxsplit` is nonzero , at most maxsplit splits occur , and the remainder of the string is returned as the final element of the list . With arguments `flags`.", "question_id": 7946}
{"snippet": "re.findall(pattern, string)", "intent": "Return all non-overlapping matches of `pattern` in `string` , as a list of strings .", "question_id": 7947}
{"snippet": "re.findall(pattern, string, flags=0)", "intent": "Return all non-overlapping matches of `pattern` in `string` , as a list of strings . With arguments `flags`.", "question_id": 7948}
{"snippet": "re.finditer(pattern, string)", "intent": "Return an iterator yielding match objects over all non-overlapping matches for the RE `pattern` in `string` .", "question_id": 7949}
{"snippet": "re.finditer(pattern, string, flags=0)", "intent": "Return an iterator yielding match objects over all non-overlapping matches for the RE `pattern` in `string` . With arguments `flags`.", "question_id": 7950}
{"snippet": "re.sub(pattern, repl, string)", "intent": "Return the `string` obtained by replacing the leftmost non-overlapping occurrences of `pattern` in string by the replacement `repl` .", "question_id": 7951}
{"snippet": "re.sub(pattern, repl, string, count=0)", "intent": "Return the `string` obtained by replacing the leftmost non-overlapping occurrences of `pattern` in string by the replacement `repl` . The optional argument `count` is the maximum number of pattern occurrences to be replaced ; count must be a non-negative integer .", "question_id": 7952}
{"snippet": "re.sub(pattern, repl, string, flags=0)", "intent": "Return the `string` obtained by replacing the leftmost non-overlapping occurrences of `pattern` in string by the replacement `repl` . With arguments `flags`.", "question_id": 7953}
{"snippet": "re.sub(pattern, repl, string, count=0, flags=0)", "intent": "Return the `string` obtained by replacing the leftmost non-overlapping occurrences of `pattern` in string by the replacement `repl` . The optional argument `count` is the maximum number of pattern occurrences to be replaced ; count must be a non-negative integer . With arguments `flags`.", "question_id": 7954}
{"snippet": "re.subn(pattern, repl, string)", "intent": "Perform the same operation as sub ( ) , but return a tuple ( new_string , number_of_subs_made ) . With arguments `pattern`, `repl`, `string`.", "question_id": 7955}
{"snippet": "re.subn(pattern, repl, string, count=0)", "intent": "Perform the same operation as sub ( ) , but return a tuple ( new_string , number_of_subs_made ) . With arguments `pattern`, `repl`, `string`, `count`.", "question_id": 7956}
{"snippet": "re.subn(pattern, repl, string, flags=0)", "intent": "Perform the same operation as sub ( ) , but return a tuple ( new_string , number_of_subs_made ) . With arguments `pattern`, `repl`, `string`, `flags`.", "question_id": 7957}
{"snippet": "re.subn(pattern, repl, string, count=0, flags=0)", "intent": "Perform the same operation as sub ( ) , but return a tuple ( new_string , number_of_subs_made ) . With arguments `pattern`, `repl`, `string`, `count`, `flags`.", "question_id": 7958}
{"snippet": "re.escape(pattern)", "intent": "Escape special characters in `pattern` .", "question_id": 7959}
{"snippet": "re.purge()", "intent": "Clear the regular expression cache .", "question_id": 7960}
{"snippet": "re.error(msg)", "intent": "Exception raised when a string passed to one of the functions here is not a valid regular expression ( for example , it might contain unmatched parentheses ) or when some other error occurs during compilation or matching . With arguments `msg`.", "question_id": 7961}
{"snippet": "re.error(msg, pattern=None)", "intent": "Exception raised when a string passed to one of the functions here is not a valid regular expression ( for example , it might contain unmatched parentheses ) or when some other error occurs during compilation or matching . It is never an error if a string contains no match for a `pattern` . With arguments `msg`.", "question_id": 7962}
{"snippet": "re.error(msg, pos=None)", "intent": "Exception raised when a string passed to one of the functions here is not a valid regular expression ( for example , it might contain unmatched parentheses ) or when some other error occurs during compilation or matching . With arguments `msg`, `pos`.", "question_id": 7963}
{"snippet": "re.error(msg, pattern=None, pos=None)", "intent": "Exception raised when a string passed to one of the functions here is not a valid regular expression ( for example , it might contain unmatched parentheses ) or when some other error occurs during compilation or matching . It is never an error if a string contains no match for a `pattern` . With arguments `msg`, `pos`.", "question_id": 7964}
{"snippet": "system_random.msg", "intent": "The unformatted error message.", "question_id": 7965}
{"snippet": "system_random.pattern", "intent": "The regular expression pattern.", "question_id": 7966}
{"snippet": "system_random.pos", "intent": "The index in pattern where compilation failed (may be None).", "question_id": 7967}
{"snippet": "system_random.lineno", "intent": "The line corresponding to pos (may be None).", "question_id": 7968}
{"snippet": "system_random.colno", "intent": "The column corresponding to pos (may be None).", "question_id": 7969}
{"snippet": "Pattern.search(string, pos, endpos)", "intent": "Scan through `string` looking for the first location where this regular expression produces a match , and return a corresponding match object . The optional second parameter `pos` gives an index in the string where the search is to start ; it defaults to 0 . The optional parameter `endpos` limits how far the string will be searched ; it will be as if the string is endpos characters long , so only the characters from pos to endpos - 1 will be searched for a match .", "question_id": 7970}
{"snippet": "Pattern.search(string, pos)", "intent": "Scan through `string` looking for the first location where this regular expression produces a match , and return a corresponding match object . The optional second parameter `pos` gives an index in the string where the search is to start ; it defaults to 0 .", "question_id": 7971}
{"snippet": "Pattern.search(string)", "intent": "Scan through `string` looking for the first location where this regular expression produces a match , and return a corresponding match object .", "question_id": 7972}
{"snippet": "Pattern.match(string, pos, endpos)", "intent": "If zero or more characters at the beginning of `string` match this regular expression , return a corresponding match object . The optional `pos` and `endpos` parameters have the same meaning as for the search ( ) method .", "question_id": 7973}
{"snippet": "Pattern.match(string, pos)", "intent": "If zero or more characters at the beginning of `string` match this regular expression , return a corresponding match object . The optional `pos` and `endpos` parameters have the same meaning as for the search ( ) method .", "question_id": 7974}
{"snippet": "Pattern.match(string)", "intent": "If zero or more characters at the beginning of `string` match this regular expression , return a corresponding match object .", "question_id": 7975}
{"snippet": "Pattern.fullmatch(string, pos, endpos)", "intent": "If the whole `string` matches this regular expression , return a corresponding match object . The optional `pos` and `endpos` parameters have the same meaning as for the search ( ) method .", "question_id": 7976}
{"snippet": "Pattern.fullmatch(string, pos)", "intent": "If the whole `string` matches this regular expression , return a corresponding match object . The optional `pos` and `endpos` parameters have the same meaning as for the search ( ) method .", "question_id": 7977}
{"snippet": "Pattern.fullmatch(string)", "intent": "If the whole `string` matches this regular expression , return a corresponding match object .", "question_id": 7978}
{"snippet": "Pattern.split(string)", "intent": "Identical to the split ( ) function , using the compiled pattern . With arguments `string`.", "question_id": 7979}
{"snippet": "Pattern.split(string, maxsplit=0)", "intent": "Identical to the split ( ) function , using the compiled pattern . With arguments `string`, `maxsplit`.", "question_id": 7980}
{"snippet": "Pattern.findall(string, pos, endpos)", "intent": "Similar to the findall ( ) function , using the compiled pattern , but also accepts optional `pos` and `endpos` parameters that limit the search region like for search ( ) . With arguments `string`.", "question_id": 7981}
{"snippet": "Pattern.findall(string, pos)", "intent": "Similar to the findall ( ) function , using the compiled pattern , but also accepts optional `pos` and `endpos` parameters that limit the search region like for search ( ) . With arguments `string`.", "question_id": 7982}
{"snippet": "Pattern.findall(string)", "intent": "Similar to the findall ( ) function , using the compiled pattern , but also accepts optional `pos` and `endpos` parameters that limit the search region like for search ( ) . With arguments `string`.", "question_id": 7983}
{"snippet": "Pattern.finditer(string, pos, endpos)", "intent": "Similar to the finditer ( ) function , using the compiled pattern , but also accepts optional `pos` and `endpos` parameters that limit the search region like for search ( ) . With arguments `string`.", "question_id": 7984}
{"snippet": "Pattern.finditer(string, pos)", "intent": "Similar to the finditer ( ) function , using the compiled pattern , but also accepts optional `pos` and `endpos` parameters that limit the search region like for search ( ) . With arguments `string`.", "question_id": 7985}
{"snippet": "Pattern.finditer(string)", "intent": "Similar to the finditer ( ) function , using the compiled pattern , but also accepts optional `pos` and `endpos` parameters that limit the search region like for search ( ) . With arguments `string`.", "question_id": 7986}
{"snippet": "Pattern.sub(repl, string)", "intent": "Identical to the sub ( ) function , using the compiled pattern . With arguments `repl`, `string`.", "question_id": 7987}
{"snippet": "Pattern.sub(repl, string, count=0)", "intent": "Identical to the sub ( ) function , using the compiled pattern . With arguments `repl`, `string`, `count`.", "question_id": 7988}
{"snippet": "Pattern.subn(repl, string)", "intent": "Identical to the subn ( ) function , using the compiled pattern . With arguments `repl`, `string`.", "question_id": 7989}
{"snippet": "Pattern.subn(repl, string, count=0)", "intent": "Identical to the subn ( ) function , using the compiled pattern . With arguments `repl`, `string`, `count`.", "question_id": 7990}
{"snippet": "Pattern.flags", "intent": "The regex matching flags.", "question_id": 7991}
{"snippet": "Pattern.groups", "intent": "The number of capturing groups in the pattern.", "question_id": 7992}
{"snippet": "Pattern.groupindex", "intent": "A dictionary mapping any symbolic group names defined by (?P<id>) to group numbers.", "question_id": 7993}
{"snippet": "Pattern.pattern", "intent": "The pattern string from which the pattern object was compiled.", "question_id": 7994}
{"snippet": "Match.expand(template)", "intent": "Return the string obtained by doing backslash substitution on the `template` string template , as done by the sub ( ) method .", "question_id": 7995}
{"snippet": "Match.group(group1)", "intent": "Returns one or more subgroups of the match . Without arguments , `group1` defaults to zero ( the whole match is returned ) .", "question_id": 7996}
{"snippet": "Match.group()", "intent": "Returns one or more subgroups of the match .", "question_id": 7997}
{"snippet": "Match.__getitem__(g)", "intent": "This is identical to m.group ( `g` ) .", "question_id": 7998}
{"snippet": "Match.groups()", "intent": "Return a tuple containing all the subgroups of the match , from 1 up to however many groups are in the pattern .", "question_id": 7999}
{"snippet": "Match.groups(default=None)", "intent": "Return a tuple containing all the subgroups of the match , from 1 up to however many groups are in the pattern . The `default` argument is used for groups that did not participate in the match ; it defaults to None .", "question_id": 8000}
{"snippet": "Match.groupdict()", "intent": "Return a dictionary containing all the named subgroups of the match , keyed by the subgroup name .", "question_id": 8001}
{"snippet": "Match.groupdict(default=None)", "intent": "Return a dictionary containing all the named subgroups of the match , keyed by the subgroup name . The `default` argument is used for groups that did not participate in the match ; it defaults to None .", "question_id": 8002}
{"snippet": "Match.start(group)", "intent": "Return the indices of the start and end of the substring matched by `group` ; group defaults to zero ( meaning the whole matched substring ) .", "question_id": 8003}
{"snippet": "Match.start()", "intent": "Return the indices of the start and end of the substring matched by `group` ; group defaults to zero ( meaning the whole matched substring ) .", "question_id": 8004}
{"snippet": "Match.end(group)", "intent": "Return the indices of the start and end of the substring matched by `group` ; group defaults to zero ( meaning the whole matched substring ) .", "question_id": 8005}
{"snippet": "Match.end()", "intent": "Return the indices of the start and end of the substring matched by `group` ; group defaults to zero ( meaning the whole matched substring ) .", "question_id": 8006}
{"snippet": "Match.span(group)", "intent": "For a match m , return the 2-tuple ( m.start ( `group` ) , m.end ( group ) ) .", "question_id": 8007}
{"snippet": "Match.span()", "intent": "For a match m , return the 2-tuple ( m.start ( `group` ) , m.end ( group ) ) .", "question_id": 8008}
{"snippet": "Match.pos", "intent": "The value of pos which was passed to the search() or match() method of a regex object.", "question_id": 8009}
{"snippet": "Match.endpos", "intent": "The value of endpos which was passed to the search() or match() method of a regex object.", "question_id": 8010}
{"snippet": "Match.lastindex", "intent": "The integer index of the last matched capturing group, or None if no group was matched at all.", "question_id": 8011}
{"snippet": "Match.lastgroup", "intent": "The name of the last matched capturing group, or None if the group didn\u2019t have a name, or if no group was matched at all.", "question_id": 8012}
{"snippet": "Match.re", "intent": "The regular expression object whose match() or search() method produced this match instance.", "question_id": 8013}
{"snippet": "Match.string", "intent": "The string passed to match() or search().", "question_id": 8014}
{"snippet": "readline.parse_and_bind(string)", "intent": "Execute the init line provided in the `string` argument .", "question_id": 8015}
{"snippet": "readline.read_init_file(filename)", "intent": "Execute a readline initialization file . The default `filename` is the last filename used .", "question_id": 8016}
{"snippet": "readline.read_init_file()", "intent": "Execute a readline initialization file .", "question_id": 8017}
{"snippet": "readline.get_line_buffer()", "intent": "Return the current contents of the line buffer ( rl_line_buffer in the underlying library ) .", "question_id": 8018}
{"snippet": "readline.insert_text(string)", "intent": "Insert text into the line buffer at the cursor position . With arguments `string`.", "question_id": 8019}
{"snippet": "readline.redisplay()", "intent": "Change what \u2019 s displayed on the screen to reflect the current contents of the line buffer .", "question_id": 8020}
{"snippet": "readline.read_history_file(filename)", "intent": "Load a readline history file , and append it to the history list . The default `filename` is ~/.history .", "question_id": 8021}
{"snippet": "readline.read_history_file()", "intent": "Load a readline history file , and append it to the history list .", "question_id": 8022}
{"snippet": "readline.write_history_file(filename)", "intent": "Save the history list to a readline history file , overwriting any existing file . The default `filename` is ~/.history .", "question_id": 8023}
{"snippet": "readline.write_history_file()", "intent": "Save the history list to a readline history file , overwriting any existing file .", "question_id": 8024}
{"snippet": "readline.append_history_file(nelements, filename)", "intent": "Append the last `nelements` items of history to a file . The default `filename` is ~/.history .", "question_id": 8025}
{"snippet": "readline.append_history_file(nelements)", "intent": "Append the last `nelements` items of history to a file .", "question_id": 8026}
{"snippet": "readline.get_history_length()", "intent": "Set or return the desired number of lines to save in the history file .", "question_id": 8027}
{"snippet": "readline.set_history_length(length)", "intent": "Set or return the desired number of lines to save in the history file . With arguments `length`.", "question_id": 8028}
{"snippet": "readline.clear_history()", "intent": "Clear the current history .", "question_id": 8029}
{"snippet": "readline.get_current_history_length()", "intent": "Return the number of items currently in the history .", "question_id": 8030}
{"snippet": "readline.get_history_item(index)", "intent": "Return the current contents of history item at `index` .", "question_id": 8031}
{"snippet": "readline.remove_history_item(pos)", "intent": "Remove history item specified by its position from the history . With arguments `pos`.", "question_id": 8032}
{"snippet": "readline.replace_history_item(pos, line)", "intent": "Replace history item specified by its position with `line` . With arguments `pos`.", "question_id": 8033}
{"snippet": "readline.add_history(line)", "intent": "Append `line` to the history buffer , as if it was the last line typed .", "question_id": 8034}
{"snippet": "readline.set_auto_history(enabled)", "intent": "Enable or disable automatic calls to add_history ( ) when reading input via readline . The `enabled` argument should be a Boolean value that when true , enables auto history , and that when false , disables auto history .", "question_id": 8035}
{"snippet": "readline.set_startup_hook(function)", "intent": "Set or remove the `function` invoked by the rl_startup_hook callback of the underlying library .", "question_id": 8036}
{"snippet": "readline.set_startup_hook()", "intent": "Set or remove the `function` invoked by the rl_startup_hook callback of the underlying library .", "question_id": 8037}
{"snippet": "readline.set_pre_input_hook(function)", "intent": "Set or remove the `function` invoked by the rl_pre_input_hook callback of the underlying library .", "question_id": 8038}
{"snippet": "readline.set_pre_input_hook()", "intent": "Set or remove the `function` invoked by the rl_pre_input_hook callback of the underlying library .", "question_id": 8039}
{"snippet": "readline.set_completer(function)", "intent": "Set or remove the completer `function` .", "question_id": 8040}
{"snippet": "readline.set_completer()", "intent": "Set or remove the completer `function` .", "question_id": 8041}
{"snippet": "readline.get_completer()", "intent": "Get the completer function , or None if no completer function has been set .", "question_id": 8042}
{"snippet": "readline.get_completion_type()", "intent": "Get the type of completion being attempted .", "question_id": 8043}
{"snippet": "readline.get_begidx()", "intent": "Get the beginning or ending index of the completion scope .", "question_id": 8044}
{"snippet": "readline.get_endidx()", "intent": "Get the beginning or ending index of the completion scope .", "question_id": 8045}
{"snippet": "readline.set_completer_delims(string)", "intent": "Set or get the word delimiters for completion . With arguments `string`.", "question_id": 8046}
{"snippet": "readline.get_completer_delims()", "intent": "Set or get the word delimiters for completion .", "question_id": 8047}
{"snippet": "readline.set_completion_display_matches_hook(function)", "intent": "Set or remove the completion display `function` .", "question_id": 8048}
{"snippet": "readline.set_completion_display_matches_hook()", "intent": "Set or remove the completion display `function` .", "question_id": 8049}
{"snippet": "reprlib.Repr", "intent": "Class which provides formatting services useful in implementing functions similar to the built-in repr(); size limits for  different object types are added to avoid the generation of representations which are excessively long.", "question_id": 8050}
{"snippet": "reprlib.aRepr", "intent": "This is an instance of Repr which is used to provide the repr() function described below.", "question_id": 8051}
{"snippet": "reprlib.repr(obj)", "intent": "This is the repr ( ) method of aRepr . With arguments `obj`.", "question_id": 8052}
{"snippet": "@reprlib.recursive_repr()", "intent": "Decorator for __repr__ ( ) methods to detect recursive calls within the same thread .", "question_id": 8053}
{"snippet": "@reprlib.recursive_repr(fillvalue=\"...\")", "intent": "Decorator for __repr__ ( ) methods to detect recursive calls within the same thread . If a recursive call is made , the `fillvalue` is returned , otherwise , the usual __repr__ ( ) call is made .", "question_id": 8054}
{"snippet": "Repr.maxlevel", "intent": "Depth limit on the creation of recursive representations.", "question_id": 8055}
{"snippet": "Repr.maxdict", "intent": "Limits on the number of entries represented for the named object type.", "question_id": 8056}
{"snippet": "Repr.maxlist", "intent": "Limits on the number of entries represented for the named object type.", "question_id": 8057}
{"snippet": "Repr.maxtuple", "intent": "Limits on the number of entries represented for the named object type.", "question_id": 8058}
{"snippet": "Repr.maxset", "intent": "Limits on the number of entries represented for the named object type.", "question_id": 8059}
{"snippet": "Repr.maxfrozenset", "intent": "Limits on the number of entries represented for the named object type.", "question_id": 8060}
{"snippet": "Repr.maxdeque", "intent": "Limits on the number of entries represented for the named object type.", "question_id": 8061}
{"snippet": "Repr.maxarray", "intent": "Limits on the number of entries represented for the named object type.", "question_id": 8062}
{"snippet": "Repr.maxlong", "intent": "Maximum number of characters in the representation for an integer.", "question_id": 8063}
{"snippet": "Repr.maxstring", "intent": "Limit on the number of characters in the representation of the string.", "question_id": 8064}
{"snippet": "Repr.maxother", "intent": "This limit is used to control the size of object types for which no specific formatting method is available on the Repr object.", "question_id": 8065}
{"snippet": "Repr.repr(obj)", "intent": "The equivalent to the built-in repr ( ) that uses the formatting imposed by the instance . With arguments `obj`.", "question_id": 8066}
{"snippet": "Repr.repr1(obj, level)", "intent": "Recursive implementation used by repr ( ) . This uses the type of `obj` to determine which formatting method to call , passing it obj and `level` .", "question_id": 8067}
{"snippet": "Repr.repr_TYPE(obj, level)", "intent": "Formatting methods for specific types are implemented as methods with a name based on the type name . In the method name , TYPE is replaced by ' _'.join ( type ( `obj` ) .__name__.split ( ) ) . Type-specific methods which need to recursively format a value should call self.repr1 ( subobj , `level` - 1 ) .", "question_id": 8068}
{"snippet": "resource.error", "intent": "A deprecated alias of OSError.", "question_id": 8069}
{"snippet": "resource.RLIM_INFINITY", "intent": "Constant used to represent the limit for an unlimited resource.", "question_id": 8070}
{"snippet": "resource.getrlimit(resource)", "intent": "Returns a tuple ( soft , hard ) with the current soft and hard limits of `resource` .", "question_id": 8071}
{"snippet": "resource.setrlimit(resource, limits)", "intent": "Sets new `limits` of consumption of `resource` .", "question_id": 8072}
{"snippet": "resource.prlimit(pid, resource, limits)", "intent": "Combines setrlimit ( ) and getrlimit ( ) in one function and supports to get and set the resources `limits` of an arbitrary process . If `pid` is 0 , then the call applies to the current process . `resource` and limits have the same meaning as in setrlimit ( ) , except that limits is optional .", "question_id": 8073}
{"snippet": "resource.prlimit(pid, resource)", "intent": "Combines setrlimit ( ) and getrlimit ( ) in one function and supports to get and set the resources `limits` of an arbitrary process . If `pid` is 0 , then the call applies to the current process . `resource` and limits have the same meaning as in setrlimit ( ) , except that limits is optional .", "question_id": 8074}
{"snippet": "resource.RLIMIT_CORE", "intent": "The maximum size (in bytes) of a core file that the current process can create.", "question_id": 8075}
{"snippet": "resource.RLIMIT_CPU", "intent": "The maximum amount of processor time (in seconds) that a process can use.", "question_id": 8076}
{"snippet": "resource.RLIMIT_FSIZE", "intent": "The maximum size of a file which the process may create.", "question_id": 8077}
{"snippet": "resource.RLIMIT_DATA", "intent": "The maximum size (in bytes) of the process\u2019s heap.", "question_id": 8078}
{"snippet": "resource.RLIMIT_STACK", "intent": "The maximum size (in bytes) of the call stack for the current process.", "question_id": 8079}
{"snippet": "resource.RLIMIT_RSS", "intent": "The maximum resident set size that should be made available to the process.", "question_id": 8080}
{"snippet": "resource.RLIMIT_NPROC", "intent": "The maximum number of processes the current process may create.", "question_id": 8081}
{"snippet": "resource.RLIMIT_NOFILE", "intent": "The maximum number of open file descriptors for the current process.", "question_id": 8082}
{"snippet": "resource.RLIMIT_OFILE", "intent": "The BSD name for RLIMIT_NOFILE.", "question_id": 8083}
{"snippet": "resource.RLIMIT_MEMLOCK", "intent": "The maximum address space which may be locked in memory.", "question_id": 8084}
{"snippet": "resource.RLIMIT_VMEM", "intent": "The largest area of mapped memory which the process may occupy.", "question_id": 8085}
{"snippet": "resource.RLIMIT_AS", "intent": "The maximum area (in bytes) of address space which may be taken by the process.", "question_id": 8086}
{"snippet": "resource.RLIMIT_MSGQUEUE", "intent": "The number of bytes that can be allocated for POSIX message queues.", "question_id": 8087}
{"snippet": "resource.RLIMIT_NICE", "intent": "The ceiling for the process\u2019s nice level (calculated as 20 - rlim_cur).", "question_id": 8088}
{"snippet": "resource.RLIMIT_RTPRIO", "intent": "The ceiling of the real-time priority.", "question_id": 8089}
{"snippet": "resource.RLIMIT_RTTIME", "intent": "The time limit (in microseconds) on CPU time that a process can spend under real-time scheduling without making a blocking syscall.", "question_id": 8090}
{"snippet": "resource.RLIMIT_SIGPENDING", "intent": "The number of signals which the process may queue.", "question_id": 8091}
{"snippet": "resource.RLIMIT_SBSIZE", "intent": "The maximum size (in bytes) of socket buffer usage for this user.", "question_id": 8092}
{"snippet": "resource.RLIMIT_SWAP", "intent": "The maximum size (in bytes) of the swap space that may be reserved or used by all of this user id\u2019s processes.", "question_id": 8093}
{"snippet": "resource.RLIMIT_NPTS", "intent": "The maximum number of pseudo-terminals created by this user id.", "question_id": 8094}
{"snippet": "resource.getrusage(who)", "intent": "This function returns an object that describes the resources consumed by either the current process or its children , as specified by the `who` parameter .", "question_id": 8095}
{"snippet": "resource.getpagesize()", "intent": "Returns the number of bytes in a system page .", "question_id": 8096}
{"snippet": "resource.RUSAGE_SELF", "intent": "Pass to getrusage() to request resources consumed by the calling process, which is the sum of resources used by all threads in the process.", "question_id": 8097}
{"snippet": "resource.RUSAGE_CHILDREN", "intent": "Pass to getrusage() to request resources consumed by child processes of the calling process which have been terminated and waited for.", "question_id": 8098}
{"snippet": "resource.RUSAGE_BOTH", "intent": "Pass to getrusage() to request resources consumed by both the current process and child processes.", "question_id": 8099}
{"snippet": "resource.RUSAGE_THREAD", "intent": "Pass to getrusage() to request resources consumed by the current thread.", "question_id": 8100}
{"snippet": "Completer.complete(text, state)", "intent": "Return the stateth completion for `text` . With arguments `state`.", "question_id": 8101}
{"snippet": "runpy.run_module(mod_name)", "intent": "Execute the code of the specified module and return the resulting module globals dictionary . The `mod_name` argument should be an absolute module name .", "question_id": 8102}
{"snippet": "runpy.run_module(mod_name, init_globals=None)", "intent": "Execute the code of the specified module and return the resulting module globals dictionary . The `mod_name` argument should be an absolute module name . The optional dictionary argument `init_globals` may be used to pre-populate the module \u2019 s globals dictionary before the code is executed .", "question_id": 8103}
{"snippet": "runpy.run_module(mod_name, run_name=None)", "intent": "Execute the code of the specified module and return the resulting module globals dictionary . The `mod_name` argument should be an absolute module name . __name__ is set to `run_name` if this optional argument is not None , to mod_name + '.__main__ ' if the named module is a package and to the mod_name argument otherwise .", "question_id": 8104}
{"snippet": "runpy.run_module(mod_name, alter_sys=False)", "intent": "Execute the code of the specified module and return the resulting module globals dictionary . The `mod_name` argument should be an absolute module name . If the argument `alter_sys` is supplied and evaluates to True , then sys.argv [ 0 ] is updated with the value of __file__ and sys.modules [ __name__ ] is updated with a temporary module object for the module being executed .", "question_id": 8105}
{"snippet": "runpy.run_module(mod_name, init_globals=None, run_name=None)", "intent": "Execute the code of the specified module and return the resulting module globals dictionary . The `mod_name` argument should be an absolute module name . The optional dictionary argument `init_globals` may be used to pre-populate the module \u2019 s globals dictionary before the code is executed . __name__ is set to `run_name` if this optional argument is not None , to mod_name + '.__main__ ' if the named module is a package and to the mod_name argument otherwise .", "question_id": 8106}
{"snippet": "runpy.run_module(mod_name, init_globals=None, alter_sys=False)", "intent": "Execute the code of the specified module and return the resulting module globals dictionary . The `mod_name` argument should be an absolute module name . The optional dictionary argument `init_globals` may be used to pre-populate the module \u2019 s globals dictionary before the code is executed . If the argument `alter_sys` is supplied and evaluates to True , then sys.argv [ 0 ] is updated with the value of __file__ and sys.modules [ __name__ ] is updated with a temporary module object for the module being executed .", "question_id": 8107}
{"snippet": "runpy.run_module(mod_name, run_name=None, alter_sys=False)", "intent": "Execute the code of the specified module and return the resulting module globals dictionary . The `mod_name` argument should be an absolute module name . __name__ is set to `run_name` if this optional argument is not None , to mod_name + '.__main__ ' if the named module is a package and to the mod_name argument otherwise . If the argument `alter_sys` is supplied and evaluates to True , then sys.argv [ 0 ] is updated with the value of __file__ and sys.modules [ __name__ ] is updated with a temporary module object for the module being executed .", "question_id": 8108}
{"snippet": "runpy.run_module(mod_name, init_globals=None, run_name=None, alter_sys=False)", "intent": "Execute the code of the specified module and return the resulting module globals dictionary . The `mod_name` argument should be an absolute module name . The optional dictionary argument `init_globals` may be used to pre-populate the module \u2019 s globals dictionary before the code is executed . __name__ is set to `run_name` if this optional argument is not None , to mod_name + '.__main__ ' if the named module is a package and to the mod_name argument otherwise . If the argument `alter_sys` is supplied and evaluates to True , then sys.argv [ 0 ] is updated with the value of __file__ and sys.modules [ __name__ ] is updated with a temporary module object for the module being executed .", "question_id": 8109}
{"snippet": "runpy.run_path(file_path)", "intent": "Execute the code at the named filesystem location and return the resulting module globals dictionary . sys.argv [ 0 ] is updated with the value of `file_path` and sys.modules [ __name__ ] is updated with a temporary module object for the module being executed .", "question_id": 8110}
{"snippet": "runpy.run_path(file_path, init_globals=None)", "intent": "Execute the code at the named filesystem location and return the resulting module globals dictionary . sys.argv [ 0 ] is updated with the value of `file_path` and sys.modules [ __name__ ] is updated with a temporary module object for the module being executed . The optional dictionary argument `init_globals` may be used to pre-populate the module \u2019 s globals dictionary before the code is executed .", "question_id": 8111}
{"snippet": "runpy.run_path(file_path, run_name=None)", "intent": "Execute the code at the named filesystem location and return the resulting module globals dictionary . sys.argv [ 0 ] is updated with the value of `file_path` and sys.modules [ __name__ ] is updated with a temporary module object for the module being executed . __name__ is set to `run_name` if this optional argument is not None and to ' < run_path > ' otherwise .", "question_id": 8112}
{"snippet": "runpy.run_path(file_path, init_globals=None, run_name=None)", "intent": "Execute the code at the named filesystem location and return the resulting module globals dictionary . sys.argv [ 0 ] is updated with the value of `file_path` and sys.modules [ __name__ ] is updated with a temporary module object for the module being executed . The optional dictionary argument `init_globals` may be used to pre-populate the module \u2019 s globals dictionary before the code is executed . __name__ is set to `run_name` if this optional argument is not None and to ' < run_path > ' otherwise .", "question_id": 8113}
{"snippet": "sched.scheduler()", "intent": "The scheduler class defines a generic interface to scheduling events .", "question_id": 8114}
{"snippet": "sched.scheduler(timefunc=time.monotonic)", "intent": "The scheduler class defines a generic interface to scheduling events . It needs two functions to actually deal with the \u201c outside world \u201d \u2014 `timefunc` should be callable without arguments , and return a number ( the \u201c time \u201d , in any units whatsoever ) .", "question_id": 8115}
{"snippet": "sched.scheduler(delayfunc=time.sleep)", "intent": "The scheduler class defines a generic interface to scheduling events . The `delayfunc` function should be callable with one argument , compatible with the output of timefunc , and should delay that many time units .", "question_id": 8116}
{"snippet": "sched.scheduler(timefunc=time.monotonic, delayfunc=time.sleep)", "intent": "The scheduler class defines a generic interface to scheduling events . It needs two functions to actually deal with the \u201c outside world \u201d \u2014 `timefunc` should be callable without arguments , and return a number ( the \u201c time \u201d , in any units whatsoever ) . The `delayfunc` function should be callable with one argument , compatible with the output of timefunc , and should delay that many time units .", "question_id": 8117}
{"snippet": "scheduler.enterabs(time, priority, action)", "intent": "Schedule a new event . The `time` `argument` should be a numeric type compatible with the return value of the timefunc function passed to the constructor . Events scheduled for the same time will be executed in the order of their `priority` . Executing the event means executing `action` ( *argument , **kwargs ) .", "question_id": 8118}
{"snippet": "scheduler.enterabs(time, priority, action, argument=())", "intent": "Schedule a new event . The `time` `argument` should be a numeric type compatible with the return value of the timefunc function passed to the constructor . Events scheduled for the same time will be executed in the order of their `priority` . Executing the event means executing `action` ( *argument , **kwargs ) .", "question_id": 8119}
{"snippet": "scheduler.enterabs(time, priority, action, kwargs={})", "intent": "Schedule a new event . The `time` `argument` should be a numeric type compatible with the return value of the timefunc function passed to the constructor . Events scheduled for the same time will be executed in the order of their `priority` . Executing the event means executing `action` ( *argument , **kwargs ) . `kwargs` is a dictionary holding the keyword arguments for action .", "question_id": 8120}
{"snippet": "scheduler.enterabs(time, priority, action, argument=(), kwargs={})", "intent": "Schedule a new event . The `time` `argument` should be a numeric type compatible with the return value of the timefunc function passed to the constructor . Events scheduled for the same time will be executed in the order of their `priority` . Executing the event means executing `action` ( *argument , **kwargs ) . `kwargs` is a dictionary holding the keyword arguments for action .", "question_id": 8121}
{"snippet": "scheduler.enter(delay, priority, action)", "intent": "Schedule an event for `delay` more time units . With arguments `priority`, `action`.", "question_id": 8122}
{"snippet": "scheduler.enter(delay, priority, action, argument=())", "intent": "Schedule an event for `delay` more time units . With arguments `priority`, `action`, `argument`.", "question_id": 8123}
{"snippet": "scheduler.enter(delay, priority, action, kwargs={})", "intent": "Schedule an event for `delay` more time units . With arguments `priority`, `action`, `kwargs`.", "question_id": 8124}
{"snippet": "scheduler.enter(delay, priority, action, argument=(), kwargs={})", "intent": "Schedule an event for `delay` more time units . With arguments `priority`, `action`, `argument`, `kwargs`.", "question_id": 8125}
{"snippet": "scheduler.cancel(event)", "intent": "Remove the `event` from the queue .", "question_id": 8126}
{"snippet": "scheduler.empty()", "intent": "Return true if the event queue is empty .", "question_id": 8127}
{"snippet": "scheduler.run()", "intent": "Run all scheduled events .", "question_id": 8128}
{"snippet": "scheduler.run(blocking=True)", "intent": "Run all scheduled events . If `blocking` is false executes the scheduled events due to expire soonest ( if any ) and then return the deadline of the next scheduled call in the scheduler ( if any ) .", "question_id": 8129}
{"snippet": "scheduler.queue", "intent": "Read-only attribute returning a list of upcoming events in the order they will be run.", "question_id": 8130}
{"snippet": "secrets.SystemRandom", "intent": "A class for generating random numbers using the highest-quality sources provided by the operating system.", "question_id": 8131}
{"snippet": "secrets.choice(sequence)", "intent": "Return a randomly-chosen element from a non-empty `sequence` .", "question_id": 8132}
{"snippet": "secrets.randbelow(n)", "intent": "Return a random int in the range [ 0 , `n` ) .", "question_id": 8133}
{"snippet": "secrets.randbits(k)", "intent": "Return an int with `k` random bits .", "question_id": 8134}
{"snippet": "secrets.token_bytes()", "intent": "Return a random byte string containing `nbytes` number of bytes .", "question_id": 8135}
{"snippet": "secrets.token_bytes(nbytes=None)", "intent": "Return a random byte string containing `nbytes` number of bytes .", "question_id": 8136}
{"snippet": "secrets.token_bytes()", "intent": "Return a random byte string containing `nbytes` number of bytes .", "question_id": 8137}
{"snippet": "secrets.token_bytes(nbytes=None)", "intent": "Return a random byte string containing `nbytes` number of bytes .", "question_id": 8138}
{"snippet": "secrets.token_hex()", "intent": "Return a random text string , in hexadecimal .", "question_id": 8139}
{"snippet": "secrets.token_hex(nbytes=None)", "intent": "Return a random text string , in hexadecimal . The string has `nbytes` random bytes , each byte converted to two hex digits .", "question_id": 8140}
{"snippet": "secrets.token_hex()", "intent": "Return a random text string , in hexadecimal .", "question_id": 8141}
{"snippet": "secrets.token_hex(nbytes=None)", "intent": "Return a random text string , in hexadecimal . The string has `nbytes` random bytes , each byte converted to two hex digits .", "question_id": 8142}
{"snippet": "secrets.token_urlsafe()", "intent": "Return a random URL-safe text string , containing `nbytes` random bytes .", "question_id": 8143}
{"snippet": "secrets.token_urlsafe(nbytes=None)", "intent": "Return a random URL-safe text string , containing `nbytes` random bytes .", "question_id": 8144}
{"snippet": "secrets.token_urlsafe()", "intent": "Return a random URL-safe text string , containing `nbytes` random bytes .", "question_id": 8145}
{"snippet": "secrets.token_urlsafe(nbytes=None)", "intent": "Return a random URL-safe text string , containing `nbytes` random bytes .", "question_id": 8146}
{"snippet": "secrets.compare_digest(a, b)", "intent": "Return True if strings `a` and `b` are equal , otherwise False , in such a way as to reduce the risk of timing attacks .", "question_id": 8147}
{"snippet": "select.error", "intent": "A deprecated alias of OSError.", "question_id": 8148}
{"snippet": "select.devpoll()", "intent": "( Only supported on Solaris and derivatives . )", "question_id": 8149}
{"snippet": "select.epoll()", "intent": "( Only supported on Linux 2.5.44 and newer . )", "question_id": 8150}
{"snippet": "select.epoll(sizehint=-1)", "intent": "( Only supported on Linux 2.5.44 and newer . ) `sizehint` informs epoll about the expected number of events to be registered .", "question_id": 8151}
{"snippet": "select.epoll(flags=0)", "intent": "( Only supported on Linux 2.5.44 and newer . ) `flags` is deprecated and completely ignored .", "question_id": 8152}
{"snippet": "select.epoll(sizehint=-1, flags=0)", "intent": "( Only supported on Linux 2.5.44 and newer . ) `sizehint` informs epoll about the expected number of events to be registered . `flags` is deprecated and completely ignored .", "question_id": 8153}
{"snippet": "select.poll()", "intent": "( Not supported by all operating systems . )", "question_id": 8154}
{"snippet": "select.kqueue()", "intent": "( Only supported on BSD . )", "question_id": 8155}
{"snippet": "select.kevent(ident)", "intent": "( Only supported on BSD . ) With arguments `ident`.", "question_id": 8156}
{"snippet": "select.kevent(ident, filter=KQ_FILTER_READ)", "intent": "( Only supported on BSD . ) With arguments `ident`, `filter`.", "question_id": 8157}
{"snippet": "select.kevent(ident, flags=KQ_EV_ADD)", "intent": "( Only supported on BSD . ) With arguments `ident`, `flags`.", "question_id": 8158}
{"snippet": "select.kevent(ident, fflags=0)", "intent": "( Only supported on BSD . ) With arguments `ident`, `fflags`.", "question_id": 8159}
{"snippet": "select.kevent(ident, data=0)", "intent": "( Only supported on BSD . ) With arguments `ident`, `data`.", "question_id": 8160}
{"snippet": "select.kevent(ident, udata=0)", "intent": "( Only supported on BSD . ) With arguments `ident`, `udata`.", "question_id": 8161}
{"snippet": "select.kevent(ident, filter=KQ_FILTER_READ, flags=KQ_EV_ADD)", "intent": "( Only supported on BSD . ) With arguments `ident`, `filter`, `flags`.", "question_id": 8162}
{"snippet": "select.kevent(ident, filter=KQ_FILTER_READ, fflags=0)", "intent": "( Only supported on BSD . ) With arguments `ident`, `filter`, `fflags`.", "question_id": 8163}
{"snippet": "select.kevent(ident, filter=KQ_FILTER_READ, data=0)", "intent": "( Only supported on BSD . ) With arguments `ident`, `filter`, `data`.", "question_id": 8164}
{"snippet": "select.kevent(ident, filter=KQ_FILTER_READ, udata=0)", "intent": "( Only supported on BSD . ) With arguments `ident`, `filter`, `udata`.", "question_id": 8165}
{"snippet": "select.select(rlist, wlist, xlist, timeout)", "intent": "This is a straightforward interface to the Unix select ( ) system call . The optional `timeout` argument specifies a time-out as a floating point number in seconds . With arguments `rlist`, `wlist`, `xlist`.", "question_id": 8166}
{"snippet": "select.select(rlist, wlist, xlist)", "intent": "This is a straightforward interface to the Unix select ( ) system call . With arguments `rlist`, `wlist`, `xlist`.", "question_id": 8167}
{"snippet": "select.PIPE_BUF", "intent": "The minimum number of bytes which can be written without blocking to a pipe when the pipe has been reported as ready for writing by select(), poll() or another interface in this module.", "question_id": 8168}
{"snippet": "devpoll.close()", "intent": "Close the file descriptor of the polling object .", "question_id": 8169}
{"snippet": "devpoll.closed", "intent": "True if the polling object is closed.", "question_id": 8170}
{"snippet": "devpoll.fileno()", "intent": "Return the file descriptor number of the polling object .", "question_id": 8171}
{"snippet": "devpoll.register(fd, eventmask)", "intent": "Register a file descriptor with the polling object . `fd` can be either an integer , or an object with a fileno ( ) method that returns an integer . `eventmask` is an optional bitmask describing the type of events you want to check for .", "question_id": 8172}
{"snippet": "devpoll.register(fd)", "intent": "Register a file descriptor with the polling object . `fd` can be either an integer , or an object with a fileno ( ) method that returns an integer .", "question_id": 8173}
{"snippet": "devpoll.modify(fd, eventmask)", "intent": "This method does an unregister ( ) followed by a register ( ) . With arguments `fd`, `eventmask`.", "question_id": 8174}
{"snippet": "devpoll.modify(fd)", "intent": "This method does an unregister ( ) followed by a register ( ) . With arguments `fd`.", "question_id": 8175}
{"snippet": "devpoll.unregister(fd)", "intent": "Remove a file descriptor being tracked by a polling object . Just like the register ( ) method , `fd` can be an integer or an object with a fileno ( ) method that returns an integer .", "question_id": 8176}
{"snippet": "devpoll.poll(timeout)", "intent": "Polls the set of registered file descriptors , and returns a possibly-empty list containing ( fd , event ) 2-tuples for the descriptors that have events or errors to report . If `timeout` is given , it specifies the length of time in milliseconds which the system will wait for events before returning .", "question_id": 8177}
{"snippet": "devpoll.poll()", "intent": "Polls the set of registered file descriptors , and returns a possibly-empty list containing ( fd , event ) 2-tuples for the descriptors that have events or errors to report .", "question_id": 8178}
{"snippet": "epoll.close()", "intent": "Close the control file descriptor of the epoll object .", "question_id": 8179}
{"snippet": "epoll.closed", "intent": "True if the epoll object is closed.", "question_id": 8180}
{"snippet": "epoll.fileno()", "intent": "Return the file descriptor number of the control fd .", "question_id": 8181}
{"snippet": "epoll.fromfd(fd)", "intent": "Create an epoll object from a given file descriptor . With arguments `fd`.", "question_id": 8182}
{"snippet": "epoll.register(fd, eventmask)", "intent": "Register a `fd` descriptor with the epoll object . With arguments `eventmask`.", "question_id": 8183}
{"snippet": "epoll.register(fd)", "intent": "Register a `fd` descriptor with the epoll object .", "question_id": 8184}
{"snippet": "epoll.modify(fd, eventmask)", "intent": "Modify a registered file descriptor . With arguments `fd`, `eventmask`.", "question_id": 8185}
{"snippet": "epoll.unregister(fd)", "intent": "Remove a registered file descriptor from the epoll object . With arguments `fd`.", "question_id": 8186}
{"snippet": "epoll.poll()", "intent": "Wait for events .", "question_id": 8187}
{"snippet": "epoll.poll(timeout=-1)", "intent": "Wait for events . `timeout` in seconds ( float )", "question_id": 8188}
{"snippet": "epoll.poll(maxevents=-1)", "intent": "Wait for events . With arguments `maxevents`.", "question_id": 8189}
{"snippet": "epoll.poll(timeout=-1, maxevents=-1)", "intent": "Wait for events . `timeout` in seconds ( float ) With arguments `maxevents`.", "question_id": 8190}
{"snippet": "poll.register(fd, eventmask)", "intent": "Register a file descriptor with the polling object . `fd` can be either an integer , or an object with a fileno ( ) method that returns an integer . `eventmask` is an optional bitmask describing the type of events you want to check for , and can be a combination of the constants POLLIN , POLLPRI , and POLLOUT , described in the table below .", "question_id": 8191}
{"snippet": "poll.register(fd)", "intent": "Register a file descriptor with the polling object . `fd` can be either an integer , or an object with a fileno ( ) method that returns an integer .", "question_id": 8192}
{"snippet": "poll.modify(fd, eventmask)", "intent": "Modifies an already registered `fd` . This has the same effect as register ( fd , `eventmask` ) .", "question_id": 8193}
{"snippet": "poll.unregister(fd)", "intent": "Remove a file descriptor being tracked by a polling object . Just like the register ( ) method , `fd` can be an integer or an object with a fileno ( ) method that returns an integer .", "question_id": 8194}
{"snippet": "poll.poll(timeout)", "intent": "Polls the set of registered file descriptors , and returns a possibly-empty list containing ( fd , event ) 2-tuples for the descriptors that have events or errors to report . If `timeout` is given , it specifies the length of time in milliseconds which the system will wait for events before returning .", "question_id": 8195}
{"snippet": "poll.poll()", "intent": "Polls the set of registered file descriptors , and returns a possibly-empty list containing ( fd , event ) 2-tuples for the descriptors that have events or errors to report .", "question_id": 8196}
{"snippet": "kqueue.close()", "intent": "Close the control file descriptor of the kqueue object .", "question_id": 8197}
{"snippet": "kqueue.closed", "intent": "True if the kqueue object is closed.", "question_id": 8198}
{"snippet": "kqueue.fileno()", "intent": "Return the file descriptor number of the control fd .", "question_id": 8199}
{"snippet": "kqueue.fromfd(fd)", "intent": "Create a kqueue object from a given file descriptor . With arguments `fd`.", "question_id": 8200}
{"snippet": "kqueue.control(changelist, max_events, timeout)", "intent": "Low level interface to kevent With arguments `changelist`, `max_events`, `timeout`.", "question_id": 8201}
{"snippet": "kqueue.control(changelist, max_events)", "intent": "Low level interface to kevent With arguments `changelist`, `max_events`.", "question_id": 8202}
{"snippet": "kevent.ident", "intent": "Value used to identify the event.", "question_id": 8203}
{"snippet": "kevent.filter", "intent": "Name of the kernel filter.", "question_id": 8204}
{"snippet": "kevent.flags", "intent": "Filter action.", "question_id": 8205}
{"snippet": "kevent.fflags", "intent": "Filter specific flags.", "question_id": 8206}
{"snippet": "kevent.data", "intent": "Filter specific data.", "question_id": 8207}
{"snippet": "kevent.udata", "intent": "User defined value.", "question_id": 8208}
{"snippet": "selectors.SelectorKey", "intent": "A SelectorKey is a namedtuple used to associate a file object to its underlying file descriptor, selected event mask and attached data.", "question_id": 8209}
{"snippet": "selector_key.fileobj", "intent": "File object registered.", "question_id": 8210}
{"snippet": "selector_key.fd", "intent": "Underlying file descriptor.", "question_id": 8211}
{"snippet": "selector_key.events", "intent": "Events that must be waited for on this file object.", "question_id": 8212}
{"snippet": "selector_key.data", "intent": "Optional opaque data associated to this file object: for example, this could be used to store a per-client session ID.", "question_id": 8213}
{"snippet": "selectors.BaseSelector", "intent": "A BaseSelector is used to wait for I/O event readiness on multiple file objects.", "question_id": 8214}
{"snippet": "base_selector.register(fileobj, events)", "intent": "Register a file object for selection , monitoring it for I/O `events` . `fileobj` is the file object to monitor .", "question_id": 8215}
{"snippet": "base_selector.register(fileobj, events, data=None)", "intent": "Register a file object for selection , monitoring it for I/O `events` . `fileobj` is the file object to monitor . `data` is an opaque object .", "question_id": 8216}
{"snippet": "base_selector.unregister(fileobj)", "intent": "Unregister a file object from selection , removing it from monitoring . `fileobj` must be a file object previously registered .", "question_id": 8217}
{"snippet": "base_selector.modify(fileobj, events)", "intent": "Change a registered file object \u2019 s monitored `events` or attached `data` . This is equivalent to BaseSelector.unregister ( `fileobj` ) ( ) followed by BaseSelector.register ( fileobj , events , data ) ( ) , except that it can be implemented more efficiently .", "question_id": 8218}
{"snippet": "base_selector.modify(fileobj, events, data=None)", "intent": "Change a registered file object \u2019 s monitored `events` or attached `data` . This is equivalent to BaseSelector.unregister ( `fileobj` ) ( ) followed by BaseSelector.register ( fileobj , events , data ) ( ) , except that it can be implemented more efficiently .", "question_id": 8219}
{"snippet": "base_selector.select()", "intent": "Wait until some registered file objects become ready , or the `timeout` expires .", "question_id": 8220}
{"snippet": "base_selector.select(timeout=None)", "intent": "Wait until some registered file objects become ready , or the `timeout` expires .", "question_id": 8221}
{"snippet": "base_selector.close()", "intent": "Close the selector .", "question_id": 8222}
{"snippet": "base_selector.get_key(fileobj)", "intent": "Return the key associated with a registered file object . With arguments `fileobj`.", "question_id": 8223}
{"snippet": "base_selector.get_map()", "intent": "Return a mapping of file objects to selector keys .", "question_id": 8224}
{"snippet": "selectors.DefaultSelector", "intent": "The default selector class, using the most efficient implementation available on the current platform.", "question_id": 8225}
{"snippet": "selectors.SelectSelector", "intent": "select.select()-based selector.", "question_id": 8226}
{"snippet": "selectors.PollSelector", "intent": "select.poll()-based selector.", "question_id": 8227}
{"snippet": "selectors.EpollSelector", "intent": "select.epoll()-based selector.", "question_id": 8228}
{"snippet": "epoll_selector.fileno()", "intent": "This returns the file descriptor used by the underlying select.epoll ( ) object .", "question_id": 8229}
{"snippet": "selectors.DevpollSelector", "intent": "select.devpoll()-based selector.", "question_id": 8230}
{"snippet": "devpoll_selector.fileno()", "intent": "This returns the file descriptor used by the underlying select.devpoll ( ) object .", "question_id": 8231}
{"snippet": "selectors.KqueueSelector", "intent": "select.kqueue()-based selector.", "question_id": 8232}
{"snippet": "kqueue_selector.fileno()", "intent": "This returns the file descriptor used by the underlying select.kqueue ( ) object .", "question_id": 8233}
{"snippet": "shelve.open(filename)", "intent": "Open a persistent dictionary . The `filename` specified is the base filename for the underlying database .", "question_id": 8234}
{"snippet": "shelve.open(filename, flag='c')", "intent": "Open a persistent dictionary . The `filename` specified is the base filename for the underlying database . The optional `flag` parameter has the same interpretation as the flag parameter of dbm.open ( ) .", "question_id": 8235}
{"snippet": "shelve.open(filename, protocol=None)", "intent": "Open a persistent dictionary . The `filename` specified is the base filename for the underlying database . The version of the pickle `protocol` can be specified with the protocol parameter .", "question_id": 8236}
{"snippet": "shelve.open(filename, writeback=False)", "intent": "Open a persistent dictionary . The `filename` specified is the base filename for the underlying database . If the optional `writeback` parameter is set to True , all entries accessed are also cached in memory , and written back on sync ( ) and close ( ) ; this can make it handier to mutate mutable entries in the persistent dictionary , but , if many entries are accessed , it can consume vast amounts of memory for the cache , and it can make the close operation very slow since all accessed entries are written back ( there is no way to determine which accessed entries are mutable , nor which ones were actually mutated ) .", "question_id": 8237}
{"snippet": "shelve.open(filename, flag='c', protocol=None)", "intent": "Open a persistent dictionary . The `filename` specified is the base filename for the underlying database . The optional `flag` parameter has the same interpretation as the flag parameter of dbm.open ( ) . The version of the pickle `protocol` can be specified with the protocol parameter .", "question_id": 8238}
{"snippet": "shelve.open(filename, flag='c', writeback=False)", "intent": "Open a persistent dictionary . The `filename` specified is the base filename for the underlying database . The optional `flag` parameter has the same interpretation as the flag parameter of dbm.open ( ) . If the optional `writeback` parameter is set to True , all entries accessed are also cached in memory , and written back on sync ( ) and close ( ) ; this can make it handier to mutate mutable entries in the persistent dictionary , but , if many entries are accessed , it can consume vast amounts of memory for the cache , and it can make the close operation very slow since all accessed entries are written back ( there is no way to determine which accessed entries are mutable , nor which ones were actually mutated ) .", "question_id": 8239}
{"snippet": "shelve.open(filename, protocol=None, writeback=False)", "intent": "Open a persistent dictionary . The `filename` specified is the base filename for the underlying database . The version of the pickle `protocol` can be specified with the protocol parameter . If the optional `writeback` parameter is set to True , all entries accessed are also cached in memory , and written back on sync ( ) and close ( ) ; this can make it handier to mutate mutable entries in the persistent dictionary , but , if many entries are accessed , it can consume vast amounts of memory for the cache , and it can make the close operation very slow since all accessed entries are written back ( there is no way to determine which accessed entries are mutable , nor which ones were actually mutated ) .", "question_id": 8240}
{"snippet": "shelve.open(filename, flag='c', protocol=None, writeback=False)", "intent": "Open a persistent dictionary . The `filename` specified is the base filename for the underlying database . The optional `flag` parameter has the same interpretation as the flag parameter of dbm.open ( ) . The version of the pickle `protocol` can be specified with the protocol parameter . If the optional `writeback` parameter is set to True , all entries accessed are also cached in memory , and written back on sync ( ) and close ( ) ; this can make it handier to mutate mutable entries in the persistent dictionary , but , if many entries are accessed , it can consume vast amounts of memory for the cache , and it can make the close operation very slow since all accessed entries are written back ( there is no way to determine which accessed entries are mutable , nor which ones were actually mutated ) .", "question_id": 8241}
{"snippet": "Shelf.sync()", "intent": "Write back all entries in the cache if the shelf was opened with writeback set to True .", "question_id": 8242}
{"snippet": "Shelf.close()", "intent": "Synchronize and close the persistent dict object .", "question_id": 8243}
{"snippet": "shelve.Shelf(dict)", "intent": "A subclass of collections.abc.MutableMapping which stores pickled values in the `dict` object .", "question_id": 8244}
{"snippet": "shelve.Shelf(dict, protocol=None)", "intent": "A subclass of collections.abc.MutableMapping which stores pickled values in the `dict` object . The version of the pickle `protocol` can be specified with the protocol parameter .", "question_id": 8245}
{"snippet": "shelve.Shelf(dict, writeback=False)", "intent": "A subclass of collections.abc.MutableMapping which stores pickled values in the `dict` object . If the `writeback` parameter is True , the object will hold a cache of all entries accessed and write them back to the dict at sync and close times .", "question_id": 8246}
{"snippet": "shelve.Shelf(dict, keyencoding='utf-8')", "intent": "A subclass of collections.abc.MutableMapping which stores pickled values in the `dict` object . The `keyencoding` parameter is the encoding used to encode keys before they are used with the underlying dict .", "question_id": 8247}
{"snippet": "shelve.Shelf(dict, protocol=None, writeback=False)", "intent": "A subclass of collections.abc.MutableMapping which stores pickled values in the `dict` object . The version of the pickle `protocol` can be specified with the protocol parameter . If the `writeback` parameter is True , the object will hold a cache of all entries accessed and write them back to the dict at sync and close times .", "question_id": 8248}
{"snippet": "shelve.Shelf(dict, protocol=None, keyencoding='utf-8')", "intent": "A subclass of collections.abc.MutableMapping which stores pickled values in the `dict` object . The version of the pickle `protocol` can be specified with the protocol parameter . The `keyencoding` parameter is the encoding used to encode keys before they are used with the underlying dict .", "question_id": 8249}
{"snippet": "shelve.Shelf(dict, writeback=False, keyencoding='utf-8')", "intent": "A subclass of collections.abc.MutableMapping which stores pickled values in the `dict` object . If the `writeback` parameter is True , the object will hold a cache of all entries accessed and write them back to the dict at sync and close times . The `keyencoding` parameter is the encoding used to encode keys before they are used with the underlying dict .", "question_id": 8250}
{"snippet": "shelve.Shelf(dict, protocol=None, writeback=False, keyencoding='utf-8')", "intent": "A subclass of collections.abc.MutableMapping which stores pickled values in the `dict` object . The version of the pickle `protocol` can be specified with the protocol parameter . If the `writeback` parameter is True , the object will hold a cache of all entries accessed and write them back to the dict at sync and close times . The `keyencoding` parameter is the encoding used to encode keys before they are used with the underlying dict .", "question_id": 8251}
{"snippet": "shelve.BsdDbShelf(dict)", "intent": "A subclass of Shelf which exposes first ( ) , next ( ) , previous ( ) , last ( ) and set_location ( ) which are available in the third-party bsddb module from pybsddb but not in other database modules . The `dict` object passed to the constructor must support those methods .", "question_id": 8252}
{"snippet": "shelve.BsdDbShelf(dict, protocol=None)", "intent": "A subclass of Shelf which exposes first ( ) , next ( ) , previous ( ) , last ( ) and set_location ( ) which are available in the third-party bsddb module from pybsddb but not in other database modules . The `dict` object passed to the constructor must support those methods . The optional `protocol` , `writeback` , and `keyencoding` parameters have the same interpretation as for the Shelf class .", "question_id": 8253}
{"snippet": "shelve.BsdDbShelf(dict, writeback=False)", "intent": "A subclass of Shelf which exposes first ( ) , next ( ) , previous ( ) , last ( ) and set_location ( ) which are available in the third-party bsddb module from pybsddb but not in other database modules . The `dict` object passed to the constructor must support those methods . The optional `protocol` , `writeback` , and `keyencoding` parameters have the same interpretation as for the Shelf class .", "question_id": 8254}
{"snippet": "shelve.BsdDbShelf(dict, keyencoding='utf-8')", "intent": "A subclass of Shelf which exposes first ( ) , next ( ) , previous ( ) , last ( ) and set_location ( ) which are available in the third-party bsddb module from pybsddb but not in other database modules . The `dict` object passed to the constructor must support those methods . The optional `protocol` , `writeback` , and `keyencoding` parameters have the same interpretation as for the Shelf class .", "question_id": 8255}
{"snippet": "shelve.BsdDbShelf(dict, protocol=None, writeback=False)", "intent": "A subclass of Shelf which exposes first ( ) , next ( ) , previous ( ) , last ( ) and set_location ( ) which are available in the third-party bsddb module from pybsddb but not in other database modules . The `dict` object passed to the constructor must support those methods . The optional `protocol` , `writeback` , and `keyencoding` parameters have the same interpretation as for the Shelf class .", "question_id": 8256}
{"snippet": "shelve.BsdDbShelf(dict, protocol=None, keyencoding='utf-8')", "intent": "A subclass of Shelf which exposes first ( ) , next ( ) , previous ( ) , last ( ) and set_location ( ) which are available in the third-party bsddb module from pybsddb but not in other database modules . The `dict` object passed to the constructor must support those methods . The optional `protocol` , `writeback` , and `keyencoding` parameters have the same interpretation as for the Shelf class .", "question_id": 8257}
{"snippet": "shelve.BsdDbShelf(dict, writeback=False, keyencoding='utf-8')", "intent": "A subclass of Shelf which exposes first ( ) , next ( ) , previous ( ) , last ( ) and set_location ( ) which are available in the third-party bsddb module from pybsddb but not in other database modules . The `dict` object passed to the constructor must support those methods . The optional `protocol` , `writeback` , and `keyencoding` parameters have the same interpretation as for the Shelf class .", "question_id": 8258}
{"snippet": "shelve.BsdDbShelf(dict, protocol=None, writeback=False, keyencoding='utf-8')", "intent": "A subclass of Shelf which exposes first ( ) , next ( ) , previous ( ) , last ( ) and set_location ( ) which are available in the third-party bsddb module from pybsddb but not in other database modules . The `dict` object passed to the constructor must support those methods . The optional `protocol` , `writeback` , and `keyencoding` parameters have the same interpretation as for the Shelf class .", "question_id": 8259}
{"snippet": "shelve.DbfilenameShelf(filename)", "intent": "A subclass of Shelf which accepts a `filename` instead of a dict-like object .", "question_id": 8260}
{"snippet": "shelve.DbfilenameShelf(filename, flag='c')", "intent": "A subclass of Shelf which accepts a `filename` instead of a dict-like object . The optional `flag` parameter has the same interpretation as for the open ( ) function .", "question_id": 8261}
{"snippet": "shelve.DbfilenameShelf(filename, protocol=None)", "intent": "A subclass of Shelf which accepts a `filename` instead of a dict-like object . The optional `protocol` and `writeback` parameters have the same interpretation as for the Shelf class .", "question_id": 8262}
{"snippet": "shelve.DbfilenameShelf(filename, writeback=False)", "intent": "A subclass of Shelf which accepts a `filename` instead of a dict-like object . The optional `protocol` and `writeback` parameters have the same interpretation as for the Shelf class .", "question_id": 8263}
{"snippet": "shelve.DbfilenameShelf(filename, flag='c', protocol=None)", "intent": "A subclass of Shelf which accepts a `filename` instead of a dict-like object . The optional `flag` parameter has the same interpretation as for the open ( ) function . The optional `protocol` and `writeback` parameters have the same interpretation as for the Shelf class .", "question_id": 8264}
{"snippet": "shelve.DbfilenameShelf(filename, flag='c', writeback=False)", "intent": "A subclass of Shelf which accepts a `filename` instead of a dict-like object . The optional `flag` parameter has the same interpretation as for the open ( ) function . The optional `protocol` and `writeback` parameters have the same interpretation as for the Shelf class .", "question_id": 8265}
{"snippet": "shelve.DbfilenameShelf(filename, protocol=None, writeback=False)", "intent": "A subclass of Shelf which accepts a `filename` instead of a dict-like object . The optional `protocol` and `writeback` parameters have the same interpretation as for the Shelf class .", "question_id": 8266}
{"snippet": "shelve.DbfilenameShelf(filename, flag='c', protocol=None, writeback=False)", "intent": "A subclass of Shelf which accepts a `filename` instead of a dict-like object . The optional `flag` parameter has the same interpretation as for the open ( ) function . The optional `protocol` and `writeback` parameters have the same interpretation as for the Shelf class .", "question_id": 8267}
{"snippet": "shlex.split(s)", "intent": "Split the string `s` using shell-like syntax .", "question_id": 8268}
{"snippet": "shlex.split(s, comments=False)", "intent": "Split the string `s` using shell-like syntax . If `comments` is False ( the default ) , the parsing of comments in the given string will be disabled ( setting the commenters attribute of the shlex instance to the empty string ) .", "question_id": 8269}
{"snippet": "shlex.split(s, posix=True)", "intent": "Split the string `s` using shell-like syntax . This function operates in POSIX mode by default , but uses non-POSIX mode if the `posix` argument is false .", "question_id": 8270}
{"snippet": "shlex.split(s, comments=False, posix=True)", "intent": "Split the string `s` using shell-like syntax . If `comments` is False ( the default ) , the parsing of comments in the given string will be disabled ( setting the commenters attribute of the shlex instance to the empty string ) . This function operates in POSIX mode by default , but uses non-POSIX mode if the `posix` argument is false .", "question_id": 8271}
{"snippet": "shlex.quote(s)", "intent": "Return a shell-escaped version of the string s. The returned value is a string that can safely be used as one token in a shell command line , for cases where you can not use a list . With arguments `s`.", "question_id": 8272}
{"snippet": "shlex.shlex()", "intent": "A shlex instance or subclass instance is a lexical analyzer object .", "question_id": 8273}
{"snippet": "shlex.shlex(instream=None)", "intent": "A shlex instance or subclass instance is a lexical analyzer object . If the `instream` argument is omitted or equal to sys.stdin , this second argument defaults to \u201c stdin \u201d .", "question_id": 8274}
{"snippet": "shlex.shlex(infile=None)", "intent": "A shlex instance or subclass instance is a lexical analyzer object . The second optional argument is a filename string , which sets the initial value of the `infile` attribute .", "question_id": 8275}
{"snippet": "shlex.shlex(posix=False)", "intent": "A shlex instance or subclass instance is a lexical analyzer object . The `posix` argument defines the operational mode : when posix is not true ( default ) , the shlex instance will operate in compatibility mode .", "question_id": 8276}
{"snippet": "shlex.shlex(punctuation_chars=False)", "intent": "A shlex instance or subclass instance is a lexical analyzer object . The `punctuation_chars` argument provides a way to make the behaviour even closer to how real shells parse .", "question_id": 8277}
{"snippet": "shlex.shlex(instream=None, infile=None)", "intent": "A shlex instance or subclass instance is a lexical analyzer object . If the `instream` argument is omitted or equal to sys.stdin , this second argument defaults to \u201c stdin \u201d . The second optional argument is a filename string , which sets the initial value of the `infile` attribute .", "question_id": 8278}
{"snippet": "shlex.shlex(instream=None, posix=False)", "intent": "A shlex instance or subclass instance is a lexical analyzer object . If the `instream` argument is omitted or equal to sys.stdin , this second argument defaults to \u201c stdin \u201d . The `posix` argument defines the operational mode : when posix is not true ( default ) , the shlex instance will operate in compatibility mode .", "question_id": 8279}
{"snippet": "shlex.shlex(instream=None, punctuation_chars=False)", "intent": "A shlex instance or subclass instance is a lexical analyzer object . If the `instream` argument is omitted or equal to sys.stdin , this second argument defaults to \u201c stdin \u201d . The `punctuation_chars` argument provides a way to make the behaviour even closer to how real shells parse .", "question_id": 8280}
{"snippet": "shlex.shlex(infile=None, posix=False)", "intent": "A shlex instance or subclass instance is a lexical analyzer object . The second optional argument is a filename string , which sets the initial value of the `infile` attribute . The `posix` argument defines the operational mode : when posix is not true ( default ) , the shlex instance will operate in compatibility mode .", "question_id": 8281}
{"snippet": "shlex.shlex(infile=None, punctuation_chars=False)", "intent": "A shlex instance or subclass instance is a lexical analyzer object . The second optional argument is a filename string , which sets the initial value of the `infile` attribute . The `punctuation_chars` argument provides a way to make the behaviour even closer to how real shells parse .", "question_id": 8282}
{"snippet": "shlex.get_token()", "intent": "Return a token .", "question_id": 8283}
{"snippet": "shlex.push_token(str)", "intent": "Push the argument onto the token stack . With arguments `str`.", "question_id": 8284}
{"snippet": "shlex.read_token()", "intent": "Read a raw token .", "question_id": 8285}
{"snippet": "shlex.sourcehook(filename)", "intent": "When shlex detects a source request ( see source below ) this method is given the following token as argument , and expected to return a tuple consisting of a `filename` and an open file-like object .", "question_id": 8286}
{"snippet": "shlex.push_source(newstream)", "intent": "Push an input source stream onto the input stack . With arguments `newstream`.", "question_id": 8287}
{"snippet": "shlex.push_source(newstream, newfile=None)", "intent": "Push an input source stream onto the input stack . With arguments `newstream`, `newfile`.", "question_id": 8288}
{"snippet": "shlex.pop_source()", "intent": "Pop the last-pushed input source from the input stack .", "question_id": 8289}
{"snippet": "shlex.error_leader()", "intent": "This method generates an error message leader in the format of a Unix C compiler error label ; the format is ' '' % s '' , line % d : ' , where the % s is replaced with the name of the current source file and the % d with the current input line number ( the optional arguments can be used to override these ) .", "question_id": 8290}
{"snippet": "shlex.error_leader(infile=None)", "intent": "This method generates an error message leader in the format of a Unix C compiler error label ; the format is ' '' % s '' , line % d : ' , where the % s is replaced with the name of the current source file and the % d with the current input line number ( the optional arguments can be used to override these ) . With arguments `infile`.", "question_id": 8291}
{"snippet": "shlex.error_leader(lineno=None)", "intent": "This method generates an error message leader in the format of a Unix C compiler error label ; the format is ' '' % s '' , line % d : ' , where the % s is replaced with the name of the current source file and the % d with the current input line number ( the optional arguments can be used to override these ) . With arguments `lineno`.", "question_id": 8292}
{"snippet": "shlex.error_leader(infile=None, lineno=None)", "intent": "This method generates an error message leader in the format of a Unix C compiler error label ; the format is ' '' % s '' , line % d : ' , where the % s is replaced with the name of the current source file and the % d with the current input line number ( the optional arguments can be used to override these ) . With arguments `infile`, `lineno`.", "question_id": 8293}
{"snippet": "shlex.commenters", "intent": "The string of characters that are recognized as comment beginners.", "question_id": 8294}
{"snippet": "shlex.wordchars", "intent": "The string of characters that will accumulate into multi-character tokens.", "question_id": 8295}
{"snippet": "shlex.whitespace", "intent": "Characters that will be considered whitespace and skipped.", "question_id": 8296}
{"snippet": "shlex.escape", "intent": "Characters that will be considered as escape.", "question_id": 8297}
{"snippet": "shlex.quotes", "intent": "Characters that will be considered string quotes.", "question_id": 8298}
{"snippet": "shlex.escapedquotes", "intent": "Characters in quotes that will interpret escape characters defined in escape.", "question_id": 8299}
{"snippet": "shlex.whitespace_split", "intent": "If True, tokens will only be split in whitespaces.", "question_id": 8300}
{"snippet": "shlex.infile", "intent": "The name of the current input file, as initially set at class instantiation time or stacked by later source requests.", "question_id": 8301}
{"snippet": "shlex.instream", "intent": "The input stream from which this shlex instance is reading characters.", "question_id": 8302}
{"snippet": "shlex.source", "intent": "This attribute is None by default.", "question_id": 8303}
{"snippet": "shlex.debug", "intent": "If this attribute is numeric and 1 or more, a shlex instance will print verbose progress output on its behavior.", "question_id": 8304}
{"snippet": "shlex.lineno", "intent": "Source line number (count of newlines seen so far plus one).", "question_id": 8305}
{"snippet": "shlex.token", "intent": "The token buffer.", "question_id": 8306}
{"snippet": "shlex.eof", "intent": "Token used to determine end of file.", "question_id": 8307}
{"snippet": "shlex.punctuation_chars", "intent": "A read-only property.", "question_id": 8308}
{"snippet": "shutil.copyfileobj(fsrc, fdst, length)", "intent": "Copy the contents of the file-like object `fsrc` to the file-like object `fdst` . The integer `length` , if given , is the buffer size .", "question_id": 8309}
{"snippet": "shutil.copyfileobj(fsrc, fdst)", "intent": "Copy the contents of the file-like object `fsrc` to the file-like object `fdst` .", "question_id": 8310}
{"snippet": "shutil.copyfile(src, dst)", "intent": "Copy the contents ( no metadata ) of the file named `src` to a file named `dst` and return dst .", "question_id": 8311}
{"snippet": "shutil.copyfile(src, dst, follow_symlinks=True)", "intent": "Copy the contents ( no metadata ) of the file named `src` to a file named `dst` and return dst . If `follow_symlinks` is false and src is a symbolic link , a new symbolic link will be created instead of copying the file src points to .", "question_id": 8312}
{"snippet": "shutil.SameFileError", "intent": "This exception is raised if source and destination in copyfile() are the same file.", "question_id": 8313}
{"snippet": "shutil.copymode(src, dst)", "intent": "Copy the permission bits from `src` to `dst` .", "question_id": 8314}
{"snippet": "shutil.copymode(src, dst, follow_symlinks=True)", "intent": "Copy the permission bits from `src` to `dst` . If `follow_symlinks` is false , and both src and dst are symbolic links , copymode ( ) will attempt to modify the mode of dst itself ( rather than the file it points to ) .", "question_id": 8315}
{"snippet": "shutil.copystat(src, dst)", "intent": "Copy the permission bits , last access time , last modification time , and flags from `src` to `dst` .", "question_id": 8316}
{"snippet": "shutil.copystat(src, dst, follow_symlinks=True)", "intent": "Copy the permission bits , last access time , last modification time , and flags from `src` to `dst` . If `follow_symlinks` is false , and src and dst both refer to symbolic links , copystat ( ) will operate on the symbolic links themselves rather than the files the symbolic links refer to\u2014reading the information from the src symbolic link , and writing the information to the dst symbolic link .", "question_id": 8317}
{"snippet": "shutil.copy(src, dst)", "intent": "Copies the file `src` to the file or directory `dst` .", "question_id": 8318}
{"snippet": "shutil.copy(src, dst, follow_symlinks=True)", "intent": "Copies the file `src` to the file or directory `dst` . If `follow_symlinks` is false , and src is a symbolic link , dst will be created as a symbolic link .", "question_id": 8319}
{"snippet": "shutil.copy2(src, dst)", "intent": "Identical to copy ( ) except that copy2 ( ) also attempts to preserve file metadata . When `follow_symlinks` is false , and `src` is a symbolic link , copy2 ( ) attempts to copy all metadata from the src symbolic link to the newly-created `dst` symbolic link .", "question_id": 8320}
{"snippet": "shutil.copy2(src, dst, follow_symlinks=True)", "intent": "Identical to copy ( ) except that copy2 ( ) also attempts to preserve file metadata . When `follow_symlinks` is false , and `src` is a symbolic link , copy2 ( ) attempts to copy all metadata from the src symbolic link to the newly-created `dst` symbolic link .", "question_id": 8321}
{"snippet": "shutil.ignore_patterns(*patterns)", "intent": "This factory function creates a function that can be used as a callable for copytree ( ) \u2019 s ignore argument , ignoring files and directories that match one of the glob-style patterns provided . With arguments `*patterns`.", "question_id": 8322}
{"snippet": "shutil.copytree(src, dst)", "intent": "Recursively copy an entire directory tree rooted at `src` , returning the destination directory . The destination directory , named by `dst` , must not already exist ; it will be created as well as missing parent directories .", "question_id": 8323}
{"snippet": "shutil.copytree(src, dst, symlinks=False)", "intent": "Recursively copy an entire directory tree rooted at `src` , returning the destination directory . The destination directory , named by `dst` , must not already exist ; it will be created as well as missing parent directories . If `symlinks` is true , symbolic links in the source tree are represented as symbolic links in the new tree and the metadata of the original links will be copied as far as the platform allows ; if false or omitted , the contents and metadata of the linked files are copied to the new tree .", "question_id": 8324}
{"snippet": "shutil.copytree(src, dst, ignore=None)", "intent": "Recursively copy an entire directory tree rooted at `src` , returning the destination directory . The destination directory , named by `dst` , must not already exist ; it will be created as well as missing parent directories . If `ignore` is given , it must be a callable that will receive as its arguments the directory being visited by copytree ( ) , and a list of its contents , as returned by os.listdir ( ) .", "question_id": 8325}
{"snippet": "shutil.copytree(src, dst, copy_function=copy2)", "intent": "Recursively copy an entire directory tree rooted at `src` , returning the destination directory . The destination directory , named by `dst` , must not already exist ; it will be created as well as missing parent directories . If `copy_function` is given , it must be a callable that will be used to copy each file .", "question_id": 8326}
{"snippet": "shutil.copytree(src, dst, ignore_dangling_symlinks=False)", "intent": "Recursively copy an entire directory tree rooted at `src` , returning the destination directory . The destination directory , named by `dst` , must not already exist ; it will be created as well as missing parent directories . You can set the optional `ignore_dangling_symlinks` flag to true if you want to silence this exception .", "question_id": 8327}
{"snippet": "shutil.copytree(src, dst, symlinks=False, ignore=None)", "intent": "Recursively copy an entire directory tree rooted at `src` , returning the destination directory . The destination directory , named by `dst` , must not already exist ; it will be created as well as missing parent directories . If `symlinks` is true , symbolic links in the source tree are represented as symbolic links in the new tree and the metadata of the original links will be copied as far as the platform allows ; if false or omitted , the contents and metadata of the linked files are copied to the new tree . If `ignore` is given , it must be a callable that will receive as its arguments the directory being visited by copytree ( ) , and a list of its contents , as returned by os.listdir ( ) .", "question_id": 8328}
{"snippet": "shutil.copytree(src, dst, symlinks=False, copy_function=copy2)", "intent": "Recursively copy an entire directory tree rooted at `src` , returning the destination directory . The destination directory , named by `dst` , must not already exist ; it will be created as well as missing parent directories . If `symlinks` is true , symbolic links in the source tree are represented as symbolic links in the new tree and the metadata of the original links will be copied as far as the platform allows ; if false or omitted , the contents and metadata of the linked files are copied to the new tree . If `copy_function` is given , it must be a callable that will be used to copy each file .", "question_id": 8329}
{"snippet": "shutil.copytree(src, dst, symlinks=False, ignore_dangling_symlinks=False)", "intent": "Recursively copy an entire directory tree rooted at `src` , returning the destination directory . The destination directory , named by `dst` , must not already exist ; it will be created as well as missing parent directories . If `symlinks` is true , symbolic links in the source tree are represented as symbolic links in the new tree and the metadata of the original links will be copied as far as the platform allows ; if false or omitted , the contents and metadata of the linked files are copied to the new tree . You can set the optional `ignore_dangling_symlinks` flag to true if you want to silence this exception .", "question_id": 8330}
{"snippet": "shutil.copytree(src, dst, ignore=None, copy_function=copy2)", "intent": "Recursively copy an entire directory tree rooted at `src` , returning the destination directory . The destination directory , named by `dst` , must not already exist ; it will be created as well as missing parent directories . If `ignore` is given , it must be a callable that will receive as its arguments the directory being visited by copytree ( ) , and a list of its contents , as returned by os.listdir ( ) . If `copy_function` is given , it must be a callable that will be used to copy each file .", "question_id": 8331}
{"snippet": "shutil.copytree(src, dst, ignore=None, ignore_dangling_symlinks=False)", "intent": "Recursively copy an entire directory tree rooted at `src` , returning the destination directory . The destination directory , named by `dst` , must not already exist ; it will be created as well as missing parent directories . If `ignore` is given , it must be a callable that will receive as its arguments the directory being visited by copytree ( ) , and a list of its contents , as returned by os.listdir ( ) . You can set the optional `ignore_dangling_symlinks` flag to true if you want to silence this exception .", "question_id": 8332}
{"snippet": "shutil.rmtree(path)", "intent": "Delete an entire directory tree ; `path` must point to a directory ( but not a symbolic link to a directory ) .", "question_id": 8333}
{"snippet": "shutil.rmtree(path, ignore_errors=False)", "intent": "Delete an entire directory tree ; `path` must point to a directory ( but not a symbolic link to a directory ) . If `ignore_errors` is true , errors resulting from failed removals will be ignored ; if false or omitted , such errors are handled by calling a handler specified by `onerror` or , if that is omitted , they raise an exception .", "question_id": 8334}
{"snippet": "shutil.rmtree(path, onerror=None)", "intent": "Delete an entire directory tree ; `path` must point to a directory ( but not a symbolic link to a directory ) . If `ignore_errors` is true , errors resulting from failed removals will be ignored ; if false or omitted , such errors are handled by calling a handler specified by `onerror` or , if that is omitted , they raise an exception .", "question_id": 8335}
{"snippet": "shutil.rmtree(path, ignore_errors=False, onerror=None)", "intent": "Delete an entire directory tree ; `path` must point to a directory ( but not a symbolic link to a directory ) . If `ignore_errors` is true , errors resulting from failed removals will be ignored ; if false or omitted , such errors are handled by calling a handler specified by `onerror` or , if that is omitted , they raise an exception .", "question_id": 8336}
{"snippet": "rmtree.avoids_symlink_attacks", "intent": "Indicates whether the current platform and implementation provides a symlink attack resistant version of rmtree().", "question_id": 8337}
{"snippet": "shutil.move(src, dst)", "intent": "Recursively move a file or directory ( `src` ) to another location ( `dst` ) and return the destination .", "question_id": 8338}
{"snippet": "shutil.move(src, dst, copy_function=copy2)", "intent": "Recursively move a file or directory ( `src` ) to another location ( `dst` ) and return the destination . Otherwise , src is copied to dst using `copy_function` and then removed .", "question_id": 8339}
{"snippet": "shutil.disk_usage(path)", "intent": "Return disk usage statistics about the given `path` as a named tuple with the attributes total , used and free , which are the amount of total , used and free space , in bytes .", "question_id": 8340}
{"snippet": "shutil.chown(path)", "intent": "Change owner `user` and/or `group` of the given `path` .", "question_id": 8341}
{"snippet": "shutil.chown(path, user=None)", "intent": "Change owner `user` and/or `group` of the given `path` .", "question_id": 8342}
{"snippet": "shutil.chown(path, group=None)", "intent": "Change owner `user` and/or `group` of the given `path` .", "question_id": 8343}
{"snippet": "shutil.chown(path, user=None, group=None)", "intent": "Change owner `user` and/or `group` of the given `path` .", "question_id": 8344}
{"snippet": "shutil.which(cmd)", "intent": "Return the `path` to an executable which would be run if the given `cmd` was called .", "question_id": 8345}
{"snippet": "shutil.which(cmd, mode=os.F_OK | os.X_OK)", "intent": "Return the `path` to an executable which would be run if the given `cmd` was called . `mode` is a permission mask passed to os.access ( ) , by default determining if the file exists and executable .", "question_id": 8346}
{"snippet": "shutil.which(cmd, path=None)", "intent": "Return the `path` to an executable which would be run if the given `cmd` was called .", "question_id": 8347}
{"snippet": "shutil.which(cmd, mode=os.F_OK | os.X_OK, path=None)", "intent": "Return the `path` to an executable which would be run if the given `cmd` was called . `mode` is a permission mask passed to os.access ( ) , by default determining if the file exists and executable .", "question_id": 8348}
{"snippet": "shutil.Error", "intent": "This exception collects exceptions that are raised during a multi-file operation.", "question_id": 8349}
{"snippet": "shutil.make_archive(base_name, format, root_dir, base_dir, verbose, dry_run, owner, group, logger)", "intent": "Create an archive file ( such as zip or tar ) and return its name . `base_name` is the name of the file to create , including the path , minus any format-specific extension . `format` is the archive format : one of \u201c zip \u201d ( if the zlib module is available ) , \u201c tar \u201d , \u201c gztar \u201d ( if the zlib module is available ) , \u201c bztar \u201d ( if the bz2 module is available ) , or \u201c xztar \u201d ( if the lzma module is available ) . `root_dir` is a directory that will be the root directory of the archive ; for example , we typically chdir into root_dir before creating the archive . `base_dir` is the directory where we start archiving from ; i.e . The `verbose` argument is unused and deprecated . If `dry_run` is true , no archive is created , but the operations that would be executed are logged to `logger` . `owner` and `group` are used when creating a tar archive .", "question_id": 8350}
{"snippet": "shutil.make_archive(base_name, format, root_dir, base_dir, verbose, dry_run, owner, group)", "intent": "Create an archive file ( such as zip or tar ) and return its name . `base_name` is the name of the file to create , including the path , minus any format-specific extension . `format` is the archive format : one of \u201c zip \u201d ( if the zlib module is available ) , \u201c tar \u201d , \u201c gztar \u201d ( if the zlib module is available ) , \u201c bztar \u201d ( if the bz2 module is available ) , or \u201c xztar \u201d ( if the lzma module is available ) . `root_dir` is a directory that will be the root directory of the archive ; for example , we typically chdir into root_dir before creating the archive . `base_dir` is the directory where we start archiving from ; i.e . The `verbose` argument is unused and deprecated . If `dry_run` is true , no archive is created , but the operations that would be executed are logged to `logger` . `owner` and `group` are used when creating a tar archive .", "question_id": 8351}
{"snippet": "shutil.make_archive(base_name, format, root_dir, base_dir, verbose, dry_run, owner)", "intent": "Create an archive file ( such as zip or tar ) and return its name . `base_name` is the name of the file to create , including the path , minus any format-specific extension . `format` is the archive format : one of \u201c zip \u201d ( if the zlib module is available ) , \u201c tar \u201d , \u201c gztar \u201d ( if the zlib module is available ) , \u201c bztar \u201d ( if the bz2 module is available ) , or \u201c xztar \u201d ( if the lzma module is available ) . `root_dir` is a directory that will be the root directory of the archive ; for example , we typically chdir into root_dir before creating the archive . `base_dir` is the directory where we start archiving from ; i.e . The `verbose` argument is unused and deprecated . If `dry_run` is true , no archive is created , but the operations that would be executed are logged to `logger` . `owner` and `group` are used when creating a tar archive .", "question_id": 8352}
{"snippet": "shutil.make_archive(base_name, format, root_dir, base_dir, verbose, dry_run)", "intent": "Create an archive file ( such as zip or tar ) and return its name . `base_name` is the name of the file to create , including the path , minus any format-specific extension . `format` is the archive format : one of \u201c zip \u201d ( if the zlib module is available ) , \u201c tar \u201d , \u201c gztar \u201d ( if the zlib module is available ) , \u201c bztar \u201d ( if the bz2 module is available ) , or \u201c xztar \u201d ( if the lzma module is available ) . `root_dir` is a directory that will be the root directory of the archive ; for example , we typically chdir into root_dir before creating the archive . `base_dir` is the directory where we start archiving from ; i.e . The `verbose` argument is unused and deprecated . If `dry_run` is true , no archive is created , but the operations that would be executed are logged to `logger` .", "question_id": 8353}
{"snippet": "shutil.make_archive(base_name, format, root_dir, base_dir, verbose)", "intent": "Create an archive file ( such as zip or tar ) and return its name . `base_name` is the name of the file to create , including the path , minus any format-specific extension . `format` is the archive format : one of \u201c zip \u201d ( if the zlib module is available ) , \u201c tar \u201d , \u201c gztar \u201d ( if the zlib module is available ) , \u201c bztar \u201d ( if the bz2 module is available ) , or \u201c xztar \u201d ( if the lzma module is available ) . `root_dir` is a directory that will be the root directory of the archive ; for example , we typically chdir into root_dir before creating the archive . `base_dir` is the directory where we start archiving from ; i.e . The `verbose` argument is unused and deprecated .", "question_id": 8354}
{"snippet": "shutil.make_archive(base_name, format, root_dir, base_dir)", "intent": "Create an archive file ( such as zip or tar ) and return its name . `base_name` is the name of the file to create , including the path , minus any format-specific extension . `format` is the archive format : one of \u201c zip \u201d ( if the zlib module is available ) , \u201c tar \u201d , \u201c gztar \u201d ( if the zlib module is available ) , \u201c bztar \u201d ( if the bz2 module is available ) , or \u201c xztar \u201d ( if the lzma module is available ) . `root_dir` is a directory that will be the root directory of the archive ; for example , we typically chdir into root_dir before creating the archive . `base_dir` is the directory where we start archiving from ; i.e .", "question_id": 8355}
{"snippet": "shutil.make_archive(base_name, format, root_dir)", "intent": "Create an archive file ( such as zip or tar ) and return its name . `base_name` is the name of the file to create , including the path , minus any format-specific extension . `format` is the archive format : one of \u201c zip \u201d ( if the zlib module is available ) , \u201c tar \u201d , \u201c gztar \u201d ( if the zlib module is available ) , \u201c bztar \u201d ( if the bz2 module is available ) , or \u201c xztar \u201d ( if the lzma module is available ) . `root_dir` is a directory that will be the root directory of the archive ; for example , we typically chdir into root_dir before creating the archive .", "question_id": 8356}
{"snippet": "shutil.make_archive(base_name, format)", "intent": "Create an archive file ( such as zip or tar ) and return its name . `base_name` is the name of the file to create , including the path , minus any format-specific extension . `format` is the archive format : one of \u201c zip \u201d ( if the zlib module is available ) , \u201c tar \u201d , \u201c gztar \u201d ( if the zlib module is available ) , \u201c bztar \u201d ( if the bz2 module is available ) , or \u201c xztar \u201d ( if the lzma module is available ) .", "question_id": 8357}
{"snippet": "shutil.get_archive_formats()", "intent": "Return a list of supported formats for archiving .", "question_id": 8358}
{"snippet": "shutil.register_archive_format(name, function, extra_args, description)", "intent": "Register an archiver for the format `name` . `function` is the callable that will be used to unpack archives . If given , `extra_args` is a sequence of ( name , value ) pairs that will be used as extra keywords arguments when the archiver callable is used . `description` is used by get_archive_formats ( ) which returns the list of archivers .", "question_id": 8359}
{"snippet": "shutil.register_archive_format(name, function, extra_args)", "intent": "Register an archiver for the format `name` . `function` is the callable that will be used to unpack archives . If given , `extra_args` is a sequence of ( name , value ) pairs that will be used as extra keywords arguments when the archiver callable is used .", "question_id": 8360}
{"snippet": "shutil.register_archive_format(name, function)", "intent": "Register an archiver for the format `name` . `function` is the callable that will be used to unpack archives .", "question_id": 8361}
{"snippet": "shutil.unregister_archive_format(name)", "intent": "Remove the archive format `name` from the list of supported formats .", "question_id": 8362}
{"snippet": "shutil.unpack_archive(filename, extract_dir, format)", "intent": "Unpack an archive . `filename` is the full path of the archive . `extract_dir` is the name of the target directory where the archive is unpacked . `format` is the archive format : one of \u201c zip \u201d , \u201c tar \u201d , \u201c gztar \u201d , \u201c bztar \u201d , or \u201c xztar \u201d .", "question_id": 8363}
{"snippet": "shutil.unpack_archive(filename, extract_dir)", "intent": "Unpack an archive . `filename` is the full path of the archive . `extract_dir` is the name of the target directory where the archive is unpacked .", "question_id": 8364}
{"snippet": "shutil.unpack_archive(filename)", "intent": "Unpack an archive . `filename` is the full path of the archive .", "question_id": 8365}
{"snippet": "shutil.register_unpack_format(name, extensions, function, extra_args, description)", "intent": "Registers an unpack format . `name` is the name of the format and `extensions` is a list of extensions corresponding to the format , like .zip for Zip files . `function` is the callable that will be used to unpack archives . When provided , `extra_args` is a sequence of ( name , value ) tuples that will be passed as keywords arguments to the callable . `description` can be provided to describe the format , and will be returned by the get_unpack_formats ( ) function .", "question_id": 8366}
{"snippet": "shutil.register_unpack_format(name, extensions, function, extra_args)", "intent": "Registers an unpack format . `name` is the name of the format and `extensions` is a list of extensions corresponding to the format , like .zip for Zip files . `function` is the callable that will be used to unpack archives . When provided , `extra_args` is a sequence of ( name , value ) tuples that will be passed as keywords arguments to the callable .", "question_id": 8367}
{"snippet": "shutil.register_unpack_format(name, extensions, function)", "intent": "Registers an unpack format . `name` is the name of the format and `extensions` is a list of extensions corresponding to the format , like .zip for Zip files . `function` is the callable that will be used to unpack archives .", "question_id": 8368}
{"snippet": "shutil.unregister_unpack_format(name)", "intent": "Unregister an unpack format . `name` is the name of the format .", "question_id": 8369}
{"snippet": "shutil.get_unpack_formats()", "intent": "Return a list of all registered formats for unpacking .", "question_id": 8370}
{"snippet": "shutil.get_terminal_size(lines))", "intent": "Get the size of the terminal window . With arguments `lines)`.", "question_id": 8371}
{"snippet": "shutil.get_terminal_size(lines), fallback=(columns)", "intent": "Get the size of the terminal window . If the terminal size can not be successfully queried , either because the system doesn \u2019 t support querying , or because we are not connected to a terminal , the value given in `fallback` parameter is used . With arguments `lines)`.", "question_id": 8372}
{"snippet": "signal.SIG_DFL", "intent": "This is one of two standard signal handling options; it will simply perform the default function for the signal.", "question_id": 8373}
{"snippet": "signal.SIG_IGN", "intent": "This is another standard signal handler, which will simply ignore the given signal.", "question_id": 8374}
{"snippet": "SIG*", "intent": "All the signal numbers are defined symbolically.", "question_id": 8375}
{"snippet": "signal.CTRL_C_EVENT", "intent": "The signal corresponding to the Ctrl+C keystroke event.", "question_id": 8376}
{"snippet": "signal.CTRL_BREAK_EVENT", "intent": "The signal corresponding to the Ctrl+Break keystroke event.", "question_id": 8377}
{"snippet": "signal.NSIG", "intent": "One more than the number of the highest signal number.", "question_id": 8378}
{"snippet": "signal.ITIMER_REAL", "intent": "Decrements interval timer in real time, and delivers SIGALRM upon expiration.", "question_id": 8379}
{"snippet": "signal.ITIMER_VIRTUAL", "intent": "Decrements interval timer only when the process is executing, and delivers SIGVTALRM upon expiration.", "question_id": 8380}
{"snippet": "signal.ITIMER_PROF", "intent": "Decrements interval timer both when the process executes and when the system is executing on behalf of the process.", "question_id": 8381}
{"snippet": "signal.SIG_BLOCK", "intent": "A possible value for the how parameter to pthread_sigmask() indicating that signals are to be blocked.", "question_id": 8382}
{"snippet": "signal.SIG_UNBLOCK", "intent": "A possible value for the how parameter to pthread_sigmask() indicating that signals are to be unblocked.", "question_id": 8383}
{"snippet": "signal.SIG_SETMASK", "intent": "A possible value for the how parameter to pthread_sigmask() indicating that the signal mask is to be replaced.", "question_id": 8384}
{"snippet": "signal.ItimerError", "intent": "Raised to signal an error from the underlying setitimer() or getitimer() implementation.", "question_id": 8385}
{"snippet": "signal.alarm(time)", "intent": "If `time` is non-zero , this function requests that a SIGALRM signal be sent to the process in time seconds .", "question_id": 8386}
{"snippet": "signal.getsignal(signalnum)", "intent": "Return the current signal handler for the signal `signalnum` .", "question_id": 8387}
{"snippet": "signal.pause()", "intent": "Cause the process to sleep until a signal is received ; the appropriate handler will then be called .", "question_id": 8388}
{"snippet": "signal.pthread_kill(thread_id, signalnum)", "intent": "Send the signal `signalnum` to the thread `thread_id` , another thread in the same process as the caller .", "question_id": 8389}
{"snippet": "signal.pthread_sigmask(how, mask)", "intent": "Fetch and/or change the signal `mask` of the calling thread . The behavior of the call is dependent on the value of `how` , as follows .", "question_id": 8390}
{"snippet": "signal.setitimer(which, seconds)", "intent": "Sets given `interval` timer ( one of signal.ITIMER_REAL , signal.ITIMER_VIRTUAL or signal.ITIMER_PROF ) specified by `which` to fire after `seconds` ( float is accepted , different from alarm ( ) ) and after that every interval seconds ( if interval is non-zero ) .", "question_id": 8391}
{"snippet": "signal.setitimer(which, seconds, interval=0.0)", "intent": "Sets given `interval` timer ( one of signal.ITIMER_REAL , signal.ITIMER_VIRTUAL or signal.ITIMER_PROF ) specified by `which` to fire after `seconds` ( float is accepted , different from alarm ( ) ) and after that every interval seconds ( if interval is non-zero ) .", "question_id": 8392}
{"snippet": "signal.getitimer(which)", "intent": "Returns current value of a given interval timer specified by `which` .", "question_id": 8393}
{"snippet": "signal.set_wakeup_fd(fd)", "intent": "Set the wakeup file descriptor to `fd` .", "question_id": 8394}
{"snippet": "signal.set_wakeup_fd(fd, warn_on_full_buffer=True)", "intent": "Set the wakeup file descriptor to `fd` . With arguments `warn_on_full_buffer`.", "question_id": 8395}
{"snippet": "signal.siginterrupt(signalnum, flag)", "intent": "Change system call restart behaviour : if `flag` is False , system calls will be restarted when interrupted by signal `signalnum` , otherwise system calls will be interrupted .", "question_id": 8396}
{"snippet": "signal.signal(signalnum, handler)", "intent": "Set the `handler` for signal `signalnum` to the function handler .", "question_id": 8397}
{"snippet": "signal.sigpending()", "intent": "Examine the set of signals that are pending for delivery to the calling thread ( i.e. , the signals which have been raised while blocked ) .", "question_id": 8398}
{"snippet": "signal.sigwait(sigset)", "intent": "Suspend execution of the calling thread until the delivery of one of the signals specified in the signal set `sigset` .", "question_id": 8399}
{"snippet": "signal.sigwaitinfo(sigset)", "intent": "Suspend execution of the calling thread until the delivery of one of the signals specified in the signal set `sigset` .", "question_id": 8400}
{"snippet": "signal.sigtimedwait(sigset, timeout)", "intent": "Like sigwaitinfo ( ) , but takes an additional `timeout` argument specifying a timeout . With arguments `sigset`.", "question_id": 8401}
{"snippet": "site.PREFIXES", "intent": "A list of prefixes for site-packages directories.", "question_id": 8402}
{"snippet": "site.ENABLE_USER_SITE", "intent": "Flag showing the status of the user site-packages directory.", "question_id": 8403}
{"snippet": "site.USER_SITE", "intent": "Path to the user site-packages for the running Python.", "question_id": 8404}
{"snippet": "site.USER_BASE", "intent": "Path to the base directory for the user site-packages.", "question_id": 8405}
{"snippet": "site.main()", "intent": "Adds all the standard site-specific directories to the module search path .", "question_id": 8406}
{"snippet": "site.addsitedir(sitedir)", "intent": "Add a directory to sys.path and process its .pth files . With arguments `sitedir`.", "question_id": 8407}
{"snippet": "site.addsitedir(sitedir, known_paths=None)", "intent": "Add a directory to sys.path and process its .pth files . With arguments `sitedir`, `known_paths`.", "question_id": 8408}
{"snippet": "site.getsitepackages()", "intent": "Return a list containing all global site-packages directories .", "question_id": 8409}
{"snippet": "site.getuserbase()", "intent": "Return the path of the user base directory , USER_BASE .", "question_id": 8410}
{"snippet": "site.getusersitepackages()", "intent": "Return the path of the user-specific site-packages directory , USER_SITE .", "question_id": 8411}
{"snippet": "smtpd.SMTPServer(localaddr, remoteaddr)", "intent": "Create a new SMTPServer object , which binds to local address `localaddr` . It will treat `remoteaddr` as an upstream SMTP relayer .", "question_id": 8412}
{"snippet": "smtpd.SMTPServer(localaddr, remoteaddr, data_size_limit=33554432)", "intent": "Create a new SMTPServer object , which binds to local address `localaddr` . It will treat `remoteaddr` as an upstream SMTP relayer . `data_size_limit` specifies the maximum number of bytes that will be accepted in a DATA command .", "question_id": 8413}
{"snippet": "smtpd.SMTPServer(localaddr, remoteaddr, map=None)", "intent": "Create a new SMTPServer object , which binds to local address `localaddr` . It will treat `remoteaddr` as an upstream SMTP relayer . `map` is the socket map to use for connections ( an initially empty dictionary is a suitable value ) .", "question_id": 8414}
{"snippet": "smtpd.SMTPServer(localaddr, remoteaddr, enable_SMTPUTF8=False)", "intent": "Create a new SMTPServer object , which binds to local address `localaddr` . It will treat `remoteaddr` as an upstream SMTP relayer . `enable_SMTPUTF8` determines whether the SMTPUTF8 extension ( as defined in RFC 6531 ) should be enabled .", "question_id": 8415}
{"snippet": "smtpd.SMTPServer(localaddr, remoteaddr, decode_data=False)", "intent": "Create a new SMTPServer object , which binds to local address `localaddr` . It will treat `remoteaddr` as an upstream SMTP relayer . `decode_data` and enable_SMTPUTF8 can not be set to True at the same time .", "question_id": 8416}
{"snippet": "smtpd.SMTPServer(localaddr, remoteaddr, data_size_limit=33554432, map=None)", "intent": "Create a new SMTPServer object , which binds to local address `localaddr` . It will treat `remoteaddr` as an upstream SMTP relayer . `data_size_limit` specifies the maximum number of bytes that will be accepted in a DATA command . `map` is the socket map to use for connections ( an initially empty dictionary is a suitable value ) .", "question_id": 8417}
{"snippet": "smtpd.SMTPServer(localaddr, remoteaddr, data_size_limit=33554432, enable_SMTPUTF8=False)", "intent": "Create a new SMTPServer object , which binds to local address `localaddr` . It will treat `remoteaddr` as an upstream SMTP relayer . `data_size_limit` specifies the maximum number of bytes that will be accepted in a DATA command . `enable_SMTPUTF8` determines whether the SMTPUTF8 extension ( as defined in RFC 6531 ) should be enabled .", "question_id": 8418}
{"snippet": "smtpd.SMTPServer(localaddr, remoteaddr, data_size_limit=33554432, decode_data=False)", "intent": "Create a new SMTPServer object , which binds to local address `localaddr` . It will treat `remoteaddr` as an upstream SMTP relayer . `data_size_limit` specifies the maximum number of bytes that will be accepted in a DATA command . `decode_data` and enable_SMTPUTF8 can not be set to True at the same time .", "question_id": 8419}
{"snippet": "smtpd.SMTPServer(localaddr, remoteaddr, map=None, enable_SMTPUTF8=False)", "intent": "Create a new SMTPServer object , which binds to local address `localaddr` . It will treat `remoteaddr` as an upstream SMTP relayer . `map` is the socket map to use for connections ( an initially empty dictionary is a suitable value ) . `enable_SMTPUTF8` determines whether the SMTPUTF8 extension ( as defined in RFC 6531 ) should be enabled .", "question_id": 8420}
{"snippet": "smtpd.SMTPServer(localaddr, remoteaddr, map=None, decode_data=False)", "intent": "Create a new SMTPServer object , which binds to local address `localaddr` . It will treat `remoteaddr` as an upstream SMTP relayer . `map` is the socket map to use for connections ( an initially empty dictionary is a suitable value ) . `decode_data` and enable_SMTPUTF8 can not be set to True at the same time .", "question_id": 8421}
{"snippet": "smtp_server.process_message(peer, mailfrom, rcpttos, data, **kwargs)", "intent": "Raise a NotImplementedError exception . `peer` is the remote host \u2019 s address , `mailfrom` is the envelope originator , `rcpttos` are the envelope recipients and `data` is a string containing the contents of the e-mail ( which should be in RFC 5321 format ) . Implementations of process_message should use the `**kwargs` signature to accept arbitrary keyword arguments , since future feature enhancements may add keys to the kwargs dictionary .", "question_id": 8422}
{"snippet": "smtp_server.channel_class", "intent": "Override this in subclasses to use a custom SMTPChannel for managing SMTP clients.", "question_id": 8423}
{"snippet": "smtpd.DebuggingServer(localaddr, remoteaddr)", "intent": "Create a new debugging server . With arguments `localaddr`, `remoteaddr`.", "question_id": 8424}
{"snippet": "smtpd.PureProxy(localaddr, remoteaddr)", "intent": "Create a new pure proxy server . Everything will be relayed to `remoteaddr` . With arguments `localaddr`.", "question_id": 8425}
{"snippet": "smtpd.MailmanProxy(localaddr, remoteaddr)", "intent": "Create a new pure proxy server . Everything will be relayed to `remoteaddr` , unless local mailman configurations knows about an address , in which case it will be handled via mailman . With arguments `localaddr`.", "question_id": 8426}
{"snippet": "smtpd.SMTPChannel(server, conn, addr)", "intent": "Create a new SMTPChannel object which manages the communication between the `server` and a single SMTP client . `conn` and `addr` are as per the instance variables described below .", "question_id": 8427}
{"snippet": "smtpd.SMTPChannel(server, conn, addr, data_size_limit=33554432)", "intent": "Create a new SMTPChannel object which manages the communication between the `server` and a single SMTP client . `conn` and `addr` are as per the instance variables described below . `data_size_limit` specifies the maximum number of bytes that will be accepted in a DATA command .", "question_id": 8428}
{"snippet": "smtpd.SMTPChannel(server, conn, addr, map=None)", "intent": "Create a new SMTPChannel object which manages the communication between the `server` and a single SMTP client . `conn` and `addr` are as per the instance variables described below . A dictionary can be specified in `map` to avoid using a global socket map .", "question_id": 8429}
{"snippet": "smtpd.SMTPChannel(server, conn, addr, enable_SMTPUTF8=False)", "intent": "Create a new SMTPChannel object which manages the communication between the `server` and a single SMTP client . `conn` and `addr` are as per the instance variables described below . `enable_SMTPUTF8` determines whether the SMTPUTF8 extension ( as defined in RFC 6531 ) should be enabled .", "question_id": 8430}
{"snippet": "smtpd.SMTPChannel(server, conn, addr, decode_data=False)", "intent": "Create a new SMTPChannel object which manages the communication between the `server` and a single SMTP client . `conn` and `addr` are as per the instance variables described below . `decode_data` and enable_SMTPUTF8 can not be set to True at the same time .", "question_id": 8431}
{"snippet": "smtpd.SMTPChannel(server, conn, addr, data_size_limit=33554432, map=None)", "intent": "Create a new SMTPChannel object which manages the communication between the `server` and a single SMTP client . `conn` and `addr` are as per the instance variables described below . `data_size_limit` specifies the maximum number of bytes that will be accepted in a DATA command . A dictionary can be specified in `map` to avoid using a global socket map .", "question_id": 8432}
{"snippet": "smtpd.SMTPChannel(server, conn, addr, data_size_limit=33554432, enable_SMTPUTF8=False)", "intent": "Create a new SMTPChannel object which manages the communication between the `server` and a single SMTP client . `conn` and `addr` are as per the instance variables described below . `data_size_limit` specifies the maximum number of bytes that will be accepted in a DATA command . `enable_SMTPUTF8` determines whether the SMTPUTF8 extension ( as defined in RFC 6531 ) should be enabled .", "question_id": 8433}
{"snippet": "smtpd.SMTPChannel(server, conn, addr, data_size_limit=33554432, decode_data=False)", "intent": "Create a new SMTPChannel object which manages the communication between the `server` and a single SMTP client . `conn` and `addr` are as per the instance variables described below . `data_size_limit` specifies the maximum number of bytes that will be accepted in a DATA command . `decode_data` and enable_SMTPUTF8 can not be set to True at the same time .", "question_id": 8434}
{"snippet": "smtpd.SMTPChannel(server, conn, addr, map=None, enable_SMTPUTF8=False)", "intent": "Create a new SMTPChannel object which manages the communication between the `server` and a single SMTP client . `conn` and `addr` are as per the instance variables described below . A dictionary can be specified in `map` to avoid using a global socket map . `enable_SMTPUTF8` determines whether the SMTPUTF8 extension ( as defined in RFC 6531 ) should be enabled .", "question_id": 8435}
{"snippet": "smtpd.SMTPChannel(server, conn, addr, map=None, decode_data=False)", "intent": "Create a new SMTPChannel object which manages the communication between the `server` and a single SMTP client . `conn` and `addr` are as per the instance variables described below . A dictionary can be specified in `map` to avoid using a global socket map . `decode_data` and enable_SMTPUTF8 can not be set to True at the same time .", "question_id": 8436}
{"snippet": "smtp_channel.smtp_server", "intent": "Holds the SMTPServer that spawned this channel.", "question_id": 8437}
{"snippet": "smtp_channel.conn", "intent": "Holds the socket object connecting to the client.", "question_id": 8438}
{"snippet": "smtp_channel.addr", "intent": "Holds the address of the client, the second value returned by socket.accept", "question_id": 8439}
{"snippet": "smtp_channel.received_lines", "intent": "Holds a list of the line strings (decoded using UTF-8) received from the client.", "question_id": 8440}
{"snippet": "smtp_channel.smtp_state", "intent": "Holds the current state of the channel.", "question_id": 8441}
{"snippet": "smtp_channel.seen_greeting", "intent": "Holds a string containing the greeting sent by the client in its \u201cHELO\u201d.", "question_id": 8442}
{"snippet": "smtp_channel.mailfrom", "intent": "Holds a string containing the address identified in the \u201cMAIL FROM:\u201d line from the client.", "question_id": 8443}
{"snippet": "smtp_channel.rcpttos", "intent": "Holds a list of strings containing the addresses identified in the \u201cRCPT TO:\u201d lines from the client.", "question_id": 8444}
{"snippet": "smtp_channel.received_data", "intent": "Holds a string containing all of the data sent by the client during the DATA state, up to but not including the terminating \"\\r\\n.\\r\\n\".", "question_id": 8445}
{"snippet": "smtp_channel.fqdn", "intent": "Holds the fully-qualified domain name of the server as returned by socket.getfqdn().", "question_id": 8446}
{"snippet": "smtp_channel.peer", "intent": "Holds the name of the client peer as returned by conn.getpeername() where conn is conn.", "question_id": 8447}
{"snippet": "smtplib.SMTP(timeout)", "intent": "An SMTP instance encapsulates an SMTP connection . The optional `timeout` parameter specifies a timeout in seconds for blocking operations like the connection attempt ( if not specified , the global default timeout setting will be used ) .", "question_id": 8448}
{"snippet": "smtplib.SMTP(timeout, host='')", "intent": "An SMTP instance encapsulates an SMTP connection . The optional `timeout` parameter specifies a timeout in seconds for blocking operations like the connection attempt ( if not specified , the global default timeout setting will be used ) . If the optional `host` and `port` parameters are given , the SMTP connect ( ) method is called with those parameters during initialization .", "question_id": 8449}
{"snippet": "smtplib.SMTP(timeout, port=0)", "intent": "An SMTP instance encapsulates an SMTP connection . The optional `timeout` parameter specifies a timeout in seconds for blocking operations like the connection attempt ( if not specified , the global default timeout setting will be used ) . If the optional `host` and `port` parameters are given , the SMTP connect ( ) method is called with those parameters during initialization .", "question_id": 8450}
{"snippet": "smtplib.SMTP(timeout, local_hostname=None)", "intent": "An SMTP instance encapsulates an SMTP connection . The optional `timeout` parameter specifies a timeout in seconds for blocking operations like the connection attempt ( if not specified , the global default timeout setting will be used ) . If specified , `local_hostname` is used as the FQDN of the local host in the HELO/EHLO command .", "question_id": 8451}
{"snippet": "smtplib.SMTP(timeout, source_address=None)", "intent": "An SMTP instance encapsulates an SMTP connection . The optional `timeout` parameter specifies a timeout in seconds for blocking operations like the connection attempt ( if not specified , the global default timeout setting will be used ) . The optional `source_address` parameter allows binding to some specific source address in a machine with multiple network interfaces , and/or to some specific source TCP port .", "question_id": 8452}
{"snippet": "smtplib.SMTP(timeout, host='', port=0)", "intent": "An SMTP instance encapsulates an SMTP connection . The optional `timeout` parameter specifies a timeout in seconds for blocking operations like the connection attempt ( if not specified , the global default timeout setting will be used ) . If the optional `host` and `port` parameters are given , the SMTP connect ( ) method is called with those parameters during initialization .", "question_id": 8453}
{"snippet": "smtplib.SMTP(timeout, host='', local_hostname=None)", "intent": "An SMTP instance encapsulates an SMTP connection . The optional `timeout` parameter specifies a timeout in seconds for blocking operations like the connection attempt ( if not specified , the global default timeout setting will be used ) . If the optional `host` and `port` parameters are given , the SMTP connect ( ) method is called with those parameters during initialization . If specified , `local_hostname` is used as the FQDN of the local host in the HELO/EHLO command .", "question_id": 8454}
{"snippet": "smtplib.SMTP(timeout, host='', source_address=None)", "intent": "An SMTP instance encapsulates an SMTP connection . The optional `timeout` parameter specifies a timeout in seconds for blocking operations like the connection attempt ( if not specified , the global default timeout setting will be used ) . If the optional `host` and `port` parameters are given , the SMTP connect ( ) method is called with those parameters during initialization . The optional `source_address` parameter allows binding to some specific source address in a machine with multiple network interfaces , and/or to some specific source TCP port .", "question_id": 8455}
{"snippet": "smtplib.SMTP(timeout, port=0, local_hostname=None)", "intent": "An SMTP instance encapsulates an SMTP connection . The optional `timeout` parameter specifies a timeout in seconds for blocking operations like the connection attempt ( if not specified , the global default timeout setting will be used ) . If the optional `host` and `port` parameters are given , the SMTP connect ( ) method is called with those parameters during initialization . If specified , `local_hostname` is used as the FQDN of the local host in the HELO/EHLO command .", "question_id": 8456}
{"snippet": "smtplib.SMTP(timeout, port=0, source_address=None)", "intent": "An SMTP instance encapsulates an SMTP connection . The optional `timeout` parameter specifies a timeout in seconds for blocking operations like the connection attempt ( if not specified , the global default timeout setting will be used ) . If the optional `host` and `port` parameters are given , the SMTP connect ( ) method is called with those parameters during initialization . The optional `source_address` parameter allows binding to some specific source address in a machine with multiple network interfaces , and/or to some specific source TCP port .", "question_id": 8457}
{"snippet": "smtplib.SMTP()", "intent": "An SMTP instance encapsulates an SMTP connection .", "question_id": 8458}
{"snippet": "smtplib.SMTP(host='')", "intent": "An SMTP instance encapsulates an SMTP connection . If the optional `host` and `port` parameters are given , the SMTP connect ( ) method is called with those parameters during initialization .", "question_id": 8459}
{"snippet": "smtplib.SMTP(port=0)", "intent": "An SMTP instance encapsulates an SMTP connection . If the optional `host` and `port` parameters are given , the SMTP connect ( ) method is called with those parameters during initialization .", "question_id": 8460}
{"snippet": "smtplib.SMTP(local_hostname=None)", "intent": "An SMTP instance encapsulates an SMTP connection . If specified , `local_hostname` is used as the FQDN of the local host in the HELO/EHLO command .", "question_id": 8461}
{"snippet": "smtplib.SMTP(source_address=None)", "intent": "An SMTP instance encapsulates an SMTP connection . The optional `source_address` parameter allows binding to some specific source address in a machine with multiple network interfaces , and/or to some specific source TCP port .", "question_id": 8462}
{"snippet": "smtplib.SMTP(host='', port=0)", "intent": "An SMTP instance encapsulates an SMTP connection . If the optional `host` and `port` parameters are given , the SMTP connect ( ) method is called with those parameters during initialization .", "question_id": 8463}
{"snippet": "smtplib.SMTP(host='', local_hostname=None)", "intent": "An SMTP instance encapsulates an SMTP connection . If the optional `host` and `port` parameters are given , the SMTP connect ( ) method is called with those parameters during initialization . If specified , `local_hostname` is used as the FQDN of the local host in the HELO/EHLO command .", "question_id": 8464}
{"snippet": "smtplib.SMTP(host='', source_address=None)", "intent": "An SMTP instance encapsulates an SMTP connection . If the optional `host` and `port` parameters are given , the SMTP connect ( ) method is called with those parameters during initialization . The optional `source_address` parameter allows binding to some specific source address in a machine with multiple network interfaces , and/or to some specific source TCP port .", "question_id": 8465}
{"snippet": "smtplib.SMTP(port=0, local_hostname=None)", "intent": "An SMTP instance encapsulates an SMTP connection . If the optional `host` and `port` parameters are given , the SMTP connect ( ) method is called with those parameters during initialization . If specified , `local_hostname` is used as the FQDN of the local host in the HELO/EHLO command .", "question_id": 8466}
{"snippet": "smtplib.SMTP(port=0, source_address=None)", "intent": "An SMTP instance encapsulates an SMTP connection . If the optional `host` and `port` parameters are given , the SMTP connect ( ) method is called with those parameters during initialization . The optional `source_address` parameter allows binding to some specific source address in a machine with multiple network interfaces , and/or to some specific source TCP port .", "question_id": 8467}
{"snippet": "smtplib.SMTP_SSL(timeout)", "intent": "An SMTP_SSL instance behaves exactly the same as instances of SMTP . The optional arguments `local_hostname` , `timeout` and `source_address` have the same meaning as they do in the SMTP class .", "question_id": 8468}
{"snippet": "smtplib.SMTP_SSL(timeout, host='')", "intent": "An SMTP_SSL instance behaves exactly the same as instances of SMTP . The optional arguments `local_hostname` , `timeout` and `source_address` have the same meaning as they do in the SMTP class . If `host` is not specified , the local host is used .", "question_id": 8469}
{"snippet": "smtplib.SMTP_SSL(timeout, port=0)", "intent": "An SMTP_SSL instance behaves exactly the same as instances of SMTP . The optional arguments `local_hostname` , `timeout` and `source_address` have the same meaning as they do in the SMTP class . If `port` is zero , the standard SMTP-over-SSL port ( 465 ) is used .", "question_id": 8470}
{"snippet": "smtplib.SMTP_SSL(timeout, local_hostname=None)", "intent": "An SMTP_SSL instance behaves exactly the same as instances of SMTP . The optional arguments `local_hostname` , `timeout` and `source_address` have the same meaning as they do in the SMTP class .", "question_id": 8471}
{"snippet": "smtplib.SMTP_SSL(timeout, keyfile=None)", "intent": "An SMTP_SSL instance behaves exactly the same as instances of SMTP . The optional arguments `local_hostname` , `timeout` and `source_address` have the same meaning as they do in the SMTP class . `keyfile` and `certfile` are a legacy alternative to context , and can point to a PEM formatted private key and certificate chain file for the SSL connection .", "question_id": 8472}
{"snippet": "smtplib.SMTP_SSL(timeout, certfile=None)", "intent": "An SMTP_SSL instance behaves exactly the same as instances of SMTP . The optional arguments `local_hostname` , `timeout` and `source_address` have the same meaning as they do in the SMTP class . `keyfile` and `certfile` are a legacy alternative to context , and can point to a PEM formatted private key and certificate chain file for the SSL connection .", "question_id": 8473}
{"snippet": "smtplib.SMTP_SSL(timeout, context=None)", "intent": "An SMTP_SSL instance behaves exactly the same as instances of SMTP . The optional arguments `local_hostname` , `timeout` and `source_address` have the same meaning as they do in the SMTP class . `context` , also optional , can contain a SSLContext and allows configuring various aspects of the secure connection .", "question_id": 8474}
{"snippet": "smtplib.SMTP_SSL(timeout, source_address=None)", "intent": "An SMTP_SSL instance behaves exactly the same as instances of SMTP . The optional arguments `local_hostname` , `timeout` and `source_address` have the same meaning as they do in the SMTP class .", "question_id": 8475}
{"snippet": "smtplib.SMTP_SSL(timeout, host='', port=0)", "intent": "An SMTP_SSL instance behaves exactly the same as instances of SMTP . The optional arguments `local_hostname` , `timeout` and `source_address` have the same meaning as they do in the SMTP class . If `host` is not specified , the local host is used . If `port` is zero , the standard SMTP-over-SSL port ( 465 ) is used .", "question_id": 8476}
{"snippet": "smtplib.SMTP_SSL(timeout, host='', local_hostname=None)", "intent": "An SMTP_SSL instance behaves exactly the same as instances of SMTP . The optional arguments `local_hostname` , `timeout` and `source_address` have the same meaning as they do in the SMTP class . If `host` is not specified , the local host is used .", "question_id": 8477}
{"snippet": "smtplib.SMTP_SSL()", "intent": "An SMTP_SSL instance behaves exactly the same as instances of SMTP .", "question_id": 8478}
{"snippet": "smtplib.SMTP_SSL(host='')", "intent": "An SMTP_SSL instance behaves exactly the same as instances of SMTP . If `host` is not specified , the local host is used .", "question_id": 8479}
{"snippet": "smtplib.SMTP_SSL(port=0)", "intent": "An SMTP_SSL instance behaves exactly the same as instances of SMTP . If `port` is zero , the standard SMTP-over-SSL port ( 465 ) is used .", "question_id": 8480}
{"snippet": "smtplib.SMTP_SSL(local_hostname=None)", "intent": "An SMTP_SSL instance behaves exactly the same as instances of SMTP . The optional arguments `local_hostname` , `timeout` and `source_address` have the same meaning as they do in the SMTP class .", "question_id": 8481}
{"snippet": "smtplib.SMTP_SSL(keyfile=None)", "intent": "An SMTP_SSL instance behaves exactly the same as instances of SMTP . `keyfile` and `certfile` are a legacy alternative to context , and can point to a PEM formatted private key and certificate chain file for the SSL connection .", "question_id": 8482}
{"snippet": "smtplib.SMTP_SSL(certfile=None)", "intent": "An SMTP_SSL instance behaves exactly the same as instances of SMTP . `keyfile` and `certfile` are a legacy alternative to context , and can point to a PEM formatted private key and certificate chain file for the SSL connection .", "question_id": 8483}
{"snippet": "smtplib.SMTP_SSL(context=None)", "intent": "An SMTP_SSL instance behaves exactly the same as instances of SMTP . `context` , also optional , can contain a SSLContext and allows configuring various aspects of the secure connection .", "question_id": 8484}
{"snippet": "smtplib.SMTP_SSL(source_address=None)", "intent": "An SMTP_SSL instance behaves exactly the same as instances of SMTP . The optional arguments `local_hostname` , `timeout` and `source_address` have the same meaning as they do in the SMTP class .", "question_id": 8485}
{"snippet": "smtplib.SMTP_SSL(host='', port=0)", "intent": "An SMTP_SSL instance behaves exactly the same as instances of SMTP . If `host` is not specified , the local host is used . If `port` is zero , the standard SMTP-over-SSL port ( 465 ) is used .", "question_id": 8486}
{"snippet": "smtplib.SMTP_SSL(host='', local_hostname=None)", "intent": "An SMTP_SSL instance behaves exactly the same as instances of SMTP . If `host` is not specified , the local host is used . The optional arguments `local_hostname` , `timeout` and `source_address` have the same meaning as they do in the SMTP class .", "question_id": 8487}
{"snippet": "smtplib.LMTP()", "intent": "The LMTP protocol , which is very similar to ESMTP , is heavily based on the standard SMTP client .", "question_id": 8488}
{"snippet": "smtplib.LMTP(host='')", "intent": "The LMTP protocol , which is very similar to ESMTP , is heavily based on the standard SMTP client . It \u2019 s common to use Unix sockets for LMTP , so our connect ( ) method must support that as well as a regular `host` : `port` server .", "question_id": 8489}
{"snippet": "smtplib.LMTP(port=LMTP_PORT)", "intent": "The LMTP protocol , which is very similar to ESMTP , is heavily based on the standard SMTP client . It \u2019 s common to use Unix sockets for LMTP , so our connect ( ) method must support that as well as a regular `host` : `port` server .", "question_id": 8490}
{"snippet": "smtplib.LMTP(local_hostname=None)", "intent": "The LMTP protocol , which is very similar to ESMTP , is heavily based on the standard SMTP client . The optional arguments `local_hostname` and `source_address` have the same meaning as they do in the SMTP class .", "question_id": 8491}
{"snippet": "smtplib.LMTP(source_address=None)", "intent": "The LMTP protocol , which is very similar to ESMTP , is heavily based on the standard SMTP client . The optional arguments `local_hostname` and `source_address` have the same meaning as they do in the SMTP class .", "question_id": 8492}
{"snippet": "smtplib.LMTP(host='', port=LMTP_PORT)", "intent": "The LMTP protocol , which is very similar to ESMTP , is heavily based on the standard SMTP client . It \u2019 s common to use Unix sockets for LMTP , so our connect ( ) method must support that as well as a regular `host` : `port` server .", "question_id": 8493}
{"snippet": "smtplib.LMTP(host='', local_hostname=None)", "intent": "The LMTP protocol , which is very similar to ESMTP , is heavily based on the standard SMTP client . It \u2019 s common to use Unix sockets for LMTP , so our connect ( ) method must support that as well as a regular `host` : `port` server . The optional arguments `local_hostname` and `source_address` have the same meaning as they do in the SMTP class .", "question_id": 8494}
{"snippet": "smtplib.LMTP(host='', source_address=None)", "intent": "The LMTP protocol , which is very similar to ESMTP , is heavily based on the standard SMTP client . It \u2019 s common to use Unix sockets for LMTP , so our connect ( ) method must support that as well as a regular `host` : `port` server . The optional arguments `local_hostname` and `source_address` have the same meaning as they do in the SMTP class .", "question_id": 8495}
{"snippet": "smtplib.LMTP(port=LMTP_PORT, local_hostname=None)", "intent": "The LMTP protocol , which is very similar to ESMTP , is heavily based on the standard SMTP client . It \u2019 s common to use Unix sockets for LMTP , so our connect ( ) method must support that as well as a regular `host` : `port` server . The optional arguments `local_hostname` and `source_address` have the same meaning as they do in the SMTP class .", "question_id": 8496}
{"snippet": "smtplib.LMTP(port=LMTP_PORT, source_address=None)", "intent": "The LMTP protocol , which is very similar to ESMTP , is heavily based on the standard SMTP client . It \u2019 s common to use Unix sockets for LMTP , so our connect ( ) method must support that as well as a regular `host` : `port` server . The optional arguments `local_hostname` and `source_address` have the same meaning as they do in the SMTP class .", "question_id": 8497}
{"snippet": "smtplib.SMTPException", "intent": "Subclass of OSError that is the base exception class for all the other exceptions provided by this module.", "question_id": 8498}
{"snippet": "smtplib.SMTPServerDisconnected", "intent": "This exception is raised when the server unexpectedly disconnects, or when an attempt is made to use the SMTP instance before connecting it to a server.", "question_id": 8499}
{"snippet": "smtplib.SMTPResponseException", "intent": "Base class for all exceptions that include an SMTP error code.", "question_id": 8500}
{"snippet": "smtplib.SMTPSenderRefused", "intent": "Sender address refused.", "question_id": 8501}
{"snippet": "smtplib.SMTPRecipientsRefused", "intent": "All recipient addresses refused.", "question_id": 8502}
{"snippet": "smtplib.SMTPDataError", "intent": "The SMTP server refused to accept the message data.", "question_id": 8503}
{"snippet": "smtplib.SMTPConnectError", "intent": "Error occurred during establishment of a connection  with the server.", "question_id": 8504}
{"snippet": "smtplib.SMTPHeloError", "intent": "The server refused our HELO message.", "question_id": 8505}
{"snippet": "smtplib.SMTPNotSupportedError", "intent": "The command or option attempted is not supported by the server.", "question_id": 8506}
{"snippet": "smtplib.SMTPAuthenticationError", "intent": "SMTP authentication went wrong.", "question_id": 8507}
{"snippet": "SMTP.set_debuglevel(level)", "intent": "Set the debug output `level` .", "question_id": 8508}
{"snippet": "SMTP.docmd(cmd)", "intent": "Send a command `cmd` to the server .", "question_id": 8509}
{"snippet": "SMTP.docmd(cmd, args='')", "intent": "Send a command `cmd` to the server . The optional argument `args` is simply concatenated to the command , separated by a space .", "question_id": 8510}
{"snippet": "SMTP.connect()", "intent": "Connect to a `host` on a given `port` .", "question_id": 8511}
{"snippet": "SMTP.connect(host='localhost')", "intent": "Connect to a `host` on a given `port` .", "question_id": 8512}
{"snippet": "SMTP.connect(port=0)", "intent": "Connect to a `host` on a given `port` .", "question_id": 8513}
{"snippet": "SMTP.connect(host='localhost', port=0)", "intent": "Connect to a `host` on a given `port` .", "question_id": 8514}
{"snippet": "SMTP.helo()", "intent": "Identify yourself to the SMTP server using HELO .", "question_id": 8515}
{"snippet": "SMTP.helo(name='')", "intent": "Identify yourself to the SMTP server using HELO . The hostname argument defaults to the fully qualified domain `name` of the local host .", "question_id": 8516}
{"snippet": "SMTP.ehlo()", "intent": "Identify yourself to an ESMTP server using EHLO .", "question_id": 8517}
{"snippet": "SMTP.ehlo(name='')", "intent": "Identify yourself to an ESMTP server using EHLO . The hostname argument defaults to the fully qualified domain `name` of the local host .", "question_id": 8518}
{"snippet": "SMTP.ehlo_or_helo_if_needed()", "intent": "This method calls ehlo ( ) and/or helo ( ) if there has been no previous EHLO or HELO command this session .", "question_id": 8519}
{"snippet": "SMTP.has_extn(name)", "intent": "Return True if `name` is in the set of SMTP service extensions returned by the server , False otherwise .", "question_id": 8520}
{"snippet": "SMTP.verify(address)", "intent": "Check the validity of an `address` on this server using SMTP VRFY .", "question_id": 8521}
{"snippet": "SMTP.login(user, password)", "intent": "Log in on an SMTP server that requires authentication . The arguments are the username and the `password` to authenticate with . With arguments `user`.", "question_id": 8522}
{"snippet": "SMTP.login(user, password, initial_response_ok=True)", "intent": "Log in on an SMTP server that requires authentication . The arguments are the username and the `password` to authenticate with . `initial_response_ok` is passed through to auth ( ) . With arguments `user`.", "question_id": 8523}
{"snippet": "SMTP.auth(mechanism, authobject)", "intent": "Issue an SMTP AUTH command for the specified authentication `mechanism` , and handle the challenge response via `authobject` .", "question_id": 8524}
{"snippet": "SMTP.auth(mechanism, authobject, initial_response_ok=True)", "intent": "Issue an SMTP AUTH command for the specified authentication `mechanism` , and handle the challenge response via `authobject` . If optional keyword argument `initial_response_ok` is true , authobject ( ) will be called first with no argument .", "question_id": 8525}
{"snippet": "SMTP.starttls()", "intent": "Put the SMTP connection in TLS ( Transport Layer Security ) mode .", "question_id": 8526}
{"snippet": "SMTP.starttls(keyfile=None)", "intent": "Put the SMTP connection in TLS ( Transport Layer Security ) mode . If `keyfile` and `certfile` are provided , they are used to create an ssl.SSLContext .", "question_id": 8527}
{"snippet": "SMTP.starttls(certfile=None)", "intent": "Put the SMTP connection in TLS ( Transport Layer Security ) mode . If `keyfile` and `certfile` are provided , they are used to create an ssl.SSLContext .", "question_id": 8528}
{"snippet": "SMTP.starttls(context=None)", "intent": "Put the SMTP connection in TLS ( Transport Layer Security ) mode . Optional `context` parameter is an ssl.SSLContext object ; This is an alternative to using a keyfile and a certfile and if specified both keyfile and certfile should be None .", "question_id": 8529}
{"snippet": "SMTP.starttls(keyfile=None, certfile=None)", "intent": "Put the SMTP connection in TLS ( Transport Layer Security ) mode . If `keyfile` and `certfile` are provided , they are used to create an ssl.SSLContext .", "question_id": 8530}
{"snippet": "SMTP.starttls(keyfile=None, context=None)", "intent": "Put the SMTP connection in TLS ( Transport Layer Security ) mode . If `keyfile` and `certfile` are provided , they are used to create an ssl.SSLContext . Optional `context` parameter is an ssl.SSLContext object ; This is an alternative to using a keyfile and a certfile and if specified both keyfile and certfile should be None .", "question_id": 8531}
{"snippet": "SMTP.starttls(certfile=None, context=None)", "intent": "Put the SMTP connection in TLS ( Transport Layer Security ) mode . If `keyfile` and `certfile` are provided , they are used to create an ssl.SSLContext . Optional `context` parameter is an ssl.SSLContext object ; This is an alternative to using a keyfile and a certfile and if specified both keyfile and certfile should be None .", "question_id": 8532}
{"snippet": "SMTP.starttls(keyfile=None, certfile=None, context=None)", "intent": "Put the SMTP connection in TLS ( Transport Layer Security ) mode . If `keyfile` and `certfile` are provided , they are used to create an ssl.SSLContext . Optional `context` parameter is an ssl.SSLContext object ; This is an alternative to using a keyfile and a certfile and if specified both keyfile and certfile should be None .", "question_id": 8533}
{"snippet": "SMTP.sendmail(from_addr, to_addrs, msg)", "intent": "Send mail . If SMTPUTF8 is included in mail_options , and the server supports it , `from_addr` and `to_addrs` may contain non-ASCII characters . `msg` may be a string containing characters in the ASCII range , or a byte string .", "question_id": 8534}
{"snippet": "SMTP.sendmail(from_addr, to_addrs, msg, mail_options=())", "intent": "Send mail . If SMTPUTF8 is included in mail_options , and the server supports it , `from_addr` and `to_addrs` may contain non-ASCII characters . `msg` may be a string containing characters in the ASCII range , or a byte string . The caller may pass a list of ESMTP options ( such as 8bitmime ) to be used in MAIL FROM commands as `mail_options` .", "question_id": 8535}
{"snippet": "SMTP.sendmail(from_addr, to_addrs, msg, rcpt_options=())", "intent": "Send mail . If SMTPUTF8 is included in mail_options , and the server supports it , `from_addr` and `to_addrs` may contain non-ASCII characters . `msg` may be a string containing characters in the ASCII range , or a byte string . ESMTP options ( such as DSN commands ) that should be used with all RCPT commands can be passed as `rcpt_options` .", "question_id": 8536}
{"snippet": "SMTP.sendmail(from_addr, to_addrs, msg, mail_options=(), rcpt_options=())", "intent": "Send mail . If SMTPUTF8 is included in mail_options , and the server supports it , `from_addr` and `to_addrs` may contain non-ASCII characters . `msg` may be a string containing characters in the ASCII range , or a byte string . The caller may pass a list of ESMTP options ( such as 8bitmime ) to be used in MAIL FROM commands as `mail_options` . ESMTP options ( such as DSN commands ) that should be used with all RCPT commands can be passed as `rcpt_options` .", "question_id": 8537}
{"snippet": "SMTP.send_message(msg)", "intent": "This is a convenience method for calling sendmail ( ) with the message represented by an email.message.Message object . The arguments have the same meaning as for sendmail ( ) , except that `msg` is a Message object .", "question_id": 8538}
{"snippet": "SMTP.send_message(msg, from_addr=None)", "intent": "This is a convenience method for calling sendmail ( ) with the message represented by an email.message.Message object . The arguments have the same meaning as for sendmail ( ) , except that `msg` is a Message object . If `from_addr` is None or `to_addrs` is None , send_message fills those arguments with addresses extracted from the headers of msg as specified in RFC 5322 : from_addr is set to the Sender field if it is present , and otherwise to the From field .", "question_id": 8539}
{"snippet": "SMTP.send_message(msg, to_addrs=None)", "intent": "This is a convenience method for calling sendmail ( ) with the message represented by an email.message.Message object . The arguments have the same meaning as for sendmail ( ) , except that `msg` is a Message object . If `from_addr` is None or `to_addrs` is None , send_message fills those arguments with addresses extracted from the headers of msg as specified in RFC 5322 : from_addr is set to the Sender field if it is present , and otherwise to the From field .", "question_id": 8540}
{"snippet": "SMTP.send_message(msg, mail_options=())", "intent": "This is a convenience method for calling sendmail ( ) with the message represented by an email.message.Message object . The arguments have the same meaning as for sendmail ( ) , except that `msg` is a Message object . Otherwise the Message is serialized with a clone of its policy with the utf8 attribute set to True , and SMTPUTF8 and BODY=8BITMIME are added to `mail_options` .", "question_id": 8541}
{"snippet": "SMTP.send_message(msg, rcpt_options=())", "intent": "This is a convenience method for calling sendmail ( ) with the message represented by an email.message.Message object . The arguments have the same meaning as for sendmail ( ) , except that `msg` is a Message object . With arguments `rcpt_options`.", "question_id": 8542}
{"snippet": "SMTP.send_message(msg, from_addr=None, to_addrs=None)", "intent": "This is a convenience method for calling sendmail ( ) with the message represented by an email.message.Message object . The arguments have the same meaning as for sendmail ( ) , except that `msg` is a Message object . If `from_addr` is None or `to_addrs` is None , send_message fills those arguments with addresses extracted from the headers of msg as specified in RFC 5322 : from_addr is set to the Sender field if it is present , and otherwise to the From field .", "question_id": 8543}
{"snippet": "SMTP.send_message(msg, from_addr=None, mail_options=())", "intent": "This is a convenience method for calling sendmail ( ) with the message represented by an email.message.Message object . The arguments have the same meaning as for sendmail ( ) , except that `msg` is a Message object . If `from_addr` is None or `to_addrs` is None , send_message fills those arguments with addresses extracted from the headers of msg as specified in RFC 5322 : from_addr is set to the Sender field if it is present , and otherwise to the From field . Otherwise the Message is serialized with a clone of its policy with the utf8 attribute set to True , and SMTPUTF8 and BODY=8BITMIME are added to `mail_options` .", "question_id": 8544}
{"snippet": "SMTP.send_message(msg, from_addr=None, rcpt_options=())", "intent": "This is a convenience method for calling sendmail ( ) with the message represented by an email.message.Message object . The arguments have the same meaning as for sendmail ( ) , except that `msg` is a Message object . If `from_addr` is None or `to_addrs` is None , send_message fills those arguments with addresses extracted from the headers of msg as specified in RFC 5322 : from_addr is set to the Sender field if it is present , and otherwise to the From field . With arguments `rcpt_options`.", "question_id": 8545}
{"snippet": "SMTP.send_message(msg, to_addrs=None, mail_options=())", "intent": "This is a convenience method for calling sendmail ( ) with the message represented by an email.message.Message object . The arguments have the same meaning as for sendmail ( ) , except that `msg` is a Message object . If `from_addr` is None or `to_addrs` is None , send_message fills those arguments with addresses extracted from the headers of msg as specified in RFC 5322 : from_addr is set to the Sender field if it is present , and otherwise to the From field . Otherwise the Message is serialized with a clone of its policy with the utf8 attribute set to True , and SMTPUTF8 and BODY=8BITMIME are added to `mail_options` .", "question_id": 8546}
{"snippet": "SMTP.send_message(msg, to_addrs=None, rcpt_options=())", "intent": "This is a convenience method for calling sendmail ( ) with the message represented by an email.message.Message object . The arguments have the same meaning as for sendmail ( ) , except that `msg` is a Message object . If `from_addr` is None or `to_addrs` is None , send_message fills those arguments with addresses extracted from the headers of msg as specified in RFC 5322 : from_addr is set to the Sender field if it is present , and otherwise to the From field . With arguments `rcpt_options`.", "question_id": 8547}
{"snippet": "SMTP.quit()", "intent": "Terminate the SMTP session and close the connection .", "question_id": 8548}
{"snippet": "sndhdr.what(filename)", "intent": "Determines the type of sound data stored in the file `filename` using whathdr ( ) .", "question_id": 8549}
{"snippet": "sndhdr.whathdr(filename)", "intent": "Determines the type of sound data stored in a file based on the file header . The name of the file is given by `filename` .", "question_id": 8550}
{"snippet": "socket.error", "intent": "A deprecated alias of OSError.", "question_id": 8551}
{"snippet": "socket.herror", "intent": "A subclass of OSError, this exception is raised for address-related errors, i.e.", "question_id": 8552}
{"snippet": "socket.gaierror", "intent": "A subclass of OSError, this exception is raised for address-related errors by getaddrinfo() and getnameinfo().", "question_id": 8553}
{"snippet": "socket.timeout", "intent": "A subclass of OSError, this exception is raised when a timeout occurs on a socket which has had timeouts enabled via a prior call to settimeout() (or implicitly through setdefaulttimeout()).", "question_id": 8554}
{"snippet": "socket.AF_UNIX", "intent": "These constants represent the address (and protocol) families, used for the first argument to socket().", "question_id": 8555}
{"snippet": "socket.AF_INET", "intent": "These constants represent the address (and protocol) families, used for the first argument to socket().", "question_id": 8556}
{"snippet": "socket.AF_INET6", "intent": "These constants represent the address (and protocol) families, used for the first argument to socket().", "question_id": 8557}
{"snippet": "socket.SOCK_STREAM", "intent": "These constants represent the socket types, used for the second argument to socket().", "question_id": 8558}
{"snippet": "socket.SOCK_DGRAM", "intent": "These constants represent the socket types, used for the second argument to socket().", "question_id": 8559}
{"snippet": "socket.SOCK_RAW", "intent": "These constants represent the socket types, used for the second argument to socket().", "question_id": 8560}
{"snippet": "socket.SOCK_RDM", "intent": "These constants represent the socket types, used for the second argument to socket().", "question_id": 8561}
{"snippet": "socket.SOCK_SEQPACKET", "intent": "These constants represent the socket types, used for the second argument to socket().", "question_id": 8562}
{"snippet": "socket.SOCK_CLOEXEC", "intent": "These two constants, if defined, can be combined with the socket types and allow you to set some flags atomically (thus avoiding possible race conditions and the need for separate calls).", "question_id": 8563}
{"snippet": "socket.SOCK_NONBLOCK", "intent": "These two constants, if defined, can be combined with the socket types and allow you to set some flags atomically (thus avoiding possible race conditions and the need for separate calls).", "question_id": 8564}
{"snippet": "SO_*", "intent": "Many constants of these forms, documented in the Unix documentation on sockets and/or the IP protocol, are also defined in the socket module.", "question_id": 8565}
{"snippet": "socket.SOMAXCONN", "intent": "Many constants of these forms, documented in the Unix documentation on sockets and/or the IP protocol, are also defined in the socket module.", "question_id": 8566}
{"snippet": "MSG_*", "intent": "Many constants of these forms, documented in the Unix documentation on sockets and/or the IP protocol, are also defined in the socket module.", "question_id": 8567}
{"snippet": "SOL_*", "intent": "Many constants of these forms, documented in the Unix documentation on sockets and/or the IP protocol, are also defined in the socket module.", "question_id": 8568}
{"snippet": "SCM_*", "intent": "Many constants of these forms, documented in the Unix documentation on sockets and/or the IP protocol, are also defined in the socket module.", "question_id": 8569}
{"snippet": "IPPROTO_*", "intent": "Many constants of these forms, documented in the Unix documentation on sockets and/or the IP protocol, are also defined in the socket module.", "question_id": 8570}
{"snippet": "IPPORT_*", "intent": "Many constants of these forms, documented in the Unix documentation on sockets and/or the IP protocol, are also defined in the socket module.", "question_id": 8571}
{"snippet": "INADDR_*", "intent": "Many constants of these forms, documented in the Unix documentation on sockets and/or the IP protocol, are also defined in the socket module.", "question_id": 8572}
{"snippet": "IP_*", "intent": "Many constants of these forms, documented in the Unix documentation on sockets and/or the IP protocol, are also defined in the socket module.", "question_id": 8573}
{"snippet": "IPV6_*", "intent": "Many constants of these forms, documented in the Unix documentation on sockets and/or the IP protocol, are also defined in the socket module.", "question_id": 8574}
{"snippet": "EAI_*", "intent": "Many constants of these forms, documented in the Unix documentation on sockets and/or the IP protocol, are also defined in the socket module.", "question_id": 8575}
{"snippet": "AI_*", "intent": "Many constants of these forms, documented in the Unix documentation on sockets and/or the IP protocol, are also defined in the socket module.", "question_id": 8576}
{"snippet": "NI_*", "intent": "Many constants of these forms, documented in the Unix documentation on sockets and/or the IP protocol, are also defined in the socket module.", "question_id": 8577}
{"snippet": "TCP_*", "intent": "Many constants of these forms, documented in the Unix documentation on sockets and/or the IP protocol, are also defined in the socket module.", "question_id": 8578}
{"snippet": "socket.AF_CAN", "intent": "Many constants of these forms, documented in the Linux documentation, are also defined in the socket module.", "question_id": 8579}
{"snippet": "socket.PF_CAN", "intent": "Many constants of these forms, documented in the Linux documentation, are also defined in the socket module.", "question_id": 8580}
{"snippet": "SOL_CAN_*", "intent": "Many constants of these forms, documented in the Linux documentation, are also defined in the socket module.", "question_id": 8581}
{"snippet": "CAN_*", "intent": "Many constants of these forms, documented in the Linux documentation, are also defined in the socket module.", "question_id": 8582}
{"snippet": "socket.CAN_BCM", "intent": "CAN_BCM, in the CAN protocol family, is the broadcast manager (BCM) protocol.", "question_id": 8583}
{"snippet": "CAN_BCM_*", "intent": "CAN_BCM, in the CAN protocol family, is the broadcast manager (BCM) protocol.", "question_id": 8584}
{"snippet": "socket.CAN_RAW_FD_FRAMES", "intent": "Enables CAN FD support in a CAN_RAW socket.", "question_id": 8585}
{"snippet": "socket.CAN_ISOTP", "intent": "CAN_ISOTP, in the CAN protocol family, is the ISO-TP (ISO 15765-2) protocol.", "question_id": 8586}
{"snippet": "socket.AF_PACKET", "intent": "Many constants of these forms, documented in the Linux documentation, are also defined in the socket module.", "question_id": 8587}
{"snippet": "socket.PF_PACKET", "intent": "Many constants of these forms, documented in the Linux documentation, are also defined in the socket module.", "question_id": 8588}
{"snippet": "PACKET_*", "intent": "Many constants of these forms, documented in the Linux documentation, are also defined in the socket module.", "question_id": 8589}
{"snippet": "socket.AF_RDS", "intent": "Many constants of these forms, documented in the Linux documentation, are also defined in the socket module.", "question_id": 8590}
{"snippet": "socket.PF_RDS", "intent": "Many constants of these forms, documented in the Linux documentation, are also defined in the socket module.", "question_id": 8591}
{"snippet": "socket.SOL_RDS", "intent": "Many constants of these forms, documented in the Linux documentation, are also defined in the socket module.", "question_id": 8592}
{"snippet": "RDS_*", "intent": "Many constants of these forms, documented in the Linux documentation, are also defined in the socket module.", "question_id": 8593}
{"snippet": "socket.SIO_RCVALL", "intent": "Constants for Windows\u2019 WSAIoctl().", "question_id": 8594}
{"snippet": "socket.SIO_KEEPALIVE_VALS", "intent": "Constants for Windows\u2019 WSAIoctl().", "question_id": 8595}
{"snippet": "socket.SIO_LOOPBACK_FAST_PATH", "intent": "Constants for Windows\u2019 WSAIoctl().", "question_id": 8596}
{"snippet": "RCVALL_*", "intent": "Constants for Windows\u2019 WSAIoctl().", "question_id": 8597}
{"snippet": "TIPC_*", "intent": "TIPC related constants, matching the ones exported by the C socket API.", "question_id": 8598}
{"snippet": "socket.AF_ALG", "intent": "Constants for Linux Kernel cryptography.", "question_id": 8599}
{"snippet": "socket.SOL_ALG", "intent": "Constants for Linux Kernel cryptography.", "question_id": 8600}
{"snippet": "ALG_*", "intent": "Constants for Linux Kernel cryptography.", "question_id": 8601}
{"snippet": "socket.AF_VSOCK", "intent": "Constants for Linux host/guest communication.", "question_id": 8602}
{"snippet": "socket.IOCTL_VM_SOCKETS_GET_LOCAL_CID", "intent": "Constants for Linux host/guest communication.", "question_id": 8603}
{"snippet": "VMADDR*", "intent": "Constants for Linux host/guest communication.", "question_id": 8604}
{"snippet": "SO_VM*", "intent": "Constants for Linux host/guest communication.", "question_id": 8605}
{"snippet": "socket.AF_LINK", "intent": "Availability: BSD, OSX.", "question_id": 8606}
{"snippet": "socket.has_ipv6", "intent": "This constant contains a boolean value which indicates if IPv6 is supported on this platform.", "question_id": 8607}
{"snippet": "socket.BDADDR_ANY", "intent": "These are string constants containing Bluetooth addresses with special meanings.", "question_id": 8608}
{"snippet": "socket.BDADDR_LOCAL", "intent": "These are string constants containing Bluetooth addresses with special meanings.", "question_id": 8609}
{"snippet": "socket.HCI_FILTER", "intent": "For use with BTPROTO_HCI.", "question_id": 8610}
{"snippet": "socket.HCI_TIME_STAMP", "intent": "For use with BTPROTO_HCI.", "question_id": 8611}
{"snippet": "socket.HCI_DATA_DIR", "intent": "For use with BTPROTO_HCI.", "question_id": 8612}
{"snippet": "socket.socket()", "intent": "Create a new socket using the given address `family` , socket `type` and protocol number .", "question_id": 8613}
{"snippet": "socket.socket(family=AF_INET)", "intent": "Create a new socket using the given address `family` , socket `type` and protocol number .", "question_id": 8614}
{"snippet": "socket.socket(type=SOCK_STREAM)", "intent": "Create a new socket using the given address `family` , socket `type` and protocol number .", "question_id": 8615}
{"snippet": "socket.socket(proto=0)", "intent": "Create a new socket using the given address `family` , socket `type` and protocol number . If `fileno` is specified , the values for family , type , and `proto` are auto-detected from the specified file descriptor .", "question_id": 8616}
{"snippet": "socket.socket(fileno=None)", "intent": "Create a new socket using the given address `family` , socket `type` and protocol number . If `fileno` is specified , the values for family , type , and `proto` are auto-detected from the specified file descriptor .", "question_id": 8617}
{"snippet": "socket.socket(family=AF_INET, type=SOCK_STREAM)", "intent": "Create a new socket using the given address `family` , socket `type` and protocol number .", "question_id": 8618}
{"snippet": "socket.socket(family=AF_INET, proto=0)", "intent": "Create a new socket using the given address `family` , socket `type` and protocol number . If `fileno` is specified , the values for family , type , and `proto` are auto-detected from the specified file descriptor .", "question_id": 8619}
{"snippet": "socket.socket(family=AF_INET, fileno=None)", "intent": "Create a new socket using the given address `family` , socket `type` and protocol number . If `fileno` is specified , the values for family , type , and `proto` are auto-detected from the specified file descriptor .", "question_id": 8620}
{"snippet": "socket.socket(type=SOCK_STREAM, proto=0)", "intent": "Create a new socket using the given address `family` , socket `type` and protocol number . If `fileno` is specified , the values for family , type , and `proto` are auto-detected from the specified file descriptor .", "question_id": 8621}
{"snippet": "socket.socket(type=SOCK_STREAM, fileno=None)", "intent": "Create a new socket using the given address `family` , socket `type` and protocol number . If `fileno` is specified , the values for family , type , and `proto` are auto-detected from the specified file descriptor .", "question_id": 8622}
{"snippet": "socket.socketpair(family, type, proto)", "intent": "Build a pair of connected socket objects using the given address `family` , socket `type` , and protocol number . With arguments `proto`.", "question_id": 8623}
{"snippet": "socket.socketpair(family, type)", "intent": "Build a pair of connected socket objects using the given address `family` , socket `type` , and protocol number .", "question_id": 8624}
{"snippet": "socket.socketpair(family)", "intent": "Build a pair of connected socket objects using the given address `family` , socket `type` , and protocol number .", "question_id": 8625}
{"snippet": "socket.socketpair()", "intent": "Build a pair of connected socket objects using the given address `family` , socket `type` , and protocol number .", "question_id": 8626}
{"snippet": "socket.create_connection(address, timeout, source_address)", "intent": "Connect to a TCP service listening on the Internet `address` ( a 2-tuple ( host , port ) ) , and return the socket object . Passing the optional `timeout` parameter will set the timeout on the socket instance before attempting to connect . If supplied , `source_address` must be a 2-tuple ( host , port ) for the socket to bind to as its source address before connecting .", "question_id": 8627}
{"snippet": "socket.create_connection(address, timeout)", "intent": "Connect to a TCP service listening on the Internet `address` ( a 2-tuple ( host , port ) ) , and return the socket object . Passing the optional `timeout` parameter will set the timeout on the socket instance before attempting to connect .", "question_id": 8628}
{"snippet": "socket.create_connection(address)", "intent": "Connect to a TCP service listening on the Internet `address` ( a 2-tuple ( host , port ) ) , and return the socket object .", "question_id": 8629}
{"snippet": "socket.fromfd(fd, family, type)", "intent": "Duplicate the file descriptor `fd` ( an integer as returned by a file object \u2019 s fileno ( ) method ) and build a socket object from the result . Address `family` , socket `type` and protocol number are as for the socket ( ) function above .", "question_id": 8630}
{"snippet": "socket.fromfd(fd, family, type, proto=0)", "intent": "Duplicate the file descriptor `fd` ( an integer as returned by a file object \u2019 s fileno ( ) method ) and build a socket object from the result . Address `family` , socket `type` and protocol number are as for the socket ( ) function above . With arguments `proto`.", "question_id": 8631}
{"snippet": "socket.fromshare(data)", "intent": "Instantiate a socket from `data` obtained from the socket.share ( ) method .", "question_id": 8632}
{"snippet": "socket.SocketType", "intent": "This is a Python type object that represents the socket object type.", "question_id": 8633}
{"snippet": "socket.close(fd)", "intent": "Close a socket file descriptor . With arguments `fd`.", "question_id": 8634}
{"snippet": "socket.getaddrinfo(host, port)", "intent": "Translate the host/port argument into a sequence of 5-tuples that contain all the necessary arguments for creating a socket connected to that service . `host` is a domain name , a string representation of an IPv4/v6 address or None . `port` is a string service name such as 'http ' , a numeric port number or None .", "question_id": 8635}
{"snippet": "socket.getaddrinfo(host, port, family=0)", "intent": "Translate the host/port argument into a sequence of 5-tuples that contain all the necessary arguments for creating a socket connected to that service . `host` is a domain name , a string representation of an IPv4/v6 address or None . `port` is a string service name such as 'http ' , a numeric port number or None . The `family` , `type` and `proto` arguments can be optionally specified in order to narrow the list of addresses returned .", "question_id": 8636}
{"snippet": "socket.getaddrinfo(host, port, type=0)", "intent": "Translate the host/port argument into a sequence of 5-tuples that contain all the necessary arguments for creating a socket connected to that service . `host` is a domain name , a string representation of an IPv4/v6 address or None . `port` is a string service name such as 'http ' , a numeric port number or None . The `family` , `type` and `proto` arguments can be optionally specified in order to narrow the list of addresses returned .", "question_id": 8637}
{"snippet": "socket.getaddrinfo(host, port, proto=0)", "intent": "Translate the host/port argument into a sequence of 5-tuples that contain all the necessary arguments for creating a socket connected to that service . `host` is a domain name , a string representation of an IPv4/v6 address or None . `port` is a string service name such as 'http ' , a numeric port number or None . The `family` , `type` and `proto` arguments can be optionally specified in order to narrow the list of addresses returned .", "question_id": 8638}
{"snippet": "socket.getaddrinfo(host, port, flags=0)", "intent": "Translate the host/port argument into a sequence of 5-tuples that contain all the necessary arguments for creating a socket connected to that service . `host` is a domain name , a string representation of an IPv4/v6 address or None . `port` is a string service name such as 'http ' , a numeric port number or None . The `flags` argument can be one or several of the AI_* constants , and will influence how results are computed and returned .", "question_id": 8639}
{"snippet": "socket.getaddrinfo(host, port, family=0, type=0)", "intent": "Translate the host/port argument into a sequence of 5-tuples that contain all the necessary arguments for creating a socket connected to that service . `host` is a domain name , a string representation of an IPv4/v6 address or None . `port` is a string service name such as 'http ' , a numeric port number or None . The `family` , `type` and `proto` arguments can be optionally specified in order to narrow the list of addresses returned .", "question_id": 8640}
{"snippet": "socket.getaddrinfo(host, port, family=0, proto=0)", "intent": "Translate the host/port argument into a sequence of 5-tuples that contain all the necessary arguments for creating a socket connected to that service . `host` is a domain name , a string representation of an IPv4/v6 address or None . `port` is a string service name such as 'http ' , a numeric port number or None . The `family` , `type` and `proto` arguments can be optionally specified in order to narrow the list of addresses returned .", "question_id": 8641}
{"snippet": "socket.getaddrinfo(host, port, family=0, flags=0)", "intent": "Translate the host/port argument into a sequence of 5-tuples that contain all the necessary arguments for creating a socket connected to that service . `host` is a domain name , a string representation of an IPv4/v6 address or None . `port` is a string service name such as 'http ' , a numeric port number or None . The `family` , `type` and `proto` arguments can be optionally specified in order to narrow the list of addresses returned . The `flags` argument can be one or several of the AI_* constants , and will influence how results are computed and returned .", "question_id": 8642}
{"snippet": "socket.getaddrinfo(host, port, type=0, proto=0)", "intent": "Translate the host/port argument into a sequence of 5-tuples that contain all the necessary arguments for creating a socket connected to that service . `host` is a domain name , a string representation of an IPv4/v6 address or None . `port` is a string service name such as 'http ' , a numeric port number or None . The `family` , `type` and `proto` arguments can be optionally specified in order to narrow the list of addresses returned .", "question_id": 8643}
{"snippet": "socket.getaddrinfo(host, port, type=0, flags=0)", "intent": "Translate the host/port argument into a sequence of 5-tuples that contain all the necessary arguments for creating a socket connected to that service . `host` is a domain name , a string representation of an IPv4/v6 address or None . `port` is a string service name such as 'http ' , a numeric port number or None . The `family` , `type` and `proto` arguments can be optionally specified in order to narrow the list of addresses returned . The `flags` argument can be one or several of the AI_* constants , and will influence how results are computed and returned .", "question_id": 8644}
{"snippet": "socket.getfqdn(name)", "intent": "Return a fully qualified domain `name` for name .", "question_id": 8645}
{"snippet": "socket.getfqdn()", "intent": "Return a fully qualified domain `name` for name .", "question_id": 8646}
{"snippet": "socket.gethostbyname(hostname)", "intent": "Translate a host name to IPv4 address format . With arguments `hostname`.", "question_id": 8647}
{"snippet": "socket.gethostbyname_ex(hostname)", "intent": "Translate a host name to IPv4 address format , extended interface . Return a triple ( `hostname` , aliaslist , ipaddrlist ) where hostname is the primary host name responding to the given ip_address , aliaslist is a ( possibly empty ) list of alternative host names for the same address , and ipaddrlist is a list of IPv4 addresses for the same interface on the same host ( often but not always a single address ) .", "question_id": 8648}
{"snippet": "socket.gethostname()", "intent": "Return a string containing the hostname of the machine where the Python interpreter is currently executing .", "question_id": 8649}
{"snippet": "socket.gethostbyaddr(ip_address)", "intent": "Return a triple ( hostname , aliaslist , ipaddrlist ) where hostname is the primary host name responding to the given `ip_address` , aliaslist is a ( possibly empty ) list of alternative host names for the same address , and ipaddrlist is a list of IPv4/v6 addresses for the same interface on the same host ( most likely containing only a single address ) .", "question_id": 8650}
{"snippet": "socket.getnameinfo(sockaddr, flags)", "intent": "Translate a socket address `sockaddr` into a 2-tuple ( host , port ) . Depending on the settings of `flags` , the result can contain a fully-qualified domain name or numeric address representation in host .", "question_id": 8651}
{"snippet": "socket.getprotobyname(protocolname)", "intent": "Translate an Internet protocol name ( for example , 'icmp ' ) to a constant suitable for passing as the ( optional ) third argument to the socket ( ) function . With arguments `protocolname`.", "question_id": 8652}
{"snippet": "socket.getservbyname(servicename, protocolname)", "intent": "Translate an Internet service name and protocol name to a port number for that service . With arguments `servicename`, `protocolname`.", "question_id": 8653}
{"snippet": "socket.getservbyname(servicename)", "intent": "Translate an Internet service name and protocol name to a port number for that service . With arguments `servicename`.", "question_id": 8654}
{"snippet": "socket.getservbyport(port, protocolname)", "intent": "Translate an Internet `port` number and protocol name to a service name for that service . With arguments `protocolname`.", "question_id": 8655}
{"snippet": "socket.getservbyport(port)", "intent": "Translate an Internet `port` number and protocol name to a service name for that service .", "question_id": 8656}
{"snippet": "socket.ntohl(x)", "intent": "Convert 32-bit positive integers from network to host byte order . With arguments `x`.", "question_id": 8657}
{"snippet": "socket.ntohs(x)", "intent": "Convert 16-bit positive integers from network to host byte order . With arguments `x`.", "question_id": 8658}
{"snippet": "socket.htonl(x)", "intent": "Convert 32-bit positive integers from host to network byte order . With arguments `x`.", "question_id": 8659}
{"snippet": "socket.htons(x)", "intent": "Convert 16-bit positive integers from host to network byte order . With arguments `x`.", "question_id": 8660}
{"snippet": "socket.inet_aton(ip_string)", "intent": "Convert an IPv4 address from dotted-quad string format ( for example , \u2018 123.45.67.89 \u2019 ) to 32-bit packed binary format , as a bytes object four characters in length . With arguments `ip_string`.", "question_id": 8661}
{"snippet": "socket.inet_ntoa(packed_ip)", "intent": "Convert a 32-bit packed IPv4 address ( a bytes-like object four bytes in length ) to its standard dotted-quad string representation ( for example , \u2018 123.45.67.89 \u2019 ) . With arguments `packed_ip`.", "question_id": 8662}
{"snippet": "socket.inet_pton(address_family, ip_string)", "intent": "Convert an IP address from its family-specific string format to a packed , binary format . Supported values for `address_family` are currently AF_INET and AF_INET6 . If the IP address string `ip_string` is invalid , OSError will be raised .", "question_id": 8663}
{"snippet": "socket.inet_ntop(address_family, packed_ip)", "intent": "Convert a packed IP address ( a bytes-like object of some number of bytes ) to its standard , family-specific string representation ( for example , ' 7.10.0.5 ' or '5aef:2b : :8 ' ) . Supported values for `address_family` are currently AF_INET and AF_INET6 . If the bytes object `packed_ip` is not the correct length for the specified address family , ValueError will be raised .", "question_id": 8664}
{"snippet": "socket.CMSG_LEN(length)", "intent": "Return the total `length` , without trailing padding , of an ancillary data item with associated data of the given length .", "question_id": 8665}
{"snippet": "socket.CMSG_SPACE(length)", "intent": "Return the buffer size needed for recvmsg ( ) to receive an ancillary data item with associated data of the given `length` , along with any trailing padding .", "question_id": 8666}
{"snippet": "socket.getdefaulttimeout()", "intent": "Return the default timeout in seconds ( float ) for new socket objects .", "question_id": 8667}
{"snippet": "socket.setdefaulttimeout(timeout)", "intent": "Set the default `timeout` in seconds ( float ) for new socket objects .", "question_id": 8668}
{"snippet": "socket.sethostname(name)", "intent": "Set the machine \u2019 s hostname to `name` .", "question_id": 8669}
{"snippet": "socket.if_nameindex()", "intent": "Return a list of network interface information ( index int , name string ) tuples .", "question_id": 8670}
{"snippet": "socket.if_nametoindex(if_name)", "intent": "Return a network interface index number corresponding to an interface name . With arguments `if_name`.", "question_id": 8671}
{"snippet": "socket.if_indextoname(if_index)", "intent": "Return a network interface name corresponding to an interface index number . With arguments `if_index`.", "question_id": 8672}
{"snippet": "socket.accept()", "intent": "Accept a connection .", "question_id": 8673}
{"snippet": "socket.bind(address)", "intent": "Bind the socket to `address` .", "question_id": 8674}
{"snippet": "socket.close()", "intent": "Mark the socket closed .", "question_id": 8675}
{"snippet": "socket.connect(address)", "intent": "Connect to a remote socket at `address` .", "question_id": 8676}
{"snippet": "socket.connect_ex(address)", "intent": "Like connect ( `address` ) , but return an error indicator instead of raising an exception for errors returned by the C-level connect ( ) call ( other problems , such as \u201c host not found , \u201d can still raise exceptions ) .", "question_id": 8677}
{"snippet": "socket.detach()", "intent": "Put the socket object into closed state without actually closing the underlying file descriptor .", "question_id": 8678}
{"snippet": "socket.dup()", "intent": "Duplicate the socket .", "question_id": 8679}
{"snippet": "socket.fileno()", "intent": "Return the socket \u2019 s file descriptor ( a small integer ) , or -1 on failure .", "question_id": 8680}
{"snippet": "socket.get_inheritable()", "intent": "Get the inheritable flag of the socket \u2019 s file descriptor or socket \u2019 s handle : True if the socket can be inherited in child processes , False if it can not .", "question_id": 8681}
{"snippet": "socket.getpeername()", "intent": "Return the remote address to which the socket is connected .", "question_id": 8682}
{"snippet": "socket.getsockname()", "intent": "Return the socket \u2019 s own address .", "question_id": 8683}
{"snippet": "socket.getsockopt(level, optname, buflen)", "intent": "Return the value of the given socket option ( see the Unix man page getsockopt ( 2 ) ) . If `buflen` is absent , an integer option is assumed and its integer value is returned by the function . With arguments `level`, `optname`.", "question_id": 8684}
{"snippet": "socket.getsockopt(level, optname)", "intent": "Return the value of the given socket option ( see the Unix man page getsockopt ( 2 ) ) . With arguments `level`, `optname`.", "question_id": 8685}
{"snippet": "socket.getblocking()", "intent": "Return True if socket is in blocking mode , False if in non-blocking .", "question_id": 8686}
{"snippet": "socket.gettimeout()", "intent": "Return the timeout in seconds ( float ) associated with socket operations , or None if no timeout is set .", "question_id": 8687}
{"snippet": "socket.ioctl(control, option)", "intent": "The ioctl ( ) method is a limited interface to the WSAIoctl system interface . Currently only the following `control` codes are supported : SIO_RCVALL , SIO_KEEPALIVE_VALS , and SIO_LOOPBACK_FAST_PATH . With arguments `option`.", "question_id": 8688}
{"snippet": "socket.listen(backlog)", "intent": "Enable a server to accept connections . If `backlog` is specified , it must be at least 0 ( if it is lower , it is set to 0 ) ; it specifies the number of unaccepted connections that the system will allow before refusing new connections .", "question_id": 8689}
{"snippet": "socket.listen()", "intent": "Enable a server to accept connections .", "question_id": 8690}
{"snippet": "socket.makefile()", "intent": "Return a file object associated with the socket .", "question_id": 8691}
{"snippet": "socket.makefile(mode='r')", "intent": "Return a file object associated with the socket . These arguments are interpreted the same way as by the built-in open ( ) function , except the only supported `mode` values are ' r ' ( default ) , ' w ' and ' b ' .", "question_id": 8692}
{"snippet": "socket.makefile(buffering=None)", "intent": "Return a file object associated with the socket . With arguments `buffering`.", "question_id": 8693}
{"snippet": "socket.makefile(encoding=None)", "intent": "Return a file object associated with the socket . With arguments `encoding`.", "question_id": 8694}
{"snippet": "socket.makefile(errors=None)", "intent": "Return a file object associated with the socket . With arguments `errors`.", "question_id": 8695}
{"snippet": "socket.makefile(newline=None)", "intent": "Return a file object associated with the socket . With arguments `newline`.", "question_id": 8696}
{"snippet": "socket.makefile(mode='r', buffering=None)", "intent": "Return a file object associated with the socket . These arguments are interpreted the same way as by the built-in open ( ) function , except the only supported `mode` values are ' r ' ( default ) , ' w ' and ' b ' . With arguments `buffering`.", "question_id": 8697}
{"snippet": "socket.makefile(mode='r', encoding=None)", "intent": "Return a file object associated with the socket . These arguments are interpreted the same way as by the built-in open ( ) function , except the only supported `mode` values are ' r ' ( default ) , ' w ' and ' b ' . With arguments `encoding`.", "question_id": 8698}
{"snippet": "socket.makefile(mode='r', errors=None)", "intent": "Return a file object associated with the socket . These arguments are interpreted the same way as by the built-in open ( ) function , except the only supported `mode` values are ' r ' ( default ) , ' w ' and ' b ' . With arguments `errors`.", "question_id": 8699}
{"snippet": "socket.makefile(mode='r', newline=None)", "intent": "Return a file object associated with the socket . These arguments are interpreted the same way as by the built-in open ( ) function , except the only supported `mode` values are ' r ' ( default ) , ' w ' and ' b ' . With arguments `newline`.", "question_id": 8700}
{"snippet": "socket.recv(bufsize, flags)", "intent": "Receive data from the socket . The maximum amount of data to be received at once is specified by `bufsize` . See the Unix manual page recv ( 2 ) for the meaning of the optional argument `flags` ; it defaults to zero .", "question_id": 8701}
{"snippet": "socket.recv(bufsize)", "intent": "Receive data from the socket . The maximum amount of data to be received at once is specified by `bufsize` .", "question_id": 8702}
{"snippet": "socket.recvfrom(bufsize, flags)", "intent": "Receive data from the socket . See the Unix manual page recv ( 2 ) for the meaning of the optional argument `flags` ; it defaults to zero . With arguments `bufsize`.", "question_id": 8703}
{"snippet": "socket.recvfrom(bufsize)", "intent": "Receive data from the socket . With arguments `bufsize`.", "question_id": 8704}
{"snippet": "socket.recvmsg(bufsize, ancbufsize, flags)", "intent": "Receive normal data ( up to `bufsize` bytes ) and ancillary data from the socket . The `ancbufsize` argument sets the size in bytes of the internal buffer used to receive the ancillary data ; it defaults to 0 , meaning that no ancillary data will be received . The `flags` argument defaults to 0 and has the same meaning as for recv ( ) .", "question_id": 8705}
{"snippet": "socket.recvmsg(bufsize, ancbufsize)", "intent": "Receive normal data ( up to `bufsize` bytes ) and ancillary data from the socket . The `ancbufsize` argument sets the size in bytes of the internal buffer used to receive the ancillary data ; it defaults to 0 , meaning that no ancillary data will be received .", "question_id": 8706}
{"snippet": "socket.recvmsg(bufsize)", "intent": "Receive normal data ( up to `bufsize` bytes ) and ancillary data from the socket .", "question_id": 8707}
{"snippet": "socket.recvmsg_into(buffers, ancbufsize, flags)", "intent": "Receive normal data and ancillary data from the socket , behaving as recvmsg ( ) would , but scatter the non-ancillary data into a series of `buffers` instead of returning a new bytes object . The `ancbufsize` and `flags` arguments have the same meaning as for recvmsg ( ) .", "question_id": 8708}
{"snippet": "socket.recvmsg_into(buffers, ancbufsize)", "intent": "Receive normal data and ancillary data from the socket , behaving as recvmsg ( ) would , but scatter the non-ancillary data into a series of `buffers` instead of returning a new bytes object . The `ancbufsize` and `flags` arguments have the same meaning as for recvmsg ( ) .", "question_id": 8709}
{"snippet": "socket.recvmsg_into(buffers)", "intent": "Receive normal data and ancillary data from the socket , behaving as recvmsg ( ) would , but scatter the non-ancillary data into a series of `buffers` instead of returning a new bytes object .", "question_id": 8710}
{"snippet": "socket.recvfrom_into(buffer, nbytes, flags)", "intent": "Receive data from the socket , writing it into `buffer` instead of creating a new bytestring . The return value is a pair ( `nbytes` , address ) where nbytes is the number of bytes received and address is the address of the socket sending the data . See the Unix manual page recv ( 2 ) for the meaning of the optional argument `flags` ; it defaults to zero .", "question_id": 8711}
{"snippet": "socket.recvfrom_into(buffer, nbytes)", "intent": "Receive data from the socket , writing it into `buffer` instead of creating a new bytestring . The return value is a pair ( `nbytes` , address ) where nbytes is the number of bytes received and address is the address of the socket sending the data .", "question_id": 8712}
{"snippet": "socket.recvfrom_into(buffer)", "intent": "Receive data from the socket , writing it into `buffer` instead of creating a new bytestring .", "question_id": 8713}
{"snippet": "socket.recv_into(buffer, nbytes, flags)", "intent": "Receive up to `nbytes` bytes from the socket , storing the data into a `buffer` rather than creating a new bytestring . See the Unix manual page recv ( 2 ) for the meaning of the optional argument `flags` ; it defaults to zero .", "question_id": 8714}
{"snippet": "socket.recv_into(buffer, nbytes)", "intent": "Receive up to `nbytes` bytes from the socket , storing the data into a `buffer` rather than creating a new bytestring .", "question_id": 8715}
{"snippet": "socket.recv_into(buffer)", "intent": "Receive up to `nbytes` bytes from the socket , storing the data into a `buffer` rather than creating a new bytestring .", "question_id": 8716}
{"snippet": "socket.send(bytes, flags)", "intent": "Send data to the socket . Returns the number of `bytes` sent . The optional `flags` argument has the same meaning as for recv ( ) above .", "question_id": 8717}
{"snippet": "socket.send(bytes)", "intent": "Send data to the socket . Returns the number of `bytes` sent .", "question_id": 8718}
{"snippet": "socket.sendall(bytes, flags)", "intent": "Send data to the socket . Unlike send ( ) , this method continues to send data from `bytes` until either all data has been sent or an error occurs . The optional `flags` argument has the same meaning as for recv ( ) above .", "question_id": 8719}
{"snippet": "socket.sendall(bytes)", "intent": "Send data to the socket . Unlike send ( ) , this method continues to send data from `bytes` until either all data has been sent or an error occurs .", "question_id": 8720}
{"snippet": "socket.sendto(bytes, address)", "intent": "Send data to the socket . Return the number of `bytes` sent . The socket should not be connected to a remote socket , since the destination socket is specified by `address` .", "question_id": 8721}
{"snippet": "socket.sendto(bytes, flags, address)", "intent": "Send data to the socket . Return the number of `bytes` sent . The optional `flags` argument has the same meaning as for recv ( ) above . The socket should not be connected to a remote socket , since the destination socket is specified by `address` .", "question_id": 8722}
{"snippet": "socket.sendmsg(buffers, ancdata, flags, address)", "intent": "Send normal and ancillary data to the socket , gathering the non-ancillary data from a series of `buffers` and concatenating it into a single message . The `ancdata` argument specifies the ancillary data ( control messages ) as an iterable of zero or more tuples ( cmsg_level , cmsg_type , cmsg_data ) , where cmsg_level and cmsg_type are integers specifying the protocol level and protocol-specific type respectively , and cmsg_data is a bytes-like object holding the associated data . The `flags` argument defaults to 0 and has the same meaning as for send ( ) . If `address` is supplied and not None , it sets a destination address for the message .", "question_id": 8723}
{"snippet": "socket.sendmsg(buffers, ancdata, flags)", "intent": "Send normal and ancillary data to the socket , gathering the non-ancillary data from a series of `buffers` and concatenating it into a single message . The `ancdata` argument specifies the ancillary data ( control messages ) as an iterable of zero or more tuples ( cmsg_level , cmsg_type , cmsg_data ) , where cmsg_level and cmsg_type are integers specifying the protocol level and protocol-specific type respectively , and cmsg_data is a bytes-like object holding the associated data . The `flags` argument defaults to 0 and has the same meaning as for send ( ) .", "question_id": 8724}
{"snippet": "socket.sendmsg(buffers, ancdata)", "intent": "Send normal and ancillary data to the socket , gathering the non-ancillary data from a series of `buffers` and concatenating it into a single message . The `ancdata` argument specifies the ancillary data ( control messages ) as an iterable of zero or more tuples ( cmsg_level , cmsg_type , cmsg_data ) , where cmsg_level and cmsg_type are integers specifying the protocol level and protocol-specific type respectively , and cmsg_data is a bytes-like object holding the associated data .", "question_id": 8725}
{"snippet": "socket.sendmsg(buffers)", "intent": "Send normal and ancillary data to the socket , gathering the non-ancillary data from a series of `buffers` and concatenating it into a single message .", "question_id": 8726}
{"snippet": "socket.sendmsg_afalg(msg, op, iv, assoclen, flags)", "intent": "Specialized version of sendmsg ( ) for AF_ALG socket . Set mode , IV , AEAD associated data length and `flags` for AF_ALG socket . With arguments `msg`, `op`, `iv`, `assoclen`.", "question_id": 8727}
{"snippet": "socket.sendmsg_afalg(msg, op, iv, assoclen)", "intent": "Specialized version of sendmsg ( ) for AF_ALG socket . With arguments `msg`, `op`, `iv`, `assoclen`.", "question_id": 8728}
{"snippet": "socket.sendmsg_afalg(msg, op, iv)", "intent": "Specialized version of sendmsg ( ) for AF_ALG socket . With arguments `msg`, `op`, `iv`.", "question_id": 8729}
{"snippet": "socket.sendmsg_afalg(msg, op)", "intent": "Specialized version of sendmsg ( ) for AF_ALG socket . With arguments `msg`, `op`.", "question_id": 8730}
{"snippet": "socket.sendmsg_afalg(msg)", "intent": "Specialized version of sendmsg ( ) for AF_ALG socket . With arguments `msg`.", "question_id": 8731}
{"snippet": "socket.sendfile(file)", "intent": "Send a `file` until EOF is reached by using high-performance os.sendfile and return the total number of bytes which were sent .", "question_id": 8732}
{"snippet": "socket.sendfile(file, offset=0)", "intent": "Send a `file` until EOF is reached by using high-performance os.sendfile and return the total number of bytes which were sent . `offset` tells from where to start reading the file .", "question_id": 8733}
{"snippet": "socket.sendfile(file, count=None)", "intent": "Send a `file` until EOF is reached by using high-performance os.sendfile and return the total number of bytes which were sent . If specified , `count` is the total number of bytes to transmit as opposed to sending the file until EOF is reached .", "question_id": 8734}
{"snippet": "socket.sendfile(file, offset=0, count=None)", "intent": "Send a `file` until EOF is reached by using high-performance os.sendfile and return the total number of bytes which were sent . `offset` tells from where to start reading the file . If specified , `count` is the total number of bytes to transmit as opposed to sending the file until EOF is reached .", "question_id": 8735}
{"snippet": "socket.set_inheritable(inheritable)", "intent": "Set the `inheritable` flag of the socket \u2019 s file descriptor or socket \u2019 s handle .", "question_id": 8736}
{"snippet": "socket.setblocking(flag)", "intent": "Set blocking or non-blocking mode of the socket : if `flag` is false , the socket is set to non-blocking , else to blocking mode .", "question_id": 8737}
{"snippet": "socket.settimeout(value)", "intent": "Set a timeout on blocking socket operations . The `value` argument can be a nonnegative floating point number expressing seconds , or None .", "question_id": 8738}
{"snippet": "socket.setsockopt(level, optname, None, optlen: int)", "intent": "Set the value of the given socket option ( see the Unix manual page setsockopt ( 2 ) ) . The value can be an integer , `None` or a bytes-like object representing a buffer . With arguments `level`, `optname`, `optlen: int`.", "question_id": 8739}
{"snippet": "socket.shutdown(how)", "intent": "Shut down one or both halves of the connection . If `how` is SHUT_RD , further receives are disallowed .", "question_id": 8740}
{"snippet": "socket.share(process_id)", "intent": "Duplicate a socket and prepare it for sharing with a target process . The target process must be provided with `process_id` .", "question_id": 8741}
{"snippet": "socket.family", "intent": "The socket family.", "question_id": 8742}
{"snippet": "socket.type", "intent": "The socket type.", "question_id": 8743}
{"snippet": "socket.proto", "intent": "The socket protocol.", "question_id": 8744}
{"snippet": "socketserver.TCPServer(server_address, RequestHandlerClass)", "intent": "This uses the Internet TCP protocol , which provides for continuous streams of data between the client and server . With arguments `server_address`, `RequestHandlerClass`.", "question_id": 8745}
{"snippet": "socketserver.TCPServer(server_address, RequestHandlerClass, bind_and_activate=True)", "intent": "This uses the Internet TCP protocol , which provides for continuous streams of data between the client and server . If `bind_and_activate` is true , the constructor automatically attempts to invoke server_bind ( ) and server_activate ( ) . With arguments `server_address`, `RequestHandlerClass`.", "question_id": 8746}
{"snippet": "socketserver.UDPServer(server_address, RequestHandlerClass)", "intent": "This uses datagrams , which are discrete packets of information that may arrive out of order or be lost while in transit . With arguments `server_address`, `RequestHandlerClass`.", "question_id": 8747}
{"snippet": "socketserver.UDPServer(server_address, RequestHandlerClass, bind_and_activate=True)", "intent": "This uses datagrams , which are discrete packets of information that may arrive out of order or be lost while in transit . With arguments `server_address`, `RequestHandlerClass`, `bind_and_activate`.", "question_id": 8748}
{"snippet": "socketserver.UnixStreamServer(server_address, RequestHandlerClass)", "intent": "These more infrequently used classes are similar to the TCP and UDP classes , but use Unix domain sockets ; they \u2019 re not available on non-Unix platforms . With arguments `server_address`, `RequestHandlerClass`.", "question_id": 8749}
{"snippet": "socketserver.UnixStreamServer(server_address, RequestHandlerClass, bind_and_activate=True)", "intent": "These more infrequently used classes are similar to the TCP and UDP classes , but use Unix domain sockets ; they \u2019 re not available on non-Unix platforms . With arguments `server_address`, `RequestHandlerClass`, `bind_and_activate`.", "question_id": 8750}
{"snippet": "socketserver.UnixDatagramServer(server_address, RequestHandlerClass)", "intent": "These more infrequently used classes are similar to the TCP and UDP classes , but use Unix domain sockets ; they \u2019 re not available on non-Unix platforms . With arguments `server_address`, `RequestHandlerClass`.", "question_id": 8751}
{"snippet": "socketserver.UnixDatagramServer(server_address, RequestHandlerClass, bind_and_activate=True)", "intent": "These more infrequently used classes are similar to the TCP and UDP classes , but use Unix domain sockets ; they \u2019 re not available on non-Unix platforms . With arguments `server_address`, `RequestHandlerClass`, `bind_and_activate`.", "question_id": 8752}
{"snippet": "socketserver.ForkingMixIn", "intent": "Forking and threading versions of each type of server can be created using these mix-in classes.", "question_id": 8753}
{"snippet": "socketserver.ThreadingMixIn", "intent": "Forking and threading versions of each type of server can be created using these mix-in classes.", "question_id": 8754}
{"snippet": "socketserver.ForkingTCPServer", "intent": "These classes are pre-defined using the mix-in classes.", "question_id": 8755}
{"snippet": "socketserver.ForkingUDPServer", "intent": "These classes are pre-defined using the mix-in classes.", "question_id": 8756}
{"snippet": "socketserver.ThreadingTCPServer", "intent": "These classes are pre-defined using the mix-in classes.", "question_id": 8757}
{"snippet": "socketserver.ThreadingUDPServer", "intent": "These classes are pre-defined using the mix-in classes.", "question_id": 8758}
{"snippet": "socketserver.BaseServer(server_address, RequestHandlerClass)", "intent": "This is the superclass of all Server objects in the module . The two parameters are stored in the respective `server_address` and `RequestHandlerClass` attributes .", "question_id": 8759}
{"snippet": "base_server.fileno()", "intent": "Return an integer file descriptor for the socket on which the server is listening .", "question_id": 8760}
{"snippet": "base_server.handle_request()", "intent": "Process a single request .", "question_id": 8761}
{"snippet": "base_server.serve_forever()", "intent": "Handle requests until an explicit shutdown ( ) request .", "question_id": 8762}
{"snippet": "base_server.serve_forever(poll_interval=0.5)", "intent": "Handle requests until an explicit shutdown ( ) request . Poll for shutdown every `poll_interval` seconds .", "question_id": 8763}
{"snippet": "base_server.service_actions()", "intent": "This is called in the serve_forever ( ) loop .", "question_id": 8764}
{"snippet": "base_server.shutdown()", "intent": "Tell the serve_forever ( ) loop to stop and wait until it does .", "question_id": 8765}
{"snippet": "base_server.server_close()", "intent": "Clean up the server .", "question_id": 8766}
{"snippet": "base_server.address_family", "intent": "The family of protocols to which the server\u2019s socket belongs.", "question_id": 8767}
{"snippet": "base_server.RequestHandlerClass", "intent": "The user-provided request handler class; an instance of this class is created for each request.", "question_id": 8768}
{"snippet": "base_server.server_address", "intent": "The address on which the server is listening.", "question_id": 8769}
{"snippet": "base_server.socket", "intent": "The socket object on which the server will listen for incoming requests.", "question_id": 8770}
{"snippet": "base_server.allow_reuse_address", "intent": "Whether the server will allow the reuse of an address.", "question_id": 8771}
{"snippet": "base_server.request_queue_size", "intent": "The size of the request queue.", "question_id": 8772}
{"snippet": "base_server.socket_type", "intent": "The type of socket used by the server; socket.SOCK_STREAM and socket.SOCK_DGRAM are two common values.", "question_id": 8773}
{"snippet": "base_server.timeout", "intent": "Timeout duration, measured in seconds, or None if no timeout is desired.", "question_id": 8774}
{"snippet": "base_server.finish_request(request, client_address)", "intent": "Actually processes the `request` by instantiating RequestHandlerClass and calling its handle ( ) method . With arguments `client_address`.", "question_id": 8775}
{"snippet": "base_server.get_request()", "intent": "Must accept a request from the socket , and return a 2-tuple containing the new socket object to be used to communicate with the client , and the client \u2019 s address .", "question_id": 8776}
{"snippet": "base_server.handle_error(request, client_address)", "intent": "This function is called if the handle ( ) method of a RequestHandlerClass instance raises an exception . With arguments `request`, `client_address`.", "question_id": 8777}
{"snippet": "base_server.handle_timeout()", "intent": "This function is called when the timeout attribute has been set to a value other than None and the timeout period has passed with no requests being received .", "question_id": 8778}
{"snippet": "base_server.process_request(request, client_address)", "intent": "Calls finish_request ( ) to create an instance of the RequestHandlerClass . If desired , this function can create a new process or thread to handle the `request` ; the ForkingMixIn and ThreadingMixIn classes do this . With arguments `client_address`.", "question_id": 8779}
{"snippet": "base_server.server_activate()", "intent": "Called by the server \u2019 s constructor to activate the server .", "question_id": 8780}
{"snippet": "base_server.server_bind()", "intent": "Called by the server \u2019 s constructor to bind the socket to the desired address .", "question_id": 8781}
{"snippet": "base_server.verify_request(request, client_address)", "intent": "Must return a Boolean value ; if the value is True , the `request` will be processed , and if it \u2019 s False , the request will be denied . With arguments `client_address`.", "question_id": 8782}
{"snippet": "socketserver.BaseRequestHandler", "intent": "This is the superclass of all request handler objects.", "question_id": 8783}
{"snippet": "base_request_handler.setup()", "intent": "Called before the handle ( ) method to perform any initialization actions required .", "question_id": 8784}
{"snippet": "base_request_handler.handle()", "intent": "This function must do all the work required to service a request .", "question_id": 8785}
{"snippet": "base_request_handler.finish()", "intent": "Called after the handle ( ) method to perform any clean-up actions required .", "question_id": 8786}
{"snippet": "socketserver.StreamRequestHandler", "intent": "These BaseRequestHandler subclasses override the setup() and finish() methods, and provide self.rfile and self.wfile attributes.", "question_id": 8787}
{"snippet": "socketserver.DatagramRequestHandler", "intent": "These BaseRequestHandler subclasses override the setup() and finish() methods, and provide self.rfile and self.wfile attributes.", "question_id": 8788}
{"snippet": "spwd.getspnam(name)", "intent": "Return the shadow password database entry for the given user `name` .", "question_id": 8789}
{"snippet": "spwd.getspall()", "intent": "Return a list of all available shadow password database entries , in arbitrary order .", "question_id": 8790}
{"snippet": "sqlite3.version", "intent": "The version number of this module, as a string.", "question_id": 8791}
{"snippet": "sqlite3.version_info", "intent": "The version number of this module, as a tuple of integers.", "question_id": 8792}
{"snippet": "sqlite3.sqlite_version", "intent": "The version number of the run-time SQLite library, as a string.", "question_id": 8793}
{"snippet": "sqlite3.sqlite_version_info", "intent": "The version number of the run-time SQLite library, as a tuple of integers.", "question_id": 8794}
{"snippet": "sqlite3.PARSE_DECLTYPES", "intent": "This constant is meant to be used with the detect_types parameter of the connect() function.", "question_id": 8795}
{"snippet": "sqlite3.PARSE_COLNAMES", "intent": "This constant is meant to be used with the detect_types parameter of the connect() function.", "question_id": 8796}
{"snippet": "sqlite3.connect(database, timeout, detect_types, isolation_level, check_same_thread, factory, cached_statements, uri)", "intent": "Opens a connection to the SQLite `database` file database . The `timeout` parameter specifies how long the connection should wait for the lock to go away until raising an exception . The `detect_types` parameter and the using custom converters registered with the module-level register_converter ( ) function allow you to easily do that . For the `isolation_level` parameter , please see the isolation_level property of Connection objects . By default , `check_same_thread` is True and only the creating thread may use the connection . By default returns a Connection object , unless a custom `factory` is given . If you want to explicitly set the number of statements that are cached for the connection , you can set the `cached_statements` parameter . If `uri` is true , database is interpreted as a URI .", "question_id": 8797}
{"snippet": "sqlite3.connect(database, timeout, detect_types, isolation_level, check_same_thread, factory, cached_statements)", "intent": "Opens a connection to the SQLite `database` file database . The `timeout` parameter specifies how long the connection should wait for the lock to go away until raising an exception . The `detect_types` parameter and the using custom converters registered with the module-level register_converter ( ) function allow you to easily do that . For the `isolation_level` parameter , please see the isolation_level property of Connection objects . By default , `check_same_thread` is True and only the creating thread may use the connection . By default returns a Connection object , unless a custom `factory` is given . If you want to explicitly set the number of statements that are cached for the connection , you can set the `cached_statements` parameter .", "question_id": 8798}
{"snippet": "sqlite3.register_converter(typename, callable)", "intent": "Registers a `callable` to convert a bytestring from the database into a custom Python type . The callable will be invoked for all database values that are of the type `typename` .", "question_id": 8799}
{"snippet": "sqlite3.register_adapter(type, callable)", "intent": "Registers a `callable` to convert the custom Python `type` type into one of SQLite \u2019 s supported types .", "question_id": 8800}
{"snippet": "sqlite3.complete_statement(sql)", "intent": "Returns True if the string `sql` contains one or more complete SQL statements terminated by semicolons .", "question_id": 8801}
{"snippet": "sqlite3.enable_callback_tracebacks(flag)", "intent": "By default you will not get any tracebacks in user-defined functions , aggregates , converters , authorizer callbacks etc . If you want to debug them , you can call this function with `flag` set to True .", "question_id": 8802}
{"snippet": "sqlite3.Connection", "intent": "A SQLite database connection has the following attributes and methods:", "question_id": 8803}
{"snippet": "connection.isolation_level", "intent": "Get or set the current default isolation level.", "question_id": 8804}
{"snippet": "connection.in_transaction", "intent": "True if a transaction is active (there are uncommitted changes), False otherwise.", "question_id": 8805}
{"snippet": "connection.cursor()", "intent": "The cursor method accepts a single optional parameter `factory` .", "question_id": 8806}
{"snippet": "connection.cursor(factory=Cursor)", "intent": "The cursor method accepts a single optional parameter `factory` .", "question_id": 8807}
{"snippet": "connection.commit()", "intent": "This method commits the current transaction .", "question_id": 8808}
{"snippet": "connection.rollback()", "intent": "This method rolls back any changes to the database since the last call to commit ( ) .", "question_id": 8809}
{"snippet": "connection.close()", "intent": "This closes the database connection .", "question_id": 8810}
{"snippet": "connection.execute(sql, parameters)", "intent": "This is a nonstandard shortcut that creates a cursor object by calling the cursor ( ) method , calls the cursor \u2019 s execute ( ) method with the `parameters` given , and returns the cursor . With arguments `sql`.", "question_id": 8811}
{"snippet": "connection.execute(sql)", "intent": "This is a nonstandard shortcut that creates a cursor object by calling the cursor ( ) method , calls the cursor \u2019 s execute ( ) method with the `parameters` given , and returns the cursor . With arguments `sql`.", "question_id": 8812}
{"snippet": "connection.executemany(sql, parameters)", "intent": "This is a nonstandard shortcut that creates a cursor object by calling the cursor ( ) method , calls the cursor \u2019 s executemany ( ) method with the `parameters` given , and returns the cursor . With arguments `sql`.", "question_id": 8813}
{"snippet": "connection.executemany(sql)", "intent": "This is a nonstandard shortcut that creates a cursor object by calling the cursor ( ) method , calls the cursor \u2019 s executemany ( ) method with the `parameters` given , and returns the cursor . With arguments `sql`.", "question_id": 8814}
{"snippet": "connection.executescript(sql_script)", "intent": "This is a nonstandard shortcut that creates a cursor object by calling the cursor ( ) method , calls the cursor \u2019 s executescript ( ) method with the given `sql_script` , and returns the cursor .", "question_id": 8815}
{"snippet": "connection.create_function(name, num_params, func)", "intent": "Creates a user-defined function that you can later use from within SQL statements under the function `name` name . `num_params` is the number of parameters the function accepts ( if num_params is -1 , the function may take any number of arguments ) , and `func` is a Python callable that is called as the SQL function .", "question_id": 8816}
{"snippet": "connection.create_aggregate(name, num_params, aggregate_class)", "intent": "Creates a user-defined aggregate function . The aggregate class must implement a step method , which accepts the number of parameters `num_params` ( if num_params is -1 , the function may take any number of arguments ) , and a finalize method which will return the final result of the aggregate . With arguments `name`, `aggregate_class`.", "question_id": 8817}
{"snippet": "connection.create_collation(name, callable)", "intent": "Creates a collation with the specified `name` and `callable` .", "question_id": 8818}
{"snippet": "connection.interrupt()", "intent": "You can call this method from a different thread to abort any queries that might be executing on the connection .", "question_id": 8819}
{"snippet": "connection.set_authorizer(authorizer_callback)", "intent": "This routine registers a callback . With arguments `authorizer_callback`.", "question_id": 8820}
{"snippet": "connection.set_progress_handler(handler, n)", "intent": "This routine registers a callback . If you want to clear any previously installed progress `handler` , call the method with None for handler . The callback is invoked for every `n` instructions of the SQLite virtual machine .", "question_id": 8821}
{"snippet": "connection.set_trace_callback(trace_callback)", "intent": "Registers `trace_callback` to be called for each SQL statement that is actually executed by the SQLite backend .", "question_id": 8822}
{"snippet": "connection.enable_load_extension(enabled)", "intent": "This routine allows/disallows the SQLite engine to load SQLite extensions from shared libraries . With arguments `enabled`.", "question_id": 8823}
{"snippet": "connection.load_extension(path)", "intent": "This routine loads a SQLite extension from a shared library . With arguments `path`.", "question_id": 8824}
{"snippet": "connection.row_factory", "intent": "You can change this attribute to a callable that accepts the cursor and the original row as a tuple and will return the real result row.", "question_id": 8825}
{"snippet": "connection.text_factory", "intent": "Using this attribute you can control what objects are returned for the TEXT data type.", "question_id": 8826}
{"snippet": "connection.total_changes", "intent": "Returns the total number of database rows that have been modified, inserted, or deleted since the database connection was opened.", "question_id": 8827}
{"snippet": "connection.iterdump()", "intent": "Returns an iterator to dump the database in an SQL text format .", "question_id": 8828}
{"snippet": "connection.backup(target)", "intent": "This method makes a backup of a SQLite database even while it \u2019 s being accessed by other clients , or concurrently by the same connection . The copy will be written into the mandatory argument `target` , that must be another Connection instance .", "question_id": 8829}
{"snippet": "connection.backup(target, pages=0)", "intent": "This method makes a backup of a SQLite database even while it \u2019 s being accessed by other clients , or concurrently by the same connection . The copy will be written into the mandatory argument `target` , that must be another Connection instance . By default , or when `pages` is either 0 or a negative integer , the entire database is copied in a single step ; otherwise the method performs a loop copying up to pages pages at a time .", "question_id": 8830}
{"snippet": "connection.backup(target, progress=None)", "intent": "This method makes a backup of a SQLite database even while it \u2019 s being accessed by other clients , or concurrently by the same connection . The copy will be written into the mandatory argument `target` , that must be another Connection instance . If `progress` is specified , it must either be None or a callable object that will be executed at each iteration with three integer arguments , respectively the status of the last iteration , the remaining number of pages still to be copied and the total number of pages .", "question_id": 8831}
{"snippet": "connection.backup(target, name=\"main\")", "intent": "This method makes a backup of a SQLite database even while it \u2019 s being accessed by other clients , or concurrently by the same connection . The copy will be written into the mandatory argument `target` , that must be another Connection instance . The `name` argument specifies the database name that will be copied : it must be a string containing either `` main '' , the default , to indicate the main database , `` temp '' to indicate the temporary database or the name specified after the AS keyword in an ATTACH DATABASE statement for an attached database .", "question_id": 8832}
{"snippet": "connection.backup(target, sleep=0.250)", "intent": "This method makes a backup of a SQLite database even while it \u2019 s being accessed by other clients , or concurrently by the same connection . The copy will be written into the mandatory argument `target` , that must be another Connection instance . The `sleep` argument specifies the number of seconds to sleep by between successive attempts to backup remaining pages , can be specified either as an integer or a floating point value .", "question_id": 8833}
{"snippet": "connection.backup(target, pages=0, progress=None)", "intent": "This method makes a backup of a SQLite database even while it \u2019 s being accessed by other clients , or concurrently by the same connection . The copy will be written into the mandatory argument `target` , that must be another Connection instance . By default , or when `pages` is either 0 or a negative integer , the entire database is copied in a single step ; otherwise the method performs a loop copying up to pages pages at a time . If `progress` is specified , it must either be None or a callable object that will be executed at each iteration with three integer arguments , respectively the status of the last iteration , the remaining number of pages still to be copied and the total number of pages .", "question_id": 8834}
{"snippet": "connection.backup(target, pages=0, name=\"main\")", "intent": "This method makes a backup of a SQLite database even while it \u2019 s being accessed by other clients , or concurrently by the same connection . The copy will be written into the mandatory argument `target` , that must be another Connection instance . By default , or when `pages` is either 0 or a negative integer , the entire database is copied in a single step ; otherwise the method performs a loop copying up to pages pages at a time . The `name` argument specifies the database name that will be copied : it must be a string containing either `` main '' , the default , to indicate the main database , `` temp '' to indicate the temporary database or the name specified after the AS keyword in an ATTACH DATABASE statement for an attached database .", "question_id": 8835}
{"snippet": "connection.backup(target, pages=0, sleep=0.250)", "intent": "This method makes a backup of a SQLite database even while it \u2019 s being accessed by other clients , or concurrently by the same connection . The copy will be written into the mandatory argument `target` , that must be another Connection instance . By default , or when `pages` is either 0 or a negative integer , the entire database is copied in a single step ; otherwise the method performs a loop copying up to pages pages at a time . The `sleep` argument specifies the number of seconds to sleep by between successive attempts to backup remaining pages , can be specified either as an integer or a floating point value .", "question_id": 8836}
{"snippet": "connection.backup(target, progress=None, name=\"main\")", "intent": "This method makes a backup of a SQLite database even while it \u2019 s being accessed by other clients , or concurrently by the same connection . The copy will be written into the mandatory argument `target` , that must be another Connection instance . If `progress` is specified , it must either be None or a callable object that will be executed at each iteration with three integer arguments , respectively the status of the last iteration , the remaining number of pages still to be copied and the total number of pages . The `name` argument specifies the database name that will be copied : it must be a string containing either `` main '' , the default , to indicate the main database , `` temp '' to indicate the temporary database or the name specified after the AS keyword in an ATTACH DATABASE statement for an attached database .", "question_id": 8837}
{"snippet": "connection.backup(target, progress=None, sleep=0.250)", "intent": "This method makes a backup of a SQLite database even while it \u2019 s being accessed by other clients , or concurrently by the same connection . The copy will be written into the mandatory argument `target` , that must be another Connection instance . If `progress` is specified , it must either be None or a callable object that will be executed at each iteration with three integer arguments , respectively the status of the last iteration , the remaining number of pages still to be copied and the total number of pages . The `sleep` argument specifies the number of seconds to sleep by between successive attempts to backup remaining pages , can be specified either as an integer or a floating point value .", "question_id": 8838}
{"snippet": "sqlite3.Cursor", "intent": "A Cursor instance has the following attributes and methods.", "question_id": 8839}
{"snippet": "cursor.execute(sql, parameters)", "intent": "Executes an SQL statement . With arguments `sql`, `parameters`.", "question_id": 8840}
{"snippet": "cursor.execute(sql)", "intent": "Executes an SQL statement . With arguments `sql`.", "question_id": 8841}
{"snippet": "cursor.executemany(sql, seq_of_parameters)", "intent": "Executes an SQL command against all parameter sequences or mappings found in the sequence `seq_of_parameters` . With arguments `sql`.", "question_id": 8842}
{"snippet": "cursor.executescript(sql_script)", "intent": "This is a nonstandard convenience method for executing multiple SQL statements at once . `sql_script` can be an instance of str .", "question_id": 8843}
{"snippet": "cursor.fetchone()", "intent": "Fetches the next row of a query result set , returning a single sequence , or None when no more data is available .", "question_id": 8844}
{"snippet": "cursor.fetchmany()", "intent": "Fetches the next set of rows of a query result , returning a list .", "question_id": 8845}
{"snippet": "cursor.fetchmany(size=cursor.arraysize)", "intent": "Fetches the next set of rows of a query result , returning a list . The number of rows to fetch per call is specified by the `size` parameter .", "question_id": 8846}
{"snippet": "cursor.fetchall()", "intent": "Fetches all ( remaining ) rows of a query result , returning a list .", "question_id": 8847}
{"snippet": "cursor.close()", "intent": "Close the cursor now ( rather than whenever __del__ is called ) .", "question_id": 8848}
{"snippet": "cursor.rowcount", "intent": "Although the Cursor class of the sqlite3 module implements this attribute, the database engine\u2019s own support for the determination of \u201crows affected\u201d/\u201drows selected\u201d is quirky.", "question_id": 8849}
{"snippet": "cursor.lastrowid", "intent": "This read-only attribute provides the rowid of the last modified row.", "question_id": 8850}
{"snippet": "cursor.arraysize", "intent": "Read/write attribute that controls the number of rows returned by fetchmany().", "question_id": 8851}
{"snippet": "cursor.description", "intent": "This read-only attribute provides the column names of the last query.", "question_id": 8852}
{"snippet": "cursor.connection", "intent": "This read-only attribute provides the SQLite database Connection used by the Cursor object.", "question_id": 8853}
{"snippet": "sqlite3.Row", "intent": "A Row instance serves as a highly optimized row_factory for Connection objects.", "question_id": 8854}
{"snippet": "row.keys()", "intent": "This method returns a list of column names .", "question_id": 8855}
{"snippet": "sqlite3.Warning", "intent": "A subclass of Exception.", "question_id": 8856}
{"snippet": "sqlite3.Error", "intent": "The base class of the other exceptions in this module.", "question_id": 8857}
{"snippet": "sqlite3.DatabaseError", "intent": "Exception raised for errors that are related to the database.", "question_id": 8858}
{"snippet": "sqlite3.IntegrityError", "intent": "Exception raised when the relational integrity of the database is affected, e.g.", "question_id": 8859}
{"snippet": "sqlite3.ProgrammingError", "intent": "Exception raised for programming errors, e.g.", "question_id": 8860}
{"snippet": "sqlite3.OperationalError", "intent": "Exception raised for errors that are related to the database\u2019s operation and not necessarily under the control of the programmer, e.g.", "question_id": 8861}
{"snippet": "sqlite3.NotSupportedError", "intent": "Exception raised in case a method or database API was used which is not supported by the database, e.g.", "question_id": 8862}
{"snippet": "ssl.create_default_context()", "intent": "Return a new SSLContext object with default settings for the given `purpose` .", "question_id": 8863}
{"snippet": "ssl.create_default_context(purpose=Purpose.SERVER_AUTH)", "intent": "Return a new SSLContext object with default settings for the given `purpose` .", "question_id": 8864}
{"snippet": "ssl.create_default_context(cafile=None)", "intent": "Return a new SSLContext object with default settings for the given `purpose` . `cafile` , `capath` , `cadata` represent optional CA certificates to trust for certificate verification , as in SSLContext.load_verify_locations ( ) .", "question_id": 8865}
{"snippet": "ssl.create_default_context(capath=None)", "intent": "Return a new SSLContext object with default settings for the given `purpose` . `cafile` , `capath` , `cadata` represent optional CA certificates to trust for certificate verification , as in SSLContext.load_verify_locations ( ) .", "question_id": 8866}
{"snippet": "ssl.create_default_context(cadata=None)", "intent": "Return a new SSLContext object with default settings for the given `purpose` . `cafile` , `capath` , `cadata` represent optional CA certificates to trust for certificate verification , as in SSLContext.load_verify_locations ( ) .", "question_id": 8867}
{"snippet": "ssl.create_default_context(purpose=Purpose.SERVER_AUTH, cafile=None)", "intent": "Return a new SSLContext object with default settings for the given `purpose` . `cafile` , `capath` , `cadata` represent optional CA certificates to trust for certificate verification , as in SSLContext.load_verify_locations ( ) .", "question_id": 8868}
{"snippet": "ssl.create_default_context(purpose=Purpose.SERVER_AUTH, capath=None)", "intent": "Return a new SSLContext object with default settings for the given `purpose` . `cafile` , `capath` , `cadata` represent optional CA certificates to trust for certificate verification , as in SSLContext.load_verify_locations ( ) .", "question_id": 8869}
{"snippet": "ssl.create_default_context(purpose=Purpose.SERVER_AUTH, cadata=None)", "intent": "Return a new SSLContext object with default settings for the given `purpose` . `cafile` , `capath` , `cadata` represent optional CA certificates to trust for certificate verification , as in SSLContext.load_verify_locations ( ) .", "question_id": 8870}
{"snippet": "ssl.create_default_context(cafile=None, capath=None)", "intent": "Return a new SSLContext object with default settings for the given `purpose` . `cafile` , `capath` , `cadata` represent optional CA certificates to trust for certificate verification , as in SSLContext.load_verify_locations ( ) .", "question_id": 8871}
{"snippet": "ssl.create_default_context(cafile=None, cadata=None)", "intent": "Return a new SSLContext object with default settings for the given `purpose` . `cafile` , `capath` , `cadata` represent optional CA certificates to trust for certificate verification , as in SSLContext.load_verify_locations ( ) .", "question_id": 8872}
{"snippet": "ssl.SSLError", "intent": "Raised to signal an error from the underlying SSL implementation (currently provided by the OpenSSL library).", "question_id": 8873}
{"snippet": "row.library", "intent": "A string mnemonic designating the OpenSSL submodule in which the error occurred, such as SSL, PEM or X509.", "question_id": 8874}
{"snippet": "row.reason", "intent": "A string mnemonic designating the reason this error occurred, for example CERTIFICATE_VERIFY_FAILED.", "question_id": 8875}
{"snippet": "ssl.SSLZeroReturnError", "intent": "A subclass of SSLError raised when trying to read or write and the SSL connection has been closed cleanly.", "question_id": 8876}
{"snippet": "ssl.SSLWantReadError", "intent": "A subclass of SSLError raised by a non-blocking SSL socket when trying to read or write data, but more data needs to be received on the underlying TCP transport before the request can be fulfilled.", "question_id": 8877}
{"snippet": "ssl.SSLWantWriteError", "intent": "A subclass of SSLError raised by a non-blocking SSL socket when trying to read or write data, but more data needs to be sent on the underlying TCP transport before the request can be fulfilled.", "question_id": 8878}
{"snippet": "ssl.SSLSyscallError", "intent": "A subclass of SSLError raised when a system error was encountered while trying to fulfill an operation on a SSL socket.", "question_id": 8879}
{"snippet": "ssl.SSLEOFError", "intent": "A subclass of SSLError raised when the SSL connection has been terminated abruptly.", "question_id": 8880}
{"snippet": "ssl.SSLCertVerificationError", "intent": "A subclass of SSLError raised when certificate validation has failed.", "question_id": 8881}
{"snippet": "row.verify_code", "intent": "A numeric error number that denotes the verification error.", "question_id": 8882}
{"snippet": "row.verify_message", "intent": "A human readable string of the verification error.", "question_id": 8883}
{"snippet": "ssl.CertificateError", "intent": "An alias for SSLCertVerificationError.", "question_id": 8884}
{"snippet": "ssl.RAND_bytes(num)", "intent": "Return `num` cryptographically strong pseudo-random bytes .", "question_id": 8885}
{"snippet": "ssl.RAND_pseudo_bytes(num)", "intent": "Return ( bytes , is_cryptographic ) : bytes are `num` pseudo-random bytes , is_cryptographic is True if the bytes generated are cryptographically strong .", "question_id": 8886}
{"snippet": "ssl.RAND_status()", "intent": "Return True if the SSL pseudo-random number generator has been seeded with \u2018 enough \u2019 randomness , and False otherwise .", "question_id": 8887}
{"snippet": "ssl.RAND_egd(path)", "intent": "If you are running an entropy-gathering daemon ( EGD ) somewhere , and `path` is the pathname of a socket connection open to it , this will read 256 bytes of randomness from the socket , and add it to the SSL pseudo-random number generator to increase the security of generated secret keys .", "question_id": 8888}
{"snippet": "ssl.RAND_add(bytes, entropy)", "intent": "Mix the given `bytes` into the SSL pseudo-random number generator . The parameter `entropy` ( a float ) is a lower bound on the entropy contained in string ( so you can always use 0.0 ) .", "question_id": 8889}
{"snippet": "ssl.match_hostname(cert, hostname)", "intent": "Verify that `cert` ( in decoded format as returned by SSLSocket.getpeercert ( ) ) matches the given `hostname` .", "question_id": 8890}
{"snippet": "ssl.cert_time_to_seconds(cert_time)", "intent": "Return the time in seconds since the Epoch , given the `cert_time` string representing the \u201c notBefore \u201d or \u201c notAfter \u201d date from a certificate in `` % b % d % H : % M : % S % Y % Z '' strptime format ( C locale ) .", "question_id": 8891}
{"snippet": "ssl.get_server_certificate(addr)", "intent": "Given the address `addr` of an SSL-protected server , as a ( hostname , port-number ) pair , fetches the server \u2019 s certificate , and returns it as a PEM-encoded string .", "question_id": 8892}
{"snippet": "ssl.get_server_certificate(addr, ssl_version=PROTOCOL_TLS)", "intent": "Given the address `addr` of an SSL-protected server , as a ( hostname , port-number ) pair , fetches the server \u2019 s certificate , and returns it as a PEM-encoded string . If `ssl_version` is specified , uses that version of the SSL protocol to attempt to connect to the server .", "question_id": 8893}
{"snippet": "ssl.get_server_certificate(addr, ca_certs=None)", "intent": "Given the address `addr` of an SSL-protected server , as a ( hostname , port-number ) pair , fetches the server \u2019 s certificate , and returns it as a PEM-encoded string . If `ca_certs` is specified , it should be a file containing a list of root certificates , the same format as used for the same parameter in SSLContext.wrap_socket ( ) .", "question_id": 8894}
{"snippet": "ssl.get_server_certificate(addr, ssl_version=PROTOCOL_TLS, ca_certs=None)", "intent": "Given the address `addr` of an SSL-protected server , as a ( hostname , port-number ) pair , fetches the server \u2019 s certificate , and returns it as a PEM-encoded string . If `ssl_version` is specified , uses that version of the SSL protocol to attempt to connect to the server . If `ca_certs` is specified , it should be a file containing a list of root certificates , the same format as used for the same parameter in SSLContext.wrap_socket ( ) .", "question_id": 8895}
{"snippet": "ssl.DER_cert_to_PEM_cert(DER_cert_bytes)", "intent": "Given a certificate as a DER-encoded blob of bytes , returns a PEM-encoded string version of the same certificate . With arguments `DER_cert_bytes`.", "question_id": 8896}
{"snippet": "ssl.PEM_cert_to_DER_cert(PEM_cert_string)", "intent": "Given a certificate as an ASCII PEM string , returns a DER-encoded sequence of bytes for that same certificate . With arguments `PEM_cert_string`.", "question_id": 8897}
{"snippet": "ssl.get_default_verify_paths()", "intent": "Returns a named tuple with paths to OpenSSL \u2019 s default cafile and capath .", "question_id": 8898}
{"snippet": "ssl.enum_certificates(store_name)", "intent": "Retrieve certificates from Windows \u2019 system cert store . `store_name` may be one of CA , ROOT or MY .", "question_id": 8899}
{"snippet": "ssl.enum_crls(store_name)", "intent": "Retrieve CRLs from Windows \u2019 system cert store . `store_name` may be one of CA , ROOT or MY .", "question_id": 8900}
{"snippet": "ssl.wrap_socket(sock)", "intent": "Takes an instance `sock` of socket.socket , and returns an instance of ssl.SSLSocket , a subtype of socket.socket , which wraps the underlying socket in an SSL context .", "question_id": 8901}
{"snippet": "ssl.wrap_socket(sock, keyfile=None)", "intent": "Takes an instance `sock` of socket.socket , and returns an instance of ssl.SSLSocket , a subtype of socket.socket , which wraps the underlying socket in an SSL context . If parameters `keyfile` , `certfile` , `ca_certs` or `ciphers` are set , then the values are passed to SSLContext.load_cert_chain ( ) , SSLContext.load_verify_locations ( ) , and SSLContext.set_ciphers ( ) .", "question_id": 8902}
{"snippet": "ssl.wrap_socket(sock, certfile=None)", "intent": "Takes an instance `sock` of socket.socket , and returns an instance of ssl.SSLSocket , a subtype of socket.socket , which wraps the underlying socket in an SSL context . If parameters `keyfile` , `certfile` , `ca_certs` or `ciphers` are set , then the values are passed to SSLContext.load_cert_chain ( ) , SSLContext.load_verify_locations ( ) , and SSLContext.set_ciphers ( ) .", "question_id": 8903}
{"snippet": "ssl.wrap_socket(sock, server_side=False)", "intent": "Takes an instance `sock` of socket.socket , and returns an instance of ssl.SSLSocket , a subtype of socket.socket , which wraps the underlying socket in an SSL context . The arguments `server_side` , `do_handshake_on_connect` , and `suppress_ragged_eofs` have the same meaning as SSLContext.wrap_socket ( ) .", "question_id": 8904}
{"snippet": "ssl.wrap_socket(sock, cert_reqs=CERT_NONE)", "intent": "Takes an instance `sock` of socket.socket , and returns an instance of ssl.SSLSocket , a subtype of socket.socket , which wraps the underlying socket in an SSL context . Internally , function creates a SSLContext with protocol `ssl_version` and SSLContext.options set to `cert_reqs` .", "question_id": 8905}
{"snippet": "ssl.wrap_socket(sock, ssl_version=PROTOCOL_TLS)", "intent": "Takes an instance `sock` of socket.socket , and returns an instance of ssl.SSLSocket , a subtype of socket.socket , which wraps the underlying socket in an SSL context . Internally , function creates a SSLContext with protocol `ssl_version` and SSLContext.options set to `cert_reqs` .", "question_id": 8906}
{"snippet": "ssl.wrap_socket(sock, ca_certs=None)", "intent": "Takes an instance `sock` of socket.socket , and returns an instance of ssl.SSLSocket , a subtype of socket.socket , which wraps the underlying socket in an SSL context . If parameters `keyfile` , `certfile` , `ca_certs` or `ciphers` are set , then the values are passed to SSLContext.load_cert_chain ( ) , SSLContext.load_verify_locations ( ) , and SSLContext.set_ciphers ( ) .", "question_id": 8907}
{"snippet": "ssl.wrap_socket(sock, do_handshake_on_connect=True)", "intent": "Takes an instance `sock` of socket.socket , and returns an instance of ssl.SSLSocket , a subtype of socket.socket , which wraps the underlying socket in an SSL context . The arguments `server_side` , `do_handshake_on_connect` , and `suppress_ragged_eofs` have the same meaning as SSLContext.wrap_socket ( ) .", "question_id": 8908}
{"snippet": "ssl.wrap_socket(sock, suppress_ragged_eofs=True)", "intent": "Takes an instance `sock` of socket.socket , and returns an instance of ssl.SSLSocket , a subtype of socket.socket , which wraps the underlying socket in an SSL context . The arguments `server_side` , `do_handshake_on_connect` , and `suppress_ragged_eofs` have the same meaning as SSLContext.wrap_socket ( ) .", "question_id": 8909}
{"snippet": "ssl.wrap_socket(sock, ciphers=None)", "intent": "Takes an instance `sock` of socket.socket , and returns an instance of ssl.SSLSocket , a subtype of socket.socket , which wraps the underlying socket in an SSL context . If parameters `keyfile` , `certfile` , `ca_certs` or `ciphers` are set , then the values are passed to SSLContext.load_cert_chain ( ) , SSLContext.load_verify_locations ( ) , and SSLContext.set_ciphers ( ) .", "question_id": 8910}
{"snippet": "ssl.CERT_NONE", "intent": "Possible value for SSLContext.verify_mode, or the cert_reqs parameter to wrap_socket().", "question_id": 8911}
{"snippet": "ssl.CERT_OPTIONAL", "intent": "Possible value for SSLContext.verify_mode, or the cert_reqs parameter to wrap_socket().", "question_id": 8912}
{"snippet": "ssl.CERT_REQUIRED", "intent": "Possible value for SSLContext.verify_mode, or the cert_reqs parameter to wrap_socket().", "question_id": 8913}
{"snippet": "ssl.VerifyMode", "intent": "enum.IntEnum collection of CERT_* constants.", "question_id": 8914}
{"snippet": "ssl.VERIFY_DEFAULT", "intent": "Possible value for SSLContext.verify_flags.", "question_id": 8915}
{"snippet": "ssl.VERIFY_CRL_CHECK_LEAF", "intent": "Possible value for SSLContext.verify_flags.", "question_id": 8916}
{"snippet": "ssl.VERIFY_CRL_CHECK_CHAIN", "intent": "Possible value for SSLContext.verify_flags.", "question_id": 8917}
{"snippet": "ssl.VERIFY_X509_STRICT", "intent": "Possible value for SSLContext.verify_flags to disable workarounds for broken X.509 certificates.", "question_id": 8918}
{"snippet": "ssl.VERIFY_X509_TRUSTED_FIRST", "intent": "Possible value for SSLContext.verify_flags.", "question_id": 8919}
{"snippet": "ssl.VerifyFlags", "intent": "enum.IntFlag collection of VERIFY_* constants.", "question_id": 8920}
{"snippet": "ssl.PROTOCOL_TLS", "intent": "Selects the highest protocol version that both the client and server support.", "question_id": 8921}
{"snippet": "ssl.PROTOCOL_TLS_CLIENT", "intent": "Auto-negotiate the highest protocol version like PROTOCOL_TLS, but only support client-side SSLSocket connections.", "question_id": 8922}
{"snippet": "ssl.PROTOCOL_TLS_SERVER", "intent": "Auto-negotiate the highest protocol version like PROTOCOL_TLS, but only support server-side SSLSocket connections.", "question_id": 8923}
{"snippet": "ssl.PROTOCOL_SSLv23", "intent": "Alias for PROTOCOL_TLS.", "question_id": 8924}
{"snippet": "ssl.PROTOCOL_SSLv2", "intent": "Selects SSL version 2 as the channel encryption protocol.", "question_id": 8925}
{"snippet": "ssl.PROTOCOL_SSLv3", "intent": "Selects SSL version 3 as the channel encryption protocol.", "question_id": 8926}
{"snippet": "ssl.PROTOCOL_TLSv1", "intent": "Selects TLS version 1.0 as the channel encryption protocol.", "question_id": 8927}
{"snippet": "ssl.PROTOCOL_TLSv1_1", "intent": "Selects TLS version 1.1 as the channel encryption protocol.", "question_id": 8928}
{"snippet": "ssl.PROTOCOL_TLSv1_2", "intent": "Selects TLS version 1.2 as the channel encryption protocol.", "question_id": 8929}
{"snippet": "ssl.OP_ALL", "intent": "Enables workarounds for various bugs present in other SSL implementations.", "question_id": 8930}
{"snippet": "ssl.OP_NO_SSLv2", "intent": "Prevents an SSLv2 connection.", "question_id": 8931}
{"snippet": "ssl.OP_NO_SSLv3", "intent": "Prevents an SSLv3 connection.", "question_id": 8932}
{"snippet": "ssl.OP_NO_TLSv1", "intent": "Prevents a TLSv1 connection.", "question_id": 8933}
{"snippet": "ssl.OP_NO_TLSv1_1", "intent": "Prevents a TLSv1.1 connection.", "question_id": 8934}
{"snippet": "ssl.OP_NO_TLSv1_2", "intent": "Prevents a TLSv1.2 connection.", "question_id": 8935}
{"snippet": "ssl.OP_NO_TLSv1_3", "intent": "Prevents a TLSv1.3 connection.", "question_id": 8936}
{"snippet": "ssl.OP_NO_RENEGOTIATION", "intent": "Disable all renegotiation in TLSv1.2 and earlier.", "question_id": 8937}
{"snippet": "ssl.OP_CIPHER_SERVER_PREFERENCE", "intent": "Use the server\u2019s cipher ordering preference, rather than the client\u2019s.", "question_id": 8938}
{"snippet": "ssl.OP_SINGLE_DH_USE", "intent": "Prevents re-use of the same DH key for distinct SSL sessions.", "question_id": 8939}
{"snippet": "ssl.OP_SINGLE_ECDH_USE", "intent": "Prevents re-use of the same ECDH key for distinct SSL sessions.", "question_id": 8940}
{"snippet": "ssl.OP_ENABLE_MIDDLEBOX_COMPAT", "intent": "Send dummy Change Cipher Spec (CCS) messages in TLS 1.3 handshake to make a TLS 1.3 connection look more like a TLS 1.2 connection.", "question_id": 8941}
{"snippet": "ssl.OP_NO_COMPRESSION", "intent": "Disable compression on the SSL channel.", "question_id": 8942}
{"snippet": "ssl.Options", "intent": "enum.IntFlag collection of OP_* constants.", "question_id": 8943}
{"snippet": "ssl.OP_NO_TICKET", "intent": "Prevent client side from requesting a session ticket.", "question_id": 8944}
{"snippet": "ssl.HAS_ALPN", "intent": "Whether the OpenSSL library has built-in support for the Application-Layer Protocol Negotiation TLS extension as described in RFC 7301.", "question_id": 8945}
{"snippet": "ssl.HAS_NEVER_CHECK_COMMON_NAME", "intent": "Whether the OpenSSL library has built-in support not checking subject common name and SSLContext.hostname_checks_common_name is writeable.", "question_id": 8946}
{"snippet": "ssl.HAS_ECDH", "intent": "Whether the OpenSSL library has built-in support for the Elliptic Curve-based Diffie-Hellman key exchange.", "question_id": 8947}
{"snippet": "ssl.HAS_SNI", "intent": "Whether the OpenSSL library has built-in support for the Server Name Indication extension (as defined in RFC 6066).", "question_id": 8948}
{"snippet": "ssl.HAS_NPN", "intent": "Whether the OpenSSL library has built-in support for the Next Protocol Negotiation as described in the Application Layer Protocol Negotiation.", "question_id": 8949}
{"snippet": "ssl.HAS_SSLv2", "intent": "Whether the OpenSSL library has built-in support for the SSL 2.0 protocol.", "question_id": 8950}
{"snippet": "ssl.HAS_SSLv3", "intent": "Whether the OpenSSL library has built-in support for the SSL 3.0 protocol.", "question_id": 8951}
{"snippet": "ssl.HAS_TLSv1", "intent": "Whether the OpenSSL library has built-in support for the TLS 1.0 protocol.", "question_id": 8952}
{"snippet": "ssl.HAS_TLSv1_1", "intent": "Whether the OpenSSL library has built-in support for the TLS 1.1 protocol.", "question_id": 8953}
{"snippet": "ssl.HAS_TLSv1_2", "intent": "Whether the OpenSSL library has built-in support for the TLS 1.2 protocol.", "question_id": 8954}
{"snippet": "ssl.HAS_TLSv1_3", "intent": "Whether the OpenSSL library has built-in support for the TLS 1.3 protocol.", "question_id": 8955}
{"snippet": "ssl.CHANNEL_BINDING_TYPES", "intent": "List of supported TLS channel binding types.", "question_id": 8956}
{"snippet": "ssl.OPENSSL_VERSION", "intent": "The version string of the OpenSSL library loaded by the interpreter:", "question_id": 8957}
{"snippet": "ssl.OPENSSL_VERSION_INFO", "intent": "A tuple of five integers representing version information about the OpenSSL library:", "question_id": 8958}
{"snippet": "ssl.OPENSSL_VERSION_NUMBER", "intent": "The raw version number of the OpenSSL library, as a single integer:", "question_id": 8959}
{"snippet": "ssl.ALERT_DESCRIPTION_HANDSHAKE_FAILURE", "intent": "Alert Descriptions from RFC 5246 and others.", "question_id": 8960}
{"snippet": "ssl.ALERT_DESCRIPTION_INTERNAL_ERROR", "intent": "Alert Descriptions from RFC 5246 and others.", "question_id": 8961}
{"snippet": "ALERT_DESCRIPTION_*", "intent": "Alert Descriptions from RFC 5246 and others.", "question_id": 8962}
{"snippet": "ssl.AlertDescription", "intent": "enum.IntEnum collection of ALERT_DESCRIPTION_* constants.", "question_id": 8963}
{"snippet": "Purpose.SERVER_AUTH", "intent": "Option for create_default_context() and SSLContext.load_default_certs().", "question_id": 8964}
{"snippet": "Purpose.CLIENT_AUTH", "intent": "Option for create_default_context() and SSLContext.load_default_certs().", "question_id": 8965}
{"snippet": "ssl.SSLErrorNumber", "intent": "enum.IntEnum collection of SSL_ERROR_* constants.", "question_id": 8966}
{"snippet": "ssl.TLSVersion", "intent": "enum.IntEnum collection of SSL and TLS versions for SSLContext.maximum_version and SSLContext.minimum_version.", "question_id": 8967}
{"snippet": "TLSVersion.MAXIMUM_SUPPORTED", "intent": "The minimum or maximum supported SSL or TLS version.", "question_id": 8968}
{"snippet": "TLSVersion.TLSv1_3", "intent": "SSL 3.0 to TLS 1.3.", "question_id": 8969}
{"snippet": "ssl.SSLSocket(socket.socket)", "intent": "SSL sockets provide the following methods of Socket Objects : With arguments `socket.socket`.", "question_id": 8970}
{"snippet": "SSLSocket.read()", "intent": "Read up to `len` bytes of data from the SSL socket and return the result as a bytes instance .", "question_id": 8971}
{"snippet": "SSLSocket.read(len=1024)", "intent": "Read up to `len` bytes of data from the SSL socket and return the result as a bytes instance .", "question_id": 8972}
{"snippet": "SSLSocket.read(buffer=None)", "intent": "Read up to `len` bytes of data from the SSL socket and return the result as a bytes instance . If `buffer` is specified , then read into the buffer instead , and return the number of bytes read .", "question_id": 8973}
{"snippet": "SSLSocket.read(len=1024, buffer=None)", "intent": "Read up to `len` bytes of data from the SSL socket and return the result as a bytes instance . If `buffer` is specified , then read into the buffer instead , and return the number of bytes read .", "question_id": 8974}
{"snippet": "SSLSocket.write(buf)", "intent": "Write `buf` to the SSL socket and return the number of bytes written .", "question_id": 8975}
{"snippet": "SSLSocket.do_handshake()", "intent": "Perform the SSL setup handshake .", "question_id": 8976}
{"snippet": "SSLSocket.getpeercert()", "intent": "If there is no certificate for the peer on the other end of the connection , return None .", "question_id": 8977}
{"snippet": "SSLSocket.getpeercert(binary_form=False)", "intent": "If there is no certificate for the peer on the other end of the connection , return None . If the `binary_form` parameter is False , and a certificate was received from the peer , this method returns a dict instance .", "question_id": 8978}
{"snippet": "SSLSocket.cipher()", "intent": "Returns a three-value tuple containing the name of the cipher being used , the version of the SSL protocol that defines its use , and the number of secret bits being used .", "question_id": 8979}
{"snippet": "SSLSocket.shared_ciphers()", "intent": "Return the list of ciphers shared by the client during the handshake .", "question_id": 8980}
{"snippet": "SSLSocket.compression()", "intent": "Return the compression algorithm being used as a string , or None if the connection isn \u2019 t compressed .", "question_id": 8981}
{"snippet": "SSLSocket.get_channel_binding()", "intent": "Get channel binding data for current connection , as a bytes object .", "question_id": 8982}
{"snippet": "SSLSocket.get_channel_binding(cb_type=\"tls-unique\")", "intent": "Get channel binding data for current connection , as a bytes object . The `cb_type` parameter allow selection of the desired channel binding type .", "question_id": 8983}
{"snippet": "SSLSocket.selected_alpn_protocol()", "intent": "Return the protocol that was selected during the TLS handshake .", "question_id": 8984}
{"snippet": "SSLSocket.selected_npn_protocol()", "intent": "Return the higher-level protocol that was selected during the TLS/SSL handshake .", "question_id": 8985}
{"snippet": "SSLSocket.unwrap()", "intent": "Performs the SSL shutdown handshake , which removes the TLS layer from the underlying socket , and returns the underlying socket object .", "question_id": 8986}
{"snippet": "SSLSocket.verify_client_post_handshake()", "intent": "Requests post-handshake authentication ( PHA ) from a TLS 1.3 client .", "question_id": 8987}
{"snippet": "SSLSocket.version()", "intent": "Return the actual SSL protocol version negotiated by the connection as a string , or None is no secure connection is established .", "question_id": 8988}
{"snippet": "SSLSocket.pending()", "intent": "Returns the number of already decrypted bytes available for read , pending on the connection .", "question_id": 8989}
{"snippet": "SSLSocket.context", "intent": "The SSLContext object this SSL socket is tied to.", "question_id": 8990}
{"snippet": "SSLSocket.server_side", "intent": "A boolean which is True for server-side sockets and False for client-side sockets.", "question_id": 8991}
{"snippet": "SSLSocket.server_hostname", "intent": "Hostname of the server: str type, or None for server-side socket or if the hostname was not specified in the constructor.", "question_id": 8992}
{"snippet": "SSLSocket.session", "intent": "The SSLSession for this SSL connection.", "question_id": 8993}
{"snippet": "ssl.SSLContext()", "intent": "Create a new SSL context .", "question_id": 8994}
{"snippet": "ssl.SSLContext(protocol=PROTOCOL_TLS)", "intent": "Create a new SSL context . You may pass `protocol` which must be one of the PROTOCOL_* constants defined in this module .", "question_id": 8995}
{"snippet": "SSLContext.cert_store_stats()", "intent": "Get statistics about quantities of loaded X.509 certificates , count of X.509 certificates flagged as CA certificates and certificate revocation lists as dictionary .", "question_id": 8996}
{"snippet": "SSLContext.load_cert_chain(certfile)", "intent": "Load a private key and the corresponding certificate . The `certfile` string must be the path to a single file in PEM format containing the certificate as well as any number of CA certificates needed to establish the certificate \u2019 s authenticity .", "question_id": 8997}
{"snippet": "SSLContext.load_cert_chain(certfile, keyfile=None)", "intent": "Load a private key and the corresponding certificate . The `certfile` string must be the path to a single file in PEM format containing the certificate as well as any number of CA certificates needed to establish the certificate \u2019 s authenticity . The `keyfile` string , if present , must point to a file containing the private key in .", "question_id": 8998}
{"snippet": "SSLContext.load_cert_chain(certfile, password=None)", "intent": "Load a private key and the corresponding certificate . The `certfile` string must be the path to a single file in PEM format containing the certificate as well as any number of CA certificates needed to establish the certificate \u2019 s authenticity . The `password` argument may be a function to call to get the password for decrypting the private key .", "question_id": 8999}
{"snippet": "SSLContext.load_cert_chain(certfile, keyfile=None, password=None)", "intent": "Load a private key and the corresponding certificate . The `certfile` string must be the path to a single file in PEM format containing the certificate as well as any number of CA certificates needed to establish the certificate \u2019 s authenticity . The `keyfile` string , if present , must point to a file containing the private key in . The `password` argument may be a function to call to get the password for decrypting the private key .", "question_id": 9000}
{"snippet": "SSLContext.load_default_certs()", "intent": "Load a set of default \u201c certification authority \u201d ( CA ) certificates from default locations .", "question_id": 9001}
{"snippet": "SSLContext.load_default_certs(purpose=Purpose.SERVER_AUTH)", "intent": "Load a set of default \u201c certification authority \u201d ( CA ) certificates from default locations . The `purpose` flag specifies what kind of CA certificates are loaded .", "question_id": 9002}
{"snippet": "SSLContext.load_verify_locations()", "intent": "Load a set of \u201c certification authority \u201d ( CA ) certificates used to validate other peers \u2019 certificates when verify_mode is other than CERT_NONE .", "question_id": 9003}
{"snippet": "SSLContext.load_verify_locations(cafile=None)", "intent": "Load a set of \u201c certification authority \u201d ( CA ) certificates used to validate other peers \u2019 certificates when verify_mode is other than CERT_NONE . At least one of `cafile` or `capath` must be specified .", "question_id": 9004}
{"snippet": "SSLContext.load_verify_locations(capath=None)", "intent": "Load a set of \u201c certification authority \u201d ( CA ) certificates used to validate other peers \u2019 certificates when verify_mode is other than CERT_NONE . At least one of `cafile` or `capath` must be specified .", "question_id": 9005}
{"snippet": "SSLContext.load_verify_locations(cadata=None)", "intent": "Load a set of \u201c certification authority \u201d ( CA ) certificates used to validate other peers \u2019 certificates when verify_mode is other than CERT_NONE . The `cadata` object , if present , is either an ASCII string of one or more PEM-encoded certificates or a bytes-like object of DER-encoded certificates .", "question_id": 9006}
{"snippet": "SSLContext.load_verify_locations(cafile=None, capath=None)", "intent": "Load a set of \u201c certification authority \u201d ( CA ) certificates used to validate other peers \u2019 certificates when verify_mode is other than CERT_NONE . At least one of `cafile` or `capath` must be specified .", "question_id": 9007}
{"snippet": "SSLContext.load_verify_locations(cafile=None, cadata=None)", "intent": "Load a set of \u201c certification authority \u201d ( CA ) certificates used to validate other peers \u2019 certificates when verify_mode is other than CERT_NONE . At least one of `cafile` or `capath` must be specified . The `cadata` object , if present , is either an ASCII string of one or more PEM-encoded certificates or a bytes-like object of DER-encoded certificates .", "question_id": 9008}
{"snippet": "SSLContext.load_verify_locations(capath=None, cadata=None)", "intent": "Load a set of \u201c certification authority \u201d ( CA ) certificates used to validate other peers \u2019 certificates when verify_mode is other than CERT_NONE . At least one of `cafile` or `capath` must be specified . The `cadata` object , if present , is either an ASCII string of one or more PEM-encoded certificates or a bytes-like object of DER-encoded certificates .", "question_id": 9009}
{"snippet": "SSLContext.load_verify_locations(cafile=None, capath=None, cadata=None)", "intent": "Load a set of \u201c certification authority \u201d ( CA ) certificates used to validate other peers \u2019 certificates when verify_mode is other than CERT_NONE . At least one of `cafile` or `capath` must be specified . The `cadata` object , if present , is either an ASCII string of one or more PEM-encoded certificates or a bytes-like object of DER-encoded certificates .", "question_id": 9010}
{"snippet": "SSLContext.get_ca_certs()", "intent": "Get a list of loaded \u201c certification authority \u201d ( CA ) certificates .", "question_id": 9011}
{"snippet": "SSLContext.get_ca_certs(binary_form=False)", "intent": "Get a list of loaded \u201c certification authority \u201d ( CA ) certificates . If the `binary_form` parameter is False each list entry is a dict like the output of SSLSocket.getpeercert ( ) .", "question_id": 9012}
{"snippet": "SSLContext.get_ciphers()", "intent": "Get a list of enabled ciphers .", "question_id": 9013}
{"snippet": "SSLContext.set_default_verify_paths()", "intent": "Load a set of default \u201c certification authority \u201d ( CA ) certificates from a filesystem path defined when building the OpenSSL library .", "question_id": 9014}
{"snippet": "SSLContext.set_ciphers(ciphers)", "intent": "Set the available `ciphers` for sockets created with this context .", "question_id": 9015}
{"snippet": "SSLContext.set_alpn_protocols(protocols)", "intent": "Specify which `protocols` the socket should advertise during the SSL/TLS handshake .", "question_id": 9016}
{"snippet": "SSLContext.set_npn_protocols(protocols)", "intent": "Specify which `protocols` the socket should advertise during the SSL/TLS handshake .", "question_id": 9017}
{"snippet": "SSLContext.sni_callback", "intent": "Register a callback function that will be called after the TLS Client Hello handshake message has been received by the SSL/TLS server when the TLS client specifies a server name indication.", "question_id": 9018}
{"snippet": "SSLContext.set_servername_callback(server_name_callback)", "intent": "This is a legacy API retained for backwards compatibility . The given `server_name_callback` is similar to sni_callback , except that when the server hostname is an IDN-encoded internationalized domain name , the server_name_callback receives a decoded U-label ( `` pyth\u00f6n.org '' ) .", "question_id": 9019}
{"snippet": "SSLContext.load_dh_params(dhfile)", "intent": "Load the key generation parameters for Diffie-Hellman ( DH ) key exchange . The `dhfile` parameter should be the path to a file containing DH parameters in PEM format .", "question_id": 9020}
{"snippet": "SSLContext.set_ecdh_curve(curve_name)", "intent": "Set the curve name for Elliptic Curve-based Diffie-Hellman ( ECDH ) key exchange . The `curve_name` parameter should be a string describing a well-known elliptic curve , for example prime256v1 for a widely supported curve .", "question_id": 9021}
{"snippet": "SSLContext.wrap_socket(sock)", "intent": "Wrap an existing Python socket `sock` and return an instance of SSLContext.sslsocket_class ( default SSLSocket ) .", "question_id": 9022}
{"snippet": "SSLContext.wrap_socket(sock, server_side=False)", "intent": "Wrap an existing Python socket `sock` and return an instance of SSLContext.sslsocket_class ( default SSLSocket ) . The parameter `server_side` is a boolean which identifies whether server-side or client-side behavior is desired from this socket .", "question_id": 9023}
{"snippet": "SSLContext.wrap_socket(sock, do_handshake_on_connect=True)", "intent": "Wrap an existing Python socket `sock` and return an instance of SSLContext.sslsocket_class ( default SSLSocket ) . The parameter `do_handshake_on_connect` specifies whether to do the SSL handshake automatically after doing a socket.connect ( ) , or whether the application program will call it explicitly , by invoking the SSLSocket.do_handshake ( ) method .", "question_id": 9024}
{"snippet": "SSLContext.wrap_socket(sock, suppress_ragged_eofs=True)", "intent": "Wrap an existing Python socket `sock` and return an instance of SSLContext.sslsocket_class ( default SSLSocket ) . The parameter `suppress_ragged_eofs` specifies how the SSLSocket.recv ( ) method should signal unexpected EOF from the other end of the connection .", "question_id": 9025}
{"snippet": "SSLContext.wrap_socket(sock, server_hostname=None)", "intent": "Wrap an existing Python socket `sock` and return an instance of SSLContext.sslsocket_class ( default SSLSocket ) . On client connections , the optional parameter `server_hostname` specifies the hostname of the service which we are connecting to .", "question_id": 9026}
{"snippet": "SSLContext.wrap_socket(sock, session=None)", "intent": "Wrap an existing Python socket `sock` and return an instance of SSLContext.sslsocket_class ( default SSLSocket ) . `session` , see session .", "question_id": 9027}
{"snippet": "SSLContext.wrap_socket(sock, server_side=False, do_handshake_on_connect=True)", "intent": "Wrap an existing Python socket `sock` and return an instance of SSLContext.sslsocket_class ( default SSLSocket ) . The parameter `server_side` is a boolean which identifies whether server-side or client-side behavior is desired from this socket . The parameter `do_handshake_on_connect` specifies whether to do the SSL handshake automatically after doing a socket.connect ( ) , or whether the application program will call it explicitly , by invoking the SSLSocket.do_handshake ( ) method .", "question_id": 9028}
{"snippet": "SSLContext.wrap_socket(sock, server_side=False, suppress_ragged_eofs=True)", "intent": "Wrap an existing Python socket `sock` and return an instance of SSLContext.sslsocket_class ( default SSLSocket ) . The parameter `server_side` is a boolean which identifies whether server-side or client-side behavior is desired from this socket . The parameter `suppress_ragged_eofs` specifies how the SSLSocket.recv ( ) method should signal unexpected EOF from the other end of the connection .", "question_id": 9029}
{"snippet": "SSLContext.wrap_socket(sock, server_side=False, server_hostname=None)", "intent": "Wrap an existing Python socket `sock` and return an instance of SSLContext.sslsocket_class ( default SSLSocket ) . The parameter `server_side` is a boolean which identifies whether server-side or client-side behavior is desired from this socket . On client connections , the optional parameter `server_hostname` specifies the hostname of the service which we are connecting to .", "question_id": 9030}
{"snippet": "SSLContext.wrap_socket(sock, server_side=False, session=None)", "intent": "Wrap an existing Python socket `sock` and return an instance of SSLContext.sslsocket_class ( default SSLSocket ) . The parameter `server_side` is a boolean which identifies whether server-side or client-side behavior is desired from this socket . `session` , see session .", "question_id": 9031}
{"snippet": "SSLContext.sslsocket_class", "intent": "The return type of SSLContext.wrap_socket(), defaults to SSLSocket.", "question_id": 9032}
{"snippet": "SSLContext.wrap_bio(incoming, outgoing)", "intent": "Wrap the BIO objects `incoming` and `outgoing` and return an instance of SSLContext.sslobject_class ( default SSLObject ) .", "question_id": 9033}
{"snippet": "SSLContext.wrap_bio(incoming, outgoing, server_side=False)", "intent": "Wrap the BIO objects `incoming` and `outgoing` and return an instance of SSLContext.sslobject_class ( default SSLObject ) . The `server_side` , `server_hostname` and `session` parameters have the same meaning as in SSLContext.wrap_socket ( ) .", "question_id": 9034}
{"snippet": "SSLContext.wrap_bio(incoming, outgoing, server_hostname=None)", "intent": "Wrap the BIO objects `incoming` and `outgoing` and return an instance of SSLContext.sslobject_class ( default SSLObject ) . The `server_side` , `server_hostname` and `session` parameters have the same meaning as in SSLContext.wrap_socket ( ) .", "question_id": 9035}
{"snippet": "SSLContext.wrap_bio(incoming, outgoing, session=None)", "intent": "Wrap the BIO objects `incoming` and `outgoing` and return an instance of SSLContext.sslobject_class ( default SSLObject ) . The `server_side` , `server_hostname` and `session` parameters have the same meaning as in SSLContext.wrap_socket ( ) .", "question_id": 9036}
{"snippet": "SSLContext.wrap_bio(incoming, outgoing, server_side=False, server_hostname=None)", "intent": "Wrap the BIO objects `incoming` and `outgoing` and return an instance of SSLContext.sslobject_class ( default SSLObject ) . The `server_side` , `server_hostname` and `session` parameters have the same meaning as in SSLContext.wrap_socket ( ) .", "question_id": 9037}
{"snippet": "SSLContext.wrap_bio(incoming, outgoing, server_side=False, session=None)", "intent": "Wrap the BIO objects `incoming` and `outgoing` and return an instance of SSLContext.sslobject_class ( default SSLObject ) . The `server_side` , `server_hostname` and `session` parameters have the same meaning as in SSLContext.wrap_socket ( ) .", "question_id": 9038}
{"snippet": "SSLContext.wrap_bio(incoming, outgoing, server_hostname=None, session=None)", "intent": "Wrap the BIO objects `incoming` and `outgoing` and return an instance of SSLContext.sslobject_class ( default SSLObject ) . The `server_side` , `server_hostname` and `session` parameters have the same meaning as in SSLContext.wrap_socket ( ) .", "question_id": 9039}
{"snippet": "SSLContext.wrap_bio(incoming, outgoing, server_side=False, server_hostname=None, session=None)", "intent": "Wrap the BIO objects `incoming` and `outgoing` and return an instance of SSLContext.sslobject_class ( default SSLObject ) . The `server_side` , `server_hostname` and `session` parameters have the same meaning as in SSLContext.wrap_socket ( ) .", "question_id": 9040}
{"snippet": "SSLContext.sslobject_class", "intent": "The return type of SSLContext.wrap_bio(), defaults to SSLObject.", "question_id": 9041}
{"snippet": "SSLContext.session_stats()", "intent": "Get statistics about the SSL sessions created or managed by this context .", "question_id": 9042}
{"snippet": "SSLContext.check_hostname", "intent": "Whether to match the peer cert\u2019s hostname with match_hostname() in SSLSocket.do_handshake().", "question_id": 9043}
{"snippet": "SSLContext.maximum_version", "intent": "A TLSVersion enum member representing the highest supported TLS version.", "question_id": 9044}
{"snippet": "SSLContext.minimum_version", "intent": "Like SSLContext.maximum_version except it is the lowest supported version or TLSVersion.MINIMUM_SUPPORTED.", "question_id": 9045}
{"snippet": "SSLContext.options", "intent": "An integer representing the set of SSL options enabled on this context.", "question_id": 9046}
{"snippet": "SSLContext.post_handshake_auth", "intent": "Enable TLS 1.3 post-handshake client authentication.", "question_id": 9047}
{"snippet": "SSLContext.protocol", "intent": "The protocol version chosen when constructing the context.", "question_id": 9048}
{"snippet": "SSLContext.hostname_checks_common_name", "intent": "Whether check_hostname falls back to verify the cert\u2019s subject common name in the absence of a subject alternative name extension (default: true).", "question_id": 9049}
{"snippet": "SSLContext.verify_flags", "intent": "The flags for certificate verification operations.", "question_id": 9050}
{"snippet": "SSLContext.verify_mode", "intent": "Whether to try to verify other peers\u2019 certificates and how to behave if verification fails.", "question_id": 9051}
{"snippet": "ssl.SSLObject", "intent": "A reduced-scope variant of SSLSocket representing an SSL protocol instance that does not contain any network IO methods.", "question_id": 9052}
{"snippet": "ssl.MemoryBIO", "intent": "A memory buffer that can be used to pass data between Python and an SSL protocol instance.", "question_id": 9053}
{"snippet": "memory_bio.pending", "intent": "Return the number of bytes currently in the memory buffer.", "question_id": 9054}
{"snippet": "memory_bio.eof", "intent": "A boolean indicating whether the memory BIO is current at the end-of-file position.", "question_id": 9055}
{"snippet": "memory_bio.read()", "intent": "Read up to `n` bytes from the memory buffer .", "question_id": 9056}
{"snippet": "memory_bio.read(n=-1)", "intent": "Read up to `n` bytes from the memory buffer .", "question_id": 9057}
{"snippet": "memory_bio.write(buf)", "intent": "Write the bytes from `buf` to the memory BIO .", "question_id": 9058}
{"snippet": "memory_bio.write_eof()", "intent": "Write an EOF marker to the memory BIO .", "question_id": 9059}
{"snippet": "ssl.SSLSession", "intent": "Session object used by session.", "question_id": 9060}
{"snippet": "stat.S_ISDIR(mode)", "intent": "Return non-zero if the `mode` is from a directory .", "question_id": 9061}
{"snippet": "stat.S_ISCHR(mode)", "intent": "Return non-zero if the `mode` is from a character special device file .", "question_id": 9062}
{"snippet": "stat.S_ISBLK(mode)", "intent": "Return non-zero if the `mode` is from a block special device file .", "question_id": 9063}
{"snippet": "stat.S_ISREG(mode)", "intent": "Return non-zero if the `mode` is from a regular file .", "question_id": 9064}
{"snippet": "stat.S_ISFIFO(mode)", "intent": "Return non-zero if the `mode` is from a FIFO ( named pipe ) .", "question_id": 9065}
{"snippet": "stat.S_ISLNK(mode)", "intent": "Return non-zero if the `mode` is from a symbolic link .", "question_id": 9066}
{"snippet": "stat.S_ISSOCK(mode)", "intent": "Return non-zero if the `mode` is from a socket .", "question_id": 9067}
{"snippet": "stat.S_ISDOOR(mode)", "intent": "Return non-zero if the `mode` is from a door .", "question_id": 9068}
{"snippet": "stat.S_ISPORT(mode)", "intent": "Return non-zero if the `mode` is from an event port .", "question_id": 9069}
{"snippet": "stat.S_ISWHT(mode)", "intent": "Return non-zero if the `mode` is from a whiteout .", "question_id": 9070}
{"snippet": "stat.S_IMODE(mode)", "intent": "Return the portion of the file \u2019 s `mode` that can be set by os.chmod ( ) \u2014that is , the file \u2019 s permission bits , plus the sticky bit , set-group-id , and set-user-id bits ( on systems that support them ) .", "question_id": 9071}
{"snippet": "stat.S_IFMT(mode)", "intent": "Return the portion of the file \u2019 s `mode` that describes the file type ( used by the S_IS* ( ) functions above ) .", "question_id": 9072}
{"snippet": "stat.filemode(mode)", "intent": "Convert a file \u2019 s `mode` to a string of the form \u2018 -rwxrwxrwx \u2019 .", "question_id": 9073}
{"snippet": "stat.ST_MODE", "intent": "Inode protection mode.", "question_id": 9074}
{"snippet": "stat.ST_INO", "intent": "Inode number.", "question_id": 9075}
{"snippet": "stat.ST_DEV", "intent": "Device inode resides on.", "question_id": 9076}
{"snippet": "stat.ST_NLINK", "intent": "Number of links to the inode.", "question_id": 9077}
{"snippet": "stat.ST_UID", "intent": "User id of the owner.", "question_id": 9078}
{"snippet": "stat.ST_GID", "intent": "Group id of the owner.", "question_id": 9079}
{"snippet": "stat.ST_SIZE", "intent": "Size in bytes of a plain file; amount of data waiting on some special files.", "question_id": 9080}
{"snippet": "stat.ST_ATIME", "intent": "Time of last access.", "question_id": 9081}
{"snippet": "stat.ST_MTIME", "intent": "Time of last modification.", "question_id": 9082}
{"snippet": "stat.ST_CTIME", "intent": "The \u201cctime\u201d as reported by the operating system.", "question_id": 9083}
{"snippet": "stat.S_IFSOCK", "intent": "Socket.", "question_id": 9084}
{"snippet": "stat.S_IFLNK", "intent": "Symbolic link.", "question_id": 9085}
{"snippet": "stat.S_IFREG", "intent": "Regular file.", "question_id": 9086}
{"snippet": "stat.S_IFBLK", "intent": "Block device.", "question_id": 9087}
{"snippet": "stat.S_IFDIR", "intent": "Directory.", "question_id": 9088}
{"snippet": "stat.S_IFCHR", "intent": "Character device.", "question_id": 9089}
{"snippet": "stat.S_IFIFO", "intent": "FIFO.", "question_id": 9090}
{"snippet": "stat.S_IFDOOR", "intent": "Door.", "question_id": 9091}
{"snippet": "stat.S_IFPORT", "intent": "Event port.", "question_id": 9092}
{"snippet": "stat.S_IFWHT", "intent": "Whiteout.", "question_id": 9093}
{"snippet": "stat.S_ISUID", "intent": "Set UID bit.", "question_id": 9094}
{"snippet": "stat.S_ISGID", "intent": "Set-group-ID bit.", "question_id": 9095}
{"snippet": "stat.S_ISVTX", "intent": "Sticky bit.", "question_id": 9096}
{"snippet": "stat.S_IRWXU", "intent": "Mask for file owner permissions.", "question_id": 9097}
{"snippet": "stat.S_IRUSR", "intent": "Owner has read permission.", "question_id": 9098}
{"snippet": "stat.S_IWUSR", "intent": "Owner has write permission.", "question_id": 9099}
{"snippet": "stat.S_IXUSR", "intent": "Owner has execute permission.", "question_id": 9100}
{"snippet": "stat.S_IRWXG", "intent": "Mask for group permissions.", "question_id": 9101}
{"snippet": "stat.S_IRGRP", "intent": "Group has read permission.", "question_id": 9102}
{"snippet": "stat.S_IWGRP", "intent": "Group has write permission.", "question_id": 9103}
{"snippet": "stat.S_IXGRP", "intent": "Group has execute permission.", "question_id": 9104}
{"snippet": "stat.S_IRWXO", "intent": "Mask for permissions for others (not in group).", "question_id": 9105}
{"snippet": "stat.S_IROTH", "intent": "Others have read permission.", "question_id": 9106}
{"snippet": "stat.S_IWOTH", "intent": "Others have write permission.", "question_id": 9107}
{"snippet": "stat.S_IXOTH", "intent": "Others have execute permission.", "question_id": 9108}
{"snippet": "stat.S_ENFMT", "intent": "System V file locking enforcement.", "question_id": 9109}
{"snippet": "stat.S_IREAD", "intent": "Unix V7 synonym for S_IRUSR.", "question_id": 9110}
{"snippet": "stat.S_IWRITE", "intent": "Unix V7 synonym for S_IWUSR.", "question_id": 9111}
{"snippet": "stat.S_IEXEC", "intent": "Unix V7 synonym for S_IXUSR.", "question_id": 9112}
{"snippet": "stat.UF_NODUMP", "intent": "Do not dump the file.", "question_id": 9113}
{"snippet": "stat.UF_IMMUTABLE", "intent": "The file may not be changed.", "question_id": 9114}
{"snippet": "stat.UF_APPEND", "intent": "The file may only be appended to.", "question_id": 9115}
{"snippet": "stat.UF_OPAQUE", "intent": "The directory is opaque when viewed through a union stack.", "question_id": 9116}
{"snippet": "stat.UF_NOUNLINK", "intent": "The file may not be renamed or deleted.", "question_id": 9117}
{"snippet": "stat.UF_COMPRESSED", "intent": "The file is stored compressed (Mac OS X 10.6+).", "question_id": 9118}
{"snippet": "stat.UF_HIDDEN", "intent": "The file should not be displayed in a GUI (Mac OS X 10.5+).", "question_id": 9119}
{"snippet": "stat.SF_ARCHIVED", "intent": "The file may be archived.", "question_id": 9120}
{"snippet": "stat.SF_IMMUTABLE", "intent": "The file may not be changed.", "question_id": 9121}
{"snippet": "stat.SF_APPEND", "intent": "The file may only be appended to.", "question_id": 9122}
{"snippet": "stat.SF_NOUNLINK", "intent": "The file may not be renamed or deleted.", "question_id": 9123}
{"snippet": "stat.SF_SNAPSHOT", "intent": "The file is a snapshot file.", "question_id": 9124}
{"snippet": "statistics.mean(data)", "intent": "Return the sample arithmetic mean of `data` which can be a sequence or iterator .", "question_id": 9125}
{"snippet": "statistics.harmonic_mean(data)", "intent": "Return the harmonic mean of `data` , a sequence or iterator of real-valued numbers .", "question_id": 9126}
{"snippet": "statistics.median(data)", "intent": "Return the median ( middle value ) of numeric `data` , using the common \u201c mean of middle two \u201d method .", "question_id": 9127}
{"snippet": "statistics.median_low(data)", "intent": "Return the low median of numeric `data` .", "question_id": 9128}
{"snippet": "statistics.median_high(data)", "intent": "Return the high median of `data` .", "question_id": 9129}
{"snippet": "statistics.median_grouped(data)", "intent": "Return the median of grouped continuous `data` , calculated as the 50th percentile , using interpolation .", "question_id": 9130}
{"snippet": "statistics.median_grouped(data, interval=1)", "intent": "Return the median of grouped continuous `data` , calculated as the 50th percentile , using interpolation . Optional argument `interval` represents the class interval , and defaults to 1 .", "question_id": 9131}
{"snippet": "statistics.mode(data)", "intent": "Return the most common `data` point from discrete or nominal data .", "question_id": 9132}
{"snippet": "statistics.pstdev(data)", "intent": "Return the population standard deviation ( the square root of the population variance ) . With arguments `data`.", "question_id": 9133}
{"snippet": "statistics.pstdev(data, mu=None)", "intent": "Return the population standard deviation ( the square root of the population variance ) . With arguments `data`, `mu`.", "question_id": 9134}
{"snippet": "statistics.pvariance(data)", "intent": "Return the population variance of `data` , a non-empty iterable of real-valued numbers .", "question_id": 9135}
{"snippet": "statistics.pvariance(data, mu=None)", "intent": "Return the population variance of `data` , a non-empty iterable of real-valued numbers . If the optional second argument `mu` is given , it should be the mean of data .", "question_id": 9136}
{"snippet": "statistics.stdev(data)", "intent": "Return the sample standard deviation ( the square root of the sample variance ) . With arguments `data`.", "question_id": 9137}
{"snippet": "statistics.stdev(data, xbar=None)", "intent": "Return the sample standard deviation ( the square root of the sample variance ) . With arguments `data`, `xbar`.", "question_id": 9138}
{"snippet": "statistics.variance(data)", "intent": "Return the sample variance of `data` , an iterable of at least two real-valued numbers .", "question_id": 9139}
{"snippet": "statistics.variance(data, xbar=None)", "intent": "Return the sample variance of `data` , an iterable of at least two real-valued numbers . If the optional second argument `xbar` is given , it should be the mean of data .", "question_id": 9140}
{"snippet": "statistics.StatisticsError", "intent": "Subclass of ValueError for statistics-related exceptions.", "question_id": 9141}
{"snippet": "int.bit_length()", "intent": "Return the number of bits necessary to represent an integer in binary , excluding the sign and leading zeros :", "question_id": 9142}
{"snippet": "int.to_bytes(length, byteorder)", "intent": "Return an array of bytes representing an integer . The integer is represented using `length` bytes . The `byteorder` argument determines the byte order used to represent the integer .", "question_id": 9143}
{"snippet": "int.to_bytes(length, byteorder, signed=False)", "intent": "Return an array of bytes representing an integer . The integer is represented using `length` bytes . The `byteorder` argument determines the byte order used to represent the integer . The `signed` argument determines whether two \u2019 s complement is used to represent the integer .", "question_id": 9144}
{"snippet": "int.from_bytes(bytes, byteorder)", "intent": "Return the integer represented by the given array of `bytes` . The `byteorder` argument determines the byte order used to represent the integer .", "question_id": 9145}
{"snippet": "int.from_bytes(bytes, byteorder, signed=False)", "intent": "Return the integer represented by the given array of `bytes` . The `byteorder` argument determines the byte order used to represent the integer . The `signed` argument indicates whether two \u2019 s complement is used to represent the integer .", "question_id": 9146}
{"snippet": "float.as_integer_ratio()", "intent": "Return a pair of integers whose ratio is exactly equal to the original float and with a positive denominator .", "question_id": 9147}
{"snippet": "float.is_integer()", "intent": "Return True if the float instance is finite with integral value , and False otherwise :", "question_id": 9148}
{"snippet": "float.hex()", "intent": "Return a representation of a floating-point number as a hexadecimal string .", "question_id": 9149}
{"snippet": "float.fromhex(s)", "intent": "Class method to return the float represented by a hexadecimal string s. The string `s` may have leading and trailing whitespace .", "question_id": 9150}
{"snippet": "container.__iter__()", "intent": "Return an iterator object .", "question_id": 9151}
{"snippet": "iterator.__iter__()", "intent": "Return the iterator object itself .", "question_id": 9152}
{"snippet": "iterator.__next__()", "intent": "Return the next item from the container .", "question_id": 9153}
{"snippet": "list(iterable)", "intent": "Lists may be constructed in several ways : The constructor builds a list whose items are the same and in the same order as `iterable` \u2019 s items .", "question_id": 9154}
{"snippet": "list()", "intent": "Lists may be constructed in several ways :", "question_id": 9155}
{"snippet": "list.sort()", "intent": "This method sorts the list in place , using only < comparisons between items .", "question_id": 9156}
{"snippet": "list.sort(key=None)", "intent": "This method sorts the list in place , using only < comparisons between items . `key` specifies a function of one argument that is used to extract a comparison key from each list element ( for example , key=str.lower ) .", "question_id": 9157}
{"snippet": "list.sort(reverse=False)", "intent": "This method sorts the list in place , using only < comparisons between items . `reverse` is a boolean value .", "question_id": 9158}
{"snippet": "list.sort(key=None, reverse=False)", "intent": "This method sorts the list in place , using only < comparisons between items . `key` specifies a function of one argument that is used to extract a comparison key from each list element ( for example , key=str.lower ) . `reverse` is a boolean value .", "question_id": 9159}
{"snippet": "tuple(iterable)", "intent": "Tuples may be constructed in a number of ways : The constructor builds a tuple whose items are the same and in the same order as `iterable` \u2019 s items .", "question_id": 9160}
{"snippet": "tuple()", "intent": "Tuples may be constructed in a number of ways :", "question_id": 9161}
{"snippet": "range(stop)", "intent": "The arguments to the range constructor must be integers ( either built-in int or any object that implements the __index__ special method ) . For a positive step , the contents of a range r are determined by the formula r [ i ] = start + step*i where i > = 0 and r [ i ] < `stop` .", "question_id": 9162}
{"snippet": "range(start, stop, step)", "intent": "The arguments to the range constructor must be integers ( either built-in int or any object that implements the __index__ special method ) . If the `start` argument is omitted , it defaults to 0 . For a positive step , the contents of a range r are determined by the formula r [ i ] = start + step*i where i > = 0 and r [ i ] < `stop` . If the `step` argument is omitted , it defaults to 1 .", "question_id": 9163}
{"snippet": "range(start, stop)", "intent": "The arguments to the range constructor must be integers ( either built-in int or any object that implements the __index__ special method ) . If the `start` argument is omitted , it defaults to 0 . For a positive step , the contents of a range r are determined by the formula r [ i ] = start + step*i where i > = 0 and r [ i ] < `stop` .", "question_id": 9164}
{"snippet": "range.start", "intent": "The value of the start parameter (or 0 if the parameter was not supplied)", "question_id": 9165}
{"snippet": "range.stop", "intent": "The value of the stop parameter", "question_id": 9166}
{"snippet": "range.step", "intent": "The value of the step parameter (or 1 if the parameter was not supplied)", "question_id": 9167}
{"snippet": "str()", "intent": "Return a string version of `object` .", "question_id": 9168}
{"snippet": "str(object='')", "intent": "Return a string version of `object` .", "question_id": 9169}
{"snippet": "str()", "intent": "Return a string version of `object` .", "question_id": 9170}
{"snippet": "str(object=b'')", "intent": "Return a string version of `object` .", "question_id": 9171}
{"snippet": "str(encoding='utf-8')", "intent": "Return a string version of `object` . Otherwise , the behavior of str ( ) depends on whether `encoding` or `errors` is given , as follows .", "question_id": 9172}
{"snippet": "str(errors='strict')", "intent": "Return a string version of `object` . Otherwise , the behavior of str ( ) depends on whether `encoding` or `errors` is given , as follows .", "question_id": 9173}
{"snippet": "str(object=b'', encoding='utf-8')", "intent": "Return a string version of `object` . Otherwise , the behavior of str ( ) depends on whether `encoding` or `errors` is given , as follows .", "question_id": 9174}
{"snippet": "str(object=b'', errors='strict')", "intent": "Return a string version of `object` . Otherwise , the behavior of str ( ) depends on whether `encoding` or `errors` is given , as follows .", "question_id": 9175}
{"snippet": "str(encoding='utf-8', errors='strict')", "intent": "Return a string version of `object` . Otherwise , the behavior of str ( ) depends on whether `encoding` or `errors` is given , as follows .", "question_id": 9176}
{"snippet": "str(object=b'', encoding='utf-8', errors='strict')", "intent": "Return a string version of `object` . Otherwise , the behavior of str ( ) depends on whether `encoding` or `errors` is given , as follows .", "question_id": 9177}
{"snippet": "str.capitalize()", "intent": "Return a copy of the string with its first character capitalized and the rest lowercased .", "question_id": 9178}
{"snippet": "str.casefold()", "intent": "Return a casefolded copy of the string .", "question_id": 9179}
{"snippet": "str.center(width, fillchar)", "intent": "Return centered in a string of length `width` . Padding is done using the specified `fillchar` ( default is an ASCII space ) .", "question_id": 9180}
{"snippet": "str.center(width)", "intent": "Return centered in a string of length `width` .", "question_id": 9181}
{"snippet": "str.count(sub, start, end)", "intent": "Return the number of non-overlapping occurrences of substring `sub` in the range [ `start` , `end` ] .", "question_id": 9182}
{"snippet": "str.count(sub, start)", "intent": "Return the number of non-overlapping occurrences of substring `sub` in the range [ `start` , `end` ] .", "question_id": 9183}
{"snippet": "str.count(sub)", "intent": "Return the number of non-overlapping occurrences of substring `sub` in the range [ `start` , `end` ] .", "question_id": 9184}
{"snippet": "str.encode()", "intent": "Return an encoded version of the string as a bytes object .", "question_id": 9185}
{"snippet": "str.encode(encoding=\"utf-8\")", "intent": "Return an encoded version of the string as a bytes object . Default `encoding` is 'utf-8 ' .", "question_id": 9186}
{"snippet": "str.encode(errors=\"strict\")", "intent": "Return an encoded version of the string as a bytes object . `errors` may be given to set a different error handling scheme .", "question_id": 9187}
{"snippet": "str.encode(encoding=\"utf-8\", errors=\"strict\")", "intent": "Return an encoded version of the string as a bytes object . Default `encoding` is 'utf-8 ' . `errors` may be given to set a different error handling scheme .", "question_id": 9188}
{"snippet": "str.endswith(suffix, start, end)", "intent": "Return True if the string ends with the specified `suffix` , otherwise return False . With optional `start` , test beginning at that position . With optional `end` , stop comparing at that position .", "question_id": 9189}
{"snippet": "str.endswith(suffix, start)", "intent": "Return True if the string ends with the specified `suffix` , otherwise return False . With optional `start` , test beginning at that position .", "question_id": 9190}
{"snippet": "str.endswith(suffix)", "intent": "Return True if the string ends with the specified `suffix` , otherwise return False .", "question_id": 9191}
{"snippet": "str.expandtabs()", "intent": "Return a copy of the string where all tab characters are replaced by one or more spaces , depending on the current column and the given tab size .", "question_id": 9192}
{"snippet": "str.expandtabs(tabsize=8)", "intent": "Return a copy of the string where all tab characters are replaced by one or more spaces , depending on the current column and the given tab size . Tab positions occur every `tabsize` characters ( default is 8 , giving tab positions at columns 0 , 8 , 16 and so on ) .", "question_id": 9193}
{"snippet": "str.find(sub, start, end)", "intent": "Return the lowest index in the string where substring `sub` is found within the slice s [ `start` : `end` ] .", "question_id": 9194}
{"snippet": "str.find(sub, start)", "intent": "Return the lowest index in the string where substring `sub` is found within the slice s [ `start` : `end` ] .", "question_id": 9195}
{"snippet": "str.find(sub)", "intent": "Return the lowest index in the string where substring `sub` is found within the slice s [ `start` : `end` ] .", "question_id": 9196}
{"snippet": "str.format(*args, **kwargs)", "intent": "Perform a string formatting operation . With arguments `*args`, `**kwargs`.", "question_id": 9197}
{"snippet": "str.format_map(mapping)", "intent": "Similar to str.format ( **mapping ) , except that `mapping` is used directly and not copied to a dict .", "question_id": 9198}
{"snippet": "str.index(sub, start, end)", "intent": "Like find ( ) , but raise ValueError when the substring is not found . With arguments `sub`, `start`, `end`.", "question_id": 9199}
{"snippet": "str.index(sub, start)", "intent": "Like find ( ) , but raise ValueError when the substring is not found . With arguments `sub`, `start`.", "question_id": 9200}
{"snippet": "str.index(sub)", "intent": "Like find ( ) , but raise ValueError when the substring is not found . With arguments `sub`.", "question_id": 9201}
{"snippet": "str.isalnum()", "intent": "Return true if all characters in the string are alphanumeric and there is at least one character , false otherwise .", "question_id": 9202}
{"snippet": "str.isalpha()", "intent": "Return true if all characters in the string are alphabetic and there is at least one character , false otherwise .", "question_id": 9203}
{"snippet": "str.isascii()", "intent": "Return true if the string is empty or all characters in the string are ASCII , false otherwise .", "question_id": 9204}
{"snippet": "str.isdecimal()", "intent": "Return true if all characters in the string are decimal characters and there is at least one character , false otherwise .", "question_id": 9205}
{"snippet": "str.isdigit()", "intent": "Return true if all characters in the string are digits and there is at least one character , false otherwise .", "question_id": 9206}
{"snippet": "str.isidentifier()", "intent": "Return true if the string is a valid identifier according to the language definition , section Identifiers and keywords .", "question_id": 9207}
{"snippet": "str.islower()", "intent": "Return true if all cased characters 4 in the string are lowercase and there is at least one cased character , false otherwise .", "question_id": 9208}
{"snippet": "str.isnumeric()", "intent": "Return true if all characters in the string are numeric characters , and there is at least one character , false otherwise .", "question_id": 9209}
{"snippet": "str.isprintable()", "intent": "Return true if all characters in the string are printable or the string is empty , false otherwise .", "question_id": 9210}
{"snippet": "str.isspace()", "intent": "Return true if there are only whitespace characters in the string and there is at least one character , false otherwise .", "question_id": 9211}
{"snippet": "str.istitle()", "intent": "Return true if the string is a titlecased string and there is at least one character , for example uppercase characters may only follow uncased characters and lowercase characters only cased ones .", "question_id": 9212}
{"snippet": "str.isupper()", "intent": "Return true if all cased characters 4 in the string are uppercase and there is at least one cased character , false otherwise .", "question_id": 9213}
{"snippet": "str.join(iterable)", "intent": "Return a string which is the concatenation of the strings in `iterable` .", "question_id": 9214}
{"snippet": "str.ljust(width, fillchar)", "intent": "Return the string left justified in a string of length `width` . Padding is done using the specified `fillchar` ( default is an ASCII space ) .", "question_id": 9215}
{"snippet": "str.ljust(width)", "intent": "Return the string left justified in a string of length `width` .", "question_id": 9216}
{"snippet": "str.lower()", "intent": "Return a copy of the string with all the cased characters 4 converted to lowercase .", "question_id": 9217}
{"snippet": "str.lstrip(chars)", "intent": "Return a copy of the string with leading characters removed . The `chars` argument is a string specifying the set of characters to be removed .", "question_id": 9218}
{"snippet": "str.lstrip()", "intent": "Return a copy of the string with leading characters removed .", "question_id": 9219}
{"snippet": "str.maketrans(x, y, z)", "intent": "This static method returns a translation table usable for str.translate ( ) . If there are two arguments , they must be strings of equal length , and in the resulting dictionary , each character in `x` will be mapped to the character at the same position in `y` . With arguments `z`.", "question_id": 9220}
{"snippet": "str.maketrans(x, y)", "intent": "This static method returns a translation table usable for str.translate ( ) . If there are two arguments , they must be strings of equal length , and in the resulting dictionary , each character in `x` will be mapped to the character at the same position in `y` .", "question_id": 9221}
{"snippet": "str.maketrans(x)", "intent": "This static method returns a translation table usable for str.translate ( ) . If there are two arguments , they must be strings of equal length , and in the resulting dictionary , each character in `x` will be mapped to the character at the same position in `y` .", "question_id": 9222}
{"snippet": "str.partition(sep)", "intent": "Split the string at the first occurrence of `sep` , and return a 3-tuple containing the part before the separator , the separator itself , and the part after the separator .", "question_id": 9223}
{"snippet": "str.replace(old, new, count)", "intent": "Return a copy of the string with all occurrences of substring `old` replaced by `new` . If the optional argument `count` is given , only the first count occurrences are replaced .", "question_id": 9224}
{"snippet": "str.replace(old, new)", "intent": "Return a copy of the string with all occurrences of substring `old` replaced by `new` .", "question_id": 9225}
{"snippet": "str.rfind(sub, start, end)", "intent": "Return the highest index in the string where substring `sub` is found , such that sub is contained within s [ `start` : `end` ] .", "question_id": 9226}
{"snippet": "str.rfind(sub, start)", "intent": "Return the highest index in the string where substring `sub` is found , such that sub is contained within s [ `start` : `end` ] .", "question_id": 9227}
{"snippet": "str.rfind(sub)", "intent": "Return the highest index in the string where substring `sub` is found , such that sub is contained within s [ `start` : `end` ] .", "question_id": 9228}
{"snippet": "str.rindex(sub, start, end)", "intent": "Like rfind ( ) but raises ValueError when the substring `sub` is not found . With arguments `start`, `end`.", "question_id": 9229}
{"snippet": "str.rindex(sub, start)", "intent": "Like rfind ( ) but raises ValueError when the substring `sub` is not found . With arguments `start`.", "question_id": 9230}
{"snippet": "str.rindex(sub)", "intent": "Like rfind ( ) but raises ValueError when the substring `sub` is not found .", "question_id": 9231}
{"snippet": "str.rjust(width, fillchar)", "intent": "Return the string right justified in a string of length `width` . Padding is done using the specified `fillchar` ( default is an ASCII space ) .", "question_id": 9232}
{"snippet": "str.rjust(width)", "intent": "Return the string right justified in a string of length `width` .", "question_id": 9233}
{"snippet": "str.rpartition(sep)", "intent": "Split the string at the last occurrence of `sep` , and return a 3-tuple containing the part before the separator , the separator itself , and the part after the separator .", "question_id": 9234}
{"snippet": "str.rsplit()", "intent": "Return a list of the words in the string , using `sep` as the delimiter string .", "question_id": 9235}
{"snippet": "str.rsplit(sep=None)", "intent": "Return a list of the words in the string , using `sep` as the delimiter string .", "question_id": 9236}
{"snippet": "str.rsplit(maxsplit=-1)", "intent": "Return a list of the words in the string , using `sep` as the delimiter string . If `maxsplit` is given , at most maxsplit splits are done , the rightmost ones .", "question_id": 9237}
{"snippet": "str.rsplit(sep=None, maxsplit=-1)", "intent": "Return a list of the words in the string , using `sep` as the delimiter string . If `maxsplit` is given , at most maxsplit splits are done , the rightmost ones .", "question_id": 9238}
{"snippet": "str.rstrip(chars)", "intent": "Return a copy of the string with trailing characters removed . The `chars` argument is a string specifying the set of characters to be removed .", "question_id": 9239}
{"snippet": "str.rstrip()", "intent": "Return a copy of the string with trailing characters removed .", "question_id": 9240}
{"snippet": "str.split()", "intent": "Return a list of the words in the string , using `sep` as the delimiter string .", "question_id": 9241}
{"snippet": "str.split(sep=None)", "intent": "Return a list of the words in the string , using `sep` as the delimiter string .", "question_id": 9242}
{"snippet": "str.split(maxsplit=-1)", "intent": "Return a list of the words in the string , using `sep` as the delimiter string . If `maxsplit` is given , at most maxsplit splits are done ( thus , the list will have at most maxsplit+1 elements ) .", "question_id": 9243}
{"snippet": "str.split(sep=None, maxsplit=-1)", "intent": "Return a list of the words in the string , using `sep` as the delimiter string . If `maxsplit` is given , at most maxsplit splits are done ( thus , the list will have at most maxsplit+1 elements ) .", "question_id": 9244}
{"snippet": "str.splitlines(keepends)", "intent": "Return a list of the lines in the string , breaking at line boundaries . Line breaks are not included in the resulting list unless `keepends` is given and true .", "question_id": 9245}
{"snippet": "str.splitlines()", "intent": "Return a list of the lines in the string , breaking at line boundaries .", "question_id": 9246}
{"snippet": "str.startswith(prefix, start, end)", "intent": "Return True if string starts with the `prefix` , otherwise return False . With optional `start` , test string beginning at that position . With optional `end` , stop comparing string at that position .", "question_id": 9247}
{"snippet": "str.startswith(prefix, start)", "intent": "Return True if string starts with the `prefix` , otherwise return False . With optional `start` , test string beginning at that position .", "question_id": 9248}
{"snippet": "str.startswith(prefix)", "intent": "Return True if string starts with the `prefix` , otherwise return False .", "question_id": 9249}
{"snippet": "str.strip(chars)", "intent": "Return a copy of the string with the leading and trailing characters removed . The `chars` argument is a string specifying the set of characters to be removed .", "question_id": 9250}
{"snippet": "str.strip()", "intent": "Return a copy of the string with the leading and trailing characters removed .", "question_id": 9251}
{"snippet": "str.swapcase()", "intent": "Return a copy of the string with uppercase characters converted to lowercase and vice versa .", "question_id": 9252}
{"snippet": "str.title()", "intent": "Return a titlecased version of the string where words start with an uppercase character and the remaining characters are lowercase .", "question_id": 9253}
{"snippet": "str.translate(table)", "intent": "Return a copy of the string in which each character has been mapped through the given translation `table` .", "question_id": 9254}
{"snippet": "str.upper()", "intent": "Return a copy of the string with all the cased characters 4 converted to uppercase .", "question_id": 9255}
{"snippet": "str.zfill(width)", "intent": "Return a copy of the string left filled with ASCII ' 0 ' digits to make a string of length `width` .", "question_id": 9256}
{"snippet": "bytes(source, encoding, errors)", "intent": "Firstly , the syntax for bytes literals is largely the same as that for string literals , except that a b prefix is added : Only ASCII characters are permitted in bytes literals ( regardless of the declared `source` code `encoding` ) . With arguments `errors`.", "question_id": 9257}
{"snippet": "bytes(source, encoding)", "intent": "Firstly , the syntax for bytes literals is largely the same as that for string literals , except that a b prefix is added : Only ASCII characters are permitted in bytes literals ( regardless of the declared `source` code `encoding` ) .", "question_id": 9258}
{"snippet": "bytes(source)", "intent": "Firstly , the syntax for bytes literals is largely the same as that for string literals , except that a b prefix is added : Only ASCII characters are permitted in bytes literals ( regardless of the declared `source` code `encoding` ) .", "question_id": 9259}
{"snippet": "bytes()", "intent": "Firstly , the syntax for bytes literals is largely the same as that for string literals , except that a b prefix is added :", "question_id": 9260}
{"snippet": "bytes.fromhex(string)", "intent": "This bytes class method returns a bytes object , decoding the given `string` object .", "question_id": 9261}
{"snippet": "bytes.hex()", "intent": "Return a string object containing two hexadecimal digits for each byte in the instance .", "question_id": 9262}
{"snippet": "bytearray(source, encoding, errors)", "intent": "There is no dedicated literal syntax for bytearray objects , instead they are always created by calling the constructor : With arguments `source`, `encoding`, `errors`.", "question_id": 9263}
{"snippet": "bytearray(source, encoding)", "intent": "There is no dedicated literal syntax for bytearray objects , instead they are always created by calling the constructor : With arguments `source`, `encoding`.", "question_id": 9264}
{"snippet": "bytearray(source)", "intent": "There is no dedicated literal syntax for bytearray objects , instead they are always created by calling the constructor : With arguments `source`.", "question_id": 9265}
{"snippet": "bytearray()", "intent": "There is no dedicated literal syntax for bytearray objects , instead they are always created by calling the constructor :", "question_id": 9266}
{"snippet": "bytearray.fromhex(string)", "intent": "This bytearray class method returns bytearray object , decoding the given `string` object .", "question_id": 9267}
{"snippet": "bytearray.hex()", "intent": "Return a string object containing two hexadecimal digits for each byte in the instance .", "question_id": 9268}
{"snippet": "bytes.count(sub, start, end)", "intent": "Return the number of non-overlapping occurrences of subsequence `sub` in the range [ `start` , `end` ] .", "question_id": 9269}
{"snippet": "bytes.count(sub, start)", "intent": "Return the number of non-overlapping occurrences of subsequence `sub` in the range [ `start` , `end` ] .", "question_id": 9270}
{"snippet": "bytes.count(sub)", "intent": "Return the number of non-overlapping occurrences of subsequence `sub` in the range [ `start` , `end` ] .", "question_id": 9271}
{"snippet": "bytearray.count(sub, start, end)", "intent": "Return the number of non-overlapping occurrences of subsequence `sub` in the range [ `start` , `end` ] .", "question_id": 9272}
{"snippet": "bytearray.count(sub, start)", "intent": "Return the number of non-overlapping occurrences of subsequence `sub` in the range [ `start` , `end` ] .", "question_id": 9273}
{"snippet": "bytearray.count(sub)", "intent": "Return the number of non-overlapping occurrences of subsequence `sub` in the range [ `start` , `end` ] .", "question_id": 9274}
{"snippet": "bytes.decode()", "intent": "Return a string decoded from the given bytes .", "question_id": 9275}
{"snippet": "bytes.decode(encoding=\"utf-8\")", "intent": "Return a string decoded from the given bytes . Default `encoding` is 'utf-8 ' .", "question_id": 9276}
{"snippet": "bytes.decode(errors=\"strict\")", "intent": "Return a string decoded from the given bytes . `errors` may be given to set a different error handling scheme .", "question_id": 9277}
{"snippet": "bytes.decode(encoding=\"utf-8\", errors=\"strict\")", "intent": "Return a string decoded from the given bytes . Default `encoding` is 'utf-8 ' . `errors` may be given to set a different error handling scheme .", "question_id": 9278}
{"snippet": "bytearray.decode()", "intent": "Return a string decoded from the given bytes .", "question_id": 9279}
{"snippet": "bytearray.decode(encoding=\"utf-8\")", "intent": "Return a string decoded from the given bytes . Default `encoding` is 'utf-8 ' .", "question_id": 9280}
{"snippet": "bytearray.decode(errors=\"strict\")", "intent": "Return a string decoded from the given bytes . `errors` may be given to set a different error handling scheme .", "question_id": 9281}
{"snippet": "bytearray.decode(encoding=\"utf-8\", errors=\"strict\")", "intent": "Return a string decoded from the given bytes . Default `encoding` is 'utf-8 ' . `errors` may be given to set a different error handling scheme .", "question_id": 9282}
{"snippet": "bytes.endswith(suffix, start, end)", "intent": "Return True if the binary data ends with the specified `suffix` , otherwise return False . With optional `start` , test beginning at that position . With optional `end` , stop comparing at that position .", "question_id": 9283}
{"snippet": "bytes.endswith(suffix, start)", "intent": "Return True if the binary data ends with the specified `suffix` , otherwise return False . With optional `start` , test beginning at that position .", "question_id": 9284}
{"snippet": "bytes.endswith(suffix)", "intent": "Return True if the binary data ends with the specified `suffix` , otherwise return False .", "question_id": 9285}
{"snippet": "bytearray.endswith(suffix, start, end)", "intent": "Return True if the binary data ends with the specified `suffix` , otherwise return False . With optional `start` , test beginning at that position . With optional `end` , stop comparing at that position .", "question_id": 9286}
{"snippet": "bytearray.endswith(suffix, start)", "intent": "Return True if the binary data ends with the specified `suffix` , otherwise return False . With optional `start` , test beginning at that position .", "question_id": 9287}
{"snippet": "bytearray.endswith(suffix)", "intent": "Return True if the binary data ends with the specified `suffix` , otherwise return False .", "question_id": 9288}
{"snippet": "bytes.find(sub, start, end)", "intent": "Return the lowest index in the data where the subsequence `sub` is found , such that sub is contained in the slice s [ `start` : `end` ] .", "question_id": 9289}
{"snippet": "bytes.find(sub, start)", "intent": "Return the lowest index in the data where the subsequence `sub` is found , such that sub is contained in the slice s [ `start` : `end` ] .", "question_id": 9290}
{"snippet": "bytes.find(sub)", "intent": "Return the lowest index in the data where the subsequence `sub` is found , such that sub is contained in the slice s [ `start` : `end` ] .", "question_id": 9291}
{"snippet": "bytearray.find(sub, start, end)", "intent": "Return the lowest index in the data where the subsequence `sub` is found , such that sub is contained in the slice s [ `start` : `end` ] .", "question_id": 9292}
{"snippet": "bytearray.find(sub, start)", "intent": "Return the lowest index in the data where the subsequence `sub` is found , such that sub is contained in the slice s [ `start` : `end` ] .", "question_id": 9293}
{"snippet": "bytearray.find(sub)", "intent": "Return the lowest index in the data where the subsequence `sub` is found , such that sub is contained in the slice s [ `start` : `end` ] .", "question_id": 9294}
{"snippet": "bytes.index(sub, start, end)", "intent": "Like find ( ) , but raise ValueError when the subsequence is not found . With arguments `sub`, `start`, `end`.", "question_id": 9295}
{"snippet": "bytes.index(sub, start)", "intent": "Like find ( ) , but raise ValueError when the subsequence is not found . With arguments `sub`, `start`.", "question_id": 9296}
{"snippet": "bytes.index(sub)", "intent": "Like find ( ) , but raise ValueError when the subsequence is not found . With arguments `sub`.", "question_id": 9297}
{"snippet": "bytearray.index(sub, start, end)", "intent": "Like find ( ) , but raise ValueError when the subsequence is not found . With arguments `sub`, `start`, `end`.", "question_id": 9298}
{"snippet": "bytearray.index(sub, start)", "intent": "Like find ( ) , but raise ValueError when the subsequence is not found . With arguments `sub`, `start`.", "question_id": 9299}
{"snippet": "bytearray.index(sub)", "intent": "Like find ( ) , but raise ValueError when the subsequence is not found . With arguments `sub`.", "question_id": 9300}
{"snippet": "bytes.join(iterable)", "intent": "Return a bytes or bytearray object which is the concatenation of the binary data sequences in `iterable` .", "question_id": 9301}
{"snippet": "bytearray.join(iterable)", "intent": "Return a bytes or bytearray object which is the concatenation of the binary data sequences in `iterable` .", "question_id": 9302}
{"snippet": "bytes.maketrans(from, to)", "intent": "This static method returns a translation table usable for bytes.translate ( ) that will map each character in `from` into the character at the same position in `to` ; from and to must both be bytes-like objects and have the same length .", "question_id": 9303}
{"snippet": "bytearray.maketrans(from, to)", "intent": "This static method returns a translation table usable for bytes.translate ( ) that will map each character in `from` into the character at the same position in `to` ; from and to must both be bytes-like objects and have the same length .", "question_id": 9304}
{"snippet": "bytes.partition(sep)", "intent": "Split the sequence at the first occurrence of `sep` , and return a 3-tuple containing the part before the separator , the separator itself or its bytearray copy , and the part after the separator .", "question_id": 9305}
{"snippet": "bytearray.partition(sep)", "intent": "Split the sequence at the first occurrence of `sep` , and return a 3-tuple containing the part before the separator , the separator itself or its bytearray copy , and the part after the separator .", "question_id": 9306}
{"snippet": "bytes.replace(old, new, count)", "intent": "Return a copy of the sequence with all occurrences of subsequence `old` replaced by `new` . If the optional argument `count` is given , only the first count occurrences are replaced .", "question_id": 9307}
{"snippet": "bytes.replace(old, new)", "intent": "Return a copy of the sequence with all occurrences of subsequence `old` replaced by `new` .", "question_id": 9308}
{"snippet": "bytearray.replace(old, new, count)", "intent": "Return a copy of the sequence with all occurrences of subsequence `old` replaced by `new` . If the optional argument `count` is given , only the first count occurrences are replaced .", "question_id": 9309}
{"snippet": "bytearray.replace(old, new)", "intent": "Return a copy of the sequence with all occurrences of subsequence `old` replaced by `new` .", "question_id": 9310}
{"snippet": "bytes.rfind(sub, start, end)", "intent": "Return the highest index in the sequence where the subsequence `sub` is found , such that sub is contained within s [ `start` : `end` ] .", "question_id": 9311}
{"snippet": "bytes.rfind(sub, start)", "intent": "Return the highest index in the sequence where the subsequence `sub` is found , such that sub is contained within s [ `start` : `end` ] .", "question_id": 9312}
{"snippet": "bytes.rfind(sub)", "intent": "Return the highest index in the sequence where the subsequence `sub` is found , such that sub is contained within s [ `start` : `end` ] .", "question_id": 9313}
{"snippet": "bytearray.rfind(sub, start, end)", "intent": "Return the highest index in the sequence where the subsequence `sub` is found , such that sub is contained within s [ `start` : `end` ] .", "question_id": 9314}
{"snippet": "bytearray.rfind(sub, start)", "intent": "Return the highest index in the sequence where the subsequence `sub` is found , such that sub is contained within s [ `start` : `end` ] .", "question_id": 9315}
{"snippet": "bytearray.rfind(sub)", "intent": "Return the highest index in the sequence where the subsequence `sub` is found , such that sub is contained within s [ `start` : `end` ] .", "question_id": 9316}
{"snippet": "bytes.rindex(sub, start, end)", "intent": "Like rfind ( ) but raises ValueError when the subsequence `sub` is not found . With arguments `start`, `end`.", "question_id": 9317}
{"snippet": "bytes.rindex(sub, start)", "intent": "Like rfind ( ) but raises ValueError when the subsequence `sub` is not found . With arguments `start`.", "question_id": 9318}
{"snippet": "bytes.rindex(sub)", "intent": "Like rfind ( ) but raises ValueError when the subsequence `sub` is not found .", "question_id": 9319}
{"snippet": "bytearray.rindex(sub, start, end)", "intent": "Like rfind ( ) but raises ValueError when the subsequence `sub` is not found . With arguments `start`, `end`.", "question_id": 9320}
{"snippet": "bytearray.rindex(sub, start)", "intent": "Like rfind ( ) but raises ValueError when the subsequence `sub` is not found . With arguments `start`.", "question_id": 9321}
{"snippet": "bytearray.rindex(sub)", "intent": "Like rfind ( ) but raises ValueError when the subsequence `sub` is not found .", "question_id": 9322}
{"snippet": "bytes.rpartition(sep)", "intent": "Split the sequence at the last occurrence of `sep` , and return a 3-tuple containing the part before the separator , the separator itself or its bytearray copy , and the part after the separator .", "question_id": 9323}
{"snippet": "bytearray.rpartition(sep)", "intent": "Split the sequence at the last occurrence of `sep` , and return a 3-tuple containing the part before the separator , the separator itself or its bytearray copy , and the part after the separator .", "question_id": 9324}
{"snippet": "bytes.startswith(prefix, start, end)", "intent": "Return True if the binary data starts with the specified `prefix` , otherwise return False . With optional `start` , test beginning at that position . With optional `end` , stop comparing at that position .", "question_id": 9325}
{"snippet": "bytes.startswith(prefix, start)", "intent": "Return True if the binary data starts with the specified `prefix` , otherwise return False . With optional `start` , test beginning at that position .", "question_id": 9326}
{"snippet": "bytes.startswith(prefix)", "intent": "Return True if the binary data starts with the specified `prefix` , otherwise return False .", "question_id": 9327}
{"snippet": "bytearray.startswith(prefix, start, end)", "intent": "Return True if the binary data starts with the specified `prefix` , otherwise return False . With optional `start` , test beginning at that position . With optional `end` , stop comparing at that position .", "question_id": 9328}
{"snippet": "bytearray.startswith(prefix, start)", "intent": "Return True if the binary data starts with the specified `prefix` , otherwise return False . With optional `start` , test beginning at that position .", "question_id": 9329}
{"snippet": "bytearray.startswith(prefix)", "intent": "Return True if the binary data starts with the specified `prefix` , otherwise return False .", "question_id": 9330}
{"snippet": "bytes.translate(table)", "intent": "Return a copy of the bytes or bytearray object where all bytes occurring in the optional argument `delete` are removed , and the remaining bytes have been mapped through the given translation `table` , which must be a bytes object of length 256 .", "question_id": 9331}
{"snippet": "bytes.translate(table, delete=b'')", "intent": "Return a copy of the bytes or bytearray object where all bytes occurring in the optional argument `delete` are removed , and the remaining bytes have been mapped through the given translation `table` , which must be a bytes object of length 256 .", "question_id": 9332}
{"snippet": "bytearray.translate(table)", "intent": "Return a copy of the bytes or bytearray object where all bytes occurring in the optional argument `delete` are removed , and the remaining bytes have been mapped through the given translation `table` , which must be a bytes object of length 256 .", "question_id": 9333}
{"snippet": "bytearray.translate(table, delete=b'')", "intent": "Return a copy of the bytes or bytearray object where all bytes occurring in the optional argument `delete` are removed , and the remaining bytes have been mapped through the given translation `table` , which must be a bytes object of length 256 .", "question_id": 9334}
{"snippet": "bytes.center(width, fillbyte)", "intent": "Return a copy of the object centered in a sequence of length `width` . Padding is done using the specified `fillbyte` ( default is an ASCII space ) .", "question_id": 9335}
{"snippet": "bytes.center(width)", "intent": "Return a copy of the object centered in a sequence of length `width` .", "question_id": 9336}
{"snippet": "bytearray.center(width, fillbyte)", "intent": "Return a copy of the object centered in a sequence of length `width` . Padding is done using the specified `fillbyte` ( default is an ASCII space ) .", "question_id": 9337}
{"snippet": "bytearray.center(width)", "intent": "Return a copy of the object centered in a sequence of length `width` .", "question_id": 9338}
{"snippet": "bytes.ljust(width, fillbyte)", "intent": "Return a copy of the object left justified in a sequence of length `width` . Padding is done using the specified `fillbyte` ( default is an ASCII space ) .", "question_id": 9339}
{"snippet": "bytes.ljust(width)", "intent": "Return a copy of the object left justified in a sequence of length `width` .", "question_id": 9340}
{"snippet": "bytearray.ljust(width, fillbyte)", "intent": "Return a copy of the object left justified in a sequence of length `width` . Padding is done using the specified `fillbyte` ( default is an ASCII space ) .", "question_id": 9341}
{"snippet": "bytearray.ljust(width)", "intent": "Return a copy of the object left justified in a sequence of length `width` .", "question_id": 9342}
{"snippet": "bytes.lstrip(chars)", "intent": "Return a copy of the sequence with specified leading bytes removed . The `chars` argument is a binary sequence specifying the set of byte values to be removed - the name refers to the fact this method is usually used with ASCII characters .", "question_id": 9343}
{"snippet": "bytes.lstrip()", "intent": "Return a copy of the sequence with specified leading bytes removed .", "question_id": 9344}
{"snippet": "bytearray.lstrip(chars)", "intent": "Return a copy of the sequence with specified leading bytes removed . The `chars` argument is a binary sequence specifying the set of byte values to be removed - the name refers to the fact this method is usually used with ASCII characters .", "question_id": 9345}
{"snippet": "bytearray.lstrip()", "intent": "Return a copy of the sequence with specified leading bytes removed .", "question_id": 9346}
{"snippet": "bytes.rjust(width, fillbyte)", "intent": "Return a copy of the object right justified in a sequence of length `width` . Padding is done using the specified `fillbyte` ( default is an ASCII space ) .", "question_id": 9347}
{"snippet": "bytes.rjust(width)", "intent": "Return a copy of the object right justified in a sequence of length `width` .", "question_id": 9348}
{"snippet": "bytearray.rjust(width, fillbyte)", "intent": "Return a copy of the object right justified in a sequence of length `width` . Padding is done using the specified `fillbyte` ( default is an ASCII space ) .", "question_id": 9349}
{"snippet": "bytearray.rjust(width)", "intent": "Return a copy of the object right justified in a sequence of length `width` .", "question_id": 9350}
{"snippet": "bytes.rsplit()", "intent": "Split the binary sequence into subsequences of the same type , using `sep` as the delimiter string .", "question_id": 9351}
{"snippet": "bytes.rsplit(sep=None)", "intent": "Split the binary sequence into subsequences of the same type , using `sep` as the delimiter string .", "question_id": 9352}
{"snippet": "bytes.rsplit(maxsplit=-1)", "intent": "Split the binary sequence into subsequences of the same type , using `sep` as the delimiter string . If `maxsplit` is given , at most maxsplit splits are done , the rightmost ones .", "question_id": 9353}
{"snippet": "bytes.rsplit(sep=None, maxsplit=-1)", "intent": "Split the binary sequence into subsequences of the same type , using `sep` as the delimiter string . If `maxsplit` is given , at most maxsplit splits are done , the rightmost ones .", "question_id": 9354}
{"snippet": "bytearray.rsplit()", "intent": "Split the binary sequence into subsequences of the same type , using `sep` as the delimiter string .", "question_id": 9355}
{"snippet": "bytearray.rsplit(sep=None)", "intent": "Split the binary sequence into subsequences of the same type , using `sep` as the delimiter string .", "question_id": 9356}
{"snippet": "bytearray.rsplit(maxsplit=-1)", "intent": "Split the binary sequence into subsequences of the same type , using `sep` as the delimiter string . If `maxsplit` is given , at most maxsplit splits are done , the rightmost ones .", "question_id": 9357}
{"snippet": "bytearray.rsplit(sep=None, maxsplit=-1)", "intent": "Split the binary sequence into subsequences of the same type , using `sep` as the delimiter string . If `maxsplit` is given , at most maxsplit splits are done , the rightmost ones .", "question_id": 9358}
{"snippet": "bytes.rstrip(chars)", "intent": "Return a copy of the sequence with specified trailing bytes removed . The `chars` argument is a binary sequence specifying the set of byte values to be removed - the name refers to the fact this method is usually used with ASCII characters .", "question_id": 9359}
{"snippet": "bytes.rstrip()", "intent": "Return a copy of the sequence with specified trailing bytes removed .", "question_id": 9360}
{"snippet": "bytearray.rstrip(chars)", "intent": "Return a copy of the sequence with specified trailing bytes removed . The `chars` argument is a binary sequence specifying the set of byte values to be removed - the name refers to the fact this method is usually used with ASCII characters .", "question_id": 9361}
{"snippet": "bytearray.rstrip()", "intent": "Return a copy of the sequence with specified trailing bytes removed .", "question_id": 9362}
{"snippet": "bytes.split()", "intent": "Split the binary sequence into subsequences of the same type , using `sep` as the delimiter string .", "question_id": 9363}
{"snippet": "bytes.split(sep=None)", "intent": "Split the binary sequence into subsequences of the same type , using `sep` as the delimiter string .", "question_id": 9364}
{"snippet": "bytes.split(maxsplit=-1)", "intent": "Split the binary sequence into subsequences of the same type , using `sep` as the delimiter string . If `maxsplit` is given and non-negative , at most maxsplit splits are done ( thus , the list will have at most maxsplit+1 elements ) .", "question_id": 9365}
{"snippet": "bytes.split(sep=None, maxsplit=-1)", "intent": "Split the binary sequence into subsequences of the same type , using `sep` as the delimiter string . If `maxsplit` is given and non-negative , at most maxsplit splits are done ( thus , the list will have at most maxsplit+1 elements ) .", "question_id": 9366}
{"snippet": "bytearray.split()", "intent": "Split the binary sequence into subsequences of the same type , using `sep` as the delimiter string .", "question_id": 9367}
{"snippet": "bytearray.split(sep=None)", "intent": "Split the binary sequence into subsequences of the same type , using `sep` as the delimiter string .", "question_id": 9368}
{"snippet": "bytearray.split(maxsplit=-1)", "intent": "Split the binary sequence into subsequences of the same type , using `sep` as the delimiter string . If `maxsplit` is given and non-negative , at most maxsplit splits are done ( thus , the list will have at most maxsplit+1 elements ) .", "question_id": 9369}
{"snippet": "bytearray.split(sep=None, maxsplit=-1)", "intent": "Split the binary sequence into subsequences of the same type , using `sep` as the delimiter string . If `maxsplit` is given and non-negative , at most maxsplit splits are done ( thus , the list will have at most maxsplit+1 elements ) .", "question_id": 9370}
{"snippet": "bytes.strip(chars)", "intent": "Return a copy of the sequence with specified leading and trailing bytes removed . The `chars` argument is a binary sequence specifying the set of byte values to be removed - the name refers to the fact this method is usually used with ASCII characters .", "question_id": 9371}
{"snippet": "bytes.strip()", "intent": "Return a copy of the sequence with specified leading and trailing bytes removed .", "question_id": 9372}
{"snippet": "bytearray.strip(chars)", "intent": "Return a copy of the sequence with specified leading and trailing bytes removed . The `chars` argument is a binary sequence specifying the set of byte values to be removed - the name refers to the fact this method is usually used with ASCII characters .", "question_id": 9373}
{"snippet": "bytearray.strip()", "intent": "Return a copy of the sequence with specified leading and trailing bytes removed .", "question_id": 9374}
{"snippet": "bytes.capitalize()", "intent": "Return a copy of the sequence with each byte interpreted as an ASCII character , and the first byte capitalized and the rest lowercased .", "question_id": 9375}
{"snippet": "bytearray.capitalize()", "intent": "Return a copy of the sequence with each byte interpreted as an ASCII character , and the first byte capitalized and the rest lowercased .", "question_id": 9376}
{"snippet": "bytes.expandtabs()", "intent": "Return a copy of the sequence where all ASCII tab characters are replaced by one or more ASCII spaces , depending on the current column and the given tab size .", "question_id": 9377}
{"snippet": "bytes.expandtabs(tabsize=8)", "intent": "Return a copy of the sequence where all ASCII tab characters are replaced by one or more ASCII spaces , depending on the current column and the given tab size . Tab positions occur every `tabsize` bytes ( default is 8 , giving tab positions at columns 0 , 8 , 16 and so on ) .", "question_id": 9378}
{"snippet": "bytearray.expandtabs()", "intent": "Return a copy of the sequence where all ASCII tab characters are replaced by one or more ASCII spaces , depending on the current column and the given tab size .", "question_id": 9379}
{"snippet": "bytearray.expandtabs(tabsize=8)", "intent": "Return a copy of the sequence where all ASCII tab characters are replaced by one or more ASCII spaces , depending on the current column and the given tab size . Tab positions occur every `tabsize` bytes ( default is 8 , giving tab positions at columns 0 , 8 , 16 and so on ) .", "question_id": 9380}
{"snippet": "bytes.isalnum()", "intent": "Return true if all bytes in the sequence are alphabetical ASCII characters or ASCII decimal digits and the sequence is not empty , false otherwise .", "question_id": 9381}
{"snippet": "bytearray.isalnum()", "intent": "Return true if all bytes in the sequence are alphabetical ASCII characters or ASCII decimal digits and the sequence is not empty , false otherwise .", "question_id": 9382}
{"snippet": "bytes.isalpha()", "intent": "Return true if all bytes in the sequence are alphabetic ASCII characters and the sequence is not empty , false otherwise .", "question_id": 9383}
{"snippet": "bytearray.isalpha()", "intent": "Return true if all bytes in the sequence are alphabetic ASCII characters and the sequence is not empty , false otherwise .", "question_id": 9384}
{"snippet": "bytes.isascii()", "intent": "Return true if the sequence is empty or all bytes in the sequence are ASCII , false otherwise .", "question_id": 9385}
{"snippet": "bytearray.isascii()", "intent": "Return true if the sequence is empty or all bytes in the sequence are ASCII , false otherwise .", "question_id": 9386}
{"snippet": "bytes.isdigit()", "intent": "Return true if all bytes in the sequence are ASCII decimal digits and the sequence is not empty , false otherwise .", "question_id": 9387}
{"snippet": "bytearray.isdigit()", "intent": "Return true if all bytes in the sequence are ASCII decimal digits and the sequence is not empty , false otherwise .", "question_id": 9388}
{"snippet": "bytes.islower()", "intent": "Return true if there is at least one lowercase ASCII character in the sequence and no uppercase ASCII characters , false otherwise .", "question_id": 9389}
{"snippet": "bytearray.islower()", "intent": "Return true if there is at least one lowercase ASCII character in the sequence and no uppercase ASCII characters , false otherwise .", "question_id": 9390}
{"snippet": "bytes.isspace()", "intent": "Return true if all bytes in the sequence are ASCII whitespace and the sequence is not empty , false otherwise .", "question_id": 9391}
{"snippet": "bytearray.isspace()", "intent": "Return true if all bytes in the sequence are ASCII whitespace and the sequence is not empty , false otherwise .", "question_id": 9392}
{"snippet": "bytes.istitle()", "intent": "Return true if the sequence is ASCII titlecase and the sequence is not empty , false otherwise .", "question_id": 9393}
{"snippet": "bytearray.istitle()", "intent": "Return true if the sequence is ASCII titlecase and the sequence is not empty , false otherwise .", "question_id": 9394}
{"snippet": "bytes.isupper()", "intent": "Return true if there is at least one uppercase alphabetic ASCII character in the sequence and no lowercase ASCII characters , false otherwise .", "question_id": 9395}
{"snippet": "bytearray.isupper()", "intent": "Return true if there is at least one uppercase alphabetic ASCII character in the sequence and no lowercase ASCII characters , false otherwise .", "question_id": 9396}
{"snippet": "bytes.lower()", "intent": "Return a copy of the sequence with all the uppercase ASCII characters converted to their corresponding lowercase counterpart .", "question_id": 9397}
{"snippet": "bytearray.lower()", "intent": "Return a copy of the sequence with all the uppercase ASCII characters converted to their corresponding lowercase counterpart .", "question_id": 9398}
{"snippet": "bytes.splitlines()", "intent": "Return a list of the lines in the binary sequence , breaking at ASCII line boundaries .", "question_id": 9399}
{"snippet": "bytes.splitlines(keepends=False)", "intent": "Return a list of the lines in the binary sequence , breaking at ASCII line boundaries . Line breaks are not included in the resulting list unless `keepends` is given and true .", "question_id": 9400}
{"snippet": "bytearray.splitlines()", "intent": "Return a list of the lines in the binary sequence , breaking at ASCII line boundaries .", "question_id": 9401}
{"snippet": "bytearray.splitlines(keepends=False)", "intent": "Return a list of the lines in the binary sequence , breaking at ASCII line boundaries . Line breaks are not included in the resulting list unless `keepends` is given and true .", "question_id": 9402}
{"snippet": "bytes.swapcase()", "intent": "Return a copy of the sequence with all the lowercase ASCII characters converted to their corresponding uppercase counterpart and vice-versa .", "question_id": 9403}
{"snippet": "bytearray.swapcase()", "intent": "Return a copy of the sequence with all the lowercase ASCII characters converted to their corresponding uppercase counterpart and vice-versa .", "question_id": 9404}
{"snippet": "bytes.title()", "intent": "Return a titlecased version of the binary sequence where words start with an uppercase ASCII character and the remaining characters are lowercase .", "question_id": 9405}
{"snippet": "bytearray.title()", "intent": "Return a titlecased version of the binary sequence where words start with an uppercase ASCII character and the remaining characters are lowercase .", "question_id": 9406}
{"snippet": "bytes.upper()", "intent": "Return a copy of the sequence with all the lowercase ASCII characters converted to their corresponding uppercase counterpart .", "question_id": 9407}
{"snippet": "bytearray.upper()", "intent": "Return a copy of the sequence with all the lowercase ASCII characters converted to their corresponding uppercase counterpart .", "question_id": 9408}
{"snippet": "bytes.zfill(width)", "intent": "Return a copy of the sequence left filled with ASCII b ' 0 ' digits to make a sequence of length `width` .", "question_id": 9409}
{"snippet": "bytearray.zfill(width)", "intent": "Return a copy of the sequence left filled with ASCII b ' 0 ' digits to make a sequence of length `width` .", "question_id": 9410}
{"snippet": "memoryview(obj)", "intent": "Create a memoryview that references `obj` .", "question_id": 9411}
{"snippet": "memoryview.__eq__(exporter)", "intent": "A memoryview and a PEP 3118 `exporter` are equal if their shapes are equivalent and if all corresponding values are equal when the operands \u2019 respective format codes are interpreted using struct syntax .", "question_id": 9412}
{"snippet": "memoryview.tobytes()", "intent": "Return the data in the buffer as a bytestring .", "question_id": 9413}
{"snippet": "memoryview.hex()", "intent": "Return a string object containing two hexadecimal digits for each byte in the buffer .", "question_id": 9414}
{"snippet": "memoryview.tolist()", "intent": "Return the data in the buffer as a list of elements .", "question_id": 9415}
{"snippet": "memoryview.release()", "intent": "Release the underlying buffer exposed by the memoryview object .", "question_id": 9416}
{"snippet": "memoryview.cast(format, shape)", "intent": "Cast a memoryview to a new `format` or `shape` .", "question_id": 9417}
{"snippet": "memoryview.cast(format)", "intent": "Cast a memoryview to a new `format` or `shape` .", "question_id": 9418}
{"snippet": "memoryview.obj", "intent": "The underlying object of the memoryview:", "question_id": 9419}
{"snippet": "memoryview.nbytes", "intent": "nbytes == product(shape) * itemsize == len(m.tobytes()).", "question_id": 9420}
{"snippet": "memoryview.readonly", "intent": "A bool indicating whether the memory is read only.", "question_id": 9421}
{"snippet": "memoryview.format", "intent": "A string containing the format (in struct module style) for each element in the view.", "question_id": 9422}
{"snippet": "memoryview.itemsize", "intent": "The size in bytes of each element of the memoryview:", "question_id": 9423}
{"snippet": "memoryview.ndim", "intent": "An integer indicating how many dimensions of a multi-dimensional array the memory represents.", "question_id": 9424}
{"snippet": "memoryview.shape", "intent": "A tuple of integers the length of ndim giving the shape of the memory as an N-dimensional array.", "question_id": 9425}
{"snippet": "memoryview.strides", "intent": "A tuple of integers the length of ndim giving the size in bytes to access each element for each dimension of the array.", "question_id": 9426}
{"snippet": "memoryview.suboffsets", "intent": "Used internally for PIL-style arrays.", "question_id": 9427}
{"snippet": "memoryview.c_contiguous", "intent": "A bool indicating whether the memory is C-contiguous.", "question_id": 9428}
{"snippet": "memoryview.f_contiguous", "intent": "A bool indicating whether the memory is Fortran contiguous.", "question_id": 9429}
{"snippet": "memoryview.contiguous", "intent": "A bool indicating whether the memory is contiguous.", "question_id": 9430}
{"snippet": "set(iterable)", "intent": "Return a new set or frozenset object whose elements are taken from `iterable` .", "question_id": 9431}
{"snippet": "set()", "intent": "Return a new set or frozenset object whose elements are taken from `iterable` .", "question_id": 9432}
{"snippet": "frozenset(iterable)", "intent": "Return a new set or frozenset object whose elements are taken from `iterable` .", "question_id": 9433}
{"snippet": "frozenset()", "intent": "Return a new set or frozenset object whose elements are taken from `iterable` .", "question_id": 9434}
{"snippet": "len(s)", "intent": "Return the number of elements in set `s` ( cardinality of s ) .", "question_id": 9435}
{"snippet": "x in s", "intent": "Test x for membership in s.", "question_id": 9436}
{"snippet": "x not in s", "intent": "Test x for non-membership in s.", "question_id": 9437}
{"snippet": "set.isdisjoint(other)", "intent": "Return True if the set has no elements in common with `other` .", "question_id": 9438}
{"snippet": "set.issubset(other)", "intent": "Test whether every element in the set is in `other` .", "question_id": 9439}
{"snippet": "set <= other", "intent": "Test whether every element in the set is in other.", "question_id": 9440}
{"snippet": "set < other", "intent": "Test whether the set is a proper subset of other, that is, set <= other and set != other.", "question_id": 9441}
{"snippet": "set.issuperset(other)", "intent": "Test whether every element in `other` is in the set .", "question_id": 9442}
{"snippet": "set >= other", "intent": "Test whether every element in other is in the set.", "question_id": 9443}
{"snippet": "set > other", "intent": "Test whether the set is a proper superset of other, that is, set >= other and set != other.", "question_id": 9444}
{"snippet": "set.union(*others)", "intent": "Return a new set with elements from the set and all others . With arguments `*others`.", "question_id": 9445}
{"snippet": "set | other | ...", "intent": "Return a new set with elements from the set and all others.", "question_id": 9446}
{"snippet": "set.intersection(*others)", "intent": "Return a new set with elements common to the set and all others . With arguments `*others`.", "question_id": 9447}
{"snippet": "set & other & ...", "intent": "Return a new set with elements common to the set and all others.", "question_id": 9448}
{"snippet": "set.difference(*others)", "intent": "Return a new set with elements in the set that are not in the others . With arguments `*others`.", "question_id": 9449}
{"snippet": "set - other - ...", "intent": "Return a new set with elements in the set that are not in the others.", "question_id": 9450}
{"snippet": "set.symmetric_difference(other)", "intent": "Return a new set with elements in either the set or `other` but not both .", "question_id": 9451}
{"snippet": "set ^ other", "intent": "Return a new set with elements in either the set or other but not both.", "question_id": 9452}
{"snippet": "set.copy()", "intent": "Return a shallow copy of the set .", "question_id": 9453}
{"snippet": "set.update(*others)", "intent": "Update the set , adding elements from all others . With arguments `*others`.", "question_id": 9454}
{"snippet": "set |= other | ...", "intent": "Update the set, adding elements from all others.", "question_id": 9455}
{"snippet": "set.intersection_update(*others)", "intent": "Update the set , keeping only elements found in it and all others . With arguments `*others`.", "question_id": 9456}
{"snippet": "set &= other & ...", "intent": "Update the set, keeping only elements found in it and all others.", "question_id": 9457}
{"snippet": "set.difference_update(*others)", "intent": "Update the set , removing elements found in others . With arguments `*others`.", "question_id": 9458}
{"snippet": "set -= other | ...", "intent": "Update the set, removing elements found in others.", "question_id": 9459}
{"snippet": "set.symmetric_difference_update(other)", "intent": "Update the set , keeping only elements found in either set , but not in both . With arguments `other`.", "question_id": 9460}
{"snippet": "set ^= other", "intent": "Update the set, keeping only elements found in either set, but not in both.", "question_id": 9461}
{"snippet": "set.add(elem)", "intent": "Add element `elem` to the set .", "question_id": 9462}
{"snippet": "set.remove(elem)", "intent": "Remove element `elem` from the set .", "question_id": 9463}
{"snippet": "set.discard(elem)", "intent": "Remove element `elem` from the set if it is present .", "question_id": 9464}
{"snippet": "set.pop()", "intent": "Remove and return an arbitrary element from the set .", "question_id": 9465}
{"snippet": "set.clear()", "intent": "Remove all elements from the set .", "question_id": 9466}
{"snippet": "dict(**kwarg)", "intent": "Return a new dictionary initialized from an optional positional argument and a possibly empty set of keyword arguments . With arguments `**kwarg`.", "question_id": 9467}
{"snippet": "dict(mapping, **kwarg)", "intent": "Return a new dictionary initialized from an optional positional argument and a possibly empty set of keyword arguments . If a positional argument is given and it is a `mapping` object , a dictionary is created with the same key-value pairs as the mapping object . With arguments `**kwarg`.", "question_id": 9468}
{"snippet": "dict(iterable, **kwarg)", "intent": "Return a new dictionary initialized from an optional positional argument and a possibly empty set of keyword arguments . Otherwise , the positional argument must be an `iterable` object . With arguments `**kwarg`.", "question_id": 9469}
{"snippet": "list(d)", "intent": "Return a list of all the keys used in the dictionary `d` .", "question_id": 9470}
{"snippet": "len(d)", "intent": "Return the number of items in the dictionary `d` .", "question_id": 9471}
{"snippet": "d[key]", "intent": "Return the item of d with key key.", "question_id": 9472}
{"snippet": "d[key] = value", "intent": "Set d[key] to value.", "question_id": 9473}
{"snippet": "del d[key]", "intent": "Remove d[key] from d.  Raises a KeyError if key is not in the map.", "question_id": 9474}
{"snippet": "key in d", "intent": "Return True if d has a key key, else False.", "question_id": 9475}
{"snippet": "key not in d", "intent": "Equivalent to not key in d.", "question_id": 9476}
{"snippet": "iter(d)", "intent": "Return an iterator over the keys of the dictionary . With arguments `d`.", "question_id": 9477}
{"snippet": "dict.clear()", "intent": "Remove all items from the dictionary .", "question_id": 9478}
{"snippet": "dict.copy()", "intent": "Return a shallow copy of the dictionary .", "question_id": 9479}
{"snippet": "dict.fromkeys(iterable, value)", "intent": "Create a new dictionary with keys from `iterable` and values set to `value` .", "question_id": 9480}
{"snippet": "dict.fromkeys(iterable)", "intent": "Create a new dictionary with keys from `iterable` and values set to `value` .", "question_id": 9481}
{"snippet": "dict.get(key, default)", "intent": "Return the value for `key` if key is in the dictionary , else `default` .", "question_id": 9482}
{"snippet": "dict.get(key)", "intent": "Return the value for `key` if key is in the dictionary , else `default` .", "question_id": 9483}
{"snippet": "dict.items()", "intent": "Return a new view of the dictionary \u2019 s items ( ( key , value ) pairs ) .", "question_id": 9484}
{"snippet": "dict.keys()", "intent": "Return a new view of the dictionary \u2019 s keys .", "question_id": 9485}
{"snippet": "dict.pop(key, default)", "intent": "If `key` is in the dictionary , remove it and return its value , else return `default` .", "question_id": 9486}
{"snippet": "dict.pop(key)", "intent": "If `key` is in the dictionary , remove it and return its value , else return `default` .", "question_id": 9487}
{"snippet": "dict.popitem()", "intent": "Remove and return a ( key , value ) pair from the dictionary .", "question_id": 9488}
{"snippet": "dict.setdefault(key, default)", "intent": "If `key` is in the dictionary , return its value . If not , insert key with a value of `default` and return default .", "question_id": 9489}
{"snippet": "dict.setdefault(key)", "intent": "If `key` is in the dictionary , return its value .", "question_id": 9490}
{"snippet": "dict.update(other)", "intent": "Update the dictionary with the key/value pairs from `other` , overwriting existing keys .", "question_id": 9491}
{"snippet": "dict.update()", "intent": "Update the dictionary with the key/value pairs from `other` , overwriting existing keys .", "question_id": 9492}
{"snippet": "dict.values()", "intent": "Return a new view of the dictionary \u2019 s values .", "question_id": 9493}
{"snippet": "len(dictview)", "intent": "Return the number of entries in the dictionary . With arguments `dictview`.", "question_id": 9494}
{"snippet": "iter(dictview)", "intent": "Return an iterator over the keys , values or items ( represented as tuples of ( key , value ) ) in the dictionary . With arguments `dictview`.", "question_id": 9495}
{"snippet": "x in dictview", "intent": "Return True if x is in the underlying dictionary\u2019s keys, values or items (in the latter case, x should be a (key, value) tuple).", "question_id": 9496}
{"snippet": "contextmanager.__enter__()", "intent": "Enter the runtime context and return either this object or another object related to the runtime context .", "question_id": 9497}
{"snippet": "contextmanager.__exit__(exc_type, exc_val, exc_tb)", "intent": "Exit the runtime context and return a Boolean flag indicating if any exception that occurred should be suppressed . With arguments `exc_type`, `exc_val`, `exc_tb`.", "question_id": 9498}
{"snippet": "object.__dict__", "intent": "A dictionary or other mapping object used to store an object\u2019s (writable) attributes.", "question_id": 9499}
{"snippet": "instance.__class__", "intent": "The class to which a class instance belongs.", "question_id": 9500}
{"snippet": "class.__bases__", "intent": "The tuple of base classes of a class object.", "question_id": 9501}
{"snippet": "definition.__name__", "intent": "The name of the class, function, method, descriptor, or generator instance.", "question_id": 9502}
{"snippet": "definition.__qualname__", "intent": "The qualified name of the class, function, method, descriptor, or generator instance.", "question_id": 9503}
{"snippet": "class.__mro__", "intent": "This attribute is a tuple of classes that are considered when looking for base classes during method resolution.", "question_id": 9504}
{"snippet": "class.mro()", "intent": "This method can be overridden by a metaclass to customize the method resolution order for its instances .", "question_id": 9505}
{"snippet": "class.__subclasses__()", "intent": "Each class keeps a list of weak references to its immediate subclasses .", "question_id": 9506}
{"snippet": "string.ascii_letters", "intent": "The concatenation of the ascii_lowercase and ascii_uppercase constants described below.", "question_id": 9507}
{"snippet": "string.ascii_lowercase", "intent": "The lowercase letters 'abcdefghijklmnopqrstuvwxyz'.", "question_id": 9508}
{"snippet": "string.ascii_uppercase", "intent": "The uppercase letters 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.", "question_id": 9509}
{"snippet": "string.digits", "intent": "The string '0123456789'.", "question_id": 9510}
{"snippet": "string.hexdigits", "intent": "The string '0123456789abcdefABCDEF'.", "question_id": 9511}
{"snippet": "string.octdigits", "intent": "The string '01234567'.", "question_id": 9512}
{"snippet": "string.punctuation", "intent": "String of ASCII characters which are considered punctuation characters in the C locale.", "question_id": 9513}
{"snippet": "string.printable", "intent": "String of ASCII characters which are considered printable.", "question_id": 9514}
{"snippet": "string.whitespace", "intent": "A string containing all ASCII characters that are considered whitespace.", "question_id": 9515}
{"snippet": "string.Formatter", "intent": "The Formatter class has the following public methods:", "question_id": 9516}
{"snippet": "formatter.format(format_string, *args, **kwargs)", "intent": "The primary API method . With arguments `format_string`, `*args`, `**kwargs`.", "question_id": 9517}
{"snippet": "formatter.vformat(format_string, args, kwargs)", "intent": "This function does the actual work of formatting . With arguments `format_string`, `args`, `kwargs`.", "question_id": 9518}
{"snippet": "formatter.parse(format_string)", "intent": "Loop over the `format_string` and return an iterable of tuples ( literal_text , field_name , format_spec , conversion ) .", "question_id": 9519}
{"snippet": "formatter.get_field(field_name, args, kwargs)", "intent": "Given `field_name` as returned by parse ( ) ( see above ) , convert it to an object to be formatted . `args` and `kwargs` are as passed in to vformat ( ) .", "question_id": 9520}
{"snippet": "formatter.get_value(key, args, kwargs)", "intent": "Retrieve a given field value . The `key` argument will be either an integer or a string . If it is an integer , it represents the index of the positional argument in `args` ; if it is a string , then it represents a named argument in `kwargs` .", "question_id": 9521}
{"snippet": "formatter.check_unused_args(used_args, args, kwargs)", "intent": "Implement checking for unused arguments if desired . The arguments to this function is the set of all argument keys that were actually referred to in the format string ( integers for positional arguments , and strings for named arguments ) , and a reference to the `args` and `kwargs` that was passed to vformat . With arguments `used_args`.", "question_id": 9522}
{"snippet": "formatter.format_field(value, format_spec)", "intent": "format_field ( ) simply calls the global format ( ) built-in . With arguments `value`, `format_spec`.", "question_id": 9523}
{"snippet": "formatter.convert_field(value, conversion)", "intent": "Converts the `value` ( returned by get_field ( ) ) given a `conversion` type ( as in the tuple returned by the parse ( ) method ) .", "question_id": 9524}
{"snippet": "string.Template(template)", "intent": "The constructor takes a single argument which is the `template` string .", "question_id": 9525}
{"snippet": "template.substitute(mapping, **kwds)", "intent": "Performs the template substitution , returning a new string . `mapping` is any dictionary-like object with keys that match the placeholders in the template . With arguments `**kwds`.", "question_id": 9526}
{"snippet": "template.safe_substitute(mapping, **kwds)", "intent": "Like substitute ( ) , except that if placeholders are missing from `mapping` and kwds , instead of raising a KeyError exception , the original placeholder will appear in the resulting string intact . With arguments `**kwds`.", "question_id": 9527}
{"snippet": "template.template", "intent": "This is the object passed to the constructor\u2019s template argument.", "question_id": 9528}
{"snippet": "string.capwords(s)", "intent": "Split the argument into words using str.split ( ) , capitalize each word using str.capitalize ( ) , and join the capitalized words using str.join ( ) . With arguments `s`.", "question_id": 9529}
{"snippet": "string.capwords(s, sep=None)", "intent": "Split the argument into words using str.split ( ) , capitalize each word using str.capitalize ( ) , and join the capitalized words using str.join ( ) . If the optional second argument `sep` is absent or None , runs of whitespace characters are replaced by a single space and leading and trailing whitespace are removed , otherwise sep is used to split and join the words . With arguments `s`.", "question_id": 9530}
{"snippet": "stringprep.in_table_a1(code)", "intent": "Determine whether `code` is in tableA.1 ( Unassigned code points in Unicode 3.2 ) .", "question_id": 9531}
{"snippet": "stringprep.in_table_b1(code)", "intent": "Determine whether `code` is in tableB.1 ( Commonly mapped to nothing ) .", "question_id": 9532}
{"snippet": "stringprep.map_table_b2(code)", "intent": "Return the mapped value for `code` according to tableB.2 ( Mapping for case-folding used with NFKC ) .", "question_id": 9533}
{"snippet": "stringprep.map_table_b3(code)", "intent": "Return the mapped value for `code` according to tableB.3 ( Mapping for case-folding used with no normalization ) .", "question_id": 9534}
{"snippet": "stringprep.in_table_c11(code)", "intent": "Determine whether `code` is in tableC.1.1 ( ASCII space characters ) .", "question_id": 9535}
{"snippet": "stringprep.in_table_c12(code)", "intent": "Determine whether `code` is in tableC.1.2 ( Non-ASCII space characters ) .", "question_id": 9536}
{"snippet": "stringprep.in_table_c11_c12(code)", "intent": "Determine whether `code` is in tableC.1 ( Space characters , union of C.1.1 and C.1.2 ) .", "question_id": 9537}
{"snippet": "stringprep.in_table_c21(code)", "intent": "Determine whether `code` is in tableC.2.1 ( ASCII control characters ) .", "question_id": 9538}
{"snippet": "stringprep.in_table_c22(code)", "intent": "Determine whether `code` is in tableC.2.2 ( Non-ASCII control characters ) .", "question_id": 9539}
{"snippet": "stringprep.in_table_c21_c22(code)", "intent": "Determine whether `code` is in tableC.2 ( Control characters , union of C.2.1 and C.2.2 ) .", "question_id": 9540}
{"snippet": "stringprep.in_table_c3(code)", "intent": "Determine whether `code` is in tableC.3 ( Private use ) .", "question_id": 9541}
{"snippet": "stringprep.in_table_c4(code)", "intent": "Determine whether `code` is in tableC.4 ( Non-character code points ) .", "question_id": 9542}
{"snippet": "stringprep.in_table_c5(code)", "intent": "Determine whether `code` is in tableC.5 ( Surrogate codes ) .", "question_id": 9543}
{"snippet": "stringprep.in_table_c6(code)", "intent": "Determine whether `code` is in tableC.6 ( Inappropriate for plain text ) .", "question_id": 9544}
{"snippet": "stringprep.in_table_c7(code)", "intent": "Determine whether `code` is in tableC.7 ( Inappropriate for canonical representation ) .", "question_id": 9545}
{"snippet": "stringprep.in_table_c8(code)", "intent": "Determine whether `code` is in tableC.8 ( Change display properties or are deprecated ) .", "question_id": 9546}
{"snippet": "stringprep.in_table_c9(code)", "intent": "Determine whether `code` is in tableC.9 ( Tagging characters ) .", "question_id": 9547}
{"snippet": "stringprep.in_table_d1(code)", "intent": "Determine whether `code` is in tableD.1 ( Characters with bidirectional property \u201c R \u201d or \u201c AL \u201d ) .", "question_id": 9548}
{"snippet": "stringprep.in_table_d2(code)", "intent": "Determine whether `code` is in tableD.2 ( Characters with bidirectional property \u201c L \u201d ) .", "question_id": 9549}
{"snippet": "struct.error", "intent": "Exception raised on various occasions; argument is a string describing what is wrong.", "question_id": 9550}
{"snippet": "struct.pack(format, v1, v2)", "intent": "Return a bytes object containing the values `v1` , `v2` , \u2026 packed according to the `format` string format .", "question_id": 9551}
{"snippet": "struct.pack_into(format, buffer, offset, v1, v2)", "intent": "Pack the values `v1` , `v2` , \u2026 according to the `format` string format and write the packed bytes into the writable `buffer` buffer starting at position `offset` .", "question_id": 9552}
{"snippet": "struct.unpack(format, buffer)", "intent": "Unpack from the `buffer` buffer ( presumably packed by pack ( `format` , ... ) ) according to the format string format .", "question_id": 9553}
{"snippet": "struct.unpack_from(format, buffer)", "intent": "Unpack from `buffer` starting at position `offset` , according to the `format` string format .", "question_id": 9554}
{"snippet": "struct.unpack_from(format, buffer, offset=0)", "intent": "Unpack from `buffer` starting at position `offset` , according to the `format` string format .", "question_id": 9555}
{"snippet": "struct.iter_unpack(format, buffer)", "intent": "Iteratively unpack from the `buffer` buffer according to the `format` string format .", "question_id": 9556}
{"snippet": "struct.calcsize(format)", "intent": "Return the size of the struct ( and hence of the bytes object produced by pack ( `format` , ... ) ) corresponding to the format string format .", "question_id": 9557}
{"snippet": "struct.Struct(format)", "intent": "Return a new Struct object which writes and reads binary data according to the `format` string format .", "question_id": 9558}
{"snippet": "struct.pack(v1, v2)", "intent": "Identical to the pack ( ) function , using the compiled format . With arguments `v1`, `v2`.", "question_id": 9559}
{"snippet": "struct.pack_into(buffer, offset, v1, v2)", "intent": "Identical to the pack_into ( ) function , using the compiled format . With arguments `buffer`, `offset`, `v1`, `v2`.", "question_id": 9560}
{"snippet": "struct.unpack(buffer)", "intent": "Identical to the unpack ( ) function , using the compiled format . The `buffer` \u2019 s size in bytes must equal size .", "question_id": 9561}
{"snippet": "struct.unpack_from(buffer)", "intent": "Identical to the unpack_from ( ) function , using the compiled format . The `buffer` \u2019 s size in bytes , minus `offset` , must be at least size .", "question_id": 9562}
{"snippet": "struct.unpack_from(buffer, offset=0)", "intent": "Identical to the unpack_from ( ) function , using the compiled format . The `buffer` \u2019 s size in bytes , minus `offset` , must be at least size .", "question_id": 9563}
{"snippet": "struct.iter_unpack(buffer)", "intent": "Identical to the iter_unpack ( ) function , using the compiled format . The `buffer` \u2019 s size in bytes must be a multiple of size .", "question_id": 9564}
{"snippet": "struct.format", "intent": "The format string used to construct this Struct object.", "question_id": 9565}
{"snippet": "struct.size", "intent": "The calculated size of the struct (and hence of the bytes object produced by the pack() method) corresponding to format.", "question_id": 9566}
{"snippet": "subprocess.run(args)", "intent": "Run the command described by `args` .", "question_id": 9567}
{"snippet": "subprocess.run(args, stdin=None)", "intent": "Run the command described by `args` . The input argument is passed to Popen.communicate ( ) and thus to the subprocess \u2019 s `stdin` .", "question_id": 9568}
{"snippet": "subprocess.run(args, input=None)", "intent": "Run the command described by `args` . ( `timeout` , `input` , `check` , and `capture_output` are not . )", "question_id": 9569}
{"snippet": "subprocess.run(args, stdout=None)", "intent": "Run the command described by `args` . If capture_output is true , `stdout` and `stderr` will be captured .", "question_id": 9570}
{"snippet": "subprocess.run(args, stderr=None)", "intent": "Run the command described by `args` . If capture_output is true , `stdout` and `stderr` will be captured .", "question_id": 9571}
{"snippet": "subprocess.run(args, capture_output=False)", "intent": "Run the command described by `args` . ( `timeout` , `input` , `check` , and `capture_output` are not . )", "question_id": 9572}
{"snippet": "subprocess.run(args, shell=False)", "intent": "Run the command described by `args` . With arguments `shell`.", "question_id": 9573}
{"snippet": "subprocess.run(args, cwd=None)", "intent": "Run the command described by `args` . With arguments `cwd`.", "question_id": 9574}
{"snippet": "subprocess.run(args, timeout=None)", "intent": "Run the command described by `args` . ( `timeout` , `input` , `check` , and `capture_output` are not . )", "question_id": 9575}
{"snippet": "subprocess.run(args, check=False)", "intent": "Run the command described by `args` . ( `timeout` , `input` , `check` , and `capture_output` are not . )", "question_id": 9576}
{"snippet": "subprocess.CompletedProcess", "intent": "The return value from run(), representing a process that has finished.", "question_id": 9577}
{"snippet": "completed_process.args", "intent": "The arguments used to launch the process.", "question_id": 9578}
{"snippet": "completed_process.returncode", "intent": "Exit status of the child process.", "question_id": 9579}
{"snippet": "completed_process.stdout", "intent": "Captured stdout from the child process.", "question_id": 9580}
{"snippet": "completed_process.stderr", "intent": "Captured stderr from the child process.", "question_id": 9581}
{"snippet": "completed_process.check_returncode()", "intent": "If returncode is non-zero , raise a CalledProcessError .", "question_id": 9582}
{"snippet": "subprocess.DEVNULL", "intent": "Special value that can be used as the stdin, stdout or stderr argument to Popen and indicates that the special file os.devnull will be used.", "question_id": 9583}
{"snippet": "subprocess.PIPE", "intent": "Special value that can be used as the stdin, stdout or stderr argument to Popen and indicates that a pipe to the standard stream should be opened.", "question_id": 9584}
{"snippet": "subprocess.STDOUT", "intent": "Special value that can be used as the stderr argument to Popen and indicates that standard error should go into the same handle as standard output.", "question_id": 9585}
{"snippet": "subprocess.SubprocessError", "intent": "Base class for all other exceptions from this module.", "question_id": 9586}
{"snippet": "subprocess.TimeoutExpired", "intent": "Subclass of SubprocessError, raised when a timeout expires while waiting for a child process.", "question_id": 9587}
{"snippet": "completed_process.cmd", "intent": "Command that was used to spawn the child process.", "question_id": 9588}
{"snippet": "completed_process.timeout", "intent": "Timeout in seconds.", "question_id": 9589}
{"snippet": "completed_process.output", "intent": "Output of the child process if it was captured by run() or check_output().", "question_id": 9590}
{"snippet": "completed_process.stdout", "intent": "Alias for output, for symmetry with stderr.", "question_id": 9591}
{"snippet": "completed_process.stderr", "intent": "Stderr output of the child process if it was captured by run().", "question_id": 9592}
{"snippet": "subprocess.CalledProcessError", "intent": "Subclass of SubprocessError, raised when a process run by check_call() or check_output() returns a non-zero exit status.", "question_id": 9593}
{"snippet": "completed_process.returncode", "intent": "Exit status of the child process.", "question_id": 9594}
{"snippet": "completed_process.cmd", "intent": "Command that was used to spawn the child process.", "question_id": 9595}
{"snippet": "completed_process.output", "intent": "Output of the child process if it was captured by run() or check_output().", "question_id": 9596}
{"snippet": "completed_process.stdout", "intent": "Alias for output, for symmetry with stderr.", "question_id": 9597}
{"snippet": "completed_process.stderr", "intent": "Stderr output of the child process if it was captured by run().", "question_id": 9598}
{"snippet": "subprocess.Popen(args)", "intent": "Execute a child program in a new process . `args` should be a sequence of program arguments or else a single string .", "question_id": 9599}
{"snippet": "subprocess.Popen(args, bufsize=-1)", "intent": "Execute a child program in a new process . `args` should be a sequence of program arguments or else a single string . `bufsize` will be supplied as the corresponding argument to the open ( ) function when creating the stdin/stdout/stderr pipe file objects :", "question_id": 9600}
{"snippet": "subprocess.Popen(args, executable=None)", "intent": "Execute a child program in a new process . `args` should be a sequence of program arguments or else a single string . See the `shell` and `executable` arguments for additional differences from the default behavior .", "question_id": 9601}
{"snippet": "subprocess.Popen(args, stdin=None)", "intent": "Execute a child program in a new process . `args` should be a sequence of program arguments or else a single string . `stdin` , `stdout` and `stderr` specify the executed program \u2019 s standard input , standard output and standard error file handles , respectively .", "question_id": 9602}
{"snippet": "subprocess.Popen(args, stdout=None)", "intent": "Execute a child program in a new process . `args` should be a sequence of program arguments or else a single string . `stdin` , `stdout` and `stderr` specify the executed program \u2019 s standard input , standard output and standard error file handles , respectively .", "question_id": 9603}
{"snippet": "subprocess.Popen(args, stderr=None)", "intent": "Execute a child program in a new process . `args` should be a sequence of program arguments or else a single string . `stdin` , `stdout` and `stderr` specify the executed program \u2019 s standard input , standard output and standard error file handles , respectively .", "question_id": 9604}
{"snippet": "subprocess.Popen(args, preexec_fn=None)", "intent": "Execute a child program in a new process . `args` should be a sequence of program arguments or else a single string . If `preexec_fn` is set to a callable object , this object will be called in the child process just before the child is executed .", "question_id": 9605}
{"snippet": "subprocess.Popen(args, close_fds=True)", "intent": "Execute a child program in a new process . `args` should be a sequence of program arguments or else a single string . If `close_fds` is true , all file descriptors except 0 , 1 and 2 will be closed before the child process is executed .", "question_id": 9606}
{"snippet": "subprocess.Popen(args, shell=False)", "intent": "Execute a child program in a new process . `args` should be a sequence of program arguments or else a single string . See the `shell` and `executable` arguments for additional differences from the default behavior .", "question_id": 9607}
{"snippet": "subprocess.Popen(args, cwd=None)", "intent": "Execute a child program in a new process . `args` should be a sequence of program arguments or else a single string . If `cwd` is not None , the function changes the working directory to cwd before executing the child .", "question_id": 9608}
{"snippet": "Popen.poll()", "intent": "Check if child process has terminated .", "question_id": 9609}
{"snippet": "Popen.wait()", "intent": "Wait for child process to terminate .", "question_id": 9610}
{"snippet": "Popen.wait(timeout=None)", "intent": "Wait for child process to terminate . If the process does not terminate after `timeout` seconds , raise a TimeoutExpired exception .", "question_id": 9611}
{"snippet": "Popen.communicate()", "intent": "Interact with process : Send data to stdin .", "question_id": 9612}
{"snippet": "Popen.communicate(input=None)", "intent": "Interact with process : Send data to stdin . The optional `input` argument should be data to be sent to the child process , or None , if no data should be sent to the child .", "question_id": 9613}
{"snippet": "Popen.communicate(timeout=None)", "intent": "Interact with process : Send data to stdin . If the process does not terminate after `timeout` seconds , a TimeoutExpired exception will be raised .", "question_id": 9614}
{"snippet": "Popen.communicate(input=None, timeout=None)", "intent": "Interact with process : Send data to stdin . The optional `input` argument should be data to be sent to the child process , or None , if no data should be sent to the child . If the process does not terminate after `timeout` seconds , a TimeoutExpired exception will be raised .", "question_id": 9615}
{"snippet": "Popen.send_signal(signal)", "intent": "Sends the `signal` signal to the child .", "question_id": 9616}
{"snippet": "Popen.terminate()", "intent": "Stop the child .", "question_id": 9617}
{"snippet": "Popen.kill()", "intent": "Kills the child .", "question_id": 9618}
{"snippet": "Popen.args", "intent": "The args argument as it was passed to Popen \u2013 a sequence of program arguments or else a single string.", "question_id": 9619}
{"snippet": "Popen.stdin", "intent": "If the stdin argument was PIPE, this attribute is a writeable stream object as returned by open().", "question_id": 9620}
{"snippet": "Popen.stdout", "intent": "If the stdout argument was PIPE, this attribute is a readable stream object as returned by open().", "question_id": 9621}
{"snippet": "Popen.stderr", "intent": "If the stderr argument was PIPE, this attribute is a readable stream object as returned by open().", "question_id": 9622}
{"snippet": "Popen.pid", "intent": "The process ID of the child process.", "question_id": 9623}
{"snippet": "Popen.returncode", "intent": "The child return code, set by poll() and wait() (and indirectly by communicate()).", "question_id": 9624}
{"snippet": "subprocess.STARTUPINFO()", "intent": "Partial support of the Windows STARTUPINFO structure is used for Popen creation .", "question_id": 9625}
{"snippet": "subprocess.STARTUPINFO(dwFlags=0)", "intent": "Partial support of the Windows STARTUPINFO structure is used for Popen creation . With arguments `dwFlags`.", "question_id": 9626}
{"snippet": "subprocess.STARTUPINFO(hStdInput=None)", "intent": "Partial support of the Windows STARTUPINFO structure is used for Popen creation . With arguments `hStdInput`.", "question_id": 9627}
{"snippet": "subprocess.STARTUPINFO(hStdOutput=None)", "intent": "Partial support of the Windows STARTUPINFO structure is used for Popen creation . With arguments `hStdOutput`.", "question_id": 9628}
{"snippet": "subprocess.STARTUPINFO(hStdError=None)", "intent": "Partial support of the Windows STARTUPINFO structure is used for Popen creation . With arguments `hStdError`.", "question_id": 9629}
{"snippet": "subprocess.STARTUPINFO(wShowWindow=0)", "intent": "Partial support of the Windows STARTUPINFO structure is used for Popen creation . With arguments `wShowWindow`.", "question_id": 9630}
{"snippet": "subprocess.STARTUPINFO(lpAttributeList=None)", "intent": "Partial support of the Windows STARTUPINFO structure is used for Popen creation . With arguments `lpAttributeList`.", "question_id": 9631}
{"snippet": "subprocess.STARTUPINFO(dwFlags=0, hStdInput=None)", "intent": "Partial support of the Windows STARTUPINFO structure is used for Popen creation . With arguments `dwFlags`, `hStdInput`.", "question_id": 9632}
{"snippet": "subprocess.STARTUPINFO(dwFlags=0, hStdOutput=None)", "intent": "Partial support of the Windows STARTUPINFO structure is used for Popen creation . With arguments `dwFlags`, `hStdOutput`.", "question_id": 9633}
{"snippet": "subprocess.STARTUPINFO(dwFlags=0, hStdError=None)", "intent": "Partial support of the Windows STARTUPINFO structure is used for Popen creation . With arguments `dwFlags`, `hStdError`.", "question_id": 9634}
{"snippet": "startupinfo.dwFlags", "intent": "A bit field that determines whether certain STARTUPINFO attributes are used when the process creates a window.", "question_id": 9635}
{"snippet": "startupinfo.hStdInput", "intent": "If dwFlags specifies STARTF_USESTDHANDLES, this attribute is the standard input handle for the process.", "question_id": 9636}
{"snippet": "startupinfo.hStdOutput", "intent": "If dwFlags specifies STARTF_USESTDHANDLES, this attribute is the standard output handle for the process.", "question_id": 9637}
{"snippet": "startupinfo.hStdError", "intent": "If dwFlags specifies STARTF_USESTDHANDLES, this attribute is the standard error handle for the process.", "question_id": 9638}
{"snippet": "startupinfo.wShowWindow", "intent": "If dwFlags specifies STARTF_USESHOWWINDOW, this attribute can be any of the values that can be specified in the nCmdShow parameter for the ShowWindow function, except for SW_SHOWDEFAULT.", "question_id": 9639}
{"snippet": "startupinfo.lpAttributeList", "intent": "A dictionary of additional attributes for process creation as given in STARTUPINFOEX, see UpdateProcThreadAttribute.", "question_id": 9640}
{"snippet": "subprocess.STD_INPUT_HANDLE", "intent": "The standard input device.", "question_id": 9641}
{"snippet": "subprocess.STD_OUTPUT_HANDLE", "intent": "The standard output device.", "question_id": 9642}
{"snippet": "subprocess.STD_ERROR_HANDLE", "intent": "The standard error device.", "question_id": 9643}
{"snippet": "subprocess.SW_HIDE", "intent": "Hides the window.", "question_id": 9644}
{"snippet": "subprocess.STARTF_USESTDHANDLES", "intent": "Specifies that the STARTUPINFO.hStdInput, STARTUPINFO.hStdOutput, and STARTUPINFO.hStdError attributes contain additional information.", "question_id": 9645}
{"snippet": "subprocess.STARTF_USESHOWWINDOW", "intent": "Specifies that the STARTUPINFO.wShowWindow attribute contains additional information.", "question_id": 9646}
{"snippet": "subprocess.CREATE_NEW_CONSOLE", "intent": "The new process has a new console, instead of inheriting its parent\u2019s console (the default).", "question_id": 9647}
{"snippet": "subprocess.CREATE_NEW_PROCESS_GROUP", "intent": "A Popen creationflags parameter to specify that a new process group will be created.", "question_id": 9648}
{"snippet": "subprocess.ABOVE_NORMAL_PRIORITY_CLASS", "intent": "A Popen creationflags parameter to specify that a new process will have an above average priority.", "question_id": 9649}
{"snippet": "subprocess.BELOW_NORMAL_PRIORITY_CLASS", "intent": "A Popen creationflags parameter to specify that a new process will have a below average priority.", "question_id": 9650}
{"snippet": "subprocess.HIGH_PRIORITY_CLASS", "intent": "A Popen creationflags parameter to specify that a new process will have a high priority.", "question_id": 9651}
{"snippet": "subprocess.IDLE_PRIORITY_CLASS", "intent": "A Popen creationflags parameter to specify that a new process will have an idle (lowest) priority.", "question_id": 9652}
{"snippet": "subprocess.NORMAL_PRIORITY_CLASS", "intent": "A Popen creationflags parameter to specify that a new process will have an normal priority.", "question_id": 9653}
{"snippet": "subprocess.REALTIME_PRIORITY_CLASS", "intent": "A Popen creationflags parameter to specify that a new process will have realtime priority.", "question_id": 9654}
{"snippet": "subprocess.CREATE_NO_WINDOW", "intent": "A Popen creationflags parameter to specify that a new process will not create a window.", "question_id": 9655}
{"snippet": "subprocess.DETACHED_PROCESS", "intent": "A Popen creationflags parameter to specify that a new process will not inherit its parent\u2019s console.", "question_id": 9656}
{"snippet": "subprocess.CREATE_DEFAULT_ERROR_MODE", "intent": "A Popen creationflags parameter to specify that a new process does not inherit the error mode of the calling process.", "question_id": 9657}
{"snippet": "subprocess.CREATE_BREAKAWAY_FROM_JOB", "intent": "A Popen creationflags parameter to specify that a new process is not associated with the job.", "question_id": 9658}
{"snippet": "subprocess.call(args)", "intent": "Run the command described by `args` .", "question_id": 9659}
{"snippet": "subprocess.call(args, stdin=None)", "intent": "Run the command described by `args` . With arguments `stdin`.", "question_id": 9660}
{"snippet": "subprocess.call(args, stdout=None)", "intent": "Run the command described by `args` . Code needing to capture `stdout` or `stderr` should use run ( ) instead :", "question_id": 9661}
{"snippet": "subprocess.call(args, stderr=None)", "intent": "Run the command described by `args` . Code needing to capture `stdout` or `stderr` should use run ( ) instead :", "question_id": 9662}
{"snippet": "subprocess.call(args, shell=False)", "intent": "Run the command described by `args` . With arguments `shell`.", "question_id": 9663}
{"snippet": "subprocess.call(args, cwd=None)", "intent": "Run the command described by `args` . With arguments `cwd`.", "question_id": 9664}
{"snippet": "subprocess.call(args, timeout=None)", "intent": "Run the command described by `args` . The full function signature is the same as that of the Popen constructor - this function passes all supplied arguments other than `timeout` directly through to that interface .", "question_id": 9665}
{"snippet": "subprocess.call(args, stdin=None, stdout=None)", "intent": "Run the command described by `args` . Code needing to capture `stdout` or `stderr` should use run ( ) instead : With arguments `stdin`.", "question_id": 9666}
{"snippet": "subprocess.call(args, stdin=None, stderr=None)", "intent": "Run the command described by `args` . Code needing to capture `stdout` or `stderr` should use run ( ) instead : With arguments `stdin`.", "question_id": 9667}
{"snippet": "subprocess.call(args, stdin=None, shell=False)", "intent": "Run the command described by `args` . With arguments `stdin`, `shell`.", "question_id": 9668}
{"snippet": "subprocess.check_call(args)", "intent": "Run command with arguments . With arguments `args`.", "question_id": 9669}
{"snippet": "subprocess.check_call(args, stdin=None)", "intent": "Run command with arguments . With arguments `args`, `stdin`.", "question_id": 9670}
{"snippet": "subprocess.check_call(args, stdout=None)", "intent": "Run command with arguments . Code needing to capture `stdout` or `stderr` should use run ( ) instead : With arguments `args`.", "question_id": 9671}
{"snippet": "subprocess.check_call(args, stderr=None)", "intent": "Run command with arguments . Code needing to capture `stdout` or `stderr` should use run ( ) instead : With arguments `args`.", "question_id": 9672}
{"snippet": "subprocess.check_call(args, shell=False)", "intent": "Run command with arguments . With arguments `args`, `shell`.", "question_id": 9673}
{"snippet": "subprocess.check_call(args, cwd=None)", "intent": "Run command with arguments . With arguments `args`, `cwd`.", "question_id": 9674}
{"snippet": "subprocess.check_call(args, timeout=None)", "intent": "Run command with arguments . The full function signature is the same as that of the Popen constructor - this function passes all supplied arguments other than `timeout` directly through to that interface . With arguments `args`.", "question_id": 9675}
{"snippet": "subprocess.check_call(args, stdin=None, stdout=None)", "intent": "Run command with arguments . Code needing to capture `stdout` or `stderr` should use run ( ) instead : With arguments `args`, `stdin`.", "question_id": 9676}
{"snippet": "subprocess.check_call(args, stdin=None, stderr=None)", "intent": "Run command with arguments . Code needing to capture `stdout` or `stderr` should use run ( ) instead : With arguments `args`, `stdin`.", "question_id": 9677}
{"snippet": "subprocess.check_call(args, stdin=None, shell=False)", "intent": "Run command with arguments . With arguments `args`, `stdin`, `shell`.", "question_id": 9678}
{"snippet": "subprocess.check_output(args)", "intent": "Run command with arguments and return its output . With arguments `args`.", "question_id": 9679}
{"snippet": "subprocess.check_output(args, stdin=None)", "intent": "Run command with arguments and return its output . With arguments `args`, `stdin`.", "question_id": 9680}
{"snippet": "subprocess.check_output(args, stderr=None)", "intent": "Run command with arguments and return its output . With arguments `args`, `stderr`.", "question_id": 9681}
{"snippet": "subprocess.check_output(args, shell=False)", "intent": "Run command with arguments and return its output . With arguments `args`, `shell`.", "question_id": 9682}
{"snippet": "subprocess.check_output(args, cwd=None)", "intent": "Run command with arguments and return its output . With arguments `args`, `cwd`.", "question_id": 9683}
{"snippet": "subprocess.check_output(args, encoding=None)", "intent": "Run command with arguments and return its output . The actual `encoding` of the output data may depend on the command being invoked , so the decoding to `text` will often need to be handled at the application level . With arguments `args`.", "question_id": 9684}
{"snippet": "subprocess.check_output(args, errors=None)", "intent": "Run command with arguments and return its output . This behaviour may be overridden by setting text , encoding , `errors` , or `universal_newlines` to True as described in Frequently Used Arguments and run ( ) . With arguments `args`.", "question_id": 9685}
{"snippet": "subprocess.check_output(args, universal_newlines=None)", "intent": "Run command with arguments and return its output . This behaviour may be overridden by setting text , encoding , `errors` , or `universal_newlines` to True as described in Frequently Used Arguments and run ( ) . With arguments `args`.", "question_id": 9686}
{"snippet": "subprocess.check_output(args, timeout=None)", "intent": "Run command with arguments and return its output . With arguments `args`, `timeout`.", "question_id": 9687}
{"snippet": "subprocess.check_output(args, text=None)", "intent": "Run command with arguments and return its output . The actual `encoding` of the output data may depend on the command being invoked , so the decoding to `text` will often need to be handled at the application level . With arguments `args`.", "question_id": 9688}
{"snippet": "subprocess.getstatusoutput(cmd)", "intent": "Return ( exitcode , output ) of executing `cmd` in a shell .", "question_id": 9689}
{"snippet": "subprocess.getoutput(cmd)", "intent": "Return output ( stdout and stderr ) of executing `cmd` in a shell .", "question_id": 9690}
{"snippet": "sunau.open(file, mode)", "intent": "If `file` is a string , open the file by that name , otherwise treat it as a seekable file-like object . `mode` can be any of", "question_id": 9691}
{"snippet": "sunau.openfp(file, mode)", "intent": "A synonym for open ( ) , maintained for backwards compatibility . With arguments `file`, `mode`.", "question_id": 9692}
{"snippet": "sunau.Error", "intent": "An error raised when something is impossible because of Sun AU specs or implementation deficiency.", "question_id": 9693}
{"snippet": "sunau.AUDIO_FILE_MAGIC", "intent": "An integer every valid Sun AU file begins with, stored in big-endian form.", "question_id": 9694}
{"snippet": "sunau.AUDIO_FILE_ENCODING_MULAW_8", "intent": "Values of the encoding field from the AU header which are supported by this module.", "question_id": 9695}
{"snippet": "sunau.AUDIO_FILE_ENCODING_LINEAR_8", "intent": "Values of the encoding field from the AU header which are supported by this module.", "question_id": 9696}
{"snippet": "sunau.AUDIO_FILE_ENCODING_LINEAR_16", "intent": "Values of the encoding field from the AU header which are supported by this module.", "question_id": 9697}
{"snippet": "sunau.AUDIO_FILE_ENCODING_LINEAR_24", "intent": "Values of the encoding field from the AU header which are supported by this module.", "question_id": 9698}
{"snippet": "sunau.AUDIO_FILE_ENCODING_LINEAR_32", "intent": "Values of the encoding field from the AU header which are supported by this module.", "question_id": 9699}
{"snippet": "sunau.AUDIO_FILE_ENCODING_ALAW_8", "intent": "Values of the encoding field from the AU header which are supported by this module.", "question_id": 9700}
{"snippet": "sunau.AUDIO_FILE_ENCODING_FLOAT", "intent": "Additional known values of the encoding field from the AU header, but which are not supported by this module.", "question_id": 9701}
{"snippet": "sunau.AUDIO_FILE_ENCODING_DOUBLE", "intent": "Additional known values of the encoding field from the AU header, but which are not supported by this module.", "question_id": 9702}
{"snippet": "sunau.AUDIO_FILE_ENCODING_ADPCM_G721", "intent": "Additional known values of the encoding field from the AU header, but which are not supported by this module.", "question_id": 9703}
{"snippet": "sunau.AUDIO_FILE_ENCODING_ADPCM_G722", "intent": "Additional known values of the encoding field from the AU header, but which are not supported by this module.", "question_id": 9704}
{"snippet": "sunau.AUDIO_FILE_ENCODING_ADPCM_G723_3", "intent": "Additional known values of the encoding field from the AU header, but which are not supported by this module.", "question_id": 9705}
{"snippet": "sunau.AUDIO_FILE_ENCODING_ADPCM_G723_5", "intent": "Additional known values of the encoding field from the AU header, but which are not supported by this module.", "question_id": 9706}
{"snippet": "AU_read.close()", "intent": "Close the stream , and make the instance unusable .", "question_id": 9707}
{"snippet": "AU_read.getnchannels()", "intent": "Returns number of audio channels ( 1 for mono , 2 for stereo ) .", "question_id": 9708}
{"snippet": "AU_read.getsampwidth()", "intent": "Returns sample width in bytes .", "question_id": 9709}
{"snippet": "AU_read.getframerate()", "intent": "Returns sampling frequency .", "question_id": 9710}
{"snippet": "AU_read.getnframes()", "intent": "Returns number of audio frames .", "question_id": 9711}
{"snippet": "AU_read.getcomptype()", "intent": "Returns compression type .", "question_id": 9712}
{"snippet": "AU_read.getcompname()", "intent": "Human-readable version of getcomptype ( ) .", "question_id": 9713}
{"snippet": "AU_read.getparams()", "intent": "Returns a namedtuple ( ) ( nchannels , sampwidth , framerate , nframes , comptype , compname ) , equivalent to output of the get* ( ) methods .", "question_id": 9714}
{"snippet": "AU_read.readframes(n)", "intent": "Reads and returns at most `n` frames of audio , as a bytes object .", "question_id": 9715}
{"snippet": "AU_read.rewind()", "intent": "Rewind the file pointer to the beginning of the audio stream .", "question_id": 9716}
{"snippet": "AU_read.setpos(pos)", "intent": "Set the file pointer to the specified position . Only values returned from tell ( ) should be used for `pos` .", "question_id": 9717}
{"snippet": "AU_read.tell()", "intent": "Return current file pointer position .", "question_id": 9718}
{"snippet": "AU_read.getmarkers()", "intent": "Returns None .", "question_id": 9719}
{"snippet": "AU_read.getmark(id)", "intent": "Raise an error . With arguments `id`.", "question_id": 9720}
{"snippet": "AU_write.setnchannels(n)", "intent": "Set the number of channels . With arguments `n`.", "question_id": 9721}
{"snippet": "AU_write.setsampwidth(n)", "intent": "Set the sample width ( in bytes . ) With arguments `n`.", "question_id": 9722}
{"snippet": "AU_write.setframerate(n)", "intent": "Set the frame rate . With arguments `n`.", "question_id": 9723}
{"snippet": "AU_write.setnframes(n)", "intent": "Set the number of frames . With arguments `n`.", "question_id": 9724}
{"snippet": "AU_write.setcomptype(type, name)", "intent": "Set the compression `type` and description . With arguments `name`.", "question_id": 9725}
{"snippet": "AU_write.setparams(tuple)", "intent": "The `tuple` should be ( nchannels , sampwidth , framerate , nframes , comptype , compname ) , with values valid for the set* ( ) methods .", "question_id": 9726}
{"snippet": "AU_write.tell()", "intent": "Return current position in the file , with the same disclaimer for the AU_read.tell ( ) and AU_read.setpos ( ) methods .", "question_id": 9727}
{"snippet": "AU_write.writeframesraw(data)", "intent": "Write audio frames , without correcting nframes . With arguments `data`.", "question_id": 9728}
{"snippet": "AU_write.writeframes(data)", "intent": "Write audio frames and make sure nframes is correct . With arguments `data`.", "question_id": 9729}
{"snippet": "AU_write.close()", "intent": "Make sure nframes is correct , and close the file .", "question_id": 9730}
{"snippet": "symbol.sym_name", "intent": "Dictionary mapping the numeric values of the constants defined in this module back to name strings, allowing more human-readable representation of parse trees to be generated.", "question_id": 9731}
{"snippet": "symtable.symtable(code, filename, compile_type)", "intent": "Return the toplevel SymbolTable for the Python source `code` . `filename` is the name of the file containing the code . `compile_type` is like the mode argument to compile ( ) .", "question_id": 9732}
{"snippet": "symtable.SymbolTable", "intent": "A namespace table for a block.", "question_id": 9733}
{"snippet": "symbol_table.get_type()", "intent": "Return the type of the symbol table .", "question_id": 9734}
{"snippet": "symbol_table.get_id()", "intent": "Return the table \u2019 s identifier .", "question_id": 9735}
{"snippet": "symbol_table.get_name()", "intent": "Return the table \u2019 s name .", "question_id": 9736}
{"snippet": "symbol_table.get_lineno()", "intent": "Return the number of the first line in the block this table represents .", "question_id": 9737}
{"snippet": "symbol_table.is_optimized()", "intent": "Return True if the locals in this table can be optimized .", "question_id": 9738}
{"snippet": "symbol_table.is_nested()", "intent": "Return True if the block is a nested class or function .", "question_id": 9739}
{"snippet": "symbol_table.has_children()", "intent": "Return True if the block has nested namespaces within it .", "question_id": 9740}
{"snippet": "symbol_table.has_exec()", "intent": "Return True if the block uses exec .", "question_id": 9741}
{"snippet": "symbol_table.get_identifiers()", "intent": "Return a list of names of symbols in this table .", "question_id": 9742}
{"snippet": "symbol_table.lookup(name)", "intent": "Lookup `name` in the table and return a Symbol instance .", "question_id": 9743}
{"snippet": "symbol_table.get_symbols()", "intent": "Return a list of Symbol instances for names in the table .", "question_id": 9744}
{"snippet": "symbol_table.get_children()", "intent": "Return a list of the nested symbol tables .", "question_id": 9745}
{"snippet": "symtable.Function", "intent": "A namespace for a function or method.", "question_id": 9746}
{"snippet": "function.get_parameters()", "intent": "Return a tuple containing names of parameters to this function .", "question_id": 9747}
{"snippet": "function.get_locals()", "intent": "Return a tuple containing names of locals in this function .", "question_id": 9748}
{"snippet": "function.get_globals()", "intent": "Return a tuple containing names of globals in this function .", "question_id": 9749}
{"snippet": "function.get_frees()", "intent": "Return a tuple containing names of free variables in this function .", "question_id": 9750}
{"snippet": "symtable.Class", "intent": "A namespace of a class.", "question_id": 9751}
{"snippet": "class.get_methods()", "intent": "Return a tuple containing the names of methods declared in the class .", "question_id": 9752}
{"snippet": "symtable.Symbol", "intent": "An entry in a SymbolTable corresponding to an identifier in the source.", "question_id": 9753}
{"snippet": "symbol.get_name()", "intent": "Return the symbol \u2019 s name .", "question_id": 9754}
{"snippet": "symbol.is_referenced()", "intent": "Return True if the symbol is used in its block .", "question_id": 9755}
{"snippet": "symbol.is_imported()", "intent": "Return True if the symbol is created from an import statement .", "question_id": 9756}
{"snippet": "symbol.is_parameter()", "intent": "Return True if the symbol is a parameter .", "question_id": 9757}
{"snippet": "symbol.is_global()", "intent": "Return True if the symbol is global .", "question_id": 9758}
{"snippet": "symbol.is_declared_global()", "intent": "Return True if the symbol is declared global with a global statement .", "question_id": 9759}
{"snippet": "symbol.is_local()", "intent": "Return True if the symbol is local to its block .", "question_id": 9760}
{"snippet": "symbol.is_free()", "intent": "Return True if the symbol is referenced in its block , but not assigned to .", "question_id": 9761}
{"snippet": "symbol.is_assigned()", "intent": "Return True if the symbol is assigned to in its block .", "question_id": 9762}
{"snippet": "symbol.is_namespace()", "intent": "Return True if name binding introduces new namespace .", "question_id": 9763}
{"snippet": "symbol.get_namespaces()", "intent": "Return a list of namespaces bound to this name .", "question_id": 9764}
{"snippet": "symbol.get_namespace()", "intent": "Return the namespace bound to this name .", "question_id": 9765}
{"snippet": "sys.abiflags", "intent": "On POSIX systems where Python was built with the standard configure script, this contains the ABI flags as specified by PEP 3149.", "question_id": 9766}
{"snippet": "sys.argv", "intent": "The list of command line arguments passed to a Python script.", "question_id": 9767}
{"snippet": "sys.base_exec_prefix", "intent": "Set during Python startup, before site.py is run, to the same value as exec_prefix.", "question_id": 9768}
{"snippet": "sys.base_prefix", "intent": "Set during Python startup, before site.py is run, to the same value as prefix.", "question_id": 9769}
{"snippet": "sys.byteorder", "intent": "An indicator of the native byte order.", "question_id": 9770}
{"snippet": "sys.builtin_module_names", "intent": "A tuple of strings giving the names of all modules that are compiled into this Python interpreter.", "question_id": 9771}
{"snippet": "sys.call_tracing(func, args)", "intent": "Call `func` ( *args ) , while tracing is enabled . With arguments `args`.", "question_id": 9772}
{"snippet": "sys.copyright", "intent": "A string containing the copyright pertaining to the Python interpreter.", "question_id": 9773}
{"snippet": "sys._clear_type_cache()", "intent": "Clear the internal type cache .", "question_id": 9774}
{"snippet": "sys._current_frames()", "intent": "Return a dictionary mapping each thread \u2019 s identifier to the topmost stack frame currently active in that thread at the time the function is called .", "question_id": 9775}
{"snippet": "sys.breakpointhook()", "intent": "This hook function is called by built-in breakpoint ( ) .", "question_id": 9776}
{"snippet": "sys._debugmallocstats()", "intent": "Print low-level information to stderr about the state of CPython \u2019 s memory allocator .", "question_id": 9777}
{"snippet": "sys.dllhandle", "intent": "Integer specifying the handle of the Python DLL.", "question_id": 9778}
{"snippet": "sys.displayhook(value)", "intent": "If `value` is not None , this function prints repr ( value ) to sys.stdout , and saves value in builtins._ .", "question_id": 9779}
{"snippet": "sys.dont_write_bytecode", "intent": "If this is true, Python won\u2019t try to write .pyc files on the import of source modules.", "question_id": 9780}
{"snippet": "sys.excepthook(type, value, traceback)", "intent": "This function prints out a given `traceback` and exception to sys.stderr . With arguments `type`, `value`.", "question_id": 9781}
{"snippet": "sys.__breakpointhook__", "intent": "These objects contain the original values of breakpointhook, displayhook, and excepthook at the start of the program.", "question_id": 9782}
{"snippet": "sys.__displayhook__", "intent": "These objects contain the original values of breakpointhook, displayhook, and excepthook at the start of the program.", "question_id": 9783}
{"snippet": "sys.__excepthook__", "intent": "These objects contain the original values of breakpointhook, displayhook, and excepthook at the start of the program.", "question_id": 9784}
{"snippet": "sys.exc_info()", "intent": "This function returns a tuple of three values that give information about the exception that is currently being handled .", "question_id": 9785}
{"snippet": "sys.exec_prefix", "intent": "A string giving the site-specific directory prefix where the platform-dependent Python files are installed; by default, this is also '/usr/local'.", "question_id": 9786}
{"snippet": "sys.executable", "intent": "A string giving the absolute path of the executable binary for the Python interpreter, on systems where this makes sense.", "question_id": 9787}
{"snippet": "sys.exit(arg)", "intent": "Exit from Python . The optional argument `arg` can be an integer giving the exit status ( defaulting to zero ) , or another type of object .", "question_id": 9788}
{"snippet": "sys.exit()", "intent": "Exit from Python .", "question_id": 9789}
{"snippet": "sys.flags", "intent": "The named tuple flags exposes the status of command line flags.", "question_id": 9790}
{"snippet": "sys.float_info", "intent": "A named tuple holding information about the float type.", "question_id": 9791}
{"snippet": "sys.float_repr_style", "intent": "A string indicating how the repr() function behaves for floats.", "question_id": 9792}
{"snippet": "sys.getallocatedblocks()", "intent": "Return the number of memory blocks currently allocated by the interpreter , regardless of their size .", "question_id": 9793}
{"snippet": "sys.getandroidapilevel()", "intent": "Return the build time API version of Android as an integer .", "question_id": 9794}
{"snippet": "sys.getcheckinterval()", "intent": "Return the interpreter \u2019 s \u201c check interval \u201d ; see setcheckinterval ( ) .", "question_id": 9795}
{"snippet": "sys.getdefaultencoding()", "intent": "Return the name of the current default string encoding used by the Unicode implementation .", "question_id": 9796}
{"snippet": "sys.getdlopenflags()", "intent": "Return the current value of the flags that are used for dlopen ( ) calls .", "question_id": 9797}
{"snippet": "sys.getfilesystemencoding()", "intent": "Return the name of the encoding used to convert between Unicode filenames and bytes filenames .", "question_id": 9798}
{"snippet": "sys.getfilesystemencodeerrors()", "intent": "Return the name of the error mode used to convert between Unicode filenames and bytes filenames .", "question_id": 9799}
{"snippet": "sys.getrefcount(object)", "intent": "Return the reference count of the `object` .", "question_id": 9800}
{"snippet": "sys.getrecursionlimit()", "intent": "Return the current value of the recursion limit , the maximum depth of the Python interpreter stack .", "question_id": 9801}
{"snippet": "sys.getsizeof(object, default)", "intent": "Return the size of an `object` in bytes . If given , `default` will be returned if the object does not provide means to retrieve the size .", "question_id": 9802}
{"snippet": "sys.getsizeof(object)", "intent": "Return the size of an `object` in bytes .", "question_id": 9803}
{"snippet": "sys.getswitchinterval()", "intent": "Return the interpreter \u2019 s \u201c thread switch interval \u201d ; see setswitchinterval ( ) .", "question_id": 9804}
{"snippet": "sys._getframe(depth)", "intent": "Return a frame object from the call stack . If optional integer `depth` is given , return the frame object that many calls below the top of the stack .", "question_id": 9805}
{"snippet": "sys._getframe()", "intent": "Return a frame object from the call stack .", "question_id": 9806}
{"snippet": "sys.getprofile()", "intent": "Get the profiler function as set by setprofile ( ) .", "question_id": 9807}
{"snippet": "sys.gettrace()", "intent": "Get the trace function as set by settrace ( ) .", "question_id": 9808}
{"snippet": "sys.getwindowsversion()", "intent": "Return a named tuple describing the Windows version currently running .", "question_id": 9809}
{"snippet": "sys.get_asyncgen_hooks()", "intent": "Returns an asyncgen_hooks object , which is similar to a namedtuple of the form ( firstiter , finalizer ) , where firstiter and finalizer are expected to be either None or functions which take an asynchronous generator iterator as an argument , and are used to schedule finalization of an asynchronous generator by an event loop .", "question_id": 9810}
{"snippet": "sys.get_coroutine_origin_tracking_depth()", "intent": "Get the current coroutine origin tracking depth , as set by set_coroutine_origin_tracking_depth ( ) .", "question_id": 9811}
{"snippet": "sys.get_coroutine_wrapper()", "intent": "Returns None , or a wrapper set by set_coroutine_wrapper ( ) .", "question_id": 9812}
{"snippet": "sys.hash_info", "intent": "A named tuple giving parameters of the numeric hash implementation.", "question_id": 9813}
{"snippet": "sys.hexversion", "intent": "The version number encoded as a single integer.", "question_id": 9814}
{"snippet": "sys.implementation", "intent": "An object containing information about the implementation of the currently running Python interpreter.", "question_id": 9815}
{"snippet": "sys.int_info", "intent": "A named tuple that holds information about Python\u2019s internal representation of integers.", "question_id": 9816}
{"snippet": "sys.__interactivehook__", "intent": "When this attribute exists, its value is automatically called (with no arguments) when the interpreter is launched in interactive mode.", "question_id": 9817}
{"snippet": "sys.intern(string)", "intent": "Enter `string` in the table of \u201c interned \u201d strings and return the interned string \u2013 which is string itself or a copy .", "question_id": 9818}
{"snippet": "sys.is_finalizing()", "intent": "Return True if the Python interpreter is shutting down , False otherwise .", "question_id": 9819}
{"snippet": "sys.last_type", "intent": "These three variables are not always defined; they are set when an exception is not handled and the interpreter prints an error message and a stack traceback.", "question_id": 9820}
{"snippet": "sys.last_value", "intent": "These three variables are not always defined; they are set when an exception is not handled and the interpreter prints an error message and a stack traceback.", "question_id": 9821}
{"snippet": "sys.last_traceback", "intent": "These three variables are not always defined; they are set when an exception is not handled and the interpreter prints an error message and a stack traceback.", "question_id": 9822}
{"snippet": "sys.maxsize", "intent": "An integer giving the maximum value a variable of type Py_ssize_t can take.", "question_id": 9823}
{"snippet": "sys.maxunicode", "intent": "An integer giving the value of the largest Unicode code point, i.e.", "question_id": 9824}
{"snippet": "sys.meta_path", "intent": "A list of meta path finder objects that have their find_spec() methods called to see if one of the objects can find the module to be imported.", "question_id": 9825}
{"snippet": "sys.modules", "intent": "This is a dictionary that maps module names to modules which have already been loaded.", "question_id": 9826}
{"snippet": "sys.path", "intent": "A list of strings that specifies the search path for modules.", "question_id": 9827}
{"snippet": "sys.path_hooks", "intent": "A list of callables that take a path argument to try to create a finder for the path.", "question_id": 9828}
{"snippet": "sys.path_importer_cache", "intent": "A dictionary acting as a cache for finder objects.", "question_id": 9829}
{"snippet": "sys.platform", "intent": "This string contains a platform identifier that can be used to append platform-specific components to sys.path, for instance.", "question_id": 9830}
{"snippet": "sys.prefix", "intent": "A string giving the site-specific directory prefix where the platform independent Python files are installed; by default, this is the string '/usr/local'.", "question_id": 9831}
{"snippet": "sys.ps1", "intent": "Strings specifying the primary and secondary prompt of the interpreter.", "question_id": 9832}
{"snippet": "sys.ps2", "intent": "Strings specifying the primary and secondary prompt of the interpreter.", "question_id": 9833}
{"snippet": "sys.setcheckinterval(interval)", "intent": "Set the interpreter \u2019 s \u201c check `interval` \u201d .", "question_id": 9834}
{"snippet": "sys.setdlopenflags(n)", "intent": "Set the flags used by the interpreter for dlopen ( ) calls , such as when the interpreter loads extension modules . With arguments `n`.", "question_id": 9835}
{"snippet": "sys.setprofile(profilefunc)", "intent": "Set the system \u2019 s profile function , which allows you to implement a Python source code profiler in Python . With arguments `profilefunc`.", "question_id": 9836}
{"snippet": "sys.setrecursionlimit(limit)", "intent": "Set the maximum depth of the Python interpreter stack to `limit` .", "question_id": 9837}
{"snippet": "sys.setswitchinterval(interval)", "intent": "Set the interpreter \u2019 s thread switch `interval` ( in seconds ) .", "question_id": 9838}
{"snippet": "sys.settrace(tracefunc)", "intent": "Set the system \u2019 s trace function , which allows you to implement a Python source code debugger in Python . For more fine-grained usage , it \u2019 s possible to set a trace function by assigning frame.f_trace = `tracefunc` explicitly , rather than relying on it being set indirectly via the return value from an already installed trace function .", "question_id": 9839}
{"snippet": "sys.set_asyncgen_hooks(firstiter, finalizer)", "intent": "Accepts two optional keyword arguments which are callables that accept an asynchronous generator iterator as an argument . The `firstiter` callable will be called when an asynchronous generator is iterated for the first time . The `finalizer` will be called when an asynchronous generator is about to be garbage collected .", "question_id": 9840}
{"snippet": "sys.set_coroutine_origin_tracking_depth(depth)", "intent": "Allows enabling or disabling coroutine origin tracking . To enable , pass a `depth` value greater than zero ; this sets the number of frames whose information will be captured .", "question_id": 9841}
{"snippet": "sys.set_coroutine_wrapper(wrapper)", "intent": "Allows intercepting creation of coroutine objects ( only ones that are created by an async def function ; generators decorated with types.coroutine ( ) or asyncio.coroutine ( ) will not be intercepted ) . The `wrapper` argument must be either :", "question_id": 9842}
{"snippet": "sys._enablelegacywindowsfsencoding()", "intent": "Changes the default filesystem encoding and errors mode to \u2018 mbcs \u2019 and \u2018 replace \u2019 respectively , for consistency with versions of Python prior to 3.6 .", "question_id": 9843}
{"snippet": "sys.stdin", "intent": "File objects used by the interpreter for standard input, output and errors:", "question_id": 9844}
{"snippet": "sys.stdout", "intent": "File objects used by the interpreter for standard input, output and errors:", "question_id": 9845}
{"snippet": "sys.stderr", "intent": "File objects used by the interpreter for standard input, output and errors:", "question_id": 9846}
{"snippet": "sys.__stdin__", "intent": "These objects contain the original values of stdin, stderr and stdout at the start of the program.", "question_id": 9847}
{"snippet": "sys.__stdout__", "intent": "These objects contain the original values of stdin, stderr and stdout at the start of the program.", "question_id": 9848}
{"snippet": "sys.__stderr__", "intent": "These objects contain the original values of stdin, stderr and stdout at the start of the program.", "question_id": 9849}
{"snippet": "sys.thread_info", "intent": "A named tuple holding information about the thread implementation.", "question_id": 9850}
{"snippet": "sys.tracebacklimit", "intent": "When this variable is set to an integer value, it determines the maximum number of levels of traceback information printed when an unhandled exception occurs.", "question_id": 9851}
{"snippet": "sys.version", "intent": "A string containing the version number of the Python interpreter plus additional information on the build number and compiler used.", "question_id": 9852}
{"snippet": "sys.api_version", "intent": "The C API version for this interpreter.", "question_id": 9853}
{"snippet": "sys.version_info", "intent": "A tuple containing the five components of the version number: major, minor, micro, releaselevel, and serial.", "question_id": 9854}
{"snippet": "sys.warnoptions", "intent": "This is an implementation detail of the warnings framework; do not modify this value.", "question_id": 9855}
{"snippet": "sys.winver", "intent": "The version number used to form registry keys on Windows platforms.", "question_id": 9856}
{"snippet": "sys._xoptions", "intent": "A dictionary of the various implementation-specific flags passed through the -X command-line option.", "question_id": 9857}
{"snippet": "sysconfig.get_config_vars(*args)", "intent": "With no arguments , return a dictionary of all configuration variables relevant for the current platform . With arguments `*args`.", "question_id": 9858}
{"snippet": "sysconfig.get_config_var(name)", "intent": "Return the value of a single variable `name` .", "question_id": 9859}
{"snippet": "sysconfig.get_scheme_names()", "intent": "Return a tuple containing all schemes currently supported in sysconfig .", "question_id": 9860}
{"snippet": "sysconfig.get_path_names()", "intent": "Return a tuple containing all path names currently supported in sysconfig .", "question_id": 9861}
{"snippet": "sysconfig.get_path(name, scheme, vars, expand)", "intent": "Return an installation path corresponding to the path `name` , from the install `scheme` named scheme . If `vars` is provided , it must be a dictionary of variables that will update the dictionary return by get_config_vars ( ) . get_path ( ) will use the variables returned by get_config_vars ( ) to `expand` the path .", "question_id": 9862}
{"snippet": "sysconfig.get_path(name, scheme, vars)", "intent": "Return an installation path corresponding to the path `name` , from the install `scheme` named scheme . If `vars` is provided , it must be a dictionary of variables that will update the dictionary return by get_config_vars ( ) .", "question_id": 9863}
{"snippet": "sysconfig.get_path(name, scheme)", "intent": "Return an installation path corresponding to the path `name` , from the install `scheme` named scheme .", "question_id": 9864}
{"snippet": "sysconfig.get_path(name)", "intent": "Return an installation path corresponding to the path `name` , from the install `scheme` named scheme .", "question_id": 9865}
{"snippet": "sysconfig.get_paths(scheme, vars, expand)", "intent": "Return a dictionary containing all installation paths corresponding to an installation `scheme` . If `vars` is provided , it must be a dictionary of variables that will update the dictionary used to `expand` the paths .", "question_id": 9866}
{"snippet": "sysconfig.get_paths(scheme, vars)", "intent": "Return a dictionary containing all installation paths corresponding to an installation `scheme` . If `vars` is provided , it must be a dictionary of variables that will update the dictionary used to `expand` the paths .", "question_id": 9867}
{"snippet": "sysconfig.get_paths(scheme)", "intent": "Return a dictionary containing all installation paths corresponding to an installation `scheme` .", "question_id": 9868}
{"snippet": "sysconfig.get_paths()", "intent": "Return a dictionary containing all installation paths corresponding to an installation `scheme` .", "question_id": 9869}
{"snippet": "sysconfig.get_python_version()", "intent": "Return the MAJOR.MINOR Python version number as a string .", "question_id": 9870}
{"snippet": "sysconfig.get_platform()", "intent": "Return a string that identifies the current platform .", "question_id": 9871}
{"snippet": "sysconfig.is_python_build()", "intent": "Return True if the running Python interpreter was built from source and is being run from its built location , and not from a location resulting from e.g .", "question_id": 9872}
{"snippet": "sysconfig.parse_config_h(fp, vars)", "intent": "Parse a config.h-style file . `fp` is a file-like object pointing to the config.h-like file . With arguments `vars`.", "question_id": 9873}
{"snippet": "sysconfig.parse_config_h(fp)", "intent": "Parse a config.h-style file . `fp` is a file-like object pointing to the config.h-like file .", "question_id": 9874}
{"snippet": "sysconfig.get_config_h_filename()", "intent": "Return the path of pyconfig.h .", "question_id": 9875}
{"snippet": "sysconfig.get_makefile_filename()", "intent": "Return the path of Makefile .", "question_id": 9876}
{"snippet": "syslog.syslog(message)", "intent": "Send the string `message` to the system logger .", "question_id": 9877}
{"snippet": "syslog.syslog(priority, message)", "intent": "Send the string `message` to the system logger . Each message is tagged with a `priority` composed of a facility and a level .", "question_id": 9878}
{"snippet": "syslog.openlog(ident, logoption, facility)", "intent": "Logging options of subsequent syslog ( ) calls can be set by calling openlog ( ) . The optional `ident` keyword argument is a string which is prepended to every message , and defaults to sys.argv [ 0 ] with leading path components stripped . The optional `logoption` keyword argument ( default is 0 ) is a bit field \u2013 see below for possible values to combine . The optional `facility` keyword argument ( default is LOG_USER ) sets the default facility for messages which do not have a facility explicitly encoded .", "question_id": 9879}
{"snippet": "syslog.openlog(ident, logoption)", "intent": "Logging options of subsequent syslog ( ) calls can be set by calling openlog ( ) . The optional `ident` keyword argument is a string which is prepended to every message , and defaults to sys.argv [ 0 ] with leading path components stripped . The optional `logoption` keyword argument ( default is 0 ) is a bit field \u2013 see below for possible values to combine .", "question_id": 9880}
{"snippet": "syslog.openlog(ident)", "intent": "Logging options of subsequent syslog ( ) calls can be set by calling openlog ( ) . The optional `ident` keyword argument is a string which is prepended to every message , and defaults to sys.argv [ 0 ] with leading path components stripped .", "question_id": 9881}
{"snippet": "syslog.openlog()", "intent": "Logging options of subsequent syslog ( ) calls can be set by calling openlog ( ) .", "question_id": 9882}
{"snippet": "syslog.closelog()", "intent": "Reset the syslog module values and call the system library closelog ( ) .", "question_id": 9883}
{"snippet": "syslog.setlogmask(maskpri)", "intent": "Set the priority mask to `maskpri` and return the previous mask value .", "question_id": 9884}
{"snippet": "tabnanny.check(file_or_dir)", "intent": "If `file_or_dir` is a directory and not a symbolic link , then recursively descend the directory tree named by file_or_dir , checking all .py files along the way .", "question_id": 9885}
{"snippet": "tabnanny.verbose", "intent": "Flag indicating whether to print verbose messages.", "question_id": 9886}
{"snippet": "tabnanny.filename_only", "intent": "Flag indicating whether to print only the filenames of files containing whitespace related problems.", "question_id": 9887}
{"snippet": "tabnanny.NannyNag", "intent": "Raised by process_tokens() if detecting an ambiguous indent.", "question_id": 9888}
{"snippet": "tabnanny.process_tokens(tokens)", "intent": "This function is used by check ( ) to process `tokens` generated by the tokenize module .", "question_id": 9889}
{"snippet": "tarfile.open(**kwargs)", "intent": "Return a TarFile object for the pathname `name` . With arguments `**kwargs`.", "question_id": 9890}
{"snippet": "tarfile.open(**kwargs, name=None)", "intent": "Return a TarFile object for the pathname `name` . With arguments `**kwargs`.", "question_id": 9891}
{"snippet": "tarfile.open(**kwargs, mode='r')", "intent": "Return a TarFile object for the pathname `name` . `mode` has to be a string of the form 'filemode [ : compression ] ' , it defaults to ' r ' . With arguments `**kwargs`.", "question_id": 9892}
{"snippet": "tarfile.open(**kwargs, fileobj=None)", "intent": "Return a TarFile object for the pathname `name` . If `fileobj` is specified , it is used as an alternative to a file object opened in binary mode for name . With arguments `**kwargs`.", "question_id": 9893}
{"snippet": "tarfile.open(**kwargs, bufsize=10240)", "intent": "Return a TarFile object for the pathname `name` . `bufsize` specifies the blocksize and defaults to 20 * 512 bytes . With arguments `**kwargs`.", "question_id": 9894}
{"snippet": "tarfile.open(**kwargs, name=None, mode='r')", "intent": "Return a TarFile object for the pathname `name` . `mode` has to be a string of the form 'filemode [ : compression ] ' , it defaults to ' r ' . With arguments `**kwargs`.", "question_id": 9895}
{"snippet": "tarfile.open(**kwargs, name=None, fileobj=None)", "intent": "Return a TarFile object for the pathname `name` . If `fileobj` is specified , it is used as an alternative to a file object opened in binary mode for name . With arguments `**kwargs`.", "question_id": 9896}
{"snippet": "tarfile.open(**kwargs, name=None, bufsize=10240)", "intent": "Return a TarFile object for the pathname `name` . `bufsize` specifies the blocksize and defaults to 20 * 512 bytes . With arguments `**kwargs`.", "question_id": 9897}
{"snippet": "tarfile.open(**kwargs, mode='r', fileobj=None)", "intent": "Return a TarFile object for the pathname `name` . `mode` has to be a string of the form 'filemode [ : compression ] ' , it defaults to ' r ' . If `fileobj` is specified , it is used as an alternative to a file object opened in binary mode for name . With arguments `**kwargs`.", "question_id": 9898}
{"snippet": "tarfile.open(**kwargs, mode='r', bufsize=10240)", "intent": "Return a TarFile object for the pathname `name` . `mode` has to be a string of the form 'filemode [ : compression ] ' , it defaults to ' r ' . `bufsize` specifies the blocksize and defaults to 20 * 512 bytes . With arguments `**kwargs`.", "question_id": 9899}
{"snippet": "tarfile.TarFile", "intent": "Class for reading and writing tar archives.", "question_id": 9900}
{"snippet": "tarfile.is_tarfile(name)", "intent": "Return True if `name` is a tar archive file , that the tarfile module can read .", "question_id": 9901}
{"snippet": "tarfile.TarError", "intent": "Base class for all tarfile exceptions.", "question_id": 9902}
{"snippet": "tarfile.ReadError", "intent": "Is raised when a tar archive is opened, that either cannot be handled by the tarfile module or is somehow invalid.", "question_id": 9903}
{"snippet": "tarfile.CompressionError", "intent": "Is raised when a compression method is not supported or when the data cannot be decoded properly.", "question_id": 9904}
{"snippet": "tarfile.StreamError", "intent": "Is raised for the limitations that are typical for stream-like TarFile objects.", "question_id": 9905}
{"snippet": "tarfile.ExtractError", "intent": "Is raised for non-fatal errors when using TarFile.extract(), but only if TarFile.errorlevel== 2.", "question_id": 9906}
{"snippet": "tarfile.HeaderError", "intent": "Is raised by TarInfo.frombuf() if the buffer it gets is invalid.", "question_id": 9907}
{"snippet": "tarfile.ENCODING", "intent": "The default character encoding: 'utf-8' on Windows, the value returned by sys.getfilesystemencoding() otherwise.", "question_id": 9908}
{"snippet": "tarfile.USTAR_FORMAT", "intent": "POSIX.1-1988 (ustar) format.", "question_id": 9909}
{"snippet": "tarfile.GNU_FORMAT", "intent": "GNU tar format.", "question_id": 9910}
{"snippet": "tarfile.PAX_FORMAT", "intent": "POSIX.1-2001 (pax) format.", "question_id": 9911}
{"snippet": "tarfile.DEFAULT_FORMAT", "intent": "The default format for creating archives.", "question_id": 9912}
{"snippet": "tarfile.TarFile()", "intent": "All following arguments are optional and can be accessed as instance attributes as well .", "question_id": 9913}
{"snippet": "tarfile.TarFile(name=None)", "intent": "All following arguments are optional and can be accessed as instance attributes as well . `name` is the pathname of the archive .", "question_id": 9914}
{"snippet": "tarfile.TarFile(mode='r')", "intent": "All following arguments are optional and can be accessed as instance attributes as well . `mode` is either ' r ' to read from an existing archive , ' a ' to append data to an existing file , ' w ' to create a new file overwriting an existing one , or ' x ' to create a new file only if it does not already exist .", "question_id": 9915}
{"snippet": "tarfile.TarFile(fileobj=None)", "intent": "All following arguments are optional and can be accessed as instance attributes as well . It can be omitted if `fileobj` is given .", "question_id": 9916}
{"snippet": "tarfile.TarFile(format=DEFAULT_FORMAT)", "intent": "All following arguments are optional and can be accessed as instance attributes as well . `format` controls the archive format .", "question_id": 9917}
{"snippet": "tarfile.TarFile(tarinfo=TarInfo)", "intent": "All following arguments are optional and can be accessed as instance attributes as well . The `tarinfo` argument can be used to replace the default TarInfo class with a different one .", "question_id": 9918}
{"snippet": "tarfile.TarFile(dereference=False)", "intent": "All following arguments are optional and can be accessed as instance attributes as well . If `dereference` is False , add symbolic and hard links to the archive .", "question_id": 9919}
{"snippet": "tarfile.TarFile(ignore_zeros=False)", "intent": "All following arguments are optional and can be accessed as instance attributes as well . If `ignore_zeros` is False , treat an empty block as the end of the archive .", "question_id": 9920}
{"snippet": "tarfile.TarFile(encoding=ENCODING)", "intent": "All following arguments are optional and can be accessed as instance attributes as well . The `encoding` and errors arguments define the character encoding to be used for reading or writing the archive and how conversion errors are going to be handled .", "question_id": 9921}
{"snippet": "tarfile.TarFile(errors='surrogateescape')", "intent": "All following arguments are optional and can be accessed as instance attributes as well . If `errorlevel` is 0 , all `errors` are ignored when using TarFile.extract ( ) .", "question_id": 9922}
{"snippet": "TarFile.open()", "intent": "Alternative constructor .", "question_id": 9923}
{"snippet": "TarFile.getmember(name)", "intent": "Return a TarInfo object for member `name` .", "question_id": 9924}
{"snippet": "TarFile.getmembers()", "intent": "Return the members of the archive as a list of TarInfo objects .", "question_id": 9925}
{"snippet": "TarFile.getnames()", "intent": "Return the members as a list of their names .", "question_id": 9926}
{"snippet": "TarFile.list()", "intent": "Print a table of contents to sys.stdout .", "question_id": 9927}
{"snippet": "TarFile.list(verbose=True)", "intent": "Print a table of contents to sys.stdout . If `verbose` is False , only the names of the `members` are printed .", "question_id": 9928}
{"snippet": "TarFile.list(members=None)", "intent": "Print a table of contents to sys.stdout . If `verbose` is False , only the names of the `members` are printed .", "question_id": 9929}
{"snippet": "TarFile.list(verbose=True, members=None)", "intent": "Print a table of contents to sys.stdout . If `verbose` is False , only the names of the `members` are printed .", "question_id": 9930}
{"snippet": "TarFile.next()", "intent": "Return the next member of the archive as a TarInfo object , when TarFile is opened for reading .", "question_id": 9931}
{"snippet": "TarFile.extractall()", "intent": "Extract all `members` from the archive to the current working directory or directory `path` .", "question_id": 9932}
{"snippet": "TarFile.extractall(path=\".\")", "intent": "Extract all `members` from the archive to the current working directory or directory `path` .", "question_id": 9933}
{"snippet": "TarFile.extractall(members=None)", "intent": "Extract all `members` from the archive to the current working directory or directory `path` .", "question_id": 9934}
{"snippet": "TarFile.extractall(numeric_owner=False)", "intent": "Extract all `members` from the archive to the current working directory or directory `path` . If `numeric_owner` is True , the uid and gid numbers from the tarfile are used to set the owner/group for the extracted files .", "question_id": 9935}
{"snippet": "TarFile.extractall(path=\".\", members=None)", "intent": "Extract all `members` from the archive to the current working directory or directory `path` .", "question_id": 9936}
{"snippet": "TarFile.extractall(path=\".\", numeric_owner=False)", "intent": "Extract all `members` from the archive to the current working directory or directory `path` . If `numeric_owner` is True , the uid and gid numbers from the tarfile are used to set the owner/group for the extracted files .", "question_id": 9937}
{"snippet": "TarFile.extractall(members=None, numeric_owner=False)", "intent": "Extract all `members` from the archive to the current working directory or directory `path` . If `numeric_owner` is True , the uid and gid numbers from the tarfile are used to set the owner/group for the extracted files .", "question_id": 9938}
{"snippet": "TarFile.extractall(path=\".\", members=None, numeric_owner=False)", "intent": "Extract all `members` from the archive to the current working directory or directory `path` . If `numeric_owner` is True , the uid and gid numbers from the tarfile are used to set the owner/group for the extracted files .", "question_id": 9939}
{"snippet": "TarFile.extract(member)", "intent": "Extract a `member` from the archive to the current working directory , using its full name .", "question_id": 9940}
{"snippet": "TarFile.extract(member, path=\"\")", "intent": "Extract a `member` from the archive to the current working directory , using its full name . You can specify a different directory using `path` .", "question_id": 9941}
{"snippet": "TarFile.extract(member, set_attrs=True)", "intent": "Extract a `member` from the archive to the current working directory , using its full name . File attributes ( owner , mtime , mode ) are set unless `set_attrs` is false .", "question_id": 9942}
{"snippet": "TarFile.extract(member, numeric_owner=False)", "intent": "Extract a `member` from the archive to the current working directory , using its full name . If `numeric_owner` is True , the uid and gid numbers from the tarfile are used to set the owner/group for the extracted files .", "question_id": 9943}
{"snippet": "TarFile.extract(member, path=\"\", set_attrs=True)", "intent": "Extract a `member` from the archive to the current working directory , using its full name . You can specify a different directory using `path` . File attributes ( owner , mtime , mode ) are set unless `set_attrs` is false .", "question_id": 9944}
{"snippet": "TarFile.extract(member, path=\"\", numeric_owner=False)", "intent": "Extract a `member` from the archive to the current working directory , using its full name . You can specify a different directory using `path` . If `numeric_owner` is True , the uid and gid numbers from the tarfile are used to set the owner/group for the extracted files .", "question_id": 9945}
{"snippet": "TarFile.extract(member, set_attrs=True, numeric_owner=False)", "intent": "Extract a `member` from the archive to the current working directory , using its full name . File attributes ( owner , mtime , mode ) are set unless `set_attrs` is false . If `numeric_owner` is True , the uid and gid numbers from the tarfile are used to set the owner/group for the extracted files .", "question_id": 9946}
{"snippet": "TarFile.extract(member, path=\"\", set_attrs=True, numeric_owner=False)", "intent": "Extract a `member` from the archive to the current working directory , using its full name . You can specify a different directory using `path` . File attributes ( owner , mtime , mode ) are set unless `set_attrs` is false . If `numeric_owner` is True , the uid and gid numbers from the tarfile are used to set the owner/group for the extracted files .", "question_id": 9947}
{"snippet": "TarFile.extractfile(member)", "intent": "Extract a `member` from the archive as a file object .", "question_id": 9948}
{"snippet": "TarFile.add(name)", "intent": "Add the file `name` to the archive .", "question_id": 9949}
{"snippet": "TarFile.add(name, arcname=None)", "intent": "Add the file `name` to the archive . If given , `arcname` specifies an alternative name for the file in the archive .", "question_id": 9950}
{"snippet": "TarFile.add(name, recursive=True)", "intent": "Add the file `name` to the archive . This can be avoided by setting `recursive` to False .", "question_id": 9951}
{"snippet": "TarFile.add(name, filter=None)", "intent": "Add the file `name` to the archive . If `filter` is given , it should be a function that takes a TarInfo object argument and returns the changed TarInfo object .", "question_id": 9952}
{"snippet": "TarFile.add(name, arcname=None, recursive=True)", "intent": "Add the file `name` to the archive . If given , `arcname` specifies an alternative name for the file in the archive . This can be avoided by setting `recursive` to False .", "question_id": 9953}
{"snippet": "TarFile.add(name, arcname=None, filter=None)", "intent": "Add the file `name` to the archive . If given , `arcname` specifies an alternative name for the file in the archive . If `filter` is given , it should be a function that takes a TarInfo object argument and returns the changed TarInfo object .", "question_id": 9954}
{"snippet": "TarFile.add(name, recursive=True, filter=None)", "intent": "Add the file `name` to the archive . This can be avoided by setting `recursive` to False . If `filter` is given , it should be a function that takes a TarInfo object argument and returns the changed TarInfo object .", "question_id": 9955}
{"snippet": "TarFile.add(name, arcname=None, recursive=True, filter=None)", "intent": "Add the file `name` to the archive . If given , `arcname` specifies an alternative name for the file in the archive . This can be avoided by setting `recursive` to False . If `filter` is given , it should be a function that takes a TarInfo object argument and returns the changed TarInfo object .", "question_id": 9956}
{"snippet": "TarFile.addfile(tarinfo)", "intent": "Add the TarInfo object `tarinfo` to the archive .", "question_id": 9957}
{"snippet": "TarFile.addfile(tarinfo, fileobj=None)", "intent": "Add the TarInfo object `tarinfo` to the archive . If `fileobj` is given , it should be a binary file , and tarinfo.size bytes are read from it and added to the archive .", "question_id": 9958}
{"snippet": "TarFile.gettarinfo()", "intent": "Create a TarInfo object from the result of os.stat ( ) or equivalent on an existing file .", "question_id": 9959}
{"snippet": "TarFile.gettarinfo(name=None)", "intent": "Create a TarInfo object from the result of os.stat ( ) or equivalent on an existing file . The file is either named by `name` , or specified as a file object `fileobj` with a file descriptor .", "question_id": 9960}
{"snippet": "TarFile.gettarinfo(arcname=None)", "intent": "Create a TarInfo object from the result of os.stat ( ) or equivalent on an existing file . If given , `arcname` specifies an alternative name for the file in the archive , otherwise , the name is taken from fileobj \u2019 s name attribute , or the name argument .", "question_id": 9961}
{"snippet": "TarFile.gettarinfo(fileobj=None)", "intent": "Create a TarInfo object from the result of os.stat ( ) or equivalent on an existing file . The file is either named by `name` , or specified as a file object `fileobj` with a file descriptor .", "question_id": 9962}
{"snippet": "TarFile.gettarinfo(name=None, arcname=None)", "intent": "Create a TarInfo object from the result of os.stat ( ) or equivalent on an existing file . The file is either named by `name` , or specified as a file object `fileobj` with a file descriptor . If given , `arcname` specifies an alternative name for the file in the archive , otherwise , the name is taken from fileobj \u2019 s name attribute , or the name argument .", "question_id": 9963}
{"snippet": "TarFile.gettarinfo(name=None, fileobj=None)", "intent": "Create a TarInfo object from the result of os.stat ( ) or equivalent on an existing file . The file is either named by `name` , or specified as a file object `fileobj` with a file descriptor .", "question_id": 9964}
{"snippet": "TarFile.gettarinfo(arcname=None, fileobj=None)", "intent": "Create a TarInfo object from the result of os.stat ( ) or equivalent on an existing file . If given , `arcname` specifies an alternative name for the file in the archive , otherwise , the name is taken from fileobj \u2019 s name attribute , or the name argument . The file is either named by `name` , or specified as a file object `fileobj` with a file descriptor .", "question_id": 9965}
{"snippet": "TarFile.gettarinfo(name=None, arcname=None, fileobj=None)", "intent": "Create a TarInfo object from the result of os.stat ( ) or equivalent on an existing file . The file is either named by `name` , or specified as a file object `fileobj` with a file descriptor . If given , `arcname` specifies an alternative name for the file in the archive , otherwise , the name is taken from fileobj \u2019 s name attribute , or the name argument .", "question_id": 9966}
{"snippet": "TarFile.close()", "intent": "Close the TarFile .", "question_id": 9967}
{"snippet": "TarFile.pax_headers", "intent": "A dictionary containing key-value pairs of pax global headers.", "question_id": 9968}
{"snippet": "tarfile.TarInfo()", "intent": "Create a TarInfo object .", "question_id": 9969}
{"snippet": "tarfile.TarInfo(name=\"\")", "intent": "Create a TarInfo object . With arguments `name`.", "question_id": 9970}
{"snippet": "TarInfo.frombuf(buf, encoding, errors)", "intent": "Create and return a TarInfo object from string buffer `buf` . With arguments `encoding`, `errors`.", "question_id": 9971}
{"snippet": "TarInfo.fromtarfile(tarfile)", "intent": "Read the next member from the TarFile object `tarfile` and return it as a TarInfo object .", "question_id": 9972}
{"snippet": "TarInfo.tobuf()", "intent": "Create a string buffer from a TarInfo object .", "question_id": 9973}
{"snippet": "TarInfo.tobuf(format=DEFAULT_FORMAT)", "intent": "Create a string buffer from a TarInfo object . With arguments `format`.", "question_id": 9974}
{"snippet": "TarInfo.tobuf(encoding=ENCODING)", "intent": "Create a string buffer from a TarInfo object . With arguments `encoding`.", "question_id": 9975}
{"snippet": "TarInfo.tobuf(errors='surrogateescape')", "intent": "Create a string buffer from a TarInfo object . With arguments `errors`.", "question_id": 9976}
{"snippet": "TarInfo.tobuf(format=DEFAULT_FORMAT, encoding=ENCODING)", "intent": "Create a string buffer from a TarInfo object . With arguments `format`, `encoding`.", "question_id": 9977}
{"snippet": "TarInfo.tobuf(format=DEFAULT_FORMAT, errors='surrogateescape')", "intent": "Create a string buffer from a TarInfo object . With arguments `format`, `errors`.", "question_id": 9978}
{"snippet": "TarInfo.tobuf(encoding=ENCODING, errors='surrogateescape')", "intent": "Create a string buffer from a TarInfo object . With arguments `encoding`, `errors`.", "question_id": 9979}
{"snippet": "TarInfo.tobuf(format=DEFAULT_FORMAT, encoding=ENCODING, errors='surrogateescape')", "intent": "Create a string buffer from a TarInfo object . With arguments `format`, `encoding`, `errors`.", "question_id": 9980}
{"snippet": "TarInfo.name", "intent": "Name of the archive member.", "question_id": 9981}
{"snippet": "TarInfo.size", "intent": "Size in bytes.", "question_id": 9982}
{"snippet": "TarInfo.mtime", "intent": "Time of last modification.", "question_id": 9983}
{"snippet": "TarInfo.mode", "intent": "Permission bits.", "question_id": 9984}
{"snippet": "TarInfo.type", "intent": "File type.", "question_id": 9985}
{"snippet": "TarInfo.linkname", "intent": "Name of the target file name, which is only present in TarInfo objects of type LNKTYPE and SYMTYPE.", "question_id": 9986}
{"snippet": "TarInfo.uid", "intent": "User ID of the user who originally stored this member.", "question_id": 9987}
{"snippet": "TarInfo.gid", "intent": "Group ID of the user who originally stored this member.", "question_id": 9988}
{"snippet": "TarInfo.uname", "intent": "User name.", "question_id": 9989}
{"snippet": "TarInfo.gname", "intent": "Group name.", "question_id": 9990}
{"snippet": "TarInfo.pax_headers", "intent": "A dictionary containing key-value pairs of an associated pax extended header.", "question_id": 9991}
{"snippet": "TarInfo.isfile()", "intent": "Return True if the Tarinfo object is a regular file .", "question_id": 9992}
{"snippet": "TarInfo.isreg()", "intent": "Same as isfile ( ) .", "question_id": 9993}
{"snippet": "TarInfo.isdir()", "intent": "Return True if it is a directory .", "question_id": 9994}
{"snippet": "TarInfo.issym()", "intent": "Return True if it is a symbolic link .", "question_id": 9995}
{"snippet": "TarInfo.islnk()", "intent": "Return True if it is a hard link .", "question_id": 9996}
{"snippet": "TarInfo.ischr()", "intent": "Return True if it is a character device .", "question_id": 9997}
{"snippet": "TarInfo.isblk()", "intent": "Return True if it is a block device .", "question_id": 9998}
{"snippet": "TarInfo.isfifo()", "intent": "Return True if it is a FIFO .", "question_id": 9999}
{"snippet": "TarInfo.isdev()", "intent": "Return True if it is one of character device , block device or FIFO .", "question_id": 10000}
{"snippet": "telnetlib.Telnet(timeout)", "intent": "Telnet represents a connection to a Telnet server . The optional `timeout` parameter specifies a timeout in seconds for blocking operations like the connection attempt ( if not specified , the global default timeout setting will be used ) .", "question_id": 10001}
{"snippet": "telnetlib.Telnet(timeout, host=None)", "intent": "Telnet represents a connection to a Telnet server . The optional `timeout` parameter specifies a timeout in seconds for blocking operations like the connection attempt ( if not specified , the global default timeout setting will be used ) . Alternatively , the `host` name and optional `port` number can be passed to the constructor too , in which case the connection to the server will be established before the constructor returns .", "question_id": 10002}
{"snippet": "telnetlib.Telnet(timeout, port=0)", "intent": "Telnet represents a connection to a Telnet server . The optional `timeout` parameter specifies a timeout in seconds for blocking operations like the connection attempt ( if not specified , the global default timeout setting will be used ) . Alternatively , the `host` name and optional `port` number can be passed to the constructor too , in which case the connection to the server will be established before the constructor returns .", "question_id": 10003}
{"snippet": "telnetlib.Telnet(timeout, host=None, port=0)", "intent": "Telnet represents a connection to a Telnet server . The optional `timeout` parameter specifies a timeout in seconds for blocking operations like the connection attempt ( if not specified , the global default timeout setting will be used ) . Alternatively , the `host` name and optional `port` number can be passed to the constructor too , in which case the connection to the server will be established before the constructor returns .", "question_id": 10004}
{"snippet": "telnetlib.Telnet()", "intent": "Telnet represents a connection to a Telnet server .", "question_id": 10005}
{"snippet": "telnetlib.Telnet(host=None)", "intent": "Telnet represents a connection to a Telnet server . Alternatively , the `host` name and optional `port` number can be passed to the constructor too , in which case the connection to the server will be established before the constructor returns .", "question_id": 10006}
{"snippet": "telnetlib.Telnet(port=0)", "intent": "Telnet represents a connection to a Telnet server . Alternatively , the `host` name and optional `port` number can be passed to the constructor too , in which case the connection to the server will be established before the constructor returns .", "question_id": 10007}
{"snippet": "telnetlib.Telnet(host=None, port=0)", "intent": "Telnet represents a connection to a Telnet server . Alternatively , the `host` name and optional `port` number can be passed to the constructor too , in which case the connection to the server will be established before the constructor returns .", "question_id": 10008}
{"snippet": "Telnet.read_until(expected)", "intent": "Read until a given byte string , `expected` , is encountered or until `timeout` seconds have passed .", "question_id": 10009}
{"snippet": "Telnet.read_until(expected, timeout=None)", "intent": "Read until a given byte string , `expected` , is encountered or until `timeout` seconds have passed .", "question_id": 10010}
{"snippet": "Telnet.read_all()", "intent": "Read all data until EOF as bytes ; block until connection closed .", "question_id": 10011}
{"snippet": "Telnet.read_some()", "intent": "Read at least one byte of cooked data unless EOF is hit .", "question_id": 10012}
{"snippet": "Telnet.read_very_eager()", "intent": "Read everything that can be without blocking in I/O ( eager ) .", "question_id": 10013}
{"snippet": "Telnet.read_eager()", "intent": "Read readily available data .", "question_id": 10014}
{"snippet": "Telnet.read_lazy()", "intent": "Process and return data already in the queues ( lazy ) .", "question_id": 10015}
{"snippet": "Telnet.read_very_lazy()", "intent": "Return any data available in the cooked queue ( very lazy ) .", "question_id": 10016}
{"snippet": "Telnet.read_sb_data()", "intent": "Return the data collected between a SB/SE pair ( suboption begin/end ) .", "question_id": 10017}
{"snippet": "Telnet.open(host, timeout)", "intent": "Connect to a `host` . The optional `timeout` parameter specifies a timeout in seconds for blocking operations like the connection attempt ( if not specified , the global default timeout setting will be used ) .", "question_id": 10018}
{"snippet": "Telnet.open(host, timeout, port=0)", "intent": "Connect to a `host` . The optional `timeout` parameter specifies a timeout in seconds for blocking operations like the connection attempt ( if not specified , the global default timeout setting will be used ) . The optional second argument is the `port` number , which defaults to the standard Telnet port ( 23 ) .", "question_id": 10019}
{"snippet": "Telnet.open(host)", "intent": "Connect to a `host` .", "question_id": 10020}
{"snippet": "Telnet.open(host, port=0)", "intent": "Connect to a `host` . The optional second argument is the `port` number , which defaults to the standard Telnet port ( 23 ) .", "question_id": 10021}
{"snippet": "Telnet.msg(msg, *args)", "intent": "Print a debug message when the debug level is > 0 . With arguments `msg`, `*args`.", "question_id": 10022}
{"snippet": "Telnet.set_debuglevel(debuglevel)", "intent": "Set the debug level . The higher the value of `debuglevel` , the more debug output you get ( on sys.stdout ) .", "question_id": 10023}
{"snippet": "Telnet.close()", "intent": "Close the connection .", "question_id": 10024}
{"snippet": "Telnet.get_socket()", "intent": "Return the socket object used internally .", "question_id": 10025}
{"snippet": "Telnet.fileno()", "intent": "Return the file descriptor of the socket object used internally .", "question_id": 10026}
{"snippet": "Telnet.write(buffer)", "intent": "Write a byte string to the socket , doubling any IAC characters . With arguments `buffer`.", "question_id": 10027}
{"snippet": "Telnet.interact()", "intent": "Interaction function , emulates a very dumb Telnet client .", "question_id": 10028}
{"snippet": "Telnet.mt_interact()", "intent": "Multithreaded version of interact ( ) .", "question_id": 10029}
{"snippet": "Telnet.expect(list)", "intent": "Read until one from a `list` of a regular expressions matches .", "question_id": 10030}
{"snippet": "Telnet.expect(list, timeout=None)", "intent": "Read until one from a `list` of a regular expressions matches . The optional second argument is a `timeout` , in seconds ; the default is to block indefinitely .", "question_id": 10031}
{"snippet": "Telnet.set_option_negotiation_callback(callback)", "intent": "Each time a telnet option is read on the input flow , this `callback` ( if set ) is called with the following parameters : callback ( telnet socket , command ( DO/DONT/WILL/WONT ) , option ) .", "question_id": 10032}
{"snippet": "tempfile.TemporaryFile()", "intent": "Return a file-like object that can be used as a temporary storage area .", "question_id": 10033}
{"snippet": "tempfile.TemporaryFile(mode='w+b')", "intent": "Return a file-like object that can be used as a temporary storage area . The `mode` parameter defaults to ' w+b ' so that the file created can be read and written without being closed .", "question_id": 10034}
{"snippet": "tempfile.TemporaryFile(buffering=None)", "intent": "Return a file-like object that can be used as a temporary storage area . `buffering` , `encoding` and `newline` are interpreted as for open ( ) .", "question_id": 10035}
{"snippet": "tempfile.TemporaryFile(encoding=None)", "intent": "Return a file-like object that can be used as a temporary storage area . `buffering` , `encoding` and `newline` are interpreted as for open ( ) .", "question_id": 10036}
{"snippet": "tempfile.TemporaryFile(newline=None)", "intent": "Return a file-like object that can be used as a temporary storage area . `buffering` , `encoding` and `newline` are interpreted as for open ( ) .", "question_id": 10037}
{"snippet": "tempfile.TemporaryFile(suffix=None)", "intent": "Return a file-like object that can be used as a temporary storage area . The `dir` , `prefix` and `suffix` parameters have the same meaning and defaults as with mkstemp ( ) .", "question_id": 10038}
{"snippet": "tempfile.TemporaryFile(prefix=None)", "intent": "Return a file-like object that can be used as a temporary storage area . The `dir` , `prefix` and `suffix` parameters have the same meaning and defaults as with mkstemp ( ) .", "question_id": 10039}
{"snippet": "tempfile.TemporaryFile(dir=None)", "intent": "Return a file-like object that can be used as a temporary storage area . The `dir` , `prefix` and `suffix` parameters have the same meaning and defaults as with mkstemp ( ) .", "question_id": 10040}
{"snippet": "tempfile.TemporaryFile(mode='w+b', buffering=None)", "intent": "Return a file-like object that can be used as a temporary storage area . The `mode` parameter defaults to ' w+b ' so that the file created can be read and written without being closed . `buffering` , `encoding` and `newline` are interpreted as for open ( ) .", "question_id": 10041}
{"snippet": "tempfile.TemporaryFile(mode='w+b', encoding=None)", "intent": "Return a file-like object that can be used as a temporary storage area . The `mode` parameter defaults to ' w+b ' so that the file created can be read and written without being closed . `buffering` , `encoding` and `newline` are interpreted as for open ( ) .", "question_id": 10042}
{"snippet": "tempfile.NamedTemporaryFile()", "intent": "This function operates exactly as TemporaryFile ( ) does , except that the file is guaranteed to have a visible name in the file system ( on Unix , the directory entry is not unlinked ) .", "question_id": 10043}
{"snippet": "tempfile.NamedTemporaryFile(mode='w+b')", "intent": "This function operates exactly as TemporaryFile ( ) does , except that the file is guaranteed to have a visible name in the file system ( on Unix , the directory entry is not unlinked ) . With arguments `mode`.", "question_id": 10044}
{"snippet": "tempfile.NamedTemporaryFile(buffering=None)", "intent": "This function operates exactly as TemporaryFile ( ) does , except that the file is guaranteed to have a visible name in the file system ( on Unix , the directory entry is not unlinked ) . With arguments `buffering`.", "question_id": 10045}
{"snippet": "tempfile.NamedTemporaryFile(encoding=None)", "intent": "This function operates exactly as TemporaryFile ( ) does , except that the file is guaranteed to have a visible name in the file system ( on Unix , the directory entry is not unlinked ) . With arguments `encoding`.", "question_id": 10046}
{"snippet": "tempfile.NamedTemporaryFile(newline=None)", "intent": "This function operates exactly as TemporaryFile ( ) does , except that the file is guaranteed to have a visible name in the file system ( on Unix , the directory entry is not unlinked ) . With arguments `newline`.", "question_id": 10047}
{"snippet": "tempfile.NamedTemporaryFile(suffix=None)", "intent": "This function operates exactly as TemporaryFile ( ) does , except that the file is guaranteed to have a visible name in the file system ( on Unix , the directory entry is not unlinked ) . With arguments `suffix`.", "question_id": 10048}
{"snippet": "tempfile.NamedTemporaryFile(prefix=None)", "intent": "This function operates exactly as TemporaryFile ( ) does , except that the file is guaranteed to have a visible name in the file system ( on Unix , the directory entry is not unlinked ) . With arguments `prefix`.", "question_id": 10049}
{"snippet": "tempfile.NamedTemporaryFile(dir=None)", "intent": "This function operates exactly as TemporaryFile ( ) does , except that the file is guaranteed to have a visible name in the file system ( on Unix , the directory entry is not unlinked ) . With arguments `dir`.", "question_id": 10050}
{"snippet": "tempfile.NamedTemporaryFile(delete=True)", "intent": "This function operates exactly as TemporaryFile ( ) does , except that the file is guaranteed to have a visible name in the file system ( on Unix , the directory entry is not unlinked ) . If `delete` is true ( the default ) , the file is deleted as soon as it is closed .", "question_id": 10051}
{"snippet": "tempfile.NamedTemporaryFile(mode='w+b', buffering=None)", "intent": "This function operates exactly as TemporaryFile ( ) does , except that the file is guaranteed to have a visible name in the file system ( on Unix , the directory entry is not unlinked ) . With arguments `mode`, `buffering`.", "question_id": 10052}
{"snippet": "tempfile.SpooledTemporaryFile()", "intent": "This function operates exactly as TemporaryFile ( ) does , except that data is spooled in memory until the file size exceeds `max_size` , or until the file \u2019 s fileno ( ) method is called , at which point the contents are written to disk and operation proceeds as with TemporaryFile ( ) .", "question_id": 10053}
{"snippet": "tempfile.SpooledTemporaryFile(max_size=0)", "intent": "This function operates exactly as TemporaryFile ( ) does , except that data is spooled in memory until the file size exceeds `max_size` , or until the file \u2019 s fileno ( ) method is called , at which point the contents are written to disk and operation proceeds as with TemporaryFile ( ) .", "question_id": 10054}
{"snippet": "tempfile.SpooledTemporaryFile(mode='w+b')", "intent": "This function operates exactly as TemporaryFile ( ) does , except that data is spooled in memory until the file size exceeds `max_size` , or until the file \u2019 s fileno ( ) method is called , at which point the contents are written to disk and operation proceeds as with TemporaryFile ( ) . The returned object is a file-like object whose _file attribute is either an io.BytesIO or io.StringIO object ( depending on whether binary or text `mode` was specified ) or a true file object , depending on whether rollover ( ) has been called .", "question_id": 10055}
{"snippet": "tempfile.SpooledTemporaryFile(buffering=None)", "intent": "This function operates exactly as TemporaryFile ( ) does , except that data is spooled in memory until the file size exceeds `max_size` , or until the file \u2019 s fileno ( ) method is called , at which point the contents are written to disk and operation proceeds as with TemporaryFile ( ) . With arguments `buffering`.", "question_id": 10056}
{"snippet": "tempfile.SpooledTemporaryFile(encoding=None)", "intent": "This function operates exactly as TemporaryFile ( ) does , except that data is spooled in memory until the file size exceeds `max_size` , or until the file \u2019 s fileno ( ) method is called , at which point the contents are written to disk and operation proceeds as with TemporaryFile ( ) . With arguments `encoding`.", "question_id": 10057}
{"snippet": "tempfile.SpooledTemporaryFile(newline=None)", "intent": "This function operates exactly as TemporaryFile ( ) does , except that data is spooled in memory until the file size exceeds `max_size` , or until the file \u2019 s fileno ( ) method is called , at which point the contents are written to disk and operation proceeds as with TemporaryFile ( ) . With arguments `newline`.", "question_id": 10058}
{"snippet": "tempfile.SpooledTemporaryFile(suffix=None)", "intent": "This function operates exactly as TemporaryFile ( ) does , except that data is spooled in memory until the file size exceeds `max_size` , or until the file \u2019 s fileno ( ) method is called , at which point the contents are written to disk and operation proceeds as with TemporaryFile ( ) . With arguments `suffix`.", "question_id": 10059}
{"snippet": "tempfile.SpooledTemporaryFile(prefix=None)", "intent": "This function operates exactly as TemporaryFile ( ) does , except that data is spooled in memory until the file size exceeds `max_size` , or until the file \u2019 s fileno ( ) method is called , at which point the contents are written to disk and operation proceeds as with TemporaryFile ( ) . With arguments `prefix`.", "question_id": 10060}
{"snippet": "tempfile.SpooledTemporaryFile(dir=None)", "intent": "This function operates exactly as TemporaryFile ( ) does , except that data is spooled in memory until the file size exceeds `max_size` , or until the file \u2019 s fileno ( ) method is called , at which point the contents are written to disk and operation proceeds as with TemporaryFile ( ) . With arguments `dir`.", "question_id": 10061}
{"snippet": "tempfile.SpooledTemporaryFile(max_size=0, mode='w+b')", "intent": "This function operates exactly as TemporaryFile ( ) does , except that data is spooled in memory until the file size exceeds `max_size` , or until the file \u2019 s fileno ( ) method is called , at which point the contents are written to disk and operation proceeds as with TemporaryFile ( ) . The returned object is a file-like object whose _file attribute is either an io.BytesIO or io.StringIO object ( depending on whether binary or text `mode` was specified ) or a true file object , depending on whether rollover ( ) has been called .", "question_id": 10062}
{"snippet": "tempfile.TemporaryDirectory()", "intent": "This function securely creates a temporary directory using the same rules as mkdtemp ( ) .", "question_id": 10063}
{"snippet": "tempfile.TemporaryDirectory(suffix=None)", "intent": "This function securely creates a temporary directory using the same rules as mkdtemp ( ) . With arguments `suffix`.", "question_id": 10064}
{"snippet": "tempfile.TemporaryDirectory(prefix=None)", "intent": "This function securely creates a temporary directory using the same rules as mkdtemp ( ) . With arguments `prefix`.", "question_id": 10065}
{"snippet": "tempfile.TemporaryDirectory(dir=None)", "intent": "This function securely creates a temporary directory using the same rules as mkdtemp ( ) . With arguments `dir`.", "question_id": 10066}
{"snippet": "tempfile.TemporaryDirectory(suffix=None, prefix=None)", "intent": "This function securely creates a temporary directory using the same rules as mkdtemp ( ) . With arguments `suffix`, `prefix`.", "question_id": 10067}
{"snippet": "tempfile.TemporaryDirectory(suffix=None, dir=None)", "intent": "This function securely creates a temporary directory using the same rules as mkdtemp ( ) . With arguments `suffix`, `dir`.", "question_id": 10068}
{"snippet": "tempfile.TemporaryDirectory(prefix=None, dir=None)", "intent": "This function securely creates a temporary directory using the same rules as mkdtemp ( ) . With arguments `prefix`, `dir`.", "question_id": 10069}
{"snippet": "tempfile.TemporaryDirectory(suffix=None, prefix=None, dir=None)", "intent": "This function securely creates a temporary directory using the same rules as mkdtemp ( ) . With arguments `suffix`, `prefix`, `dir`.", "question_id": 10070}
{"snippet": "tempfile.mkstemp()", "intent": "Creates a temporary file in the most secure manner possible .", "question_id": 10071}
{"snippet": "tempfile.mkstemp(suffix=None)", "intent": "Creates a temporary file in the most secure manner possible . If `suffix` is not None , the file name will end with that suffix , otherwise there will be no suffix .", "question_id": 10072}
{"snippet": "tempfile.mkstemp(prefix=None)", "intent": "Creates a temporary file in the most secure manner possible . If `prefix` is not None , the file name will begin with that prefix ; otherwise , a default prefix is used .", "question_id": 10073}
{"snippet": "tempfile.mkstemp(dir=None)", "intent": "Creates a temporary file in the most secure manner possible . If `dir` is not None , the file will be created in that directory ; otherwise , a default directory is used .", "question_id": 10074}
{"snippet": "tempfile.mkstemp(text=False)", "intent": "Creates a temporary file in the most secure manner possible . If `text` is specified , it indicates whether to open the file in binary mode ( the default ) or text mode .", "question_id": 10075}
{"snippet": "tempfile.mkstemp(suffix=None, prefix=None)", "intent": "Creates a temporary file in the most secure manner possible . If `suffix` is not None , the file name will end with that suffix , otherwise there will be no suffix . If `prefix` is not None , the file name will begin with that prefix ; otherwise , a default prefix is used .", "question_id": 10076}
{"snippet": "tempfile.mkstemp(suffix=None, dir=None)", "intent": "Creates a temporary file in the most secure manner possible . If `suffix` is not None , the file name will end with that suffix , otherwise there will be no suffix . If `dir` is not None , the file will be created in that directory ; otherwise , a default directory is used .", "question_id": 10077}
{"snippet": "tempfile.mkstemp(suffix=None, text=False)", "intent": "Creates a temporary file in the most secure manner possible . If `suffix` is not None , the file name will end with that suffix , otherwise there will be no suffix . If `text` is specified , it indicates whether to open the file in binary mode ( the default ) or text mode .", "question_id": 10078}
{"snippet": "tempfile.mkstemp(prefix=None, dir=None)", "intent": "Creates a temporary file in the most secure manner possible . If `prefix` is not None , the file name will begin with that prefix ; otherwise , a default prefix is used . If `dir` is not None , the file will be created in that directory ; otherwise , a default directory is used .", "question_id": 10079}
{"snippet": "tempfile.mkstemp(prefix=None, text=False)", "intent": "Creates a temporary file in the most secure manner possible . If `prefix` is not None , the file name will begin with that prefix ; otherwise , a default prefix is used . If `text` is specified , it indicates whether to open the file in binary mode ( the default ) or text mode .", "question_id": 10080}
{"snippet": "tempfile.mkdtemp()", "intent": "Creates a temporary directory in the most secure manner possible .", "question_id": 10081}
{"snippet": "tempfile.mkdtemp(suffix=None)", "intent": "Creates a temporary directory in the most secure manner possible . The `prefix` , `suffix` , and `dir` arguments are the same as for mkstemp ( ) .", "question_id": 10082}
{"snippet": "tempfile.mkdtemp(prefix=None)", "intent": "Creates a temporary directory in the most secure manner possible . The `prefix` , `suffix` , and `dir` arguments are the same as for mkstemp ( ) .", "question_id": 10083}
{"snippet": "tempfile.mkdtemp(dir=None)", "intent": "Creates a temporary directory in the most secure manner possible . The `prefix` , `suffix` , and `dir` arguments are the same as for mkstemp ( ) .", "question_id": 10084}
{"snippet": "tempfile.mkdtemp(suffix=None, prefix=None)", "intent": "Creates a temporary directory in the most secure manner possible . The `prefix` , `suffix` , and `dir` arguments are the same as for mkstemp ( ) .", "question_id": 10085}
{"snippet": "tempfile.mkdtemp(suffix=None, dir=None)", "intent": "Creates a temporary directory in the most secure manner possible . The `prefix` , `suffix` , and `dir` arguments are the same as for mkstemp ( ) .", "question_id": 10086}
{"snippet": "tempfile.mkdtemp(prefix=None, dir=None)", "intent": "Creates a temporary directory in the most secure manner possible . The `prefix` , `suffix` , and `dir` arguments are the same as for mkstemp ( ) .", "question_id": 10087}
{"snippet": "tempfile.mkdtemp(suffix=None, prefix=None, dir=None)", "intent": "Creates a temporary directory in the most secure manner possible . The `prefix` , `suffix` , and `dir` arguments are the same as for mkstemp ( ) .", "question_id": 10088}
{"snippet": "tempfile.gettempdir()", "intent": "Return the name of the directory used for temporary files .", "question_id": 10089}
{"snippet": "tempfile.gettempdirb()", "intent": "Same as gettempdir ( ) but the return value is in bytes .", "question_id": 10090}
{"snippet": "tempfile.gettempprefix()", "intent": "Return the filename prefix used to create temporary files .", "question_id": 10091}
{"snippet": "tempfile.gettempprefixb()", "intent": "Same as gettempprefix ( ) but the return value is in bytes .", "question_id": 10092}
{"snippet": "tempfile.tempdir", "intent": "When set to a value other than None, this variable defines the default value for the dir argument to the functions defined in this module.", "question_id": 10093}
{"snippet": "tempfile.mktemp()", "intent": "Return an absolute pathname of a file that did not exist at the time the call is made .", "question_id": 10094}
{"snippet": "tempfile.mktemp(suffix='')", "intent": "Return an absolute pathname of a file that did not exist at the time the call is made . The `prefix` , `suffix` , and `dir` arguments are similar to those of mkstemp ( ) , except that bytes file names , suffix=None and prefix=None are not supported .", "question_id": 10095}
{"snippet": "tempfile.mktemp(prefix='tmp')", "intent": "Return an absolute pathname of a file that did not exist at the time the call is made . The `prefix` , `suffix` , and `dir` arguments are similar to those of mkstemp ( ) , except that bytes file names , suffix=None and prefix=None are not supported .", "question_id": 10096}
{"snippet": "tempfile.mktemp(dir=None)", "intent": "Return an absolute pathname of a file that did not exist at the time the call is made . The `prefix` , `suffix` , and `dir` arguments are similar to those of mkstemp ( ) , except that bytes file names , suffix=None and prefix=None are not supported .", "question_id": 10097}
{"snippet": "tempfile.mktemp(suffix='', prefix='tmp')", "intent": "Return an absolute pathname of a file that did not exist at the time the call is made . The `prefix` , `suffix` , and `dir` arguments are similar to those of mkstemp ( ) , except that bytes file names , suffix=None and prefix=None are not supported .", "question_id": 10098}
{"snippet": "tempfile.mktemp(suffix='', dir=None)", "intent": "Return an absolute pathname of a file that did not exist at the time the call is made . The `prefix` , `suffix` , and `dir` arguments are similar to those of mkstemp ( ) , except that bytes file names , suffix=None and prefix=None are not supported .", "question_id": 10099}
{"snippet": "tempfile.mktemp(prefix='tmp', dir=None)", "intent": "Return an absolute pathname of a file that did not exist at the time the call is made . The `prefix` , `suffix` , and `dir` arguments are similar to those of mkstemp ( ) , except that bytes file names , suffix=None and prefix=None are not supported .", "question_id": 10100}
{"snippet": "tempfile.mktemp(suffix='', prefix='tmp', dir=None)", "intent": "Return an absolute pathname of a file that did not exist at the time the call is made . The `prefix` , `suffix` , and `dir` arguments are similar to those of mkstemp ( ) , except that bytes file names , suffix=None and prefix=None are not supported .", "question_id": 10101}
{"snippet": "termios.tcgetattr(fd)", "intent": "Return a list containing the tty attributes for file descriptor `fd` , as follows : [ iflag , oflag , cflag , lflag , ispeed , ospeed , cc ] where cc is a list of the tty special characters ( each a string of length 1 , except the items with indices VMIN and VTIME , which are integers when these fields are defined ) .", "question_id": 10102}
{"snippet": "termios.tcsetattr(fd, when, attributes)", "intent": "Set the tty `attributes` for file descriptor `fd` from the attributes , which is a list like the one returned by tcgetattr ( ) . The `when` argument determines when the attributes are changed : TCSANOW to change immediately , TCSADRAIN to change after transmitting all queued output , or TCSAFLUSH to change after transmitting all queued output and discarding all queued input .", "question_id": 10103}
{"snippet": "termios.tcsendbreak(fd, duration)", "intent": "Send a break on file descriptor `fd` . A zero `duration` sends a break for 0.25\u20130.5 seconds ; a nonzero duration has a system dependent meaning .", "question_id": 10104}
{"snippet": "termios.tcdrain(fd)", "intent": "Wait until all output written to file descriptor `fd` has been transmitted .", "question_id": 10105}
{"snippet": "termios.tcflush(fd, queue)", "intent": "Discard queued data on file descriptor `fd` . The `queue` selector specifies which queue : TCIFLUSH for the input queue , TCOFLUSH for the output queue , or TCIOFLUSH for both queues .", "question_id": 10106}
{"snippet": "termios.tcflow(fd, action)", "intent": "Suspend or resume input or output on file descriptor `fd` . The `action` argument can be TCOOFF to suspend output , TCOON to restart output , TCIOFF to suspend input , or TCION to restart input .", "question_id": 10107}
{"snippet": "test.support.TestFailed", "intent": "Exception to be raised when a test fails.", "question_id": 10108}
{"snippet": "test.support.ResourceDenied", "intent": "Subclass of unittest.SkipTest.", "question_id": 10109}
{"snippet": "test.support.verbose", "intent": "True when verbose output is enabled.", "question_id": 10110}
{"snippet": "test.support.is_jython", "intent": "True if the running interpreter is Jython.", "question_id": 10111}
{"snippet": "test.support.is_android", "intent": "True if the system is Android.", "question_id": 10112}
{"snippet": "test.support.unix_shell", "intent": "Path for shell if not on Windows; otherwise None.", "question_id": 10113}
{"snippet": "test.support.FS_NONASCII", "intent": "A non-ASCII character encodable by os.fsencode().", "question_id": 10114}
{"snippet": "test.support.TESTFN", "intent": "Set to a name that is safe to use as the name of a temporary file.", "question_id": 10115}
{"snippet": "test.support.TESTFN_UNICODE", "intent": "Set to a non-ASCII name for a temporary file.", "question_id": 10116}
{"snippet": "test.support.TESTFN_ENCODING", "intent": "Set to sys.getfilesystemencoding().", "question_id": 10117}
{"snippet": "test.support.TESTFN_UNENCODABLE", "intent": "Set to a filename (str type) that should not be able to be encoded by file system encoding in strict mode.", "question_id": 10118}
{"snippet": "test.support.TESTFN_UNDECODABLE", "intent": "Set to a filename (bytes type) that should not be able to be decoded by file system encoding in strict mode.", "question_id": 10119}
{"snippet": "test.support.TESTFN_NONASCII", "intent": "Set to a filename containing the FS_NONASCII character.", "question_id": 10120}
{"snippet": "test.support.IPV6_ENABLED", "intent": "Set to True if IPV6 is enabled on this host, False otherwise.", "question_id": 10121}
{"snippet": "test.support.SAVEDCWD", "intent": "Set to os.getcwd().", "question_id": 10122}
{"snippet": "test.support.PGO", "intent": "Set when tests can be skipped when they are not useful for PGO.", "question_id": 10123}
{"snippet": "test.support.PIPE_MAX_SIZE", "intent": "A constant that is likely larger than the underlying OS pipe buffer size, to make writes blocking.", "question_id": 10124}
{"snippet": "test.support.SOCK_MAX_SIZE", "intent": "A constant that is likely larger than the underlying OS socket buffer size, to make writes blocking.", "question_id": 10125}
{"snippet": "test.support.TEST_SUPPORT_DIR", "intent": "Set to the top level directory that contains test.support.", "question_id": 10126}
{"snippet": "test.support.TEST_HOME_DIR", "intent": "Set to the top level directory for the test package.", "question_id": 10127}
{"snippet": "test.support.TEST_DATA_DIR", "intent": "Set to the data directory within the test package.", "question_id": 10128}
{"snippet": "test.support.MAX_Py_ssize_t", "intent": "Set to sys.maxsize for big memory tests.", "question_id": 10129}
{"snippet": "test.support.max_memuse", "intent": "Set by set_memlimit() as the memory limit for big memory tests.", "question_id": 10130}
{"snippet": "test.support.real_max_memuse", "intent": "Set by set_memlimit() as the memory limit for big memory tests.", "question_id": 10131}
{"snippet": "test.support.MISSING_C_DOCSTRINGS", "intent": "Return True if running on CPython, not on Windows, and configuration not set with WITH_DOC_STRINGS.", "question_id": 10132}
{"snippet": "test.support.HAVE_DOCSTRINGS", "intent": "Check for presence of docstrings.", "question_id": 10133}
{"snippet": "test.support.TEST_HTTP_URL", "intent": "Define the URL of a dedicated HTTP server for the network tests.", "question_id": 10134}
{"snippet": "test.support.ALWAYS_EQ", "intent": "Object that is equal to anything.", "question_id": 10135}
{"snippet": "test.support.LARGEST", "intent": "Object that is greater than anything (except itself).", "question_id": 10136}
{"snippet": "test.support.SMALLEST", "intent": "Object that is less than anything (except itself).", "question_id": 10137}
{"snippet": "test.support.forget(module_name)", "intent": "Remove the module named `module_name` from sys.modules and delete any byte-compiled files of the module .", "question_id": 10138}
{"snippet": "test.support.unload(name)", "intent": "Delete `name` from sys.modules .", "question_id": 10139}
{"snippet": "test.support.unlink(filename)", "intent": "Call os.unlink ( ) on `filename` .", "question_id": 10140}
{"snippet": "test.support.rmdir(filename)", "intent": "Call os.rmdir ( ) on `filename` .", "question_id": 10141}
{"snippet": "test.support.rmtree(path)", "intent": "Call shutil.rmtree ( ) on `path` or call os.lstat ( ) and os.rmdir ( ) to remove a path and its contents .", "question_id": 10142}
{"snippet": "test.support.make_legacy_pyc(source)", "intent": "Move a PEP 3147/488 pyc file to its legacy pyc location and return the file system path to the legacy pyc file . The `source` value is the file system path to the source file .", "question_id": 10143}
{"snippet": "test.support.is_resource_enabled(resource)", "intent": "Return True if `resource` is enabled and available .", "question_id": 10144}
{"snippet": "test.support.python_is_optimized()", "intent": "Return True if Python was not built with -O0 or -Og .", "question_id": 10145}
{"snippet": "test.support.with_pymalloc()", "intent": "Return _testcapi.WITH_PYMALLOC .", "question_id": 10146}
{"snippet": "test.support.requires(resource)", "intent": "Raise ResourceDenied if `resource` is not available .", "question_id": 10147}
{"snippet": "test.support.requires(resource, msg=None)", "intent": "Raise ResourceDenied if `resource` is not available . `msg` is the argument to ResourceDenied if it is raised .", "question_id": 10148}
{"snippet": "test.support.system_must_validate_cert(f)", "intent": "Raise unittest.SkipTest on TLS certification validation failures . With arguments `f`.", "question_id": 10149}
{"snippet": "test.support.sortdict(dict)", "intent": "Return a repr of `dict` with keys sorted .", "question_id": 10150}
{"snippet": "test.support.findfile(filename)", "intent": "Return the path to the file named `filename` .", "question_id": 10151}
{"snippet": "test.support.findfile(filename, subdir=None)", "intent": "Return the path to the file named `filename` . Setting `subdir` indicates a relative path to use to find the file rather than looking directly in the path directories .", "question_id": 10152}
{"snippet": "test.support.create_empty_file(filename)", "intent": "Create an empty file with `filename` .", "question_id": 10153}
{"snippet": "test.support.fd_count()", "intent": "Count the number of open file descriptors .", "question_id": 10154}
{"snippet": "test.support.match_test(test)", "intent": "Match `test` to patterns set in set_match_tests ( ) .", "question_id": 10155}
{"snippet": "test.support.set_match_tests(patterns)", "intent": "Define match test with regular expression `patterns` .", "question_id": 10156}
{"snippet": "test.support.run_unittest(*classes)", "intent": "Execute unittest.TestCase subclasses passed to the function . With arguments `*classes`.", "question_id": 10157}
{"snippet": "test.support.run_doctest(module)", "intent": "Run doctest.testmod ( ) on the given `module` .", "question_id": 10158}
{"snippet": "test.support.run_doctest(module, verbosity=None)", "intent": "Run doctest.testmod ( ) on the given `module` . If `verbosity` is None , doctest.testmod ( ) is run with verbosity set to verbose .", "question_id": 10159}
{"snippet": "test.support.run_doctest(module, optionflags=0)", "intent": "Run doctest.testmod ( ) on the given `module` . `optionflags` is passed as optionflags to doctest.testmod ( ) .", "question_id": 10160}
{"snippet": "test.support.run_doctest(module, verbosity=None, optionflags=0)", "intent": "Run doctest.testmod ( ) on the given `module` . If `verbosity` is None , doctest.testmod ( ) is run with verbosity set to verbose . `optionflags` is passed as optionflags to doctest.testmod ( ) .", "question_id": 10161}
{"snippet": "test.support.setswitchinterval(interval)", "intent": "Set the sys.setswitchinterval ( ) to the given `interval` .", "question_id": 10162}
{"snippet": "test.support.check_impl_detail(**guards)", "intent": "Use this check to guard CPython \u2019 s implementation-specific tests or to run them only on the implementations guarded by the arguments : With arguments `**guards`.", "question_id": 10163}
{"snippet": "test.support.check_warnings(*filters)", "intent": "A convenience wrapper for warnings.catch_warnings ( ) that makes it easier to test that a warning was correctly raised . With arguments `*filters`.", "question_id": 10164}
{"snippet": "test.support.check_warnings(*filters, quiet=True)", "intent": "A convenience wrapper for warnings.catch_warnings ( ) that makes it easier to test that a warning was correctly raised . If one or more filters are provided , or if the optional keyword argument `quiet` is False , it checks to make sure the warnings are as expected : each specified filter must match at least one of the warnings raised by the enclosed code or the test fails , and if any warnings are raised that do not match any of the specified filters the test fails . With arguments `*filters`.", "question_id": 10165}
{"snippet": "test.support.check_no_resource_warning(testcase)", "intent": "Context manager to check that no ResourceWarning was raised . With arguments `testcase`.", "question_id": 10166}
{"snippet": "test.support.set_memlimit(limit)", "intent": "Set the values for max_memuse and real_max_memuse for big memory tests . With arguments `limit`.", "question_id": 10167}
{"snippet": "test.support.record_original_stdout(stdout)", "intent": "Store the value from `stdout` .", "question_id": 10168}
{"snippet": "test.support.get_original_stdout()", "intent": "Return the original stdout set by record_original_stdout ( ) or sys.stdout if it \u2019 s not set .", "question_id": 10169}
{"snippet": "test.support.strip_python_strerr(stderr)", "intent": "Strip the `stderr` of a Python process from potential debug output emitted by the interpreter .", "question_id": 10170}
{"snippet": "test.support.args_from_interpreter_flags()", "intent": "Return a list of command line arguments reproducing the current settings in sys.flags and sys.warnoptions .", "question_id": 10171}
{"snippet": "test.support.optim_args_from_interpreter_flags()", "intent": "Return a list of command line arguments reproducing the current optimization settings in sys.flags .", "question_id": 10172}
{"snippet": "test.support.captured_stdin()", "intent": "A context managers that temporarily replaces the named stream with io.StringIO object .", "question_id": 10173}
{"snippet": "test.support.captured_stdout()", "intent": "A context managers that temporarily replaces the named stream with io.StringIO object .", "question_id": 10174}
{"snippet": "test.support.captured_stderr()", "intent": "A context managers that temporarily replaces the named stream with io.StringIO object .", "question_id": 10175}
{"snippet": "test.support.temp_dir()", "intent": "A context manager that creates a temporary directory at `path` and yields the directory .", "question_id": 10176}
{"snippet": "test.support.temp_dir(path=None)", "intent": "A context manager that creates a temporary directory at `path` and yields the directory .", "question_id": 10177}
{"snippet": "test.support.temp_dir(quiet=False)", "intent": "A context manager that creates a temporary directory at `path` and yields the directory . If `quiet` is False , the context manager raises an exception on error .", "question_id": 10178}
{"snippet": "test.support.temp_dir(path=None, quiet=False)", "intent": "A context manager that creates a temporary directory at `path` and yields the directory . If `quiet` is False , the context manager raises an exception on error .", "question_id": 10179}
{"snippet": "test.support.change_cwd(path)", "intent": "A context manager that temporarily changes the current working directory to `path` and yields the directory .", "question_id": 10180}
{"snippet": "test.support.change_cwd(path, quiet=False)", "intent": "A context manager that temporarily changes the current working directory to `path` and yields the directory . If `quiet` is False , the context manager raises an exception on error .", "question_id": 10181}
{"snippet": "test.support.temp_cwd()", "intent": "A context manager that temporarily creates a new directory and changes the current working directory ( CWD ) .", "question_id": 10182}
{"snippet": "test.support.temp_cwd(name='tempcwd')", "intent": "A context manager that temporarily creates a new directory and changes the current working directory ( CWD ) . The context manager creates a temporary directory in the current directory with `name` name before temporarily changing the current working directory .", "question_id": 10183}
{"snippet": "test.support.temp_cwd(quiet=False)", "intent": "A context manager that temporarily creates a new directory and changes the current working directory ( CWD ) . If `quiet` is False and it is not possible to create or change the CWD , an error is raised .", "question_id": 10184}
{"snippet": "test.support.temp_cwd(name='tempcwd', quiet=False)", "intent": "A context manager that temporarily creates a new directory and changes the current working directory ( CWD ) . The context manager creates a temporary directory in the current directory with `name` name before temporarily changing the current working directory . If `quiet` is False and it is not possible to create or change the CWD , an error is raised .", "question_id": 10185}
{"snippet": "test.support.temp_umask(umask)", "intent": "A context manager that temporarily sets the process `umask` .", "question_id": 10186}
{"snippet": "test.support.transient_internet(resource_name)", "intent": "A context manager that raises ResourceDenied when various issues with the internet connection manifest themselves as exceptions . With arguments `resource_name`.", "question_id": 10187}
{"snippet": "test.support.transient_internet(resource_name, timeout=30.0)", "intent": "A context manager that raises ResourceDenied when various issues with the internet connection manifest themselves as exceptions . With arguments `resource_name`, `timeout`.", "question_id": 10188}
{"snippet": "test.support.transient_internet(resource_name, errnos=())", "intent": "A context manager that raises ResourceDenied when various issues with the internet connection manifest themselves as exceptions . With arguments `resource_name`, `errnos`.", "question_id": 10189}
{"snippet": "test.support.transient_internet(resource_name, timeout=30.0, errnos=())", "intent": "A context manager that raises ResourceDenied when various issues with the internet connection manifest themselves as exceptions . With arguments `resource_name`, `timeout`, `errnos`.", "question_id": 10190}
{"snippet": "test.support.disable_faulthandler()", "intent": "A context manager that replaces sys.stderr with sys.__stderr__ .", "question_id": 10191}
{"snippet": "test.support.gc_collect()", "intent": "Force as many objects as possible to be collected .", "question_id": 10192}
{"snippet": "test.support.disable_gc()", "intent": "A context manager that disables the garbage collector upon entry and reenables it upon exit .", "question_id": 10193}
{"snippet": "test.support.swap_attr(obj, attr, new_val)", "intent": "Context manager to swap out an attribute with a new object . If `attr` doesn \u2019 t exist on `obj` , it will be created and then deleted at the end of the block . With arguments `new_val`.", "question_id": 10194}
{"snippet": "test.support.swap_item(obj, attr, new_val)", "intent": "Context manager to swap out an item with a new object . This will set `obj` [ `` item '' ] to 5 for the duration of the with block , restoring the old value at the end of the block . With arguments `attr`, `new_val`.", "question_id": 10195}
{"snippet": "test.support.wait_threads_exit()", "intent": "Context manager to wait until all threads created in the with statement exit .", "question_id": 10196}
{"snippet": "test.support.wait_threads_exit(timeout=60.0)", "intent": "Context manager to wait until all threads created in the with statement exit . With arguments `timeout`.", "question_id": 10197}
{"snippet": "test.support.start_threads(threads)", "intent": "Context manager to start `threads` .", "question_id": 10198}
{"snippet": "test.support.start_threads(threads, unlock=None)", "intent": "Context manager to start `threads` . With arguments `unlock`.", "question_id": 10199}
{"snippet": "test.support.calcobjsize(fmt)", "intent": "Return struct.calcsize ( ) for nP { `fmt` } 0n or , if gettotalrefcount exists , 2PnP { fmt } 0P .", "question_id": 10200}
{"snippet": "test.support.calcvobjsize(fmt)", "intent": "Return struct.calcsize ( ) for nPn { `fmt` } 0n or , if gettotalrefcount exists , 2PnPn { fmt } 0P .", "question_id": 10201}
{"snippet": "test.support.checksizeof(test, o, size)", "intent": "For testcase `test` , assert that the sys.getsizeof for `o` plus the GC header `size` equals size .", "question_id": 10202}
{"snippet": "test.support.can_symlink()", "intent": "Return True if the OS supports symbolic links , False otherwise .", "question_id": 10203}
{"snippet": "test.support.can_xattr()", "intent": "Return True if the OS supports xattr , False otherwise .", "question_id": 10204}
{"snippet": "@test.support.skip_unless_symlink", "intent": "A decorator for running tests that require support for symbolic links.", "question_id": 10205}
{"snippet": "@test.support.skip_unless_xattr", "intent": "A decorator for running tests that require support for xattr.", "question_id": 10206}
{"snippet": "@test.support.skip_unless_bind_unix_socket", "intent": "A decorator for running tests that require a functional bind() for Unix sockets.", "question_id": 10207}
{"snippet": "@test.support.anticipate_failure(condition)", "intent": "A decorator to conditionally mark tests with unittest.expectedFailure ( ) . With arguments `condition`.", "question_id": 10208}
{"snippet": "@test.support.run_with_locale(catstr, *locales)", "intent": "A decorator for running a function in a different locale , correctly resetting it after it has finished . `catstr` is the locale category as a string ( for example `` LC_ALL '' ) . With arguments `*locales`.", "question_id": 10209}
{"snippet": "@test.support.run_with_tz(tz)", "intent": "A decorator for running a function in a specific timezone , correctly resetting it after it has finished . With arguments `tz`.", "question_id": 10210}
{"snippet": "@test.support.requires_freebsd_version(*min_version)", "intent": "Decorator for the minimum version when running test on FreeBSD . With arguments `*min_version`.", "question_id": 10211}
{"snippet": "@test.support.requires_linux_version(*min_version)", "intent": "Decorator for the minimum version when running test on Linux . With arguments `*min_version`.", "question_id": 10212}
{"snippet": "@test.support.requires_mac_version(*min_version)", "intent": "Decorator for the minimum version when running test on Mac OS X . With arguments `*min_version`.", "question_id": 10213}
{"snippet": "@test.support.requires_IEEE_754", "intent": "Decorator for skipping tests on non-IEEE 754 platforms.", "question_id": 10214}
{"snippet": "@test.support.requires_zlib", "intent": "Decorator for skipping tests if zlib doesn\u2019t exist.", "question_id": 10215}
{"snippet": "@test.support.requires_gzip", "intent": "Decorator for skipping tests if gzip doesn\u2019t exist.", "question_id": 10216}
{"snippet": "@test.support.requires_bz2", "intent": "Decorator for skipping tests if bz2 doesn\u2019t exist.", "question_id": 10217}
{"snippet": "@test.support.requires_lzma", "intent": "Decorator for skipping tests if lzma doesn\u2019t exist.", "question_id": 10218}
{"snippet": "@test.support.requires_resource(resource)", "intent": "Decorator for skipping tests if `resource` is not available .", "question_id": 10219}
{"snippet": "@test.support.requires_docstrings", "intent": "Decorator for only running the test if HAVE_DOCSTRINGS.", "question_id": 10220}
{"snippet": "@test.support.cpython_only(test)", "intent": "Decorator for tests only applicable to CPython . With arguments `test`.", "question_id": 10221}
{"snippet": "@test.support.impl_detail(**guards)", "intent": "Decorator for invoking check_impl_detail ( ) on guards . With arguments `**guards`.", "question_id": 10222}
{"snippet": "@test.support.impl_detail(**guards, msg=None)", "intent": "Decorator for invoking check_impl_detail ( ) on guards . If that returns False , then uses `msg` as the reason for skipping the test . With arguments `**guards`.", "question_id": 10223}
{"snippet": "@test.support.no_tracing(func)", "intent": "Decorator to temporarily turn off tracing for the duration of the test . With arguments `func`.", "question_id": 10224}
{"snippet": "@test.support.refcount_test(test)", "intent": "Decorator for tests which involve reference counting . The decorator does not run the `test` if it is not run by CPython .", "question_id": 10225}
{"snippet": "@test.support.reap_threads(func)", "intent": "Decorator to ensure the threads are cleaned up even if the test fails . With arguments `func`.", "question_id": 10226}
{"snippet": "@test.support.bigmemtest(size, memuse)", "intent": "Decorator for bigmem tests . `size` is a requested size for the test ( in arbitrary , test-interpreted units . ) `memuse` is the number of bytes per unit for the test , or a good estimate of it .", "question_id": 10227}
{"snippet": "@test.support.bigmemtest(size, memuse, dry_run=True)", "intent": "Decorator for bigmem tests . `size` is a requested size for the test ( in arbitrary , test-interpreted units . ) `memuse` is the number of bytes per unit for the test , or a good estimate of it . If `dry_run` is True , the value passed to the test method may be less than the requested value .", "question_id": 10228}
{"snippet": "@test.support.bigaddrspacetest(f)", "intent": "Decorator for tests that fill the address space . `f` is the function to wrap .", "question_id": 10229}
{"snippet": "test.support.make_bad_fd()", "intent": "Create an invalid file descriptor by opening and closing a temporary file , and returning its descriptor .", "question_id": 10230}
{"snippet": "test.support.check_syntax_error(testcase, statement)", "intent": "Test for syntax errors in `statement` by attempting to compile statement . `testcase` is the unittest instance for the test .", "question_id": 10231}
{"snippet": "test.support.check_syntax_error(testcase, statement, errtext='')", "intent": "Test for syntax errors in `statement` by attempting to compile statement . `testcase` is the unittest instance for the test . `errtext` is the text of the error raised by SyntaxError .", "question_id": 10232}
{"snippet": "test.support.check_syntax_error(testcase, statement, lineno=None)", "intent": "Test for syntax errors in `statement` by attempting to compile statement . `testcase` is the unittest instance for the test . If `lineno` is not None , compares to the line of the SyntaxError .", "question_id": 10233}
{"snippet": "test.support.check_syntax_error(testcase, statement, offset=None)", "intent": "Test for syntax errors in `statement` by attempting to compile statement . `testcase` is the unittest instance for the test . If `offset` is not None , compares to the offset of the SyntaxError .", "question_id": 10234}
{"snippet": "test.support.check_syntax_error(testcase, statement, errtext='', lineno=None)", "intent": "Test for syntax errors in `statement` by attempting to compile statement . `testcase` is the unittest instance for the test . `errtext` is the text of the error raised by SyntaxError . If `lineno` is not None , compares to the line of the SyntaxError .", "question_id": 10235}
{"snippet": "test.support.check_syntax_error(testcase, statement, errtext='', offset=None)", "intent": "Test for syntax errors in `statement` by attempting to compile statement . `testcase` is the unittest instance for the test . `errtext` is the text of the error raised by SyntaxError . If `offset` is not None , compares to the offset of the SyntaxError .", "question_id": 10236}
{"snippet": "test.support.check_syntax_error(testcase, statement, lineno=None, offset=None)", "intent": "Test for syntax errors in `statement` by attempting to compile statement . `testcase` is the unittest instance for the test . If `lineno` is not None , compares to the line of the SyntaxError . If `offset` is not None , compares to the offset of the SyntaxError .", "question_id": 10237}
{"snippet": "test.support.check_syntax_error(testcase, statement, errtext='', lineno=None, offset=None)", "intent": "Test for syntax errors in `statement` by attempting to compile statement . `testcase` is the unittest instance for the test . `errtext` is the text of the error raised by SyntaxError . If `lineno` is not None , compares to the line of the SyntaxError . If `offset` is not None , compares to the offset of the SyntaxError .", "question_id": 10238}
{"snippet": "test.support.open_urlresource(url, *args, **kw)", "intent": "Open `url` . With arguments `*args`, `**kw`.", "question_id": 10239}
{"snippet": "test.support.import_module(name, required_on())", "intent": "This function imports and returns the named module . With arguments `name`, `required_on()`.", "question_id": 10240}
{"snippet": "test.support.import_module(name, required_on(), deprecated=False)", "intent": "This function imports and returns the named module . Module and package deprecation messages are suppressed during this import if `deprecated` is True . With arguments `name`, `required_on()`.", "question_id": 10241}
{"snippet": "test.support.import_fresh_module(name)", "intent": "This function imports and returns a `fresh` copy of the named Python module by removing the named module from sys.modules before doing the import . With arguments `name`.", "question_id": 10242}
{"snippet": "test.support.import_fresh_module(name, fresh=())", "intent": "This function imports and returns a `fresh` copy of the named Python module by removing the named module from sys.modules before doing the import . With arguments `name`.", "question_id": 10243}
{"snippet": "test.support.import_fresh_module(name, blocked=())", "intent": "This function imports and returns a `fresh` copy of the named Python module by removing the named module from sys.modules before doing the import . `blocked` is an iterable of module names that are replaced with None in the module cache during the import to ensure that attempts to import them raise ImportError . With arguments `name`.", "question_id": 10244}
{"snippet": "test.support.import_fresh_module(name, deprecated=False)", "intent": "This function imports and returns a `fresh` copy of the named Python module by removing the named module from sys.modules before doing the import . Module and package deprecation messages are suppressed during this import if `deprecated` is True . With arguments `name`.", "question_id": 10245}
{"snippet": "test.support.import_fresh_module(name, fresh=(), blocked=())", "intent": "This function imports and returns a `fresh` copy of the named Python module by removing the named module from sys.modules before doing the import . `blocked` is an iterable of module names that are replaced with None in the module cache during the import to ensure that attempts to import them raise ImportError . With arguments `name`.", "question_id": 10246}
{"snippet": "test.support.import_fresh_module(name, fresh=(), deprecated=False)", "intent": "This function imports and returns a `fresh` copy of the named Python module by removing the named module from sys.modules before doing the import . Module and package deprecation messages are suppressed during this import if `deprecated` is True . With arguments `name`.", "question_id": 10247}
{"snippet": "test.support.import_fresh_module(name, blocked=(), deprecated=False)", "intent": "This function imports and returns a `fresh` copy of the named Python module by removing the named module from sys.modules before doing the import . `blocked` is an iterable of module names that are replaced with None in the module cache during the import to ensure that attempts to import them raise ImportError . Module and package deprecation messages are suppressed during this import if `deprecated` is True . With arguments `name`.", "question_id": 10248}
{"snippet": "test.support.import_fresh_module(name, fresh=(), blocked=(), deprecated=False)", "intent": "This function imports and returns a `fresh` copy of the named Python module by removing the named module from sys.modules before doing the import . `blocked` is an iterable of module names that are replaced with None in the module cache during the import to ensure that attempts to import them raise ImportError . Module and package deprecation messages are suppressed during this import if `deprecated` is True . With arguments `name`.", "question_id": 10249}
{"snippet": "test.support.modules_setup()", "intent": "Return a copy of sys.modules .", "question_id": 10250}
{"snippet": "test.support.modules_cleanup(oldmodules)", "intent": "Remove modules except for `oldmodules` and encodings in order to preserve internal cache .", "question_id": 10251}
{"snippet": "test.support.threading_setup()", "intent": "Return current thread count and copy of dangling threads .", "question_id": 10252}
{"snippet": "test.support.threading_cleanup(*original_values)", "intent": "Cleanup up threads not specified in original_values . With arguments `*original_values`.", "question_id": 10253}
{"snippet": "test.support.join_thread(thread)", "intent": "Join a `thread` within `timeout` .", "question_id": 10254}
{"snippet": "test.support.join_thread(thread, timeout=30.0)", "intent": "Join a `thread` within `timeout` .", "question_id": 10255}
{"snippet": "test.support.reap_children()", "intent": "Use this at the end of test_main whenever sub-processes are started .", "question_id": 10256}
{"snippet": "test.support.get_attribute(obj, name)", "intent": "Get an attribute , raising unittest.SkipTest if AttributeError is raised . With arguments `obj`, `name`.", "question_id": 10257}
{"snippet": "test.support.bind_port(sock)", "intent": "Bind the socket to a free port and return the port number . With arguments `sock`.", "question_id": 10258}
{"snippet": "test.support.bind_port(sock, host=HOST)", "intent": "Bind the socket to a free port and return the port number . With arguments `sock`, `host`.", "question_id": 10259}
{"snippet": "test.support.bind_unix_socket(sock, addr)", "intent": "Bind a unix socket , raising unittest.SkipTest if PermissionError is raised . With arguments `sock`, `addr`.", "question_id": 10260}
{"snippet": "test.support.find_unused_port()", "intent": "Returns an unused port that should be suitable for binding .", "question_id": 10261}
{"snippet": "test.support.find_unused_port(family=socket.AF_INET)", "intent": "Returns an unused port that should be suitable for binding . This is achieved by creating a temporary socket with the same `family` and type as the sock parameter ( default is AF_INET , SOCK_STREAM ) , and binding it to the specified host address ( defaults to 0.0.0.0 ) with the port set to 0 , eliciting an unused ephemeral port from the OS .", "question_id": 10262}
{"snippet": "test.support.find_unused_port(socktype=socket.SOCK_STREAM)", "intent": "Returns an unused port that should be suitable for binding . With arguments `socktype`.", "question_id": 10263}
{"snippet": "test.support.find_unused_port(family=socket.AF_INET, socktype=socket.SOCK_STREAM)", "intent": "Returns an unused port that should be suitable for binding . This is achieved by creating a temporary socket with the same `family` and type as the sock parameter ( default is AF_INET , SOCK_STREAM ) , and binding it to the specified host address ( defaults to 0.0.0.0 ) with the port set to 0 , eliciting an unused ephemeral port from the OS . With arguments `socktype`.", "question_id": 10264}
{"snippet": "test.support.load_package_tests(pkg_dir, loader, standard_tests, pattern)", "intent": "Generic implementation of the unittest load_tests protocol for use in test packages . `pkg_dir` is the root directory of the package ; `loader` , `standard_tests` , and `pattern` are the arguments expected by load_tests .", "question_id": 10265}
{"snippet": "test.support.fs_is_case_insensitive(directory)", "intent": "Return True if the file system for `directory` is case-insensitive .", "question_id": 10266}
{"snippet": "test.support.detect_api_mismatch(ref_api, other_api)", "intent": "Returns the set of attributes , functions or methods of `ref_api` not found on `other_api` , except for a defined list of items to be ignored in this check specified in `ignore` .", "question_id": 10267}
{"snippet": "test.support.detect_api_mismatch(ref_api, other_api, ignore=())", "intent": "Returns the set of attributes , functions or methods of `ref_api` not found on `other_api` , except for a defined list of items to be ignored in this check specified in `ignore` .", "question_id": 10268}
{"snippet": "test.support.patch(test_instance, object_to_patch, attr_name, new_value)", "intent": "Override object_to_patch.attr_name with `new_value` . Also add cleanup procedure to `test_instance` to restore `object_to_patch` for `attr_name` .", "question_id": 10269}
{"snippet": "test.support.run_in_subinterp(code)", "intent": "Run `code` in subinterpreter .", "question_id": 10270}
{"snippet": "test.support.check_free_after_iterating(test, iter, cls)", "intent": "Assert that `iter` is deallocated after iterating . With arguments `test`, `cls`.", "question_id": 10271}
{"snippet": "test.support.check_free_after_iterating(test, iter, cls, args=())", "intent": "Assert that `iter` is deallocated after iterating . With arguments `test`, `cls`, `args`.", "question_id": 10272}
{"snippet": "test.support.missing_compiler_executable()", "intent": "Check for the existence of the compiler executables whose names are listed in `cmd_names` or all the compiler executables when cmd_names is empty and return the first missing executable or None when none is found missing .", "question_id": 10273}
{"snippet": "test.support.missing_compiler_executable(cmd_names=)", "intent": "Check for the existence of the compiler executables whose names are listed in `cmd_names` or all the compiler executables when cmd_names is empty and return the first missing executable or None when none is found missing .", "question_id": 10274}
{"snippet": "test.support.missing_compiler_executable()", "intent": "Check for the existence of the compiler executables whose names are listed in `cmd_names` or all the compiler executables when cmd_names is empty and return the first missing executable or None when none is found missing .", "question_id": 10275}
{"snippet": "test.support.missing_compiler_executable(cmd_names=)", "intent": "Check for the existence of the compiler executables whose names are listed in `cmd_names` or all the compiler executables when cmd_names is empty and return the first missing executable or None when none is found missing .", "question_id": 10276}
{"snippet": "test.support.check__all__(test_case, module)", "intent": "Assert that the __all__ variable of `module` contains all public names . With arguments `test_case`.", "question_id": 10277}
{"snippet": "test.support.check__all__(test_case, module, name_of_module=None)", "intent": "Assert that the __all__ variable of `module` contains all public names . The `name_of_module` argument can specify ( as a string or tuple thereof ) what module ( s ) an API could be defined in order to be detected as a public API . With arguments `test_case`.", "question_id": 10278}
{"snippet": "test.support.check__all__(test_case, module, extra=())", "intent": "Assert that the __all__ variable of `module` contains all public names . The `extra` argument can be a set of names that wouldn \u2019 t otherwise be automatically detected as \u201c public \u201d , like objects without a proper __module__ attribute . With arguments `test_case`.", "question_id": 10279}
{"snippet": "test.support.check__all__(test_case, module, blacklist=())", "intent": "Assert that the __all__ variable of `module` contains all public names . The `blacklist` argument can be a set of names that must not be treated as part of the public API even though their names indicate otherwise . With arguments `test_case`.", "question_id": 10280}
{"snippet": "test.support.check__all__(test_case, module, name_of_module=None, extra=())", "intent": "Assert that the __all__ variable of `module` contains all public names . The `name_of_module` argument can specify ( as a string or tuple thereof ) what module ( s ) an API could be defined in order to be detected as a public API . The `extra` argument can be a set of names that wouldn \u2019 t otherwise be automatically detected as \u201c public \u201d , like objects without a proper __module__ attribute . With arguments `test_case`.", "question_id": 10281}
{"snippet": "test.support.check__all__(test_case, module, name_of_module=None, blacklist=())", "intent": "Assert that the __all__ variable of `module` contains all public names . The `name_of_module` argument can specify ( as a string or tuple thereof ) what module ( s ) an API could be defined in order to be detected as a public API . The `blacklist` argument can be a set of names that must not be treated as part of the public API even though their names indicate otherwise . With arguments `test_case`.", "question_id": 10282}
{"snippet": "test.support.check__all__(test_case, module, extra=(), blacklist=())", "intent": "Assert that the __all__ variable of `module` contains all public names . The `extra` argument can be a set of names that wouldn \u2019 t otherwise be automatically detected as \u201c public \u201d , like objects without a proper __module__ attribute . The `blacklist` argument can be a set of names that must not be treated as part of the public API even though their names indicate otherwise . With arguments `test_case`.", "question_id": 10283}
{"snippet": "test.support.check__all__(test_case, module, name_of_module=None, extra=(), blacklist=())", "intent": "Assert that the __all__ variable of `module` contains all public names . The `name_of_module` argument can specify ( as a string or tuple thereof ) what module ( s ) an API could be defined in order to be detected as a public API . The `extra` argument can be a set of names that wouldn \u2019 t otherwise be automatically detected as \u201c public \u201d , like objects without a proper __module__ attribute . The `blacklist` argument can be a set of names that must not be treated as part of the public API even though their names indicate otherwise . With arguments `test_case`.", "question_id": 10284}
{"snippet": "test.support.TransientResource(exc, **kwargs)", "intent": "Instances are a context manager that raises ResourceDenied if the specified exception type is raised . With arguments `exc`, `**kwargs`.", "question_id": 10285}
{"snippet": "test.support.EnvironmentVarGuard", "intent": "Class used to temporarily set or unset environment variables.", "question_id": 10286}
{"snippet": "EnvironmentVarGuard.set(envvar, value)", "intent": "Temporarily set the environment variable `envvar` to the `value` of value .", "question_id": 10287}
{"snippet": "EnvironmentVarGuard.unset(envvar)", "intent": "Temporarily unset the environment variable `envvar` .", "question_id": 10288}
{"snippet": "test.support.SuppressCrashReport", "intent": "A context manager used to try to prevent crash dialog popups on tests that are expected to crash a subprocess.", "question_id": 10289}
{"snippet": "test.support.CleanImport(*module_names)", "intent": "A context manager to force import to return a new module reference . With arguments `*module_names`.", "question_id": 10290}
{"snippet": "test.support.DirsOnSysPath(*paths)", "intent": "A context manager to temporarily add directories to sys.path . With arguments `*paths`.", "question_id": 10291}
{"snippet": "test.support.SaveSignals", "intent": "Class to save and restore signal handlers registered by the Python signal handler.", "question_id": 10292}
{"snippet": "save_signals.matches(self, d, **kwargs)", "intent": "Try to match a single dict with the supplied arguments . With arguments `self`, `d`, `**kwargs`.", "question_id": 10293}
{"snippet": "save_signals.match_value(self, k, dv, v)", "intent": "Try to match a single stored value ( `dv` ) with a supplied value ( `v` ) . With arguments `self`, `k`.", "question_id": 10294}
{"snippet": "test.support.WarningsRecorder", "intent": "Class used to record warnings for unit tests.", "question_id": 10295}
{"snippet": "warnings_recorder.run(test)", "intent": "Run `test` and return the result .", "question_id": 10296}
{"snippet": "test.support.TestHandler(logging.handlers.BufferingHandler)", "intent": "Class for logging support . With arguments `logging.handlers.BufferingHandler`.", "question_id": 10297}
{"snippet": "test.support.FakePath(path)", "intent": "Simple path-like object . It implements the __fspath__ ( ) method which just returns the `path` argument .", "question_id": 10298}
{"snippet": "test.support.script_helper.interpreter_requires_environment()", "intent": "Return True if sys.executable interpreter requires environment variables in order to be able to run at all .", "question_id": 10299}
{"snippet": "test.support.script_helper.run_python_until_end(*args, **env_vars)", "intent": "Set up the environment based on env_vars for running the interpreter in a subprocess . With arguments `*args`, `**env_vars`.", "question_id": 10300}
{"snippet": "test.support.script_helper.assert_python_ok(*args, **env_vars)", "intent": "Assert that running the interpreter with args and optional environment variables env_vars succeeds ( rc == 0 ) and return a ( return code , stdout , stderr ) tuple . With arguments `*args`, `**env_vars`.", "question_id": 10301}
{"snippet": "test.support.script_helper.assert_python_failure(*args, **env_vars)", "intent": "Assert that running the interpreter with args and optional environment variables env_vars fails ( rc ! = 0 ) and return a ( return code , stdout , stderr ) tuple . With arguments `*args`, `**env_vars`.", "question_id": 10302}
{"snippet": "test.support.script_helper.spawn_python(*args, **kw)", "intent": "Run a Python subprocess with the given arguments . With arguments `*args`, `**kw`.", "question_id": 10303}
{"snippet": "test.support.script_helper.spawn_python(*args, **kw, stdout=subprocess.PIPE)", "intent": "Run a Python subprocess with the given arguments . With arguments `*args`, `**kw`, `stdout`.", "question_id": 10304}
{"snippet": "test.support.script_helper.spawn_python(*args, **kw, stderr=subprocess.STDOUT)", "intent": "Run a Python subprocess with the given arguments . With arguments `*args`, `**kw`, `stderr`.", "question_id": 10305}
{"snippet": "test.support.script_helper.spawn_python(*args, **kw, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)", "intent": "Run a Python subprocess with the given arguments . With arguments `*args`, `**kw`, `stdout`, `stderr`.", "question_id": 10306}
{"snippet": "test.support.script_helper.kill_python(p)", "intent": "Run the given subprocess.Popen process until completion and return stdout . With arguments `p`.", "question_id": 10307}
{"snippet": "test.support.script_helper.make_script(script_dir, script_basename, source)", "intent": "Create script containing `source` in path `script_dir` and `script_basename` .", "question_id": 10308}
{"snippet": "test.support.script_helper.make_script(script_dir, script_basename, source, omit_suffix=False)", "intent": "Create script containing `source` in path `script_dir` and `script_basename` . If `omit_suffix` is False , append .py to the name .", "question_id": 10309}
{"snippet": "test.support.script_helper.make_zip_script(zip_dir, zip_basename, script_name)", "intent": "Create zip file at `zip_dir` and `zip_basename` with extension zip which contains the files in `script_name` .", "question_id": 10310}
{"snippet": "test.support.script_helper.make_zip_script(zip_dir, zip_basename, script_name, name_in_zip=None)", "intent": "Create zip file at `zip_dir` and `zip_basename` with extension zip which contains the files in `script_name` . `name_in_zip` is the archive name .", "question_id": 10311}
{"snippet": "test.support.script_helper.make_pkg(pkg_dir)", "intent": "Create a directory named `pkg_dir` containing an __init__ file with `init_source` as its contents .", "question_id": 10312}
{"snippet": "test.support.script_helper.make_pkg(pkg_dir, init_source='')", "intent": "Create a directory named `pkg_dir` containing an __init__ file with `init_source` as its contents .", "question_id": 10313}
{"snippet": "test.support.script_helper.make_zip_pkg(zip_dir, zip_basename, pkg_name, script_basename, source)", "intent": "Create a zip package directory with a path of `zip_dir` and `zip_basename` containing an empty __init__ file and a file `script_basename` containing the `source` . With arguments `pkg_name`.", "question_id": 10314}
{"snippet": "test.support.script_helper.make_zip_pkg(zip_dir, zip_basename, pkg_name, script_basename, source, depth=1)", "intent": "Create a zip package directory with a path of `zip_dir` and `zip_basename` containing an empty __init__ file and a file `script_basename` containing the `source` . With arguments `pkg_name`, `depth`.", "question_id": 10315}
{"snippet": "test.support.script_helper.make_zip_pkg(zip_dir, zip_basename, pkg_name, script_basename, source, compiled=False)", "intent": "Create a zip package directory with a path of `zip_dir` and `zip_basename` containing an empty __init__ file and a file `script_basename` containing the `source` . If `compiled` is True , both source files will be compiled and added to the zip package . With arguments `pkg_name`.", "question_id": 10316}
{"snippet": "test.support.script_helper.make_zip_pkg(zip_dir, zip_basename, pkg_name, script_basename, source, depth=1, compiled=False)", "intent": "Create a zip package directory with a path of `zip_dir` and `zip_basename` containing an empty __init__ file and a file `script_basename` containing the `source` . If `compiled` is True , both source files will be compiled and added to the zip package . With arguments `pkg_name`, `depth`.", "question_id": 10317}
{"snippet": "textwrap.wrap(text, **kwargs)", "intent": "Wraps the single paragraph in `text` ( a string ) so every line is at most `width` characters long . With arguments `**kwargs`.", "question_id": 10318}
{"snippet": "textwrap.wrap(text, **kwargs, width=70)", "intent": "Wraps the single paragraph in `text` ( a string ) so every line is at most `width` characters long . With arguments `**kwargs`.", "question_id": 10319}
{"snippet": "textwrap.fill(text, **kwargs)", "intent": "Wraps the single paragraph in `text` , and returns a single string containing the wrapped paragraph . With arguments `**kwargs`.", "question_id": 10320}
{"snippet": "textwrap.fill(text, **kwargs, width=70)", "intent": "Wraps the single paragraph in `text` , and returns a single string containing the wrapped paragraph . With arguments `**kwargs`, `width`.", "question_id": 10321}
{"snippet": "textwrap.shorten(text, width, **kwargs)", "intent": "Collapse and truncate the given `text` to fit in the given `width` . With arguments `**kwargs`.", "question_id": 10322}
{"snippet": "textwrap.dedent(text)", "intent": "Remove any common leading whitespace from every line in `text` .", "question_id": 10323}
{"snippet": "textwrap.indent(text, prefix)", "intent": "Add `prefix` to the beginning of selected lines in `text` .", "question_id": 10324}
{"snippet": "textwrap.indent(text, prefix, predicate=None)", "intent": "Add `prefix` to the beginning of selected lines in `text` . The optional `predicate` argument can be used to control which lines are indented .", "question_id": 10325}
{"snippet": "textwrap.TextWrapper(**kwargs)", "intent": "The TextWrapper constructor accepts a number of optional keyword arguments . With arguments `**kwargs`.", "question_id": 10326}
{"snippet": "text_wrapper.width", "intent": "(default: 70) The maximum length of wrapped lines.", "question_id": 10327}
{"snippet": "text_wrapper.expand_tabs", "intent": "(default: True) If true, then all tab characters in text will be expanded to spaces using the expandtabs() method of text.", "question_id": 10328}
{"snippet": "text_wrapper.tabsize", "intent": "(default: 8) If expand_tabs is true, then all tab characters in text will be expanded to zero or more spaces, depending on the current column and the given tab size.", "question_id": 10329}
{"snippet": "text_wrapper.replace_whitespace", "intent": "(default: True) If true, after tab expansion but before wrapping, the wrap() method will replace each whitespace character with a single space.", "question_id": 10330}
{"snippet": "text_wrapper.drop_whitespace", "intent": "(default: True) If true, whitespace at the beginning and ending of every line (after wrapping but before indenting) is dropped.", "question_id": 10331}
{"snippet": "text_wrapper.initial_indent", "intent": "(default: '') String that will be prepended to the first line of wrapped output.", "question_id": 10332}
{"snippet": "text_wrapper.subsequent_indent", "intent": "(default: '') String that will be prepended to all lines of wrapped output except the first.", "question_id": 10333}
{"snippet": "text_wrapper.fix_sentence_endings", "intent": "(default: False) If true, TextWrapper attempts to detect sentence endings and ensure that sentences are always separated by exactly two spaces.", "question_id": 10334}
{"snippet": "text_wrapper.break_long_words", "intent": "(default: True) If true, then words longer than width will be broken in order to ensure that no lines are longer than width.", "question_id": 10335}
{"snippet": "text_wrapper.break_on_hyphens", "intent": "(default: True) If true, wrapping will occur preferably on whitespaces and right after hyphens in compound words, as it is customary in English.", "question_id": 10336}
{"snippet": "text_wrapper.max_lines", "intent": "(default: None) If not None, then the output will contain at most max_lines lines, with placeholder appearing at the end of the output.", "question_id": 10337}
{"snippet": "text_wrapper.placeholder", "intent": "(default: ' [...]') String that will appear at the end of the output text if it has been truncated.", "question_id": 10338}
{"snippet": "text_wrapper.wrap(text)", "intent": "Wraps the single paragraph in `text` ( a string ) so every line is at most width characters long .", "question_id": 10339}
{"snippet": "text_wrapper.fill(text)", "intent": "Wraps the single paragraph in `text` , and returns a single string containing the wrapped paragraph .", "question_id": 10340}
{"snippet": "threading.active_count()", "intent": "Return the number of Thread objects currently alive .", "question_id": 10341}
{"snippet": "threading.current_thread()", "intent": "Return the current Thread object , corresponding to the caller \u2019 s thread of control .", "question_id": 10342}
{"snippet": "threading.get_ident()", "intent": "Return the \u2018 thread identifier \u2019 of the current thread .", "question_id": 10343}
{"snippet": "threading.enumerate()", "intent": "Return a list of all Thread objects currently alive .", "question_id": 10344}
{"snippet": "threading.main_thread()", "intent": "Return the main Thread object .", "question_id": 10345}
{"snippet": "threading.settrace(func)", "intent": "Set a trace function for all threads started from the threading module . The `func` will be passed to sys.settrace ( ) for each thread , before its run ( ) method is called .", "question_id": 10346}
{"snippet": "threading.setprofile(func)", "intent": "Set a profile function for all threads started from the threading module . The `func` will be passed to sys.setprofile ( ) for each thread , before its run ( ) method is called .", "question_id": 10347}
{"snippet": "threading.stack_size(size)", "intent": "Return the thread stack `size` used when creating new threads .", "question_id": 10348}
{"snippet": "threading.stack_size()", "intent": "Return the thread stack `size` used when creating new threads .", "question_id": 10349}
{"snippet": "threading.TIMEOUT_MAX", "intent": "The maximum value allowed for the timeout parameter of blocking functions (Lock.acquire(), RLock.acquire(), Condition.wait(), etc.).", "question_id": 10350}
{"snippet": "threading.local", "intent": "A class that represents thread-local data.", "question_id": 10351}
{"snippet": "threading.Thread()", "intent": "This constructor should always be called with keyword arguments .", "question_id": 10352}
{"snippet": "threading.Thread(group=None)", "intent": "This constructor should always be called with keyword arguments . `group` should be None ; reserved for future extension when a ThreadGroup class is implemented .", "question_id": 10353}
{"snippet": "threading.Thread(target=None)", "intent": "This constructor should always be called with keyword arguments . `target` is the callable object to be invoked by the run ( ) method .", "question_id": 10354}
{"snippet": "threading.Thread(name=None)", "intent": "This constructor should always be called with keyword arguments . `name` is the thread name .", "question_id": 10355}
{"snippet": "threading.Thread(args=())", "intent": "This constructor should always be called with keyword arguments . `args` is the argument tuple for the target invocation .", "question_id": 10356}
{"snippet": "threading.Thread(kwargs={})", "intent": "This constructor should always be called with keyword arguments . `kwargs` is a dictionary of keyword arguments for the target invocation .", "question_id": 10357}
{"snippet": "threading.Thread(daemon=None)", "intent": "This constructor should always be called with keyword arguments . If not None , `daemon` explicitly sets whether the thread is daemonic .", "question_id": 10358}
{"snippet": "threading.Thread(group=None, target=None)", "intent": "This constructor should always be called with keyword arguments . `group` should be None ; reserved for future extension when a ThreadGroup class is implemented . `target` is the callable object to be invoked by the run ( ) method .", "question_id": 10359}
{"snippet": "threading.Thread(group=None, name=None)", "intent": "This constructor should always be called with keyword arguments . `group` should be None ; reserved for future extension when a ThreadGroup class is implemented . `name` is the thread name .", "question_id": 10360}
{"snippet": "threading.Thread(group=None, args=())", "intent": "This constructor should always be called with keyword arguments . `group` should be None ; reserved for future extension when a ThreadGroup class is implemented . `args` is the argument tuple for the target invocation .", "question_id": 10361}
{"snippet": "thread.start()", "intent": "Start the thread \u2019 s activity .", "question_id": 10362}
{"snippet": "thread.run()", "intent": "Method representing the thread \u2019 s activity .", "question_id": 10363}
{"snippet": "thread.join()", "intent": "Wait until the thread terminates .", "question_id": 10364}
{"snippet": "thread.join(timeout=None)", "intent": "Wait until the thread terminates . This blocks the calling thread until the thread whose join ( ) method is called terminates \u2013 either normally or through an unhandled exception \u2013 or until the optional `timeout` occurs .", "question_id": 10365}
{"snippet": "thread.name", "intent": "A string used for identification purposes only.", "question_id": 10366}
{"snippet": "thread.getName()", "intent": "Old getter/setter API for name ; use it directly as a property instead .", "question_id": 10367}
{"snippet": "thread.setName()", "intent": "Old getter/setter API for name ; use it directly as a property instead .", "question_id": 10368}
{"snippet": "thread.ident", "intent": "The \u2018thread identifier\u2019 of this thread or None if the thread has not been started.", "question_id": 10369}
{"snippet": "thread.is_alive()", "intent": "Return whether the thread is alive .", "question_id": 10370}
{"snippet": "thread.daemon", "intent": "A boolean value indicating whether this thread is a daemon thread (True) or not (False).", "question_id": 10371}
{"snippet": "thread.isDaemon()", "intent": "Old getter/setter API for daemon ; use it directly as a property instead .", "question_id": 10372}
{"snippet": "thread.setDaemon()", "intent": "Old getter/setter API for daemon ; use it directly as a property instead .", "question_id": 10373}
{"snippet": "threading.Lock", "intent": "The class implementing primitive lock objects.", "question_id": 10374}
{"snippet": "lock.acquire()", "intent": "Acquire a lock , `blocking` or non-blocking .", "question_id": 10375}
{"snippet": "lock.acquire(blocking=True)", "intent": "Acquire a lock , `blocking` or non-blocking .", "question_id": 10376}
{"snippet": "lock.acquire(timeout=-1)", "intent": "Acquire a lock , `blocking` or non-blocking . When invoked with the floating-point `timeout` argument set to a positive value , block for at most the number of seconds specified by timeout and as long as the lock can not be acquired .", "question_id": 10377}
{"snippet": "lock.acquire(blocking=True, timeout=-1)", "intent": "Acquire a lock , `blocking` or non-blocking . When invoked with the floating-point `timeout` argument set to a positive value , block for at most the number of seconds specified by timeout and as long as the lock can not be acquired .", "question_id": 10378}
{"snippet": "lock.release()", "intent": "Release a lock .", "question_id": 10379}
{"snippet": "threading.RLock", "intent": "This class implements reentrant lock objects.", "question_id": 10380}
{"snippet": "r_lock.acquire()", "intent": "Acquire a lock , `blocking` or non-blocking .", "question_id": 10381}
{"snippet": "r_lock.acquire(blocking=True)", "intent": "Acquire a lock , `blocking` or non-blocking .", "question_id": 10382}
{"snippet": "r_lock.acquire(timeout=-1)", "intent": "Acquire a lock , `blocking` or non-blocking . When invoked with the floating-point `timeout` argument set to a positive value , block for at most the number of seconds specified by timeout and as long as the lock can not be acquired .", "question_id": 10383}
{"snippet": "r_lock.acquire(blocking=True, timeout=-1)", "intent": "Acquire a lock , `blocking` or non-blocking . When invoked with the floating-point `timeout` argument set to a positive value , block for at most the number of seconds specified by timeout and as long as the lock can not be acquired .", "question_id": 10384}
{"snippet": "r_lock.release()", "intent": "Release a lock , decrementing the recursion level .", "question_id": 10385}
{"snippet": "threading.Condition()", "intent": "This class implements condition variable objects .", "question_id": 10386}
{"snippet": "threading.Condition(lock=None)", "intent": "This class implements condition variable objects . If the `lock` argument is given and not None , it must be a Lock or RLock object , and it is used as the underlying lock .", "question_id": 10387}
{"snippet": "condition.acquire(*args)", "intent": "Acquire the underlying lock . With arguments `*args`.", "question_id": 10388}
{"snippet": "condition.release()", "intent": "Release the underlying lock .", "question_id": 10389}
{"snippet": "condition.wait()", "intent": "Wait until notified or until a `timeout` occurs .", "question_id": 10390}
{"snippet": "condition.wait(timeout=None)", "intent": "Wait until notified or until a `timeout` occurs .", "question_id": 10391}
{"snippet": "condition.wait_for(predicate)", "intent": "Wait until a condition evaluates to true . `predicate` should be a callable which result will be interpreted as a boolean value .", "question_id": 10392}
{"snippet": "condition.wait_for(predicate, timeout=None)", "intent": "Wait until a condition evaluates to true . `predicate` should be a callable which result will be interpreted as a boolean value . A `timeout` may be provided giving the maximum time to wait .", "question_id": 10393}
{"snippet": "condition.notify()", "intent": "By default , wake up one thread waiting on this condition , if any .", "question_id": 10394}
{"snippet": "condition.notify(n=1)", "intent": "By default , wake up one thread waiting on this condition , if any . This method wakes up at most `n` of the threads waiting for the condition variable ; it is a no-op if no threads are waiting .", "question_id": 10395}
{"snippet": "condition.notify_all()", "intent": "Wake up all threads waiting on this condition .", "question_id": 10396}
{"snippet": "threading.Semaphore()", "intent": "This class implements semaphore objects .", "question_id": 10397}
{"snippet": "threading.Semaphore(value=1)", "intent": "This class implements semaphore objects . A semaphore manages an atomic counter representing the number of release ( ) calls minus the number of acquire ( ) calls , plus an initial `value` .", "question_id": 10398}
{"snippet": "semaphore.acquire()", "intent": "Acquire a semaphore .", "question_id": 10399}
{"snippet": "semaphore.acquire(blocking=True)", "intent": "Acquire a semaphore . When invoked with `blocking` set to false , do not block .", "question_id": 10400}
{"snippet": "semaphore.acquire(timeout=None)", "intent": "Acquire a semaphore . When invoked with a `timeout` other than None , it will block for at most timeout seconds .", "question_id": 10401}
{"snippet": "semaphore.acquire(blocking=True, timeout=None)", "intent": "Acquire a semaphore . When invoked with `blocking` set to false , do not block . When invoked with a `timeout` other than None , it will block for at most timeout seconds .", "question_id": 10402}
{"snippet": "semaphore.release()", "intent": "Release a semaphore , incrementing the internal counter by one .", "question_id": 10403}
{"snippet": "threading.BoundedSemaphore()", "intent": "Class implementing bounded semaphore objects .", "question_id": 10404}
{"snippet": "threading.BoundedSemaphore(value=1)", "intent": "Class implementing bounded semaphore objects . A bounded semaphore checks to make sure its current `value` doesn \u2019 t exceed its initial value .", "question_id": 10405}
{"snippet": "threading.Event", "intent": "Class implementing event objects.", "question_id": 10406}
{"snippet": "event.is_set()", "intent": "Return true if and only if the internal flag is true .", "question_id": 10407}
{"snippet": "event.set()", "intent": "Set the internal flag to true .", "question_id": 10408}
{"snippet": "event.clear()", "intent": "Reset the internal flag to false .", "question_id": 10409}
{"snippet": "event.wait()", "intent": "Block until the internal flag is true .", "question_id": 10410}
{"snippet": "event.wait(timeout=None)", "intent": "Block until the internal flag is true . Otherwise , block until another thread calls set ( ) to set the flag to true , or until the optional `timeout` occurs .", "question_id": 10411}
{"snippet": "threading.Timer(interval, function)", "intent": "Create a timer that will run `function` with arguments `args` and keyword arguments `kwargs` , after `interval` seconds have passed .", "question_id": 10412}
{"snippet": "threading.Timer(interval, function, args=None)", "intent": "Create a timer that will run `function` with arguments `args` and keyword arguments `kwargs` , after `interval` seconds have passed .", "question_id": 10413}
{"snippet": "threading.Timer(interval, function, kwargs=None)", "intent": "Create a timer that will run `function` with arguments `args` and keyword arguments `kwargs` , after `interval` seconds have passed .", "question_id": 10414}
{"snippet": "threading.Timer(interval, function, args=None, kwargs=None)", "intent": "Create a timer that will run `function` with arguments `args` and keyword arguments `kwargs` , after `interval` seconds have passed .", "question_id": 10415}
{"snippet": "timer.cancel()", "intent": "Stop the timer , and cancel the execution of the timer \u2019 s action .", "question_id": 10416}
{"snippet": "threading.Barrier(parties)", "intent": "Create a barrier object for `parties` number of threads .", "question_id": 10417}
{"snippet": "threading.Barrier(parties, action=None)", "intent": "Create a barrier object for `parties` number of threads . An `action` , when provided , is a callable to be called by one of the threads when they are released .", "question_id": 10418}
{"snippet": "threading.Barrier(parties, timeout=None)", "intent": "Create a barrier object for `parties` number of threads . `timeout` is the default timeout value if none is specified for the wait ( ) method .", "question_id": 10419}
{"snippet": "threading.Barrier(parties, action=None, timeout=None)", "intent": "Create a barrier object for `parties` number of threads . An `action` , when provided , is a callable to be called by one of the threads when they are released . `timeout` is the default timeout value if none is specified for the wait ( ) method .", "question_id": 10420}
{"snippet": "barrier.wait()", "intent": "Pass the barrier .", "question_id": 10421}
{"snippet": "barrier.wait(timeout=None)", "intent": "Pass the barrier . If a `timeout` is provided , it is used in preference to any that was supplied to the class constructor .", "question_id": 10422}
{"snippet": "barrier.reset()", "intent": "Return the barrier to the default , empty state .", "question_id": 10423}
{"snippet": "barrier.abort()", "intent": "Put the barrier into a broken state .", "question_id": 10424}
{"snippet": "barrier.parties", "intent": "The number of threads required to pass the barrier.", "question_id": 10425}
{"snippet": "barrier.n_waiting", "intent": "The number of threads currently waiting in the barrier.", "question_id": 10426}
{"snippet": "barrier.broken", "intent": "A boolean that is True if the barrier is in the broken state.", "question_id": 10427}
{"snippet": "threading.BrokenBarrierError", "intent": "This exception, a subclass of RuntimeError, is raised when the Barrier object is reset or broken.", "question_id": 10428}
{"snippet": "time.asctime(t)", "intent": "Convert a tuple or struct_time representing a time as returned by gmtime ( ) or localtime ( ) to a string of the following form : 'Sun Jun 20 23:21:05 1993 ' . If `t` is not provided , the current time as returned by localtime ( ) is used .", "question_id": 10429}
{"snippet": "time.asctime()", "intent": "Convert a tuple or struct_time representing a time as returned by gmtime ( ) or localtime ( ) to a string of the following form : 'Sun Jun 20 23:21:05 1993 ' .", "question_id": 10430}
{"snippet": "time.clock()", "intent": "On Unix , return the current processor time as a floating point number expressed in seconds .", "question_id": 10431}
{"snippet": "time.pthread_getcpuclockid(thread_id)", "intent": "Return the clk_id of the thread-specific CPU-time clock for the specified `thread_id` .", "question_id": 10432}
{"snippet": "time.clock_getres(clk_id)", "intent": "Return the resolution ( precision ) of the specified clock `clk_id` .", "question_id": 10433}
{"snippet": "time.clock_gettime(clk_id)", "intent": "Return the time of the specified clock `clk_id` .", "question_id": 10434}
{"snippet": "time.clock_gettime_ns(clk_id)", "intent": "Similar to clock_gettime ( ) but return time as nanoseconds . With arguments `clk_id`.", "question_id": 10435}
{"snippet": "time.clock_settime(clk_id, time: float)", "intent": "Set the time of the specified clock `clk_id` . With arguments `time: float`.", "question_id": 10436}
{"snippet": "time.clock_settime_ns(clk_id, time: int)", "intent": "Similar to clock_settime ( ) but set time with nanoseconds . With arguments `clk_id`, `time: int`.", "question_id": 10437}
{"snippet": "time.ctime(secs)", "intent": "Convert a time expressed in seconds since the epoch to a string representing local time . If `secs` is not provided or None , the current time as returned by time ( ) is used .", "question_id": 10438}
{"snippet": "time.ctime()", "intent": "Convert a time expressed in seconds since the epoch to a string representing local time .", "question_id": 10439}
{"snippet": "time.get_clock_info(name)", "intent": "Get information on the specified clock as a namespace object . With arguments `name`.", "question_id": 10440}
{"snippet": "time.gmtime(secs)", "intent": "Convert a time expressed in seconds since the epoch to a struct_time in UTC in which the dst flag is always zero . If `secs` is not provided or None , the current time as returned by time ( ) is used .", "question_id": 10441}
{"snippet": "time.gmtime()", "intent": "Convert a time expressed in seconds since the epoch to a struct_time in UTC in which the dst flag is always zero .", "question_id": 10442}
{"snippet": "time.localtime(secs)", "intent": "Like gmtime ( ) but converts to local time . If `secs` is not provided or None , the current time as returned by time ( ) is used .", "question_id": 10443}
{"snippet": "time.localtime()", "intent": "Like gmtime ( ) but converts to local time .", "question_id": 10444}
{"snippet": "time.mktime(t)", "intent": "This is the inverse function of localtime ( ) . With arguments `t`.", "question_id": 10445}
{"snippet": "time.monotonic()", "intent": "Return the value ( in fractional seconds ) of a monotonic clock , i.e .", "question_id": 10446}
{"snippet": "time.monotonic_ns()", "intent": "Similar to monotonic ( ) , but return time as nanoseconds .", "question_id": 10447}
{"snippet": "time.perf_counter()", "intent": "Return the value ( in fractional seconds ) of a performance counter , i.e .", "question_id": 10448}
{"snippet": "time.perf_counter_ns()", "intent": "Similar to perf_counter ( ) , but return time as nanoseconds .", "question_id": 10449}
{"snippet": "time.process_time()", "intent": "Return the value ( in fractional seconds ) of the sum of the system and user CPU time of the current process .", "question_id": 10450}
{"snippet": "time.process_time_ns()", "intent": "Similar to process_time ( ) but return time as nanoseconds .", "question_id": 10451}
{"snippet": "time.sleep(secs)", "intent": "Suspend execution of the calling thread for the given number of seconds . With arguments `secs`.", "question_id": 10452}
{"snippet": "time.strftime(format, t)", "intent": "Convert a tuple or struct_time representing a time as returned by gmtime ( ) or localtime ( ) to a string as specified by the `format` argument . If `t` is not provided , the current time as returned by localtime ( ) is used .", "question_id": 10453}
{"snippet": "time.strftime(format)", "intent": "Convert a tuple or struct_time representing a time as returned by gmtime ( ) or localtime ( ) to a string as specified by the `format` argument .", "question_id": 10454}
{"snippet": "time.strptime(string, format)", "intent": "Parse a `string` representing a time according to a `format` .", "question_id": 10455}
{"snippet": "time.strptime(string)", "intent": "Parse a `string` representing a time according to a `format` .", "question_id": 10456}
{"snippet": "time.struct_time", "intent": "The type of the time value sequence returned by gmtime(), localtime(), and strptime().", "question_id": 10457}
{"snippet": "time.time()", "intent": "Return the time in seconds since the epoch as a floating point number .", "question_id": 10458}
{"snippet": "time.thread_time()", "intent": "Return the value ( in fractional seconds ) of the sum of the system and user CPU time of the current thread .", "question_id": 10459}
{"snippet": "time.thread_time_ns()", "intent": "Similar to thread_time ( ) but return time as nanoseconds .", "question_id": 10460}
{"snippet": "time.time_ns()", "intent": "Similar to time ( ) but returns time as an integer number of nanoseconds since the epoch .", "question_id": 10461}
{"snippet": "time.tzset()", "intent": "Reset the time conversion rules used by the library routines .", "question_id": 10462}
{"snippet": "time.CLOCK_BOOTTIME", "intent": "Identical to CLOCK_MONOTONIC, except it also includes any time that the system is suspended.", "question_id": 10463}
{"snippet": "time.CLOCK_HIGHRES", "intent": "The Solaris OS has a CLOCK_HIGHRES timer that attempts to use an optimal hardware source, and may give close to nanosecond resolution.", "question_id": 10464}
{"snippet": "time.CLOCK_MONOTONIC", "intent": "Clock that cannot be set and represents monotonic time since some unspecified starting point.", "question_id": 10465}
{"snippet": "time.CLOCK_MONOTONIC_RAW", "intent": "Similar to CLOCK_MONOTONIC, but provides access to a raw hardware-based time that is not subject to NTP adjustments.", "question_id": 10466}
{"snippet": "time.CLOCK_PROCESS_CPUTIME_ID", "intent": "High-resolution per-process timer from the CPU.", "question_id": 10467}
{"snippet": "time.CLOCK_PROF", "intent": "High-resolution per-process timer from the CPU.", "question_id": 10468}
{"snippet": "time.CLOCK_THREAD_CPUTIME_ID", "intent": "Thread-specific CPU-time clock.", "question_id": 10469}
{"snippet": "time.CLOCK_UPTIME", "intent": "Time whose absolute value is the time the system has been running and not suspended, providing accurate uptime measurement, both absolute and interval.", "question_id": 10470}
{"snippet": "time.CLOCK_REALTIME", "intent": "System-wide real-time clock.", "question_id": 10471}
{"snippet": "time.altzone", "intent": "The offset of the local DST timezone, in seconds west of UTC, if one is defined.", "question_id": 10472}
{"snippet": "time.daylight", "intent": "Nonzero if a DST timezone is defined.", "question_id": 10473}
{"snippet": "time.timezone", "intent": "The offset of the local (non-DST) timezone, in seconds west of UTC (negative in most of Western Europe, positive in the US, zero in the UK).", "question_id": 10474}
{"snippet": "time.tzname", "intent": "A tuple of two strings: the first is the name of the local non-DST timezone, the second is the name of the local DST timezone.", "question_id": 10475}
{"snippet": "timeit.timeit()", "intent": "Create a Timer instance with the given statement , `setup` code and `timer` function and run its timeit ( ) method with `number` executions .", "question_id": 10476}
{"snippet": "timeit.timeit(stmt='pass')", "intent": "Create a Timer instance with the given statement , `setup` code and `timer` function and run its timeit ( ) method with `number` executions . With arguments `stmt`.", "question_id": 10477}
{"snippet": "timeit.timeit(setup='pass')", "intent": "Create a Timer instance with the given statement , `setup` code and `timer` function and run its timeit ( ) method with `number` executions .", "question_id": 10478}
{"snippet": "timeit.timeit(timer=<default timer>)", "intent": "Create a Timer instance with the given statement , `setup` code and `timer` function and run its timeit ( ) method with `number` executions .", "question_id": 10479}
{"snippet": "timeit.timeit(number=1000000)", "intent": "Create a Timer instance with the given statement , `setup` code and `timer` function and run its timeit ( ) method with `number` executions .", "question_id": 10480}
{"snippet": "timeit.timeit(globals=None)", "intent": "Create a Timer instance with the given statement , `setup` code and `timer` function and run its timeit ( ) method with `number` executions . The optional `globals` argument specifies a namespace in which to execute the code .", "question_id": 10481}
{"snippet": "timeit.timeit(stmt='pass', setup='pass')", "intent": "Create a Timer instance with the given statement , `setup` code and `timer` function and run its timeit ( ) method with `number` executions . With arguments `stmt`.", "question_id": 10482}
{"snippet": "timeit.timeit(stmt='pass', timer=<default timer>)", "intent": "Create a Timer instance with the given statement , `setup` code and `timer` function and run its timeit ( ) method with `number` executions . With arguments `stmt`.", "question_id": 10483}
{"snippet": "timeit.timeit(stmt='pass', number=1000000)", "intent": "Create a Timer instance with the given statement , `setup` code and `timer` function and run its timeit ( ) method with `number` executions . With arguments `stmt`.", "question_id": 10484}
{"snippet": "timeit.timeit(stmt='pass', globals=None)", "intent": "Create a Timer instance with the given statement , `setup` code and `timer` function and run its timeit ( ) method with `number` executions . The optional `globals` argument specifies a namespace in which to execute the code . With arguments `stmt`.", "question_id": 10485}
{"snippet": "timeit.repeat()", "intent": "Create a Timer instance with the given statement , `setup` code and `timer` function and run its `repeat` ( ) method with the given repeat count and `number` executions .", "question_id": 10486}
{"snippet": "timeit.repeat(stmt='pass')", "intent": "Create a Timer instance with the given statement , `setup` code and `timer` function and run its `repeat` ( ) method with the given repeat count and `number` executions . With arguments `stmt`.", "question_id": 10487}
{"snippet": "timeit.repeat(setup='pass')", "intent": "Create a Timer instance with the given statement , `setup` code and `timer` function and run its `repeat` ( ) method with the given repeat count and `number` executions .", "question_id": 10488}
{"snippet": "timeit.repeat(timer=<default timer>)", "intent": "Create a Timer instance with the given statement , `setup` code and `timer` function and run its `repeat` ( ) method with the given repeat count and `number` executions .", "question_id": 10489}
{"snippet": "timeit.repeat(repeat=5)", "intent": "Create a Timer instance with the given statement , `setup` code and `timer` function and run its `repeat` ( ) method with the given repeat count and `number` executions .", "question_id": 10490}
{"snippet": "timeit.repeat(number=1000000)", "intent": "Create a Timer instance with the given statement , `setup` code and `timer` function and run its `repeat` ( ) method with the given repeat count and `number` executions .", "question_id": 10491}
{"snippet": "timeit.repeat(globals=None)", "intent": "Create a Timer instance with the given statement , `setup` code and `timer` function and run its `repeat` ( ) method with the given repeat count and `number` executions . The optional `globals` argument specifies a namespace in which to execute the code .", "question_id": 10492}
{"snippet": "timeit.repeat(stmt='pass', setup='pass')", "intent": "Create a Timer instance with the given statement , `setup` code and `timer` function and run its `repeat` ( ) method with the given repeat count and `number` executions . With arguments `stmt`.", "question_id": 10493}
{"snippet": "timeit.repeat(stmt='pass', timer=<default timer>)", "intent": "Create a Timer instance with the given statement , `setup` code and `timer` function and run its `repeat` ( ) method with the given repeat count and `number` executions . With arguments `stmt`.", "question_id": 10494}
{"snippet": "timeit.repeat(stmt='pass', repeat=5)", "intent": "Create a Timer instance with the given statement , `setup` code and `timer` function and run its `repeat` ( ) method with the given repeat count and `number` executions . With arguments `stmt`.", "question_id": 10495}
{"snippet": "timeit.default_timer()", "intent": "The default timer , which is always time.perf_counter ( ) .", "question_id": 10496}
{"snippet": "timeit.Timer()", "intent": "Class for timing execution speed of small code snippets .", "question_id": 10497}
{"snippet": "timeit.Timer(stmt='pass')", "intent": "Class for timing execution speed of small code snippets . `stmt` and setup may also contain multiple statements separated by ; or newlines , as long as they don \u2019 t contain multi-line string literals .", "question_id": 10498}
{"snippet": "timeit.Timer(setup='pass')", "intent": "Class for timing execution speed of small code snippets . The constructor takes a statement to be timed , an additional statement used for `setup` , and a `timer` function .", "question_id": 10499}
{"snippet": "timeit.Timer(timer=<timer function>)", "intent": "Class for timing execution speed of small code snippets . The constructor takes a statement to be timed , an additional statement used for `setup` , and a `timer` function .", "question_id": 10500}
{"snippet": "timeit.Timer(globals=None)", "intent": "Class for timing execution speed of small code snippets . The statement will by default be executed within timeit \u2019 s namespace ; this behavior can be controlled by passing a namespace to `globals` .", "question_id": 10501}
{"snippet": "timeit.Timer(stmt='pass', setup='pass')", "intent": "Class for timing execution speed of small code snippets . `stmt` and setup may also contain multiple statements separated by ; or newlines , as long as they don \u2019 t contain multi-line string literals . The constructor takes a statement to be timed , an additional statement used for `setup` , and a `timer` function .", "question_id": 10502}
{"snippet": "timeit.Timer(stmt='pass', timer=<timer function>)", "intent": "Class for timing execution speed of small code snippets . `stmt` and setup may also contain multiple statements separated by ; or newlines , as long as they don \u2019 t contain multi-line string literals . The constructor takes a statement to be timed , an additional statement used for `setup` , and a `timer` function .", "question_id": 10503}
{"snippet": "timeit.Timer(stmt='pass', globals=None)", "intent": "Class for timing execution speed of small code snippets . `stmt` and setup may also contain multiple statements separated by ; or newlines , as long as they don \u2019 t contain multi-line string literals . The statement will by default be executed within timeit \u2019 s namespace ; this behavior can be controlled by passing a namespace to `globals` .", "question_id": 10504}
{"snippet": "timeit.Timer(setup='pass', timer=<timer function>)", "intent": "Class for timing execution speed of small code snippets . The constructor takes a statement to be timed , an additional statement used for `setup` , and a `timer` function .", "question_id": 10505}
{"snippet": "timeit.Timer(setup='pass', globals=None)", "intent": "Class for timing execution speed of small code snippets . The constructor takes a statement to be timed , an additional statement used for `setup` , and a `timer` function . The statement will by default be executed within timeit \u2019 s namespace ; this behavior can be controlled by passing a namespace to `globals` .", "question_id": 10506}
{"snippet": "timer.timeit()", "intent": "Time `number` executions of the main statement .", "question_id": 10507}
{"snippet": "timer.timeit(number=1000000)", "intent": "Time `number` executions of the main statement .", "question_id": 10508}
{"snippet": "timer.autorange()", "intent": "Automatically determine how many times to call timeit ( ) .", "question_id": 10509}
{"snippet": "timer.autorange(callback=None)", "intent": "Automatically determine how many times to call timeit ( ) . If `callback` is given and is not None , it will be called after each trial with two arguments : callback ( number , time_taken ) .", "question_id": 10510}
{"snippet": "timer.repeat()", "intent": "Call timeit ( ) a few times .", "question_id": 10511}
{"snippet": "timer.repeat(repeat=5)", "intent": "Call timeit ( ) a few times . With arguments `repeat`.", "question_id": 10512}
{"snippet": "timer.repeat(number=1000000)", "intent": "Call timeit ( ) a few times . The second argument specifies the `number` argument for timeit ( ) .", "question_id": 10513}
{"snippet": "timer.repeat(repeat=5, number=1000000)", "intent": "Call timeit ( ) a few times . The second argument specifies the `number` argument for timeit ( ) . With arguments `repeat`.", "question_id": 10514}
{"snippet": "timer.print_exc()", "intent": "Helper to print a traceback from the timed code .", "question_id": 10515}
{"snippet": "timer.print_exc(file=None)", "intent": "Helper to print a traceback from the timed code . The optional `file` argument directs where the traceback is sent ; it defaults to sys.stderr .", "question_id": 10516}
{"snippet": "tkinter.Tk()", "intent": "The Tk class is instantiated without arguments .", "question_id": 10517}
{"snippet": "tkinter.Tk(screenName=None)", "intent": "The Tk class is instantiated without arguments . With arguments `screenName`.", "question_id": 10518}
{"snippet": "tkinter.Tk(baseName=None)", "intent": "The Tk class is instantiated without arguments . With arguments `baseName`.", "question_id": 10519}
{"snippet": "tkinter.Tk(className='Tk')", "intent": "The Tk class is instantiated without arguments . With arguments `className`.", "question_id": 10520}
{"snippet": "tkinter.Tk(useTk=1)", "intent": "The Tk class is instantiated without arguments . With arguments `useTk`.", "question_id": 10521}
{"snippet": "tkinter.Tk(screenName=None, baseName=None)", "intent": "The Tk class is instantiated without arguments . With arguments `screenName`, `baseName`.", "question_id": 10522}
{"snippet": "tkinter.Tk(screenName=None, className='Tk')", "intent": "The Tk class is instantiated without arguments . With arguments `screenName`, `className`.", "question_id": 10523}
{"snippet": "tkinter.Tk(screenName=None, useTk=1)", "intent": "The Tk class is instantiated without arguments . With arguments `screenName`, `useTk`.", "question_id": 10524}
{"snippet": "tkinter.Tk(baseName=None, className='Tk')", "intent": "The Tk class is instantiated without arguments . With arguments `baseName`, `className`.", "question_id": 10525}
{"snippet": "tkinter.Tk(baseName=None, useTk=1)", "intent": "The Tk class is instantiated without arguments . With arguments `baseName`, `useTk`.", "question_id": 10526}
{"snippet": "tkinter.Tcl()", "intent": "The Tcl ( ) function is a factory function which creates an object much like that created by the Tk class , except that it does not initialize the Tk subsystem .", "question_id": 10527}
{"snippet": "tkinter.Tcl(screenName=None)", "intent": "The Tcl ( ) function is a factory function which creates an object much like that created by the Tk class , except that it does not initialize the Tk subsystem . With arguments `screenName`.", "question_id": 10528}
{"snippet": "tkinter.Tcl(baseName=None)", "intent": "The Tcl ( ) function is a factory function which creates an object much like that created by the Tk class , except that it does not initialize the Tk subsystem . With arguments `baseName`.", "question_id": 10529}
{"snippet": "tkinter.Tcl(className='Tk')", "intent": "The Tcl ( ) function is a factory function which creates an object much like that created by the Tk class , except that it does not initialize the Tk subsystem . With arguments `className`.", "question_id": 10530}
{"snippet": "tkinter.Tcl(useTk=0)", "intent": "The Tcl ( ) function is a factory function which creates an object much like that created by the Tk class , except that it does not initialize the Tk subsystem . With arguments `useTk`.", "question_id": 10531}
{"snippet": "tkinter.Tcl(screenName=None, baseName=None)", "intent": "The Tcl ( ) function is a factory function which creates an object much like that created by the Tk class , except that it does not initialize the Tk subsystem . With arguments `screenName`, `baseName`.", "question_id": 10532}
{"snippet": "tkinter.Tcl(screenName=None, className='Tk')", "intent": "The Tcl ( ) function is a factory function which creates an object much like that created by the Tk class , except that it does not initialize the Tk subsystem . With arguments `screenName`, `className`.", "question_id": 10533}
{"snippet": "tkinter.Tcl(screenName=None, useTk=0)", "intent": "The Tcl ( ) function is a factory function which creates an object much like that created by the Tk class , except that it does not initialize the Tk subsystem . With arguments `screenName`, `useTk`.", "question_id": 10534}
{"snippet": "tkinter.Tcl(baseName=None, className='Tk')", "intent": "The Tcl ( ) function is a factory function which creates an object much like that created by the Tk class , except that it does not initialize the Tk subsystem . With arguments `baseName`, `className`.", "question_id": 10535}
{"snippet": "tkinter.Tcl(baseName=None, useTk=0)", "intent": "The Tcl ( ) function is a factory function which creates an object much like that created by the Tk class , except that it does not initialize the Tk subsystem . With arguments `baseName`, `useTk`.", "question_id": 10536}
{"snippet": "Widget.tk.createfilehandler(file, mask, func)", "intent": "Registers the `file` handler callback function `func` . The `mask` argument is an ORed combination of any of the three constants below .", "question_id": 10537}
{"snippet": "Widget.tk.deletefilehandler(file)", "intent": "Unregisters a `file` handler .", "question_id": 10538}
{"snippet": "tkinter.READABLE", "intent": "Constants used in the mask arguments.", "question_id": 10539}
{"snippet": "tkinter.WRITABLE", "intent": "Constants used in the mask arguments.", "question_id": 10540}
{"snippet": "tkinter.EXCEPTION", "intent": "Constants used in the mask arguments.", "question_id": 10541}
{"snippet": "ScrolledText.frame", "intent": "The frame which surrounds the text and scroll bar widgets.", "question_id": 10542}
{"snippet": "ScrolledText.vbar", "intent": "The scroll bar widget.", "question_id": 10543}
{"snippet": "tkinter.tix.Tk()", "intent": "Toplevel widget of Tix which represents mostly the main window of an application .", "question_id": 10544}
{"snippet": "tkinter.tix.Tk(screenName=None)", "intent": "Toplevel widget of Tix which represents mostly the main window of an application . With arguments `screenName`.", "question_id": 10545}
{"snippet": "tkinter.tix.Tk(baseName=None)", "intent": "Toplevel widget of Tix which represents mostly the main window of an application . With arguments `baseName`.", "question_id": 10546}
{"snippet": "tkinter.tix.Tk(className='Tix')", "intent": "Toplevel widget of Tix which represents mostly the main window of an application . With arguments `className`.", "question_id": 10547}
{"snippet": "tkinter.tix.Tk(screenName=None, baseName=None)", "intent": "Toplevel widget of Tix which represents mostly the main window of an application . With arguments `screenName`, `baseName`.", "question_id": 10548}
{"snippet": "tkinter.tix.Tk(screenName=None, className='Tix')", "intent": "Toplevel widget of Tix which represents mostly the main window of an application . With arguments `screenName`, `className`.", "question_id": 10549}
{"snippet": "tkinter.tix.Tk(baseName=None, className='Tix')", "intent": "Toplevel widget of Tix which represents mostly the main window of an application . With arguments `baseName`, `className`.", "question_id": 10550}
{"snippet": "tkinter.tix.Tk(screenName=None, baseName=None, className='Tix')", "intent": "Toplevel widget of Tix which represents mostly the main window of an application . With arguments `screenName`, `baseName`, `className`.", "question_id": 10551}
{"snippet": "tkinter.tix.Balloon", "intent": "A Balloon that pops up over a widget to provide help.", "question_id": 10552}
{"snippet": "tkinter.tix.ButtonBox", "intent": "The ButtonBox widget creates a box of buttons, such as is commonly used for Ok Cancel.", "question_id": 10553}
{"snippet": "tkinter.tix.ComboBox", "intent": "The ComboBox widget is similar to the combo box control in MS Windows.", "question_id": 10554}
{"snippet": "tkinter.tix.Control", "intent": "The Control widget is also known as the SpinBox widget.", "question_id": 10555}
{"snippet": "tkinter.tix.LabelEntry", "intent": "The LabelEntry widget packages an entry widget and a label into one mega widget.", "question_id": 10556}
{"snippet": "tkinter.tix.LabelFrame", "intent": "The LabelFrame widget packages a frame widget and a label into one mega widget.", "question_id": 10557}
{"snippet": "tkinter.tix.Meter", "intent": "The Meter widget can be used to show the progress of a background job which may take a long time to execute.", "question_id": 10558}
{"snippet": "tkinter.tix.OptionMenu", "intent": "The OptionMenu creates a menu button of options.", "question_id": 10559}
{"snippet": "tkinter.tix.PopupMenu", "intent": "The PopupMenu widget can be used as a replacement of the tk_popup command.", "question_id": 10560}
{"snippet": "tkinter.tix.Select", "intent": "The Select widget is a container of button subwidgets.", "question_id": 10561}
{"snippet": "tkinter.tix.StdButtonBox", "intent": "The StdButtonBox widget is a group of standard buttons for Motif-like dialog boxes.", "question_id": 10562}
{"snippet": "tkinter.tix.DirList", "intent": "The DirList widget displays a list view of a directory, its previous directories and its sub-directories.", "question_id": 10563}
{"snippet": "tkinter.tix.DirTree", "intent": "The DirTree widget displays a tree view of a directory, its previous directories and its sub-directories.", "question_id": 10564}
{"snippet": "tkinter.tix.DirSelectDialog", "intent": "The DirSelectDialog widget presents the directories in the file system in a dialog window.", "question_id": 10565}
{"snippet": "tkinter.tix.DirSelectBox", "intent": "The DirSelectBox is similar to the standard Motif(TM) directory-selection box.", "question_id": 10566}
{"snippet": "tkinter.tix.ExFileSelectBox", "intent": "The ExFileSelectBox widget is usually embedded in a tixExFileSelectDialog widget.", "question_id": 10567}
{"snippet": "tkinter.tix.FileSelectBox", "intent": "The FileSelectBox is similar to the standard Motif(TM) file-selection box.", "question_id": 10568}
{"snippet": "tkinter.tix.FileEntry", "intent": "The FileEntry widget can be used to input a filename.", "question_id": 10569}
{"snippet": "tkinter.tix.HList", "intent": "The HList widget can be used to display any data that have a hierarchical structure, for example, file system directory trees.", "question_id": 10570}
{"snippet": "tkinter.tix.CheckList", "intent": "The CheckList widget displays a list of items to be selected by the user.", "question_id": 10571}
{"snippet": "tkinter.tix.Tree", "intent": "The Tree widget can be used to display hierarchical data in a tree form.", "question_id": 10572}
{"snippet": "tkinter.tix.TList", "intent": "The TList widget can be used to display data in a tabular format.", "question_id": 10573}
{"snippet": "tkinter.tix.PanedWindow", "intent": "The PanedWindow widget allows the user to interactively manipulate the sizes of several panes.", "question_id": 10574}
{"snippet": "tkinter.tix.ListNoteBook", "intent": "The ListNoteBook widget is very similar to the TixNoteBook widget: it can be used to display many windows in a limited space using a notebook metaphor.", "question_id": 10575}
{"snippet": "tkinter.tix.NoteBook", "intent": "The NoteBook widget can be used to display many windows in a limited space using a notebook metaphor.", "question_id": 10576}
{"snippet": "tkinter.tix.InputOnly", "intent": "The InputOnly widgets are to accept inputs from the user, which can be done with the bind command (Unix only).", "question_id": 10577}
{"snippet": "tkinter.tix.Form", "intent": "The Form geometry manager based on attachment rules for all Tk widgets.", "question_id": 10578}
{"snippet": "tkinter.tix.tixCommand", "intent": "The tix commands provide access to miscellaneous elements of Tix\u2019s internal state and the Tix application context.", "question_id": 10579}
{"snippet": "tixCommand.tix_configure(**kw)", "intent": "Query or modify the configuration options of the Tix application context . With arguments `**kw`.", "question_id": 10580}
{"snippet": "tixCommand.tix_configure(**kw, cnf=None)", "intent": "Query or modify the configuration options of the Tix application context . With arguments `**kw`, `cnf`.", "question_id": 10581}
{"snippet": "tixCommand.tix_cget(option)", "intent": "Returns the current value of the configuration `option` given by option .", "question_id": 10582}
{"snippet": "tixCommand.tix_getbitmap(name)", "intent": "Locates a bitmap file of the `name` name.xpm or name in one of the bitmap directories ( see the tix_addbitmapdir ( ) method ) .", "question_id": 10583}
{"snippet": "tixCommand.tix_addbitmapdir(directory)", "intent": "Tix maintains a list of directories under which the tix_getimage ( ) and tix_getbitmap ( ) methods will search for image files . The standard bitmap `directory` is $ TIX_LIBRARY/bitmaps .", "question_id": 10584}
{"snippet": "tixCommand.tix_filedialog(dlgclass)", "intent": "Returns the file selection dialog that may be shared among different calls from this application . An optional `dlgclass` parameter can be passed as a string to specified what type of file selection dialog widget is desired .", "question_id": 10585}
{"snippet": "tixCommand.tix_filedialog()", "intent": "Returns the file selection dialog that may be shared among different calls from this application .", "question_id": 10586}
{"snippet": "tixCommand.tix_getimage(self, name)", "intent": "Locates an image file of the `name` name.xpm , name.xbm or name.ppm in one of the bitmap directories ( see the tix_addbitmapdir ( ) method above ) . With arguments `self`.", "question_id": 10587}
{"snippet": "tixCommand.tix_option_get(name)", "intent": "Gets the options maintained by the Tix scheme mechanism . With arguments `name`.", "question_id": 10588}
{"snippet": "tixCommand.tix_resetoptions(newScheme, newFontSet, newScmPrio)", "intent": "Resets the scheme and fontset of the Tix application to `newScheme` and `newFontSet` , respectively . The optional parameter `newScmPrio` can be given to reset the priority level of the Tk options set by the Tix schemes .", "question_id": 10589}
{"snippet": "tixCommand.tix_resetoptions(newScheme, newFontSet)", "intent": "Resets the scheme and fontset of the Tix application to `newScheme` and `newFontSet` , respectively .", "question_id": 10590}
{"snippet": "tkinter.ttk.Widget", "intent": "statespec will usually be a list or a tuple.", "question_id": 10591}
{"snippet": "widget.identify(x, y)", "intent": "Returns the name of the element at position `x` `y` , or the empty string if the point does not lie within any element .", "question_id": 10592}
{"snippet": "widget.instate(statespec, *args, **kw)", "intent": "Test the widget \u2019 s state . If a `callback` is not specified , returns True if the widget state matches `statespec` and False otherwise . With arguments `*args`, `**kw`.", "question_id": 10593}
{"snippet": "widget.instate(statespec, *args, **kw, callback=None)", "intent": "Test the widget \u2019 s state . If a `callback` is not specified , returns True if the widget state matches `statespec` and False otherwise . With arguments `*args`, `**kw`.", "question_id": 10594}
{"snippet": "widget.state()", "intent": "Modify or inquire widget state .", "question_id": 10595}
{"snippet": "widget.state(statespec=None)", "intent": "Modify or inquire widget state . If `statespec` is specified , sets the widget state according to it and return a new statespec indicating which flags were changed .", "question_id": 10596}
{"snippet": "widget.current()", "intent": "If `newindex` is specified , sets the combobox value to the element position newindex .", "question_id": 10597}
{"snippet": "widget.current(newindex=None)", "intent": "If `newindex` is specified , sets the combobox value to the element position newindex .", "question_id": 10598}
{"snippet": "widget.get()", "intent": "Returns the current value of the combobox .", "question_id": 10599}
{"snippet": "widget.set(value)", "intent": "Sets the `value` of the combobox to value .", "question_id": 10600}
{"snippet": "widget.get()", "intent": "Returns the current value of the spinbox .", "question_id": 10601}
{"snippet": "widget.set(value)", "intent": "Sets the `value` of the spinbox to value .", "question_id": 10602}
{"snippet": "widget.add(child, **kw)", "intent": "Adds a new tab to the notebook . With arguments `child`, `**kw`.", "question_id": 10603}
{"snippet": "widget.forget(tab_id)", "intent": "Removes the tab specified by `tab_id` , unmaps and unmanages the associated window .", "question_id": 10604}
{"snippet": "widget.hide(tab_id)", "intent": "Hides the tab specified by `tab_id` .", "question_id": 10605}
{"snippet": "widget.identify(x, y)", "intent": "Returns the name of the tab element at position `x` , `y` , or the empty string if none .", "question_id": 10606}
{"snippet": "widget.index(tab_id)", "intent": "Returns the numeric index of the tab specified by `tab_id` , or the total number of tabs if tab_id is the string \u201c end \u201d .", "question_id": 10607}
{"snippet": "widget.insert(pos, child, **kw)", "intent": "Inserts a pane at the specified position . `pos` is either the string \u201c end \u201d , an integer index , or the name of a managed `child` . With arguments `**kw`.", "question_id": 10608}
{"snippet": "widget.select()", "intent": "Selects the specified `tab_id` .", "question_id": 10609}
{"snippet": "widget.select(tab_id=None)", "intent": "Selects the specified `tab_id` .", "question_id": 10610}
{"snippet": "widget.tab(tab_id, **kw)", "intent": "Query or modify the options of the specific `tab_id` . With arguments `**kw`.", "question_id": 10611}
{"snippet": "widget.tab(tab_id, **kw, option=None)", "intent": "Query or modify the options of the specific `tab_id` . If kw is not given , returns a dictionary of the tab `option` values . With arguments `**kw`.", "question_id": 10612}
{"snippet": "widget.tabs()", "intent": "Returns a list of windows managed by the notebook .", "question_id": 10613}
{"snippet": "widget.enable_traversal()", "intent": "Enable keyboard traversal for a toplevel window containing this notebook .", "question_id": 10614}
{"snippet": "widget.start()", "intent": "Begin autoincrement mode : schedules a recurring timer event that calls Progressbar.step ( ) every `interval` milliseconds .", "question_id": 10615}
{"snippet": "widget.start(interval=None)", "intent": "Begin autoincrement mode : schedules a recurring timer event that calls Progressbar.step ( ) every `interval` milliseconds .", "question_id": 10616}
{"snippet": "widget.step()", "intent": "Increments the progress bar \u2019 s value by `amount` .", "question_id": 10617}
{"snippet": "widget.step(amount=None)", "intent": "Increments the progress bar \u2019 s value by `amount` .", "question_id": 10618}
{"snippet": "widget.stop()", "intent": "Stop autoincrement mode : cancels any recurring timer event initiated by Progressbar.start ( ) for this progress bar .", "question_id": 10619}
{"snippet": "widget.bbox(item)", "intent": "Returns the bounding box ( relative to the treeview widget \u2019 s window ) of the specified `item` in the form ( x , y , width , height ) .", "question_id": 10620}
{"snippet": "widget.bbox(item, column=None)", "intent": "Returns the bounding box ( relative to the treeview widget \u2019 s window ) of the specified `item` in the form ( x , y , width , height ) . If `column` is specified , returns the bounding box of that cell .", "question_id": 10621}
{"snippet": "widget.get_children()", "intent": "Returns the list of children belonging to `item` .", "question_id": 10622}
{"snippet": "widget.get_children(item=None)", "intent": "Returns the list of children belonging to `item` .", "question_id": 10623}
{"snippet": "widget.set_children(item, *newchildren)", "intent": "Replaces `item` \u2019 s child with newchildren . With arguments `*newchildren`.", "question_id": 10624}
{"snippet": "widget.column(column, **kw)", "intent": "Query or modify the options for the specified `column` . With arguments `**kw`.", "question_id": 10625}
{"snippet": "widget.column(column, **kw, option=None)", "intent": "Query or modify the options for the specified `column` . If kw is not given , returns a dict of the column `option` values . With arguments `**kw`.", "question_id": 10626}
{"snippet": "widget.delete(*items)", "intent": "Delete all specified items and all their descendants . With arguments `*items`.", "question_id": 10627}
{"snippet": "widget.detach(*items)", "intent": "Unlinks all of the specified items from the tree . With arguments `*items`.", "question_id": 10628}
{"snippet": "widget.exists(item)", "intent": "Returns True if the specified `item` is present in the tree .", "question_id": 10629}
{"snippet": "widget.focus()", "intent": "If `item` is specified , sets the focus item to item .", "question_id": 10630}
{"snippet": "widget.focus(item=None)", "intent": "If `item` is specified , sets the focus item to item .", "question_id": 10631}
{"snippet": "widget.heading(column, **kw)", "intent": "Query or modify the heading options for the specified `column` . With arguments `**kw`.", "question_id": 10632}
{"snippet": "widget.heading(column, **kw, option=None)", "intent": "Query or modify the heading options for the specified `column` . If kw is not given , returns a dict of the heading `option` values . With arguments `**kw`.", "question_id": 10633}
{"snippet": "widget.identify(component, x, y)", "intent": "Returns a description of the specified `component` under the point given by `x` and `y` , or the empty string if no such component is present at that position .", "question_id": 10634}
{"snippet": "widget.identify_row(y)", "intent": "Returns the item ID of the item at position `y` .", "question_id": 10635}
{"snippet": "widget.identify_column(x)", "intent": "Returns the data column identifier of the cell at position `x` .", "question_id": 10636}
{"snippet": "widget.identify_region(x, y)", "intent": "Returns one of : With arguments `x`, `y`.", "question_id": 10637}
{"snippet": "widget.identify_element(x, y)", "intent": "Returns the element at position `x` , `y` .", "question_id": 10638}
{"snippet": "widget.index(item)", "intent": "Returns the integer index of `item` within its parent \u2019 s list of children .", "question_id": 10639}
{"snippet": "widget.insert(parent, index, **kw)", "intent": "Creates a new item and returns the item identifier of the newly created item . `parent` is the item ID of the parent item , or the empty string to create a new top-level item . `index` is an integer , or the value \u201c end \u201d , specifying where in the list of parent \u2019 s children to insert the new item . With arguments `**kw`.", "question_id": 10640}
{"snippet": "widget.insert(parent, index, **kw, iid=None)", "intent": "Creates a new item and returns the item identifier of the newly created item . `parent` is the item ID of the parent item , or the empty string to create a new top-level item . `index` is an integer , or the value \u201c end \u201d , specifying where in the list of parent \u2019 s children to insert the new item . If `iid` is specified , it is used as the item identifier ; iid must not already exist in the tree . With arguments `**kw`.", "question_id": 10641}
{"snippet": "widget.item(item, **kw)", "intent": "Query or modify the options for the specified `item` . With arguments `**kw`.", "question_id": 10642}
{"snippet": "widget.item(item, **kw, option=None)", "intent": "Query or modify the options for the specified `item` . If `option` is specified then the value for that option is returned . With arguments `**kw`.", "question_id": 10643}
{"snippet": "widget.move(item, parent, index)", "intent": "Moves `item` to position `index` in `parent` \u2019 s list of children .", "question_id": 10644}
{"snippet": "widget.next(item)", "intent": "Returns the identifier of `item` \u2019 s next sibling , or \u2018 \u2019 if item is the last child of its parent .", "question_id": 10645}
{"snippet": "widget.parent(item)", "intent": "Returns the ID of the parent of `item` , or \u2018 \u2019 if item is at the top level of the hierarchy .", "question_id": 10646}
{"snippet": "widget.prev(item)", "intent": "Returns the identifier of `item` \u2019 s previous sibling , or \u2018 \u2019 if item is the first child of its parent .", "question_id": 10647}
{"snippet": "widget.reattach(item, parent, index)", "intent": "An alias for Treeview.move ( ) . With arguments `item`, `parent`, `index`.", "question_id": 10648}
{"snippet": "widget.see(item)", "intent": "Ensure that `item` is visible .", "question_id": 10649}
{"snippet": "widget.selection()", "intent": "If `selop` is not specified , returns selected `items` .", "question_id": 10650}
{"snippet": "widget.selection(selop=None)", "intent": "If `selop` is not specified , returns selected `items` .", "question_id": 10651}
{"snippet": "widget.selection(items=None)", "intent": "If `selop` is not specified , returns selected `items` .", "question_id": 10652}
{"snippet": "widget.selection(selop=None, items=None)", "intent": "If `selop` is not specified , returns selected `items` .", "question_id": 10653}
{"snippet": "widget.selection_set(*items)", "intent": "items becomes the new selection . With arguments `*items`.", "question_id": 10654}
{"snippet": "widget.selection_add(*items)", "intent": "Add items to the selection . With arguments `*items`.", "question_id": 10655}
{"snippet": "widget.selection_remove(*items)", "intent": "Remove items from the selection . With arguments `*items`.", "question_id": 10656}
{"snippet": "widget.selection_toggle(*items)", "intent": "Toggle the selection state of each item in items . With arguments `*items`.", "question_id": 10657}
{"snippet": "widget.set(item)", "intent": "With one argument , returns a dictionary of column/value pairs for the specified `item` .", "question_id": 10658}
{"snippet": "widget.set(item, column=None)", "intent": "With one argument , returns a dictionary of column/value pairs for the specified `item` . With two arguments , returns the current `value` of the specified `column` .", "question_id": 10659}
{"snippet": "widget.set(item, value=None)", "intent": "With one argument , returns a dictionary of column/value pairs for the specified `item` . With two arguments , returns the current `value` of the specified `column` .", "question_id": 10660}
{"snippet": "widget.set(item, column=None, value=None)", "intent": "With one argument , returns a dictionary of column/value pairs for the specified `item` . With two arguments , returns the current `value` of the specified `column` .", "question_id": 10661}
{"snippet": "widget.tag_bind(tagname)", "intent": "Bind a `callback` for the given event `sequence` to the tag `tagname` .", "question_id": 10662}
{"snippet": "widget.tag_bind(tagname, sequence=None)", "intent": "Bind a `callback` for the given event `sequence` to the tag `tagname` .", "question_id": 10663}
{"snippet": "widget.tag_bind(tagname, callback=None)", "intent": "Bind a `callback` for the given event `sequence` to the tag `tagname` .", "question_id": 10664}
{"snippet": "widget.tag_bind(tagname, sequence=None, callback=None)", "intent": "Bind a `callback` for the given event `sequence` to the tag `tagname` .", "question_id": 10665}
{"snippet": "widget.tag_configure(tagname, **kw)", "intent": "Query or modify the options for the specified `tagname` . With arguments `**kw`.", "question_id": 10666}
{"snippet": "widget.tag_configure(tagname, **kw, option=None)", "intent": "Query or modify the options for the specified `tagname` . If kw is not given , returns a dict of the `option` settings for tagname . With arguments `**kw`.", "question_id": 10667}
{"snippet": "widget.tag_has(tagname)", "intent": "If `item` is specified , returns 1 or 0 depending on whether the specified item has the given `tagname` .", "question_id": 10668}
{"snippet": "widget.tag_has(tagname, item=None)", "intent": "If `item` is specified , returns 1 or 0 depending on whether the specified item has the given `tagname` .", "question_id": 10669}
{"snippet": "widget.xview(*args)", "intent": "Query or modify horizontal position of the treeview . With arguments `*args`.", "question_id": 10670}
{"snippet": "widget.yview(*args)", "intent": "Query or modify vertical position of the treeview . With arguments `*args`.", "question_id": 10671}
{"snippet": "tkinter.ttk.Style", "intent": "This class is used to manipulate the style database.", "question_id": 10672}
{"snippet": "style.configure(style, **kw)", "intent": "Query or set the default value of the specified option ( s ) in `style` . With arguments `**kw`.", "question_id": 10673}
{"snippet": "style.configure(style, **kw, query_opt=None)", "intent": "Query or set the default value of the specified option ( s ) in `style` . With arguments `**kw`, `query_opt`.", "question_id": 10674}
{"snippet": "style.map(style, **kw)", "intent": "Query or sets dynamic values of the specified option ( s ) in `style` . With arguments `**kw`.", "question_id": 10675}
{"snippet": "style.map(style, **kw, query_opt=None)", "intent": "Query or sets dynamic values of the specified option ( s ) in `style` . With arguments `**kw`, `query_opt`.", "question_id": 10676}
{"snippet": "style.lookup(style, option)", "intent": "Returns the value specified for `option` in `style` .", "question_id": 10677}
{"snippet": "style.lookup(style, option, state=None)", "intent": "Returns the value specified for `option` in `style` . If `state` is specified , it is expected to be a sequence of one or more states .", "question_id": 10678}
{"snippet": "style.lookup(style, option, default=None)", "intent": "Returns the value specified for `option` in `style` . If the `default` argument is set , it is used as a fallback value in case no specification for option is found .", "question_id": 10679}
{"snippet": "style.lookup(style, option, state=None, default=None)", "intent": "Returns the value specified for `option` in `style` . If `state` is specified , it is expected to be a sequence of one or more states . If the `default` argument is set , it is used as a fallback value in case no specification for option is found .", "question_id": 10680}
{"snippet": "style.layout(style)", "intent": "Define the widget layout for given `style` .", "question_id": 10681}
{"snippet": "style.layout(style, layoutspec=None)", "intent": "Define the widget layout for given `style` . If `layoutspec` is omitted , return the layout specification for given style .", "question_id": 10682}
{"snippet": "style.element_create(elementname, etype, *args, **kw)", "intent": "Create a new element in the current theme , of the given `etype` which is expected to be either \u201c image \u201d , \u201c from \u201d or \u201c vsapi \u201d . With arguments `elementname`, `*args`, `**kw`.", "question_id": 10683}
{"snippet": "style.element_names()", "intent": "Returns the list of elements defined in the current theme .", "question_id": 10684}
{"snippet": "style.element_options(elementname)", "intent": "Returns the list of `elementname` \u2019 s options .", "question_id": 10685}
{"snippet": "style.theme_create(themename)", "intent": "Create a new theme . It is an error if `themename` already exists .", "question_id": 10686}
{"snippet": "style.theme_create(themename, parent=None)", "intent": "Create a new theme . It is an error if `themename` already exists . If `parent` is specified , the new theme will inherit styles , elements and layouts from the parent theme .", "question_id": 10687}
{"snippet": "style.theme_create(themename, settings=None)", "intent": "Create a new theme . It is an error if `themename` already exists . If `settings` are present they are expected to have the same syntax used for theme_settings ( ) .", "question_id": 10688}
{"snippet": "style.theme_create(themename, parent=None, settings=None)", "intent": "Create a new theme . It is an error if `themename` already exists . If `parent` is specified , the new theme will inherit styles , elements and layouts from the parent theme . If `settings` are present they are expected to have the same syntax used for theme_settings ( ) .", "question_id": 10689}
{"snippet": "style.theme_settings(themename, settings)", "intent": "Temporarily sets the current theme to `themename` , apply specified `settings` and then restore the previous theme .", "question_id": 10690}
{"snippet": "style.theme_names()", "intent": "Returns a list of all known themes .", "question_id": 10691}
{"snippet": "style.theme_use()", "intent": "If `themename` is not given , returns the theme in use .", "question_id": 10692}
{"snippet": "style.theme_use(themename=None)", "intent": "If `themename` is not given , returns the theme in use .", "question_id": 10693}
{"snippet": "token.tok_name", "intent": "Dictionary mapping the numeric values of the constants defined in this module back to name strings, allowing more human-readable representation of parse trees to be generated.", "question_id": 10694}
{"snippet": "token.ISTERMINAL(x)", "intent": "Return true for terminal token values . With arguments `x`.", "question_id": 10695}
{"snippet": "token.ISNONTERMINAL(x)", "intent": "Return true for non-terminal token values . With arguments `x`.", "question_id": 10696}
{"snippet": "token.ISEOF(x)", "intent": "Return true if `x` is the marker indicating the end of input .", "question_id": 10697}
{"snippet": "token.COMMENT", "intent": "Token value used to indicate a comment.", "question_id": 10698}
{"snippet": "token.NL", "intent": "Token value used to indicate a non-terminating newline.", "question_id": 10699}
{"snippet": "token.ENCODING", "intent": "Token value that indicates the encoding used to decode the source bytes into text.", "question_id": 10700}
{"snippet": "tokenize.tokenize(readline)", "intent": "The tokenize ( ) generator requires one argument , `readline` , which must be a callable object which provides the same interface as the io.IOBase.readline ( ) method of file objects .", "question_id": 10701}
{"snippet": "tokenize.untokenize(iterable)", "intent": "Converts tokens back into Python source code . The `iterable` must return sequences with at least two elements , the token type and the token string .", "question_id": 10702}
{"snippet": "tokenize.detect_encoding(readline)", "intent": "The detect_encoding ( ) function is used to detect the encoding that should be used to decode a Python source file . It requires one argument , `readline` , in the same way as the tokenize ( ) generator .", "question_id": 10703}
{"snippet": "tokenize.open(filename)", "intent": "Open a file in read only mode using the encoding detected by detect_encoding ( ) . With arguments `filename`.", "question_id": 10704}
{"snippet": "tokenize.TokenError", "intent": "Raised when either a docstring or expression that may be split over several lines is not completed anywhere in the file, for example:", "question_id": 10705}
{"snippet": "trace.Trace()", "intent": "Create an object to `trace` execution of a single statement or expression .", "question_id": 10706}
{"snippet": "trace.Trace(count=1)", "intent": "Create an object to `trace` execution of a single statement or expression . `count` enables counting of line numbers .", "question_id": 10707}
{"snippet": "trace.Trace(trace=1)", "intent": "Create an object to `trace` execution of a single statement or expression .", "question_id": 10708}
{"snippet": "trace.Trace(countfuncs=0)", "intent": "Create an object to `trace` execution of a single statement or expression . `countfuncs` enables listing of the functions called during the run .", "question_id": 10709}
{"snippet": "trace.Trace(countcallers=0)", "intent": "Create an object to `trace` execution of a single statement or expression . `countcallers` enables call relationship tracking .", "question_id": 10710}
{"snippet": "trace.Trace(ignoremods=())", "intent": "Create an object to `trace` execution of a single statement or expression . `ignoremods` is a list of modules or packages to ignore .", "question_id": 10711}
{"snippet": "trace.Trace(ignoredirs=())", "intent": "Create an object to `trace` execution of a single statement or expression . `ignoredirs` is a list of directories whose modules or packages should be ignored .", "question_id": 10712}
{"snippet": "trace.Trace(infile=None)", "intent": "Create an object to `trace` execution of a single statement or expression . `infile` is the name of the file from which to read stored count information .", "question_id": 10713}
{"snippet": "trace.Trace(outfile=None)", "intent": "Create an object to `trace` execution of a single statement or expression . `outfile` is the name of the file in which to write updated count information .", "question_id": 10714}
{"snippet": "trace.Trace(timing=False)", "intent": "Create an object to `trace` execution of a single statement or expression . `timing` enables a timestamp relative to when tracing was started to be displayed .", "question_id": 10715}
{"snippet": "trace.run(cmd)", "intent": "Execute the command and gather statistics from the execution with the current tracing parameters . `cmd` must be a string or code object , suitable for passing into exec ( ) .", "question_id": 10716}
{"snippet": "trace.runctx(cmd)", "intent": "Execute the command and gather statistics from the execution with the current tracing parameters , in the defined global and local environments . With arguments `cmd`.", "question_id": 10717}
{"snippet": "trace.runctx(cmd, globals=None)", "intent": "Execute the command and gather statistics from the execution with the current tracing parameters , in the defined global and local environments . If not defined , `globals` and `locals` default to empty dictionaries . With arguments `cmd`.", "question_id": 10718}
{"snippet": "trace.runctx(cmd, locals=None)", "intent": "Execute the command and gather statistics from the execution with the current tracing parameters , in the defined global and local environments . If not defined , `globals` and `locals` default to empty dictionaries . With arguments `cmd`.", "question_id": 10719}
{"snippet": "trace.runctx(cmd, globals=None, locals=None)", "intent": "Execute the command and gather statistics from the execution with the current tracing parameters , in the defined global and local environments . If not defined , `globals` and `locals` default to empty dictionaries . With arguments `cmd`.", "question_id": 10720}
{"snippet": "trace.runfunc(func, *args, **kwds)", "intent": "Call `func` with the given arguments under control of the Trace object with the current tracing parameters . With arguments `*args`, `**kwds`.", "question_id": 10721}
{"snippet": "trace.results()", "intent": "Return a CoverageResults object that contains the cumulative results of all previous calls to run , runctx and runfunc for the given Trace instance .", "question_id": 10722}
{"snippet": "trace.CoverageResults", "intent": "A container for coverage results, created by Trace.results().", "question_id": 10723}
{"snippet": "coverage_results.update(other)", "intent": "Merge in data from another CoverageResults object . With arguments `other`.", "question_id": 10724}
{"snippet": "coverage_results.write_results()", "intent": "Write coverage results .", "question_id": 10725}
{"snippet": "coverage_results.write_results(show_missing=True)", "intent": "Write coverage results . Set `show_missing` to show lines that had no hits .", "question_id": 10726}
{"snippet": "coverage_results.write_results(summary=False)", "intent": "Write coverage results . Set `summary` to include in the output the coverage summary per module .", "question_id": 10727}
{"snippet": "coverage_results.write_results(coverdir=None)", "intent": "Write coverage results . `coverdir` specifies the directory into which the coverage result files will be output .", "question_id": 10728}
{"snippet": "coverage_results.write_results(show_missing=True, summary=False)", "intent": "Write coverage results . Set `show_missing` to show lines that had no hits . Set `summary` to include in the output the coverage summary per module .", "question_id": 10729}
{"snippet": "coverage_results.write_results(show_missing=True, coverdir=None)", "intent": "Write coverage results . Set `show_missing` to show lines that had no hits . `coverdir` specifies the directory into which the coverage result files will be output .", "question_id": 10730}
{"snippet": "coverage_results.write_results(summary=False, coverdir=None)", "intent": "Write coverage results . Set `summary` to include in the output the coverage summary per module . `coverdir` specifies the directory into which the coverage result files will be output .", "question_id": 10731}
{"snippet": "coverage_results.write_results(show_missing=True, summary=False, coverdir=None)", "intent": "Write coverage results . Set `show_missing` to show lines that had no hits . Set `summary` to include in the output the coverage summary per module . `coverdir` specifies the directory into which the coverage result files will be output .", "question_id": 10732}
{"snippet": "traceback.print_tb(tb)", "intent": "Print up to `limit` stack trace entries from traceback object `tb` ( starting from the caller \u2019 s frame ) if limit is positive .", "question_id": 10733}
{"snippet": "traceback.print_tb(tb, limit=None)", "intent": "Print up to `limit` stack trace entries from traceback object `tb` ( starting from the caller \u2019 s frame ) if limit is positive .", "question_id": 10734}
{"snippet": "traceback.print_tb(tb, file=None)", "intent": "Print up to `limit` stack trace entries from traceback object `tb` ( starting from the caller \u2019 s frame ) if limit is positive . If `file` is omitted or None , the output goes to sys.stderr ; otherwise it should be an open file or file-like object to receive the output .", "question_id": 10735}
{"snippet": "traceback.print_tb(tb, limit=None, file=None)", "intent": "Print up to `limit` stack trace entries from traceback object `tb` ( starting from the caller \u2019 s frame ) if limit is positive . If `file` is omitted or None , the output goes to sys.stderr ; otherwise it should be an open file or file-like object to receive the output .", "question_id": 10736}
{"snippet": "traceback.print_exception(etype, value, tb)", "intent": "Print exception information and stack trace entries from traceback object `tb` to `file` . With arguments `etype`, `value`.", "question_id": 10737}
{"snippet": "traceback.print_exception(etype, value, tb, limit=None)", "intent": "Print exception information and stack trace entries from traceback object `tb` to `file` . The optional `limit` argument has the same meaning as for print_tb ( ) . With arguments `etype`, `value`.", "question_id": 10738}
{"snippet": "traceback.print_exception(etype, value, tb, file=None)", "intent": "Print exception information and stack trace entries from traceback object `tb` to `file` . With arguments `etype`, `value`.", "question_id": 10739}
{"snippet": "traceback.print_exception(etype, value, tb, chain=True)", "intent": "Print exception information and stack trace entries from traceback object `tb` to `file` . If `chain` is true ( the default ) , then chained exceptions ( the __cause__ or __context__ attributes of the exception ) will be printed as well , like the interpreter itself does when printing an unhandled exception . With arguments `etype`, `value`.", "question_id": 10740}
{"snippet": "traceback.print_exception(etype, value, tb, limit=None, file=None)", "intent": "Print exception information and stack trace entries from traceback object `tb` to `file` . The optional `limit` argument has the same meaning as for print_tb ( ) . With arguments `etype`, `value`.", "question_id": 10741}
{"snippet": "traceback.print_exception(etype, value, tb, limit=None, chain=True)", "intent": "Print exception information and stack trace entries from traceback object `tb` to `file` . The optional `limit` argument has the same meaning as for print_tb ( ) . If `chain` is true ( the default ) , then chained exceptions ( the __cause__ or __context__ attributes of the exception ) will be printed as well , like the interpreter itself does when printing an unhandled exception . With arguments `etype`, `value`.", "question_id": 10742}
{"snippet": "traceback.print_exception(etype, value, tb, file=None, chain=True)", "intent": "Print exception information and stack trace entries from traceback object `tb` to `file` . If `chain` is true ( the default ) , then chained exceptions ( the __cause__ or __context__ attributes of the exception ) will be printed as well , like the interpreter itself does when printing an unhandled exception . With arguments `etype`, `value`.", "question_id": 10743}
{"snippet": "traceback.print_exception(etype, value, tb, limit=None, file=None, chain=True)", "intent": "Print exception information and stack trace entries from traceback object `tb` to `file` . The optional `limit` argument has the same meaning as for print_tb ( ) . If `chain` is true ( the default ) , then chained exceptions ( the __cause__ or __context__ attributes of the exception ) will be printed as well , like the interpreter itself does when printing an unhandled exception . With arguments `etype`, `value`.", "question_id": 10744}
{"snippet": "traceback.print_exc()", "intent": "This is a shorthand for print_exception ( *sys.exc_info ( ) , `limit` , `file` , `chain` ) .", "question_id": 10745}
{"snippet": "traceback.print_exc(limit=None)", "intent": "This is a shorthand for print_exception ( *sys.exc_info ( ) , `limit` , `file` , `chain` ) .", "question_id": 10746}
{"snippet": "traceback.print_exc(file=None)", "intent": "This is a shorthand for print_exception ( *sys.exc_info ( ) , `limit` , `file` , `chain` ) .", "question_id": 10747}
{"snippet": "traceback.print_exc(chain=True)", "intent": "This is a shorthand for print_exception ( *sys.exc_info ( ) , `limit` , `file` , `chain` ) .", "question_id": 10748}
{"snippet": "traceback.print_exc(limit=None, file=None)", "intent": "This is a shorthand for print_exception ( *sys.exc_info ( ) , `limit` , `file` , `chain` ) .", "question_id": 10749}
{"snippet": "traceback.print_exc(limit=None, chain=True)", "intent": "This is a shorthand for print_exception ( *sys.exc_info ( ) , `limit` , `file` , `chain` ) .", "question_id": 10750}
{"snippet": "traceback.print_exc(file=None, chain=True)", "intent": "This is a shorthand for print_exception ( *sys.exc_info ( ) , `limit` , `file` , `chain` ) .", "question_id": 10751}
{"snippet": "traceback.print_exc(limit=None, file=None, chain=True)", "intent": "This is a shorthand for print_exception ( *sys.exc_info ( ) , `limit` , `file` , `chain` ) .", "question_id": 10752}
{"snippet": "traceback.print_last()", "intent": "This is a shorthand for print_exception ( sys.last_type , sys.last_value , sys.last_traceback , `limit` , `file` , `chain` ) .", "question_id": 10753}
{"snippet": "traceback.print_last(limit=None)", "intent": "This is a shorthand for print_exception ( sys.last_type , sys.last_value , sys.last_traceback , `limit` , `file` , `chain` ) .", "question_id": 10754}
{"snippet": "traceback.print_last(file=None)", "intent": "This is a shorthand for print_exception ( sys.last_type , sys.last_value , sys.last_traceback , `limit` , `file` , `chain` ) .", "question_id": 10755}
{"snippet": "traceback.print_last(chain=True)", "intent": "This is a shorthand for print_exception ( sys.last_type , sys.last_value , sys.last_traceback , `limit` , `file` , `chain` ) .", "question_id": 10756}
{"snippet": "traceback.print_last(limit=None, file=None)", "intent": "This is a shorthand for print_exception ( sys.last_type , sys.last_value , sys.last_traceback , `limit` , `file` , `chain` ) .", "question_id": 10757}
{"snippet": "traceback.print_last(limit=None, chain=True)", "intent": "This is a shorthand for print_exception ( sys.last_type , sys.last_value , sys.last_traceback , `limit` , `file` , `chain` ) .", "question_id": 10758}
{"snippet": "traceback.print_last(file=None, chain=True)", "intent": "This is a shorthand for print_exception ( sys.last_type , sys.last_value , sys.last_traceback , `limit` , `file` , `chain` ) .", "question_id": 10759}
{"snippet": "traceback.print_last(limit=None, file=None, chain=True)", "intent": "This is a shorthand for print_exception ( sys.last_type , sys.last_value , sys.last_traceback , `limit` , `file` , `chain` ) .", "question_id": 10760}
{"snippet": "traceback.print_stack()", "intent": "Print up to `limit` stack trace entries ( starting from the invocation point ) if limit is positive .", "question_id": 10761}
{"snippet": "traceback.print_stack(f=None)", "intent": "Print up to `limit` stack trace entries ( starting from the invocation point ) if limit is positive . The optional `f` argument can be used to specify an alternate stack frame to start .", "question_id": 10762}
{"snippet": "traceback.print_stack(limit=None)", "intent": "Print up to `limit` stack trace entries ( starting from the invocation point ) if limit is positive .", "question_id": 10763}
{"snippet": "traceback.print_stack(file=None)", "intent": "Print up to `limit` stack trace entries ( starting from the invocation point ) if limit is positive . The optional `file` argument has the same meaning as for print_tb ( ) .", "question_id": 10764}
{"snippet": "traceback.print_stack(f=None, limit=None)", "intent": "Print up to `limit` stack trace entries ( starting from the invocation point ) if limit is positive . The optional `f` argument can be used to specify an alternate stack frame to start .", "question_id": 10765}
{"snippet": "traceback.print_stack(f=None, file=None)", "intent": "Print up to `limit` stack trace entries ( starting from the invocation point ) if limit is positive . The optional `f` argument can be used to specify an alternate stack frame to start . The optional `file` argument has the same meaning as for print_tb ( ) .", "question_id": 10766}
{"snippet": "traceback.print_stack(limit=None, file=None)", "intent": "Print up to `limit` stack trace entries ( starting from the invocation point ) if limit is positive . The optional `file` argument has the same meaning as for print_tb ( ) .", "question_id": 10767}
{"snippet": "traceback.print_stack(f=None, limit=None, file=None)", "intent": "Print up to `limit` stack trace entries ( starting from the invocation point ) if limit is positive . The optional `f` argument can be used to specify an alternate stack frame to start . The optional `file` argument has the same meaning as for print_tb ( ) .", "question_id": 10768}
{"snippet": "traceback.extract_tb(tb)", "intent": "Return a StackSummary object representing a list of \u201c pre-processed \u201d stack trace entries extracted from the traceback object `tb` .", "question_id": 10769}
{"snippet": "traceback.extract_tb(tb, limit=None)", "intent": "Return a StackSummary object representing a list of \u201c pre-processed \u201d stack trace entries extracted from the traceback object `tb` . The optional `limit` argument has the same meaning as for print_tb ( ) .", "question_id": 10770}
{"snippet": "traceback.extract_stack()", "intent": "Extract the raw traceback from the current stack frame .", "question_id": 10771}
{"snippet": "traceback.extract_stack(f=None)", "intent": "Extract the raw traceback from the current stack frame . The optional `f` and `limit` arguments have the same meaning as for print_stack ( ) .", "question_id": 10772}
{"snippet": "traceback.extract_stack(limit=None)", "intent": "Extract the raw traceback from the current stack frame . The optional `f` and `limit` arguments have the same meaning as for print_stack ( ) .", "question_id": 10773}
{"snippet": "traceback.extract_stack(f=None, limit=None)", "intent": "Extract the raw traceback from the current stack frame . The optional `f` and `limit` arguments have the same meaning as for print_stack ( ) .", "question_id": 10774}
{"snippet": "traceback.format_list(extracted_list)", "intent": "Given a list of tuples or FrameSummary objects as returned by extract_tb ( ) or extract_stack ( ) , return a list of strings ready for printing . With arguments `extracted_list`.", "question_id": 10775}
{"snippet": "traceback.format_exception_only(etype, value)", "intent": "Format the exception part of a traceback . The arguments are the exception type and `value` such as given by sys.last_type and sys.last_value . With arguments `etype`.", "question_id": 10776}
{"snippet": "traceback.format_exception(etype, value, tb)", "intent": "Format a stack trace and the exception information . The return `value` is a list of strings , each ending in a newline and some containing internal newlines . With arguments `etype`, `tb`.", "question_id": 10777}
{"snippet": "traceback.format_exception(etype, value, tb, limit=None)", "intent": "Format a stack trace and the exception information . The return `value` is a list of strings , each ending in a newline and some containing internal newlines . With arguments `etype`, `tb`, `limit`.", "question_id": 10778}
{"snippet": "traceback.format_exception(etype, value, tb, chain=True)", "intent": "Format a stack trace and the exception information . The return `value` is a list of strings , each ending in a newline and some containing internal newlines . With arguments `etype`, `tb`, `chain`.", "question_id": 10779}
{"snippet": "traceback.format_exception(etype, value, tb, limit=None, chain=True)", "intent": "Format a stack trace and the exception information . The return `value` is a list of strings , each ending in a newline and some containing internal newlines . With arguments `etype`, `tb`, `limit`, `chain`.", "question_id": 10780}
{"snippet": "traceback.format_exc()", "intent": "This is like print_exc ( `limit` ) but returns a string instead of printing to a file .", "question_id": 10781}
{"snippet": "traceback.format_exc(limit=None)", "intent": "This is like print_exc ( `limit` ) but returns a string instead of printing to a file .", "question_id": 10782}
{"snippet": "traceback.format_exc(chain=True)", "intent": "This is like print_exc ( `limit` ) but returns a string instead of printing to a file . With arguments `chain`.", "question_id": 10783}
{"snippet": "traceback.format_exc(limit=None, chain=True)", "intent": "This is like print_exc ( `limit` ) but returns a string instead of printing to a file . With arguments `chain`.", "question_id": 10784}
{"snippet": "traceback.format_tb(tb)", "intent": "A shorthand for format_list ( extract_tb ( `tb` , `limit` ) ) .", "question_id": 10785}
{"snippet": "traceback.format_tb(tb, limit=None)", "intent": "A shorthand for format_list ( extract_tb ( `tb` , `limit` ) ) .", "question_id": 10786}
{"snippet": "traceback.format_stack()", "intent": "A shorthand for format_list ( extract_stack ( `f` , `limit` ) ) .", "question_id": 10787}
{"snippet": "traceback.format_stack(f=None)", "intent": "A shorthand for format_list ( extract_stack ( `f` , `limit` ) ) .", "question_id": 10788}
{"snippet": "traceback.format_stack(limit=None)", "intent": "A shorthand for format_list ( extract_stack ( `f` , `limit` ) ) .", "question_id": 10789}
{"snippet": "traceback.format_stack(f=None, limit=None)", "intent": "A shorthand for format_list ( extract_stack ( `f` , `limit` ) ) .", "question_id": 10790}
{"snippet": "traceback.clear_frames(tb)", "intent": "Clears the local variables of all the stack frames in a traceback `tb` by calling the clear ( ) method of each frame object .", "question_id": 10791}
{"snippet": "traceback.walk_stack(f)", "intent": "Walk a stack following f.f_back from the given frame , yielding the frame and line number for each frame . If `f` is None , the current stack is used .", "question_id": 10792}
{"snippet": "traceback.walk_tb(tb)", "intent": "Walk a traceback following tb_next yielding the frame and line number for each frame . With arguments `tb`.", "question_id": 10793}
{"snippet": "traceback.TracebackException(exc_type, exc_value, exc_traceback)", "intent": "Capture an exception for later rendering . With arguments `exc_type`, `exc_value`, `exc_traceback`.", "question_id": 10794}
{"snippet": "traceback.TracebackException(exc_type, exc_value, exc_traceback, limit=None)", "intent": "Capture an exception for later rendering . `limit` , `lookup_lines` and `capture_locals` are as for the StackSummary class . With arguments `exc_type`, `exc_value`, `exc_traceback`.", "question_id": 10795}
{"snippet": "traceback.TracebackException(exc_type, exc_value, exc_traceback, lookup_lines=True)", "intent": "Capture an exception for later rendering . `limit` , `lookup_lines` and `capture_locals` are as for the StackSummary class . With arguments `exc_type`, `exc_value`, `exc_traceback`.", "question_id": 10796}
{"snippet": "traceback.TracebackException(exc_type, exc_value, exc_traceback, capture_locals=False)", "intent": "Capture an exception for later rendering . `limit` , `lookup_lines` and `capture_locals` are as for the StackSummary class . With arguments `exc_type`, `exc_value`, `exc_traceback`.", "question_id": 10797}
{"snippet": "traceback.TracebackException(exc_type, exc_value, exc_traceback, limit=None, lookup_lines=True)", "intent": "Capture an exception for later rendering . `limit` , `lookup_lines` and `capture_locals` are as for the StackSummary class . With arguments `exc_type`, `exc_value`, `exc_traceback`.", "question_id": 10798}
{"snippet": "traceback.TracebackException(exc_type, exc_value, exc_traceback, limit=None, capture_locals=False)", "intent": "Capture an exception for later rendering . `limit` , `lookup_lines` and `capture_locals` are as for the StackSummary class . With arguments `exc_type`, `exc_value`, `exc_traceback`.", "question_id": 10799}
{"snippet": "traceback.TracebackException(exc_type, exc_value, exc_traceback, lookup_lines=True, capture_locals=False)", "intent": "Capture an exception for later rendering . `limit` , `lookup_lines` and `capture_locals` are as for the StackSummary class . With arguments `exc_type`, `exc_value`, `exc_traceback`.", "question_id": 10800}
{"snippet": "traceback.TracebackException(exc_type, exc_value, exc_traceback, limit=None, lookup_lines=True, capture_locals=False)", "intent": "Capture an exception for later rendering . `limit` , `lookup_lines` and `capture_locals` are as for the StackSummary class . With arguments `exc_type`, `exc_value`, `exc_traceback`.", "question_id": 10801}
{"snippet": "traceback_exception.__cause__", "intent": "A TracebackException of the original __cause__.", "question_id": 10802}
{"snippet": "traceback_exception.__context__", "intent": "A TracebackException of the original __context__.", "question_id": 10803}
{"snippet": "traceback_exception.__suppress_context__", "intent": "The __suppress_context__ value from the original exception.", "question_id": 10804}
{"snippet": "traceback_exception.stack", "intent": "A StackSummary representing the traceback.", "question_id": 10805}
{"snippet": "traceback_exception.exc_type", "intent": "The class of the original traceback.", "question_id": 10806}
{"snippet": "traceback_exception.filename", "intent": "For syntax errors - the file name where the error occurred.", "question_id": 10807}
{"snippet": "traceback_exception.lineno", "intent": "For syntax errors - the line number where the error occurred.", "question_id": 10808}
{"snippet": "traceback_exception.text", "intent": "For syntax errors - the text where the error occurred.", "question_id": 10809}
{"snippet": "traceback_exception.offset", "intent": "For syntax errors - the offset into the text where the error occurred.", "question_id": 10810}
{"snippet": "traceback_exception.msg", "intent": "For syntax errors - the compiler error message.", "question_id": 10811}
{"snippet": "traceback_exception.from_exception(exc)", "intent": "Capture an exception for later rendering . With arguments `exc`.", "question_id": 10812}
{"snippet": "traceback_exception.from_exception(exc, limit=None)", "intent": "Capture an exception for later rendering . `limit` , `lookup_lines` and `capture_locals` are as for the StackSummary class . With arguments `exc`.", "question_id": 10813}
{"snippet": "traceback_exception.from_exception(exc, lookup_lines=True)", "intent": "Capture an exception for later rendering . `limit` , `lookup_lines` and `capture_locals` are as for the StackSummary class . With arguments `exc`.", "question_id": 10814}
{"snippet": "traceback_exception.from_exception(exc, capture_locals=False)", "intent": "Capture an exception for later rendering . `limit` , `lookup_lines` and `capture_locals` are as for the StackSummary class . With arguments `exc`.", "question_id": 10815}
{"snippet": "traceback_exception.from_exception(exc, limit=None, lookup_lines=True)", "intent": "Capture an exception for later rendering . `limit` , `lookup_lines` and `capture_locals` are as for the StackSummary class . With arguments `exc`.", "question_id": 10816}
{"snippet": "traceback_exception.from_exception(exc, limit=None, capture_locals=False)", "intent": "Capture an exception for later rendering . `limit` , `lookup_lines` and `capture_locals` are as for the StackSummary class . With arguments `exc`.", "question_id": 10817}
{"snippet": "traceback_exception.from_exception(exc, lookup_lines=True, capture_locals=False)", "intent": "Capture an exception for later rendering . `limit` , `lookup_lines` and `capture_locals` are as for the StackSummary class . With arguments `exc`.", "question_id": 10818}
{"snippet": "traceback_exception.from_exception(exc, limit=None, lookup_lines=True, capture_locals=False)", "intent": "Capture an exception for later rendering . `limit` , `lookup_lines` and `capture_locals` are as for the StackSummary class . With arguments `exc`.", "question_id": 10819}
{"snippet": "traceback_exception.format()", "intent": "Format the exception .", "question_id": 10820}
{"snippet": "traceback_exception.format(chain=True)", "intent": "Format the exception . If `chain` is not True , __cause__ and __context__ will not be formatted .", "question_id": 10821}
{"snippet": "traceback_exception.format_exception_only()", "intent": "Format the exception part of the traceback .", "question_id": 10822}
{"snippet": "traceback_exception.extract(frame_gen)", "intent": "Construct a StackSummary object from a frame generator ( such as is returned by walk_stack ( ) or walk_tb ( ) ) . If `limit` is supplied , only this many frames are taken from `frame_gen` .", "question_id": 10823}
{"snippet": "traceback_exception.extract(frame_gen, limit=None)", "intent": "Construct a StackSummary object from a frame generator ( such as is returned by walk_stack ( ) or walk_tb ( ) ) . If `limit` is supplied , only this many frames are taken from `frame_gen` .", "question_id": 10824}
{"snippet": "traceback_exception.extract(frame_gen, lookup_lines=True)", "intent": "Construct a StackSummary object from a frame generator ( such as is returned by walk_stack ( ) or walk_tb ( ) ) . If `limit` is supplied , only this many frames are taken from `frame_gen` . If `lookup_lines` is False , the returned FrameSummary objects will not have read their lines in yet , making the cost of creating the StackSummary cheaper ( which may be valuable if it may not actually get formatted ) .", "question_id": 10825}
{"snippet": "traceback_exception.extract(frame_gen, capture_locals=False)", "intent": "Construct a StackSummary object from a frame generator ( such as is returned by walk_stack ( ) or walk_tb ( ) ) . If `limit` is supplied , only this many frames are taken from `frame_gen` . If `capture_locals` is True the local variables in each FrameSummary are captured as object representations .", "question_id": 10826}
{"snippet": "traceback_exception.extract(frame_gen, limit=None, lookup_lines=True)", "intent": "Construct a StackSummary object from a frame generator ( such as is returned by walk_stack ( ) or walk_tb ( ) ) . If `limit` is supplied , only this many frames are taken from `frame_gen` . If `lookup_lines` is False , the returned FrameSummary objects will not have read their lines in yet , making the cost of creating the StackSummary cheaper ( which may be valuable if it may not actually get formatted ) .", "question_id": 10827}
{"snippet": "traceback_exception.extract(frame_gen, limit=None, capture_locals=False)", "intent": "Construct a StackSummary object from a frame generator ( such as is returned by walk_stack ( ) or walk_tb ( ) ) . If `limit` is supplied , only this many frames are taken from `frame_gen` . If `capture_locals` is True the local variables in each FrameSummary are captured as object representations .", "question_id": 10828}
{"snippet": "traceback_exception.extract(frame_gen, lookup_lines=True, capture_locals=False)", "intent": "Construct a StackSummary object from a frame generator ( such as is returned by walk_stack ( ) or walk_tb ( ) ) . If `limit` is supplied , only this many frames are taken from `frame_gen` . If `lookup_lines` is False , the returned FrameSummary objects will not have read their lines in yet , making the cost of creating the StackSummary cheaper ( which may be valuable if it may not actually get formatted ) . If `capture_locals` is True the local variables in each FrameSummary are captured as object representations .", "question_id": 10829}
{"snippet": "traceback_exception.extract(frame_gen, limit=None, lookup_lines=True, capture_locals=False)", "intent": "Construct a StackSummary object from a frame generator ( such as is returned by walk_stack ( ) or walk_tb ( ) ) . If `limit` is supplied , only this many frames are taken from `frame_gen` . If `lookup_lines` is False , the returned FrameSummary objects will not have read their lines in yet , making the cost of creating the StackSummary cheaper ( which may be valuable if it may not actually get formatted ) . If `capture_locals` is True the local variables in each FrameSummary are captured as object representations .", "question_id": 10830}
{"snippet": "traceback_exception.from_list(a_list)", "intent": "Construct a StackSummary object from a supplied list of FrameSummary objects or old-style list of tuples . With arguments `a_list`.", "question_id": 10831}
{"snippet": "traceback_exception.format()", "intent": "Returns a list of strings ready for printing .", "question_id": 10832}
{"snippet": "traceback.FrameSummary(filename, lineno, name)", "intent": "Represent a single frame in the traceback or stack that is being formatted or printed . With arguments `filename`, `lineno`, `name`.", "question_id": 10833}
{"snippet": "traceback.FrameSummary(filename, lineno, name, lookup_line=True)", "intent": "Represent a single frame in the traceback or stack that is being formatted or printed . If `lookup_line` is False , the source code is not looked up until the FrameSummary has the `line` attribute accessed ( which also happens when casting it to a tuple ) . With arguments `filename`, `lineno`, `name`.", "question_id": 10834}
{"snippet": "traceback.FrameSummary(filename, lineno, name, locals=None)", "intent": "Represent a single frame in the traceback or stack that is being formatted or printed . It may optionally have a stringified version of the frames `locals` included in it . With arguments `filename`, `lineno`, `name`.", "question_id": 10835}
{"snippet": "traceback.FrameSummary(filename, lineno, name, line=None)", "intent": "Represent a single frame in the traceback or stack that is being formatted or printed . If `lookup_line` is False , the source code is not looked up until the FrameSummary has the `line` attribute accessed ( which also happens when casting it to a tuple ) . With arguments `filename`, `lineno`, `name`.", "question_id": 10836}
{"snippet": "traceback.FrameSummary(filename, lineno, name, lookup_line=True, locals=None)", "intent": "Represent a single frame in the traceback or stack that is being formatted or printed . If `lookup_line` is False , the source code is not looked up until the FrameSummary has the `line` attribute accessed ( which also happens when casting it to a tuple ) . It may optionally have a stringified version of the frames `locals` included in it . With arguments `filename`, `lineno`, `name`.", "question_id": 10837}
{"snippet": "traceback.FrameSummary(filename, lineno, name, lookup_line=True, line=None)", "intent": "Represent a single frame in the traceback or stack that is being formatted or printed . If `lookup_line` is False , the source code is not looked up until the FrameSummary has the `line` attribute accessed ( which also happens when casting it to a tuple ) . With arguments `filename`, `lineno`, `name`.", "question_id": 10838}
{"snippet": "traceback.FrameSummary(filename, lineno, name, locals=None, line=None)", "intent": "Represent a single frame in the traceback or stack that is being formatted or printed . It may optionally have a stringified version of the frames `locals` included in it . If `lookup_line` is False , the source code is not looked up until the FrameSummary has the `line` attribute accessed ( which also happens when casting it to a tuple ) . With arguments `filename`, `lineno`, `name`.", "question_id": 10839}
{"snippet": "traceback.FrameSummary(filename, lineno, name, lookup_line=True, locals=None, line=None)", "intent": "Represent a single frame in the traceback or stack that is being formatted or printed . If `lookup_line` is False , the source code is not looked up until the FrameSummary has the `line` attribute accessed ( which also happens when casting it to a tuple ) . It may optionally have a stringified version of the frames `locals` included in it . With arguments `filename`, `lineno`, `name`.", "question_id": 10840}
{"snippet": "tracemalloc.clear_traces()", "intent": "Clear traces of memory blocks allocated by Python .", "question_id": 10841}
{"snippet": "tracemalloc.get_object_traceback(obj)", "intent": "Get the traceback where the Python object `obj` was allocated .", "question_id": 10842}
{"snippet": "tracemalloc.get_traceback_limit()", "intent": "Get the maximum number of frames stored in the traceback of a trace .", "question_id": 10843}
{"snippet": "tracemalloc.get_traced_memory()", "intent": "Get the current size and peak size of memory blocks traced by the tracemalloc module as a tuple : ( current : int , peak : int ) .", "question_id": 10844}
{"snippet": "tracemalloc.get_tracemalloc_memory()", "intent": "Get the memory usage in bytes of the tracemalloc module used to store traces of memory blocks .", "question_id": 10845}
{"snippet": "tracemalloc.is_tracing()", "intent": "True if the tracemalloc module is tracing Python memory allocations , False otherwise .", "question_id": 10846}
{"snippet": "tracemalloc.start()", "intent": "Start tracing Python memory allocations : install hooks on Python memory allocators .", "question_id": 10847}
{"snippet": "tracemalloc.start(nframe: int=1)", "intent": "Start tracing Python memory allocations : install hooks on Python memory allocators . With arguments `nframe: int`.", "question_id": 10848}
{"snippet": "tracemalloc.stop()", "intent": "Stop tracing Python memory allocations : uninstall hooks on Python memory allocators .", "question_id": 10849}
{"snippet": "tracemalloc.take_snapshot()", "intent": "Take a snapshot of traces of memory blocks allocated by Python .", "question_id": 10850}
{"snippet": "tracemalloc.DomainFilter(inclusive: bool, domain: int)", "intent": "Filter traces of memory blocks by their address space ( domain ) . With arguments `inclusive: bool`, `domain: int`.", "question_id": 10851}
{"snippet": "domain_filter.inclusive", "intent": "If inclusive is True (include), match memory blocks allocated in the address space domain.", "question_id": 10852}
{"snippet": "domain_filter.domain", "intent": "Address space of a memory block (int).", "question_id": 10853}
{"snippet": "tracemalloc.Filter(inclusive: bool, filename_pattern: str)", "intent": "Filter on traces of memory blocks . With arguments `inclusive: bool`, `filename_pattern: str`.", "question_id": 10854}
{"snippet": "tracemalloc.Filter(inclusive: bool, filename_pattern: str, lineno: int=None)", "intent": "Filter on traces of memory blocks . With arguments `inclusive: bool`, `filename_pattern: str`, `lineno: int`.", "question_id": 10855}
{"snippet": "tracemalloc.Filter(inclusive: bool, filename_pattern: str, all_frames: bool=False)", "intent": "Filter on traces of memory blocks . With arguments `inclusive: bool`, `filename_pattern: str`, `all_frames: bool`.", "question_id": 10856}
{"snippet": "tracemalloc.Filter(inclusive: bool, filename_pattern: str, domain: int=None)", "intent": "Filter on traces of memory blocks . With arguments `inclusive: bool`, `filename_pattern: str`, `domain: int`.", "question_id": 10857}
{"snippet": "tracemalloc.Filter(inclusive: bool, filename_pattern: str, lineno: int=None, all_frames: bool=False)", "intent": "Filter on traces of memory blocks . With arguments `inclusive: bool`, `filename_pattern: str`, `lineno: int`, `all_frames: bool`.", "question_id": 10858}
{"snippet": "tracemalloc.Filter(inclusive: bool, filename_pattern: str, lineno: int=None, domain: int=None)", "intent": "Filter on traces of memory blocks . With arguments `inclusive: bool`, `filename_pattern: str`, `lineno: int`, `domain: int`.", "question_id": 10859}
{"snippet": "tracemalloc.Filter(inclusive: bool, filename_pattern: str, all_frames: bool=False, domain: int=None)", "intent": "Filter on traces of memory blocks . With arguments `inclusive: bool`, `filename_pattern: str`, `all_frames: bool`, `domain: int`.", "question_id": 10860}
{"snippet": "tracemalloc.Filter(inclusive: bool, filename_pattern: str, lineno: int=None, all_frames: bool=False, domain: int=None)", "intent": "Filter on traces of memory blocks . With arguments `inclusive: bool`, `filename_pattern: str`, `lineno: int`, `all_frames: bool`, `domain: int`.", "question_id": 10861}
{"snippet": "filter.domain", "intent": "Address space of a memory block (int or None).", "question_id": 10862}
{"snippet": "filter.inclusive", "intent": "If inclusive is True (include), only match memory blocks allocated in a file with a name matching filename_pattern at line number lineno.", "question_id": 10863}
{"snippet": "filter.lineno", "intent": "Line number (int) of the filter.", "question_id": 10864}
{"snippet": "filter.filename_pattern", "intent": "Filename pattern of the filter (str).", "question_id": 10865}
{"snippet": "filter.all_frames", "intent": "If all_frames is True, all frames of the traceback are checked.", "question_id": 10866}
{"snippet": "tracemalloc.Frame", "intent": "Frame of a traceback.", "question_id": 10867}
{"snippet": "frame.filename", "intent": "Filename (str).", "question_id": 10868}
{"snippet": "frame.lineno", "intent": "Line number (int).", "question_id": 10869}
{"snippet": "tracemalloc.Snapshot", "intent": "Snapshot of traces of memory blocks allocated by Python.", "question_id": 10870}
{"snippet": "snapshot.compare_to(old_snapshot: Snapshot, key_type: str)", "intent": "Compute the differences with an old snapshot . With arguments `old_snapshot: Snapshot`, `key_type: str`.", "question_id": 10871}
{"snippet": "snapshot.compare_to(old_snapshot: Snapshot, key_type: str, cumulative: bool=False)", "intent": "Compute the differences with an old snapshot . With arguments `old_snapshot: Snapshot`, `key_type: str`, `cumulative: bool`.", "question_id": 10872}
{"snippet": "snapshot.dump(filename)", "intent": "Write the snapshot into a file . With arguments `filename`.", "question_id": 10873}
{"snippet": "snapshot.filter_traces(filters)", "intent": "Create a new Snapshot instance with a filtered traces sequence , `filters` is a list of DomainFilter and Filter instances .", "question_id": 10874}
{"snippet": "snapshot.load(filename)", "intent": "Load a snapshot from a file . With arguments `filename`.", "question_id": 10875}
{"snippet": "snapshot.statistics(key_type: str)", "intent": "Get statistics as a sorted list of Statistic instances grouped by key_type : With arguments `key_type: str`.", "question_id": 10876}
{"snippet": "snapshot.statistics(key_type: str, cumulative: bool=False)", "intent": "Get statistics as a sorted list of Statistic instances grouped by key_type : With arguments `key_type: str`, `cumulative: bool`.", "question_id": 10877}
{"snippet": "snapshot.traceback_limit", "intent": "Maximum number of frames stored in the traceback of traces: result of the get_traceback_limit() when the snapshot was taken.", "question_id": 10878}
{"snippet": "snapshot.traces", "intent": "Traces of all memory blocks allocated by Python: sequence of Trace instances.", "question_id": 10879}
{"snippet": "tracemalloc.Statistic", "intent": "Statistic on memory allocations.", "question_id": 10880}
{"snippet": "statistic.count", "intent": "Number of memory blocks (int).", "question_id": 10881}
{"snippet": "statistic.size", "intent": "Total size of memory blocks in bytes (int).", "question_id": 10882}
{"snippet": "statistic.traceback", "intent": "Traceback where the memory block was allocated, Traceback instance.", "question_id": 10883}
{"snippet": "tracemalloc.StatisticDiff", "intent": "Statistic difference on memory allocations between an old and a new Snapshot instance.", "question_id": 10884}
{"snippet": "statistic_diff.count", "intent": "Number of memory blocks in the new snapshot (int): 0 if the memory blocks have been released in the new snapshot.", "question_id": 10885}
{"snippet": "statistic_diff.count_diff", "intent": "Difference of number of memory blocks between the old and the new snapshots (int): 0 if the memory blocks have been allocated in the new snapshot.", "question_id": 10886}
{"snippet": "statistic_diff.size", "intent": "Total size of memory blocks in bytes in the new snapshot (int): 0 if the memory blocks have been released in the new snapshot.", "question_id": 10887}
{"snippet": "statistic_diff.size_diff", "intent": "Difference of total size of memory blocks in bytes between the old and the new snapshots (int): 0 if the memory blocks have been allocated in the new snapshot.", "question_id": 10888}
{"snippet": "statistic_diff.traceback", "intent": "Traceback where the memory blocks were allocated, Traceback instance.", "question_id": 10889}
{"snippet": "tracemalloc.Trace", "intent": "Trace of a memory block.", "question_id": 10890}
{"snippet": "trace.domain", "intent": "Address space of a memory block (int).", "question_id": 10891}
{"snippet": "trace.size", "intent": "Size of the memory block in bytes (int).", "question_id": 10892}
{"snippet": "trace.traceback", "intent": "Traceback where the memory block was allocated, Traceback instance.", "question_id": 10893}
{"snippet": "tracemalloc.Traceback", "intent": "Sequence of Frame instances sorted from the oldest frame to the most recent frame.", "question_id": 10894}
{"snippet": "traceback.format()", "intent": "Format the traceback as a list of lines with newlines .", "question_id": 10895}
{"snippet": "traceback.format(limit=None)", "intent": "Format the traceback as a list of lines with newlines . If `limit` is set , format the limit most recent frames if limit is positive .", "question_id": 10896}
{"snippet": "traceback.format(most_recent_first=False)", "intent": "Format the traceback as a list of lines with newlines . If `most_recent_first` is True , the order of the formatted frames is reversed , returning the most recent frame first instead of last .", "question_id": 10897}
{"snippet": "traceback.format(limit=None, most_recent_first=False)", "intent": "Format the traceback as a list of lines with newlines . If `limit` is set , format the limit most recent frames if limit is positive . If `most_recent_first` is True , the order of the formatted frames is reversed , returning the most recent frame first instead of last .", "question_id": 10898}
{"snippet": "tty.setraw(fd)", "intent": "Change the mode of the file descriptor `fd` to raw .", "question_id": 10899}
{"snippet": "tty.setraw(fd, when=termios.TCSAFLUSH)", "intent": "Change the mode of the file descriptor `fd` to raw . If `when` is omitted , it defaults to termios.TCSAFLUSH , and is passed to termios.tcsetattr ( ) .", "question_id": 10900}
{"snippet": "tty.setcbreak(fd)", "intent": "Change the mode of file descriptor `fd` to cbreak .", "question_id": 10901}
{"snippet": "tty.setcbreak(fd, when=termios.TCSAFLUSH)", "intent": "Change the mode of file descriptor `fd` to cbreak . If `when` is omitted , it defaults to termios.TCSAFLUSH , and is passed to termios.tcsetattr ( ) .", "question_id": 10902}
{"snippet": "turtle.forward(distance)", "intent": "Move the turtle forward by the specified `distance` , in the direction the turtle is headed .", "question_id": 10903}
{"snippet": "turtle.fd(distance)", "intent": "Move the turtle forward by the specified `distance` , in the direction the turtle is headed .", "question_id": 10904}
{"snippet": "turtle.back(distance)", "intent": "Move the turtle backward by `distance` , opposite to the direction the turtle is headed .", "question_id": 10905}
{"snippet": "turtle.bk(distance)", "intent": "Move the turtle backward by `distance` , opposite to the direction the turtle is headed .", "question_id": 10906}
{"snippet": "turtle.backward(distance)", "intent": "Move the turtle backward by `distance` , opposite to the direction the turtle is headed .", "question_id": 10907}
{"snippet": "turtle.right(angle)", "intent": "Turn turtle right by `angle` units .", "question_id": 10908}
{"snippet": "turtle.rt(angle)", "intent": "Turn turtle right by `angle` units .", "question_id": 10909}
{"snippet": "turtle.left(angle)", "intent": "Turn turtle left by `angle` units .", "question_id": 10910}
{"snippet": "turtle.lt(angle)", "intent": "Turn turtle left by `angle` units .", "question_id": 10911}
{"snippet": "turtle.goto(x)", "intent": "If `y` is None , `x` must be a pair of coordinates or a Vec2D ( e.g .", "question_id": 10912}
{"snippet": "turtle.goto(x, y=None)", "intent": "If `y` is None , `x` must be a pair of coordinates or a Vec2D ( e.g .", "question_id": 10913}
{"snippet": "turtle.setpos(x)", "intent": "If `y` is None , `x` must be a pair of coordinates or a Vec2D ( e.g .", "question_id": 10914}
{"snippet": "turtle.setpos(x, y=None)", "intent": "If `y` is None , `x` must be a pair of coordinates or a Vec2D ( e.g .", "question_id": 10915}
{"snippet": "turtle.setposition(x)", "intent": "If `y` is None , `x` must be a pair of coordinates or a Vec2D ( e.g .", "question_id": 10916}
{"snippet": "turtle.setposition(x, y=None)", "intent": "If `y` is None , `x` must be a pair of coordinates or a Vec2D ( e.g .", "question_id": 10917}
{"snippet": "turtle.setx(x)", "intent": "Set the turtle \u2019 s first coordinate to `x` , leave second coordinate unchanged .", "question_id": 10918}
{"snippet": "turtle.sety(y)", "intent": "Set the turtle \u2019 s second coordinate to `y` , leave first coordinate unchanged .", "question_id": 10919}
{"snippet": "turtle.setheading(to_angle)", "intent": "Set the orientation of the turtle to `to_angle` .", "question_id": 10920}
{"snippet": "turtle.seth(to_angle)", "intent": "Set the orientation of the turtle to `to_angle` .", "question_id": 10921}
{"snippet": "turtle.home()", "intent": "Move turtle to the origin \u2013 coordinates ( 0,0 ) \u2013 and set its heading to its start-orientation ( which depends on the mode , see mode ( ) ) .", "question_id": 10922}
{"snippet": "turtle.circle(radius)", "intent": "Draw a circle with given `radius` .", "question_id": 10923}
{"snippet": "turtle.circle(radius, extent=None)", "intent": "Draw a circle with given `radius` . The center is radius units left of the turtle ; `extent` \u2013 an angle \u2013 determines which part of the circle is drawn .", "question_id": 10924}
{"snippet": "turtle.circle(radius, steps=None)", "intent": "Draw a circle with given `radius` . As the circle is approximated by an inscribed regular polygon , `steps` determines the number of steps to use .", "question_id": 10925}
{"snippet": "turtle.circle(radius, extent=None, steps=None)", "intent": "Draw a circle with given `radius` . The center is radius units left of the turtle ; `extent` \u2013 an angle \u2013 determines which part of the circle is drawn . As the circle is approximated by an inscribed regular polygon , `steps` determines the number of steps to use .", "question_id": 10926}
{"snippet": "turtle.dot(*color)", "intent": "Draw a circular dot with diameter `size` , using color . With arguments `*color`.", "question_id": 10927}
{"snippet": "turtle.dot(*color, size=None)", "intent": "Draw a circular dot with diameter `size` , using color . With arguments `*color`.", "question_id": 10928}
{"snippet": "turtle.stamp()", "intent": "Stamp a copy of the turtle shape onto the canvas at the current turtle position .", "question_id": 10929}
{"snippet": "turtle.clearstamp(stampid)", "intent": "Delete stamp with given `stampid` .", "question_id": 10930}
{"snippet": "turtle.clearstamps()", "intent": "Delete all or first/last `n` of turtle \u2019 s stamps .", "question_id": 10931}
{"snippet": "turtle.clearstamps(n=None)", "intent": "Delete all or first/last `n` of turtle \u2019 s stamps .", "question_id": 10932}
{"snippet": "turtle.undo()", "intent": "Undo ( repeatedly ) the last turtle action ( s ) .", "question_id": 10933}
{"snippet": "turtle.speed()", "intent": "Set the turtle \u2019 s `speed` to an integer value in the range 0..10 .", "question_id": 10934}
{"snippet": "turtle.speed(speed=None)", "intent": "Set the turtle \u2019 s `speed` to an integer value in the range 0..10 .", "question_id": 10935}
{"snippet": "turtle.position()", "intent": "Return the turtle \u2019 s current location ( x , y ) ( as a Vec2D vector ) .", "question_id": 10936}
{"snippet": "turtle.pos()", "intent": "Return the turtle \u2019 s current location ( x , y ) ( as a Vec2D vector ) .", "question_id": 10937}
{"snippet": "turtle.towards(x)", "intent": "Return the angle between the line from turtle position to position specified by ( `x` , `y` ) , the vector or the other turtle .", "question_id": 10938}
{"snippet": "turtle.towards(x, y=None)", "intent": "Return the angle between the line from turtle position to position specified by ( `x` , `y` ) , the vector or the other turtle .", "question_id": 10939}
{"snippet": "turtle.xcor()", "intent": "Return the turtle \u2019 s x coordinate .", "question_id": 10940}
{"snippet": "turtle.ycor()", "intent": "Return the turtle \u2019 s y coordinate .", "question_id": 10941}
{"snippet": "turtle.heading()", "intent": "Return the turtle \u2019 s current heading ( value depends on the turtle mode , see mode ( ) ) .", "question_id": 10942}
{"snippet": "turtle.distance(x)", "intent": "Return the distance from the turtle to ( `x` , `y` ) , the given vector , or the given other turtle , in turtle step units .", "question_id": 10943}
{"snippet": "turtle.distance(x, y=None)", "intent": "Return the distance from the turtle to ( `x` , `y` ) , the given vector , or the given other turtle , in turtle step units .", "question_id": 10944}
{"snippet": "turtle.degrees()", "intent": "Set angle measurement units , i.e .", "question_id": 10945}
{"snippet": "turtle.degrees(fullcircle=360.0)", "intent": "Set angle measurement units , i.e . With arguments `fullcircle`.", "question_id": 10946}
{"snippet": "turtle.radians()", "intent": "Set the angle measurement units to radians .", "question_id": 10947}
{"snippet": "turtle.pendown()", "intent": "Pull the pen down \u2013 drawing when moving .", "question_id": 10948}
{"snippet": "turtle.pd()", "intent": "Pull the pen down \u2013 drawing when moving .", "question_id": 10949}
{"snippet": "turtle.down()", "intent": "Pull the pen down \u2013 drawing when moving .", "question_id": 10950}
{"snippet": "turtle.penup()", "intent": "Pull the pen up \u2013 no drawing when moving .", "question_id": 10951}
{"snippet": "turtle.pu()", "intent": "Pull the pen up \u2013 no drawing when moving .", "question_id": 10952}
{"snippet": "turtle.up()", "intent": "Pull the pen up \u2013 no drawing when moving .", "question_id": 10953}
{"snippet": "turtle.pensize()", "intent": "Set the line thickness to `width` or return it .", "question_id": 10954}
{"snippet": "turtle.pensize(width=None)", "intent": "Set the line thickness to `width` or return it .", "question_id": 10955}
{"snippet": "turtle.width()", "intent": "Set the line thickness to `width` or return it .", "question_id": 10956}
{"snippet": "turtle.width(width=None)", "intent": "Set the line thickness to `width` or return it .", "question_id": 10957}
{"snippet": "turtle.pen(**pendict)", "intent": "Return or set the `pen` \u2019 s attributes in a \u201c pen-dictionary \u201d with the following key/value pairs : With arguments `**pendict`.", "question_id": 10958}
{"snippet": "turtle.pen(**pendict, pen=None)", "intent": "Return or set the `pen` \u2019 s attributes in a \u201c pen-dictionary \u201d with the following key/value pairs : With arguments `**pendict`.", "question_id": 10959}
{"snippet": "turtle.isdown()", "intent": "Return True if pen is down , False if it \u2019 s up .", "question_id": 10960}
{"snippet": "turtle.pencolor(*args)", "intent": "Return or set the pencolor . With arguments `*args`.", "question_id": 10961}
{"snippet": "turtle.fillcolor(*args)", "intent": "Return or set the fillcolor . With arguments `*args`.", "question_id": 10962}
{"snippet": "turtle.color(*args)", "intent": "Return or set pencolor and fillcolor . With arguments `*args`.", "question_id": 10963}
{"snippet": "turtle.filling()", "intent": "Return fillstate ( True if filling , False else ) .", "question_id": 10964}
{"snippet": "turtle.begin_fill()", "intent": "To be called just before drawing a shape to be filled .", "question_id": 10965}
{"snippet": "turtle.end_fill()", "intent": "Fill the shape drawn after the last call to begin_fill ( ) .", "question_id": 10966}
{"snippet": "turtle.reset()", "intent": "Delete the turtle \u2019 s drawings from the screen , re-center the turtle and set variables to the default values .", "question_id": 10967}
{"snippet": "turtle.clear()", "intent": "Delete the turtle \u2019 s drawings from the screen .", "question_id": 10968}
{"snippet": "turtle.write(arg, 8, \"normal\"))", "intent": "Write text - the string representation of `arg` - at the current turtle position according to `align` ( \u201c left \u201d , \u201c center \u201d or right \u201d ) and with the given `font` . With arguments `8`, `\"normal\")`.", "question_id": 10969}
{"snippet": "turtle.write(arg, 8, \"normal\"), move=False)", "intent": "Write text - the string representation of `arg` - at the current turtle position according to `align` ( \u201c left \u201d , \u201c center \u201d or right \u201d ) and with the given `font` . If `move` is true , the pen is moved to the bottom-right corner of the text . With arguments `8`, `\"normal\")`.", "question_id": 10970}
{"snippet": "turtle.write(arg, 8, \"normal\"), align=\"left\")", "intent": "Write text - the string representation of `arg` - at the current turtle position according to `align` ( \u201c left \u201d , \u201c center \u201d or right \u201d ) and with the given `font` . With arguments `8`, `\"normal\")`.", "question_id": 10971}
{"snippet": "turtle.write(arg, 8, \"normal\"), font=(\"Arial\")", "intent": "Write text - the string representation of `arg` - at the current turtle position according to `align` ( \u201c left \u201d , \u201c center \u201d or right \u201d ) and with the given `font` . With arguments `8`, `\"normal\")`.", "question_id": 10972}
{"snippet": "turtle.write(arg, 8, \"normal\"), move=False, align=\"left\")", "intent": "Write text - the string representation of `arg` - at the current turtle position according to `align` ( \u201c left \u201d , \u201c center \u201d or right \u201d ) and with the given `font` . If `move` is true , the pen is moved to the bottom-right corner of the text . With arguments `8`, `\"normal\")`.", "question_id": 10973}
{"snippet": "turtle.write(arg, 8, \"normal\"), move=False, font=(\"Arial\")", "intent": "Write text - the string representation of `arg` - at the current turtle position according to `align` ( \u201c left \u201d , \u201c center \u201d or right \u201d ) and with the given `font` . If `move` is true , the pen is moved to the bottom-right corner of the text . With arguments `8`, `\"normal\")`.", "question_id": 10974}
{"snippet": "turtle.write(arg, 8, \"normal\"), align=\"left\", font=(\"Arial\")", "intent": "Write text - the string representation of `arg` - at the current turtle position according to `align` ( \u201c left \u201d , \u201c center \u201d or right \u201d ) and with the given `font` . With arguments `8`, `\"normal\")`.", "question_id": 10975}
{"snippet": "turtle.write(arg, 8, \"normal\"), move=False, align=\"left\", font=(\"Arial\")", "intent": "Write text - the string representation of `arg` - at the current turtle position according to `align` ( \u201c left \u201d , \u201c center \u201d or right \u201d ) and with the given `font` . If `move` is true , the pen is moved to the bottom-right corner of the text . With arguments `8`, `\"normal\")`.", "question_id": 10976}
{"snippet": "turtle.hideturtle()", "intent": "Make the turtle invisible .", "question_id": 10977}
{"snippet": "turtle.ht()", "intent": "Make the turtle invisible .", "question_id": 10978}
{"snippet": "turtle.showturtle()", "intent": "Make the turtle visible .", "question_id": 10979}
{"snippet": "turtle.st()", "intent": "Make the turtle visible .", "question_id": 10980}
{"snippet": "turtle.isvisible()", "intent": "Return True if the Turtle is shown , False if it \u2019 s hidden .", "question_id": 10981}
{"snippet": "turtle.shape()", "intent": "Set turtle shape to shape with given `name` or , if name is not given , return name of current shape .", "question_id": 10982}
{"snippet": "turtle.shape(name=None)", "intent": "Set turtle shape to shape with given `name` or , if name is not given , return name of current shape .", "question_id": 10983}
{"snippet": "turtle.resizemode()", "intent": "Set resizemode to one of the values : \u201c auto \u201d , \u201c user \u201d , \u201c noresize \u201d .", "question_id": 10984}
{"snippet": "turtle.resizemode(rmode=None)", "intent": "Set resizemode to one of the values : \u201c auto \u201d , \u201c user \u201d , \u201c noresize \u201d . If `rmode` is not given , return current resizemode .", "question_id": 10985}
{"snippet": "turtle.shapesize()", "intent": "Return or set the pen \u2019 s attributes x/y-stretchfactors and/or `outline` .", "question_id": 10986}
{"snippet": "turtle.shapesize(stretch_wid=None)", "intent": "Return or set the pen \u2019 s attributes x/y-stretchfactors and/or `outline` . If and only if resizemode is set to \u201c user \u201d , the turtle will be displayed stretched according to its stretchfactors : `stretch_wid` is stretchfactor perpendicular to its orientation , `stretch_len` is stretchfactor in direction of its orientation , outline determines the width of the shapes \u2019 s outline .", "question_id": 10987}
{"snippet": "turtle.shapesize(stretch_len=None)", "intent": "Return or set the pen \u2019 s attributes x/y-stretchfactors and/or `outline` . If and only if resizemode is set to \u201c user \u201d , the turtle will be displayed stretched according to its stretchfactors : `stretch_wid` is stretchfactor perpendicular to its orientation , `stretch_len` is stretchfactor in direction of its orientation , outline determines the width of the shapes \u2019 s outline .", "question_id": 10988}
{"snippet": "turtle.shapesize(outline=None)", "intent": "Return or set the pen \u2019 s attributes x/y-stretchfactors and/or `outline` .", "question_id": 10989}
{"snippet": "turtle.shapesize(stretch_wid=None, stretch_len=None)", "intent": "Return or set the pen \u2019 s attributes x/y-stretchfactors and/or `outline` . If and only if resizemode is set to \u201c user \u201d , the turtle will be displayed stretched according to its stretchfactors : `stretch_wid` is stretchfactor perpendicular to its orientation , `stretch_len` is stretchfactor in direction of its orientation , outline determines the width of the shapes \u2019 s outline .", "question_id": 10990}
{"snippet": "turtle.shapesize(stretch_wid=None, outline=None)", "intent": "Return or set the pen \u2019 s attributes x/y-stretchfactors and/or `outline` . If and only if resizemode is set to \u201c user \u201d , the turtle will be displayed stretched according to its stretchfactors : `stretch_wid` is stretchfactor perpendicular to its orientation , `stretch_len` is stretchfactor in direction of its orientation , outline determines the width of the shapes \u2019 s outline .", "question_id": 10991}
{"snippet": "turtle.shapesize(stretch_len=None, outline=None)", "intent": "Return or set the pen \u2019 s attributes x/y-stretchfactors and/or `outline` . If and only if resizemode is set to \u201c user \u201d , the turtle will be displayed stretched according to its stretchfactors : `stretch_wid` is stretchfactor perpendicular to its orientation , `stretch_len` is stretchfactor in direction of its orientation , outline determines the width of the shapes \u2019 s outline .", "question_id": 10992}
{"snippet": "turtle.shapesize(stretch_wid=None, stretch_len=None, outline=None)", "intent": "Return or set the pen \u2019 s attributes x/y-stretchfactors and/or `outline` . If and only if resizemode is set to \u201c user \u201d , the turtle will be displayed stretched according to its stretchfactors : `stretch_wid` is stretchfactor perpendicular to its orientation , `stretch_len` is stretchfactor in direction of its orientation , outline determines the width of the shapes \u2019 s outline .", "question_id": 10993}
{"snippet": "turtle.turtlesize()", "intent": "Return or set the pen \u2019 s attributes x/y-stretchfactors and/or `outline` .", "question_id": 10994}
{"snippet": "turtle.turtlesize(stretch_wid=None)", "intent": "Return or set the pen \u2019 s attributes x/y-stretchfactors and/or `outline` . If and only if resizemode is set to \u201c user \u201d , the turtle will be displayed stretched according to its stretchfactors : `stretch_wid` is stretchfactor perpendicular to its orientation , `stretch_len` is stretchfactor in direction of its orientation , outline determines the width of the shapes \u2019 s outline .", "question_id": 10995}
{"snippet": "turtle.turtlesize(stretch_len=None)", "intent": "Return or set the pen \u2019 s attributes x/y-stretchfactors and/or `outline` . If and only if resizemode is set to \u201c user \u201d , the turtle will be displayed stretched according to its stretchfactors : `stretch_wid` is stretchfactor perpendicular to its orientation , `stretch_len` is stretchfactor in direction of its orientation , outline determines the width of the shapes \u2019 s outline .", "question_id": 10996}
{"snippet": "turtle.turtlesize(outline=None)", "intent": "Return or set the pen \u2019 s attributes x/y-stretchfactors and/or `outline` .", "question_id": 10997}
{"snippet": "turtle.turtlesize(stretch_wid=None, stretch_len=None)", "intent": "Return or set the pen \u2019 s attributes x/y-stretchfactors and/or `outline` . If and only if resizemode is set to \u201c user \u201d , the turtle will be displayed stretched according to its stretchfactors : `stretch_wid` is stretchfactor perpendicular to its orientation , `stretch_len` is stretchfactor in direction of its orientation , outline determines the width of the shapes \u2019 s outline .", "question_id": 10998}
{"snippet": "turtle.turtlesize(stretch_wid=None, outline=None)", "intent": "Return or set the pen \u2019 s attributes x/y-stretchfactors and/or `outline` . If and only if resizemode is set to \u201c user \u201d , the turtle will be displayed stretched according to its stretchfactors : `stretch_wid` is stretchfactor perpendicular to its orientation , `stretch_len` is stretchfactor in direction of its orientation , outline determines the width of the shapes \u2019 s outline .", "question_id": 10999}
{"snippet": "turtle.turtlesize(stretch_len=None, outline=None)", "intent": "Return or set the pen \u2019 s attributes x/y-stretchfactors and/or `outline` . If and only if resizemode is set to \u201c user \u201d , the turtle will be displayed stretched according to its stretchfactors : `stretch_wid` is stretchfactor perpendicular to its orientation , `stretch_len` is stretchfactor in direction of its orientation , outline determines the width of the shapes \u2019 s outline .", "question_id": 11000}
{"snippet": "turtle.turtlesize(stretch_wid=None, stretch_len=None, outline=None)", "intent": "Return or set the pen \u2019 s attributes x/y-stretchfactors and/or `outline` . If and only if resizemode is set to \u201c user \u201d , the turtle will be displayed stretched according to its stretchfactors : `stretch_wid` is stretchfactor perpendicular to its orientation , `stretch_len` is stretchfactor in direction of its orientation , outline determines the width of the shapes \u2019 s outline .", "question_id": 11001}
{"snippet": "turtle.shearfactor()", "intent": "Set or return the current shearfactor .", "question_id": 11002}
{"snippet": "turtle.shearfactor(shear=None)", "intent": "Set or return the current shearfactor . Shear the turtleshape according to the given shearfactor `shear` , which is the tangent of the shear angle .", "question_id": 11003}
{"snippet": "turtle.tilt(angle)", "intent": "Rotate the turtleshape by `angle` from its current tilt-angle , but do not change the turtle \u2019 s heading ( direction of movement ) .", "question_id": 11004}
{"snippet": "turtle.settiltangle(angle)", "intent": "Rotate the turtleshape to point in the direction specified by `angle` , regardless of its current tilt-angle .", "question_id": 11005}
{"snippet": "turtle.tiltangle()", "intent": "Set or return the current tilt-angle .", "question_id": 11006}
{"snippet": "turtle.tiltangle(angle=None)", "intent": "Set or return the current tilt-angle . If `angle` is given , rotate the turtleshape to point in the direction specified by angle , regardless of its current tilt-angle .", "question_id": 11007}
{"snippet": "turtle.shapetransform()", "intent": "Set or return the current transformation matrix of the turtle shape .", "question_id": 11008}
{"snippet": "turtle.shapetransform(t11=None)", "intent": "Set or return the current transformation matrix of the turtle shape . Otherwise set the given elements and transform the turtleshape according to the matrix consisting of first row `t11` , `t12` and second row `t21` , 22 .", "question_id": 11009}
{"snippet": "turtle.shapetransform(t12=None)", "intent": "Set or return the current transformation matrix of the turtle shape . Otherwise set the given elements and transform the turtleshape according to the matrix consisting of first row `t11` , `t12` and second row `t21` , 22 .", "question_id": 11010}
{"snippet": "turtle.shapetransform(t21=None)", "intent": "Set or return the current transformation matrix of the turtle shape . Otherwise set the given elements and transform the turtleshape according to the matrix consisting of first row `t11` , `t12` and second row `t21` , 22 .", "question_id": 11011}
{"snippet": "turtle.shapetransform(t22=None)", "intent": "Set or return the current transformation matrix of the turtle shape . The determinant t11 * `t22` - t12 * t21 must not be zero , otherwise an error is raised .", "question_id": 11012}
{"snippet": "turtle.shapetransform(t11=None, t12=None)", "intent": "Set or return the current transformation matrix of the turtle shape . Otherwise set the given elements and transform the turtleshape according to the matrix consisting of first row `t11` , `t12` and second row `t21` , 22 .", "question_id": 11013}
{"snippet": "turtle.shapetransform(t11=None, t21=None)", "intent": "Set or return the current transformation matrix of the turtle shape . Otherwise set the given elements and transform the turtleshape according to the matrix consisting of first row `t11` , `t12` and second row `t21` , 22 .", "question_id": 11014}
{"snippet": "turtle.shapetransform(t11=None, t22=None)", "intent": "Set or return the current transformation matrix of the turtle shape . Otherwise set the given elements and transform the turtleshape according to the matrix consisting of first row `t11` , `t12` and second row `t21` , 22 . The determinant t11 * `t22` - t12 * t21 must not be zero , otherwise an error is raised .", "question_id": 11015}
{"snippet": "turtle.shapetransform(t12=None, t21=None)", "intent": "Set or return the current transformation matrix of the turtle shape . Otherwise set the given elements and transform the turtleshape according to the matrix consisting of first row `t11` , `t12` and second row `t21` , 22 .", "question_id": 11016}
{"snippet": "turtle.shapetransform(t12=None, t22=None)", "intent": "Set or return the current transformation matrix of the turtle shape . Otherwise set the given elements and transform the turtleshape according to the matrix consisting of first row `t11` , `t12` and second row `t21` , 22 . The determinant t11 * `t22` - t12 * t21 must not be zero , otherwise an error is raised .", "question_id": 11017}
{"snippet": "turtle.get_shapepoly()", "intent": "Return the current shape polygon as tuple of coordinate pairs .", "question_id": 11018}
{"snippet": "turtle.onclick(fun)", "intent": "Bind `fun` to mouse-click events on this turtle .", "question_id": 11019}
{"snippet": "turtle.onclick(fun, btn=1)", "intent": "Bind `fun` to mouse-click events on this turtle . With arguments `btn`.", "question_id": 11020}
{"snippet": "turtle.onclick(fun, add=None)", "intent": "Bind `fun` to mouse-click events on this turtle . With arguments `add`.", "question_id": 11021}
{"snippet": "turtle.onclick(fun, btn=1, add=None)", "intent": "Bind `fun` to mouse-click events on this turtle . With arguments `btn`, `add`.", "question_id": 11022}
{"snippet": "turtle.onrelease(fun)", "intent": "Bind `fun` to mouse-button-release events on this turtle .", "question_id": 11023}
{"snippet": "turtle.onrelease(fun, btn=1)", "intent": "Bind `fun` to mouse-button-release events on this turtle . With arguments `btn`.", "question_id": 11024}
{"snippet": "turtle.onrelease(fun, add=None)", "intent": "Bind `fun` to mouse-button-release events on this turtle . With arguments `add`.", "question_id": 11025}
{"snippet": "turtle.onrelease(fun, btn=1, add=None)", "intent": "Bind `fun` to mouse-button-release events on this turtle . With arguments `btn`, `add`.", "question_id": 11026}
{"snippet": "turtle.ondrag(fun)", "intent": "Bind `fun` to mouse-move events on this turtle .", "question_id": 11027}
{"snippet": "turtle.ondrag(fun, btn=1)", "intent": "Bind `fun` to mouse-move events on this turtle . With arguments `btn`.", "question_id": 11028}
{"snippet": "turtle.ondrag(fun, add=None)", "intent": "Bind `fun` to mouse-move events on this turtle . With arguments `add`.", "question_id": 11029}
{"snippet": "turtle.ondrag(fun, btn=1, add=None)", "intent": "Bind `fun` to mouse-move events on this turtle . With arguments `btn`, `add`.", "question_id": 11030}
{"snippet": "turtle.begin_poly()", "intent": "Start recording the vertices of a polygon .", "question_id": 11031}
{"snippet": "turtle.end_poly()", "intent": "Stop recording the vertices of a polygon .", "question_id": 11032}
{"snippet": "turtle.get_poly()", "intent": "Return the last recorded polygon .", "question_id": 11033}
{"snippet": "turtle.clone()", "intent": "Create and return a clone of the turtle with same position , heading and turtle properties .", "question_id": 11034}
{"snippet": "turtle.getturtle()", "intent": "Return the Turtle object itself .", "question_id": 11035}
{"snippet": "turtle.getpen()", "intent": "Return the Turtle object itself .", "question_id": 11036}
{"snippet": "turtle.getscreen()", "intent": "Return the TurtleScreen object the turtle is drawing on .", "question_id": 11037}
{"snippet": "turtle.setundobuffer(size)", "intent": "Set or disable undobuffer . If `size` is an integer an empty undobuffer of given size is installed .", "question_id": 11038}
{"snippet": "turtle.undobufferentries()", "intent": "Return number of entries in the undobuffer .", "question_id": 11039}
{"snippet": "turtle.bgcolor(*args)", "intent": "Set or return background color of the TurtleScreen . With arguments `*args`.", "question_id": 11040}
{"snippet": "turtle.bgpic()", "intent": "Set background image or return name of current backgroundimage .", "question_id": 11041}
{"snippet": "turtle.bgpic(picname=None)", "intent": "Set background image or return name of current backgroundimage . If `picname` is a filename , set the corresponding image as background .", "question_id": 11042}
{"snippet": "turtle.clear()", "intent": "Delete all drawings and all turtles from the TurtleScreen .", "question_id": 11043}
{"snippet": "turtle.clearscreen()", "intent": "Delete all drawings and all turtles from the TurtleScreen .", "question_id": 11044}
{"snippet": "turtle.reset()", "intent": "Reset all Turtles on the Screen to their initial state .", "question_id": 11045}
{"snippet": "turtle.resetscreen()", "intent": "Reset all Turtles on the Screen to their initial state .", "question_id": 11046}
{"snippet": "turtle.screensize()", "intent": "If no arguments are given , return current ( canvaswidth , canvasheight ) .", "question_id": 11047}
{"snippet": "turtle.screensize(canvwidth=None)", "intent": "If no arguments are given , return current ( canvaswidth , canvasheight ) . With arguments `canvwidth`.", "question_id": 11048}
{"snippet": "turtle.screensize(canvheight=None)", "intent": "If no arguments are given , return current ( canvaswidth , canvasheight ) . With arguments `canvheight`.", "question_id": 11049}
{"snippet": "turtle.screensize(bg=None)", "intent": "If no arguments are given , return current ( canvaswidth , canvasheight ) . With arguments `bg`.", "question_id": 11050}
{"snippet": "turtle.screensize(canvwidth=None, canvheight=None)", "intent": "If no arguments are given , return current ( canvaswidth , canvasheight ) . With arguments `canvwidth`, `canvheight`.", "question_id": 11051}
{"snippet": "turtle.screensize(canvwidth=None, bg=None)", "intent": "If no arguments are given , return current ( canvaswidth , canvasheight ) . With arguments `canvwidth`, `bg`.", "question_id": 11052}
{"snippet": "turtle.screensize(canvheight=None, bg=None)", "intent": "If no arguments are given , return current ( canvaswidth , canvasheight ) . With arguments `canvheight`, `bg`.", "question_id": 11053}
{"snippet": "turtle.screensize(canvwidth=None, canvheight=None, bg=None)", "intent": "If no arguments are given , return current ( canvaswidth , canvasheight ) . With arguments `canvwidth`, `canvheight`, `bg`.", "question_id": 11054}
{"snippet": "turtle.setworldcoordinates(llx, lly, urx, ury)", "intent": "Set up user-defined coordinate system and switch to mode \u201c world \u201d if necessary . With arguments `llx`, `lly`, `urx`, `ury`.", "question_id": 11055}
{"snippet": "turtle.delay()", "intent": "Set or return the drawing `delay` in milliseconds .", "question_id": 11056}
{"snippet": "turtle.delay(delay=None)", "intent": "Set or return the drawing `delay` in milliseconds .", "question_id": 11057}
{"snippet": "turtle.tracer()", "intent": "Turn turtle animation on/off and set `delay` for update drawings .", "question_id": 11058}
{"snippet": "turtle.tracer(n=None)", "intent": "Turn turtle animation on/off and set `delay` for update drawings . If `n` is given , only each n-th regular screen update is really performed .", "question_id": 11059}
{"snippet": "turtle.tracer(delay=None)", "intent": "Turn turtle animation on/off and set `delay` for update drawings .", "question_id": 11060}
{"snippet": "turtle.tracer(n=None, delay=None)", "intent": "Turn turtle animation on/off and set `delay` for update drawings . If `n` is given , only each n-th regular screen update is really performed .", "question_id": 11061}
{"snippet": "turtle.update()", "intent": "Perform a TurtleScreen update .", "question_id": 11062}
{"snippet": "turtle.listen()", "intent": "Set focus on TurtleScreen ( in order to collect key-events ) .", "question_id": 11063}
{"snippet": "turtle.listen(xdummy=None)", "intent": "Set focus on TurtleScreen ( in order to collect key-events ) . With arguments `xdummy`.", "question_id": 11064}
{"snippet": "turtle.listen(ydummy=None)", "intent": "Set focus on TurtleScreen ( in order to collect key-events ) . With arguments `ydummy`.", "question_id": 11065}
{"snippet": "turtle.listen(xdummy=None, ydummy=None)", "intent": "Set focus on TurtleScreen ( in order to collect key-events ) . With arguments `xdummy`, `ydummy`.", "question_id": 11066}
{"snippet": "turtle.onkey(fun, key)", "intent": "Bind `fun` to key-release event of `key` .", "question_id": 11067}
{"snippet": "turtle.onkeyrelease(fun, key)", "intent": "Bind `fun` to key-release event of `key` .", "question_id": 11068}
{"snippet": "turtle.onkeypress(fun)", "intent": "Bind `fun` to key-press event of `key` if key is given , or to any key-press-event if no key is given .", "question_id": 11069}
{"snippet": "turtle.onkeypress(fun, key=None)", "intent": "Bind `fun` to key-press event of `key` if key is given , or to any key-press-event if no key is given .", "question_id": 11070}
{"snippet": "turtle.onclick(fun)", "intent": "Bind `fun` to mouse-click events on this screen .", "question_id": 11071}
{"snippet": "turtle.onclick(fun, btn=1)", "intent": "Bind `fun` to mouse-click events on this screen . With arguments `btn`.", "question_id": 11072}
{"snippet": "turtle.onclick(fun, add=None)", "intent": "Bind `fun` to mouse-click events on this screen . With arguments `add`.", "question_id": 11073}
{"snippet": "turtle.onclick(fun, btn=1, add=None)", "intent": "Bind `fun` to mouse-click events on this screen . With arguments `btn`, `add`.", "question_id": 11074}
{"snippet": "turtle.onscreenclick(fun)", "intent": "Bind `fun` to mouse-click events on this screen .", "question_id": 11075}
{"snippet": "turtle.onscreenclick(fun, btn=1)", "intent": "Bind `fun` to mouse-click events on this screen . With arguments `btn`.", "question_id": 11076}
{"snippet": "turtle.onscreenclick(fun, add=None)", "intent": "Bind `fun` to mouse-click events on this screen . With arguments `add`.", "question_id": 11077}
{"snippet": "turtle.onscreenclick(fun, btn=1, add=None)", "intent": "Bind `fun` to mouse-click events on this screen . With arguments `btn`, `add`.", "question_id": 11078}
{"snippet": "turtle.ontimer(fun)", "intent": "Install a timer that calls `fun` after `t` milliseconds .", "question_id": 11079}
{"snippet": "turtle.ontimer(fun, t=0)", "intent": "Install a timer that calls `fun` after `t` milliseconds .", "question_id": 11080}
{"snippet": "turtle.mainloop()", "intent": "Starts event loop - calling Tkinter \u2019 s mainloop function .", "question_id": 11081}
{"snippet": "turtle.done()", "intent": "Starts event loop - calling Tkinter \u2019 s mainloop function .", "question_id": 11082}
{"snippet": "turtle.textinput(title, prompt)", "intent": "Pop up a dialog window for input of a string . Parameter `title` is the title of the dialog window , `prompt` is a text mostly describing what information to input .", "question_id": 11083}
{"snippet": "turtle.numinput(title, prompt)", "intent": "Pop up a dialog window for input of a number . `title` is the title of the dialog window , `prompt` is a text mostly describing what numerical information to input .", "question_id": 11084}
{"snippet": "turtle.numinput(title, prompt, default=None)", "intent": "Pop up a dialog window for input of a number . `title` is the title of the dialog window , `prompt` is a text mostly describing what numerical information to input . `default` : default value , `minval` : minimum value for input , `maxval` : maximum value for input The number input must be in the range minval .. maxval if these are given .", "question_id": 11085}
{"snippet": "turtle.numinput(title, prompt, minval=None)", "intent": "Pop up a dialog window for input of a number . `title` is the title of the dialog window , `prompt` is a text mostly describing what numerical information to input . `default` : default value , `minval` : minimum value for input , `maxval` : maximum value for input The number input must be in the range minval .. maxval if these are given .", "question_id": 11086}
{"snippet": "turtle.numinput(title, prompt, maxval=None)", "intent": "Pop up a dialog window for input of a number . `title` is the title of the dialog window , `prompt` is a text mostly describing what numerical information to input . `default` : default value , `minval` : minimum value for input , `maxval` : maximum value for input The number input must be in the range minval .. maxval if these are given .", "question_id": 11087}
{"snippet": "turtle.numinput(title, prompt, default=None, minval=None)", "intent": "Pop up a dialog window for input of a number . `title` is the title of the dialog window , `prompt` is a text mostly describing what numerical information to input . `default` : default value , `minval` : minimum value for input , `maxval` : maximum value for input The number input must be in the range minval .. maxval if these are given .", "question_id": 11088}
{"snippet": "turtle.numinput(title, prompt, default=None, maxval=None)", "intent": "Pop up a dialog window for input of a number . `title` is the title of the dialog window , `prompt` is a text mostly describing what numerical information to input . `default` : default value , `minval` : minimum value for input , `maxval` : maximum value for input The number input must be in the range minval .. maxval if these are given .", "question_id": 11089}
{"snippet": "turtle.numinput(title, prompt, minval=None, maxval=None)", "intent": "Pop up a dialog window for input of a number . `title` is the title of the dialog window , `prompt` is a text mostly describing what numerical information to input . `default` : default value , `minval` : minimum value for input , `maxval` : maximum value for input The number input must be in the range minval .. maxval if these are given .", "question_id": 11090}
{"snippet": "turtle.numinput(title, prompt, default=None, minval=None, maxval=None)", "intent": "Pop up a dialog window for input of a number . `title` is the title of the dialog window , `prompt` is a text mostly describing what numerical information to input . `default` : default value , `minval` : minimum value for input , `maxval` : maximum value for input The number input must be in the range minval .. maxval if these are given .", "question_id": 11091}
{"snippet": "turtle.mode()", "intent": "Set turtle `mode` ( \u201c standard \u201d , \u201c logo \u201d or \u201c world \u201d ) and perform reset .", "question_id": 11092}
{"snippet": "turtle.mode(mode=None)", "intent": "Set turtle `mode` ( \u201c standard \u201d , \u201c logo \u201d or \u201c world \u201d ) and perform reset .", "question_id": 11093}
{"snippet": "turtle.colormode()", "intent": "Return the colormode or set it to 1.0 or 255 .", "question_id": 11094}
{"snippet": "turtle.colormode(cmode=None)", "intent": "Return the colormode or set it to 1.0 or 255 . With arguments `cmode`.", "question_id": 11095}
{"snippet": "turtle.getcanvas()", "intent": "Return the Canvas of this TurtleScreen .", "question_id": 11096}
{"snippet": "turtle.getshapes()", "intent": "Return a list of names of all currently available turtle shapes .", "question_id": 11097}
{"snippet": "turtle.register_shape(name)", "intent": "There are three different ways to call this function : With arguments `name`.", "question_id": 11098}
{"snippet": "turtle.register_shape(name, shape=None)", "intent": "There are three different ways to call this function : Add a turtle `shape` to TurtleScreen \u2019 s shapelist . With arguments `name`.", "question_id": 11099}
{"snippet": "turtle.addshape(name)", "intent": "There are three different ways to call this function : With arguments `name`.", "question_id": 11100}
{"snippet": "turtle.addshape(name, shape=None)", "intent": "There are three different ways to call this function : Add a turtle `shape` to TurtleScreen \u2019 s shapelist . With arguments `name`.", "question_id": 11101}
{"snippet": "turtle.turtles()", "intent": "Return the list of turtles on the screen .", "question_id": 11102}
{"snippet": "turtle.window_height()", "intent": "Return the height of the turtle window .", "question_id": 11103}
{"snippet": "turtle.window_width()", "intent": "Return the width of the turtle window .", "question_id": 11104}
{"snippet": "turtle.bye()", "intent": "Shut the turtlegraphics window .", "question_id": 11105}
{"snippet": "turtle.exitonclick()", "intent": "Bind bye ( ) method to mouse clicks on the Screen .", "question_id": 11106}
{"snippet": "turtle.setup()", "intent": "Set the size and position of the main window .", "question_id": 11107}
{"snippet": "turtle.setup(width=_CFG\"width\")", "intent": "Set the size and position of the main window . With arguments `width`.", "question_id": 11108}
{"snippet": "turtle.setup(height=_CFG\"height\")", "intent": "Set the size and position of the main window . With arguments `height`.", "question_id": 11109}
{"snippet": "turtle.setup(startx=_CFG\"leftright\")", "intent": "Set the size and position of the main window . With arguments `startx`.", "question_id": 11110}
{"snippet": "turtle.setup(starty=_CFG\"topbottom\")", "intent": "Set the size and position of the main window . With arguments `starty`.", "question_id": 11111}
{"snippet": "turtle.setup(width=_CFG\"width\", height=_CFG\"height\")", "intent": "Set the size and position of the main window . With arguments `width`, `height`.", "question_id": 11112}
{"snippet": "turtle.setup(width=_CFG\"width\", startx=_CFG\"leftright\")", "intent": "Set the size and position of the main window . With arguments `width`, `startx`.", "question_id": 11113}
{"snippet": "turtle.setup(width=_CFG\"width\", starty=_CFG\"topbottom\")", "intent": "Set the size and position of the main window . With arguments `width`, `starty`.", "question_id": 11114}
{"snippet": "turtle.setup(height=_CFG\"height\", startx=_CFG\"leftright\")", "intent": "Set the size and position of the main window . With arguments `height`, `startx`.", "question_id": 11115}
{"snippet": "turtle.setup(height=_CFG\"height\", starty=_CFG\"topbottom\")", "intent": "Set the size and position of the main window . With arguments `height`, `starty`.", "question_id": 11116}
{"snippet": "turtle.setup()", "intent": "Set the size and position of the main window .", "question_id": 11117}
{"snippet": "turtle.setup(width=_CFG\"width\")", "intent": "Set the size and position of the main window . With arguments `width`.", "question_id": 11118}
{"snippet": "turtle.setup(height=_CFG\"height\")", "intent": "Set the size and position of the main window . With arguments `height`.", "question_id": 11119}
{"snippet": "turtle.setup(startx=_CFG\"leftright\")", "intent": "Set the size and position of the main window . With arguments `startx`.", "question_id": 11120}
{"snippet": "turtle.setup(starty=_CFG\"topbottom\")", "intent": "Set the size and position of the main window . With arguments `starty`.", "question_id": 11121}
{"snippet": "turtle.setup(width=_CFG\"width\", height=_CFG\"height\")", "intent": "Set the size and position of the main window . With arguments `width`, `height`.", "question_id": 11122}
{"snippet": "turtle.setup(width=_CFG\"width\", startx=_CFG\"leftright\")", "intent": "Set the size and position of the main window . With arguments `width`, `startx`.", "question_id": 11123}
{"snippet": "turtle.setup(width=_CFG\"width\", starty=_CFG\"topbottom\")", "intent": "Set the size and position of the main window . With arguments `width`, `starty`.", "question_id": 11124}
{"snippet": "turtle.setup(height=_CFG\"height\", startx=_CFG\"leftright\")", "intent": "Set the size and position of the main window . With arguments `height`, `startx`.", "question_id": 11125}
{"snippet": "turtle.setup(height=_CFG\"height\", starty=_CFG\"topbottom\")", "intent": "Set the size and position of the main window . With arguments `height`, `starty`.", "question_id": 11126}
{"snippet": "turtle.setup()", "intent": "Set the size and position of the main window .", "question_id": 11127}
{"snippet": "turtle.setup(width=_CFG\"width\")", "intent": "Set the size and position of the main window . With arguments `width`.", "question_id": 11128}
{"snippet": "turtle.setup(height=_CFG\"height\")", "intent": "Set the size and position of the main window . With arguments `height`.", "question_id": 11129}
{"snippet": "turtle.setup(startx=_CFG\"leftright\")", "intent": "Set the size and position of the main window . With arguments `startx`.", "question_id": 11130}
{"snippet": "turtle.setup(starty=_CFG\"topbottom\")", "intent": "Set the size and position of the main window . With arguments `starty`.", "question_id": 11131}
{"snippet": "turtle.setup(width=_CFG\"width\", height=_CFG\"height\")", "intent": "Set the size and position of the main window . With arguments `width`, `height`.", "question_id": 11132}
{"snippet": "turtle.setup(width=_CFG\"width\", startx=_CFG\"leftright\")", "intent": "Set the size and position of the main window . With arguments `width`, `startx`.", "question_id": 11133}
{"snippet": "turtle.setup(width=_CFG\"width\", starty=_CFG\"topbottom\")", "intent": "Set the size and position of the main window . With arguments `width`, `starty`.", "question_id": 11134}
{"snippet": "turtle.setup(height=_CFG\"height\", startx=_CFG\"leftright\")", "intent": "Set the size and position of the main window . With arguments `height`, `startx`.", "question_id": 11135}
{"snippet": "turtle.setup(height=_CFG\"height\", starty=_CFG\"topbottom\")", "intent": "Set the size and position of the main window . With arguments `height`, `starty`.", "question_id": 11136}
{"snippet": "turtle.setup()", "intent": "Set the size and position of the main window .", "question_id": 11137}
{"snippet": "turtle.setup(width=_CFG\"width\")", "intent": "Set the size and position of the main window . With arguments `width`.", "question_id": 11138}
{"snippet": "turtle.setup(height=_CFG\"height\")", "intent": "Set the size and position of the main window . With arguments `height`.", "question_id": 11139}
{"snippet": "turtle.setup(startx=_CFG\"leftright\")", "intent": "Set the size and position of the main window . With arguments `startx`.", "question_id": 11140}
{"snippet": "turtle.setup(starty=_CFG\"topbottom\")", "intent": "Set the size and position of the main window . With arguments `starty`.", "question_id": 11141}
{"snippet": "turtle.setup(width=_CFG\"width\", height=_CFG\"height\")", "intent": "Set the size and position of the main window . With arguments `width`, `height`.", "question_id": 11142}
{"snippet": "turtle.setup(width=_CFG\"width\", startx=_CFG\"leftright\")", "intent": "Set the size and position of the main window . With arguments `width`, `startx`.", "question_id": 11143}
{"snippet": "turtle.setup(width=_CFG\"width\", starty=_CFG\"topbottom\")", "intent": "Set the size and position of the main window . With arguments `width`, `starty`.", "question_id": 11144}
{"snippet": "turtle.setup(height=_CFG\"height\", startx=_CFG\"leftright\")", "intent": "Set the size and position of the main window . With arguments `height`, `startx`.", "question_id": 11145}
{"snippet": "turtle.setup(height=_CFG\"height\", starty=_CFG\"topbottom\")", "intent": "Set the size and position of the main window . With arguments `height`, `starty`.", "question_id": 11146}
{"snippet": "turtle.setup()", "intent": "Set the size and position of the main window .", "question_id": 11147}
{"snippet": "turtle.setup(width=_CFG\"width\")", "intent": "Set the size and position of the main window . With arguments `width`.", "question_id": 11148}
{"snippet": "turtle.setup(height=_CFG\"height\")", "intent": "Set the size and position of the main window . With arguments `height`.", "question_id": 11149}
{"snippet": "turtle.setup(startx=_CFG\"leftright\")", "intent": "Set the size and position of the main window . With arguments `startx`.", "question_id": 11150}
{"snippet": "turtle.setup(starty=_CFG\"topbottom\")", "intent": "Set the size and position of the main window . With arguments `starty`.", "question_id": 11151}
{"snippet": "turtle.setup(width=_CFG\"width\", height=_CFG\"height\")", "intent": "Set the size and position of the main window . With arguments `width`, `height`.", "question_id": 11152}
{"snippet": "turtle.setup(width=_CFG\"width\", startx=_CFG\"leftright\")", "intent": "Set the size and position of the main window . With arguments `width`, `startx`.", "question_id": 11153}
{"snippet": "turtle.setup(width=_CFG\"width\", starty=_CFG\"topbottom\")", "intent": "Set the size and position of the main window . With arguments `width`, `starty`.", "question_id": 11154}
{"snippet": "turtle.setup(height=_CFG\"height\", startx=_CFG\"leftright\")", "intent": "Set the size and position of the main window . With arguments `height`, `startx`.", "question_id": 11155}
{"snippet": "turtle.setup(height=_CFG\"height\", starty=_CFG\"topbottom\")", "intent": "Set the size and position of the main window . With arguments `height`, `starty`.", "question_id": 11156}
{"snippet": "turtle.title(titlestring)", "intent": "Set title of turtle window to `titlestring` .", "question_id": 11157}
{"snippet": "turtle.RawTurtle(canvas)", "intent": "Create a turtle . With arguments `canvas`.", "question_id": 11158}
{"snippet": "turtle.RawPen(canvas)", "intent": "Create a turtle . With arguments `canvas`.", "question_id": 11159}
{"snippet": "turtle.Turtle", "intent": "Subclass of RawTurtle, has the same interface but draws on a default Screen object created automatically when needed for the first time.", "question_id": 11160}
{"snippet": "turtle.TurtleScreen(cv)", "intent": "Provides screen oriented methods like setbg ( ) etc . With arguments `cv`.", "question_id": 11161}
{"snippet": "turtle.Screen", "intent": "Subclass of TurtleScreen, with four methods added.", "question_id": 11162}
{"snippet": "turtle.ScrolledCanvas(master)", "intent": "Used by class Screen , which thus automatically provides a ScrolledCanvas as playground for the turtles . With arguments `master`.", "question_id": 11163}
{"snippet": "turtle.Shape(type_, data)", "intent": "Data structure modeling shapes . The pair ( `type_` , `data` ) must follow this specification :", "question_id": 11164}
{"snippet": "shape.addcomponent(poly, fill)", "intent": "Example : With arguments `poly`, `fill`.", "question_id": 11165}
{"snippet": "shape.addcomponent(poly, fill, outline=None)", "intent": "Example : With arguments `poly`, `fill`, `outline`.", "question_id": 11166}
{"snippet": "turtle.Vec2D(x, y)", "intent": "A two-dimensional vector class , used as a helper class for implementing turtle graphics . With arguments `x`, `y`.", "question_id": 11167}
{"snippet": "turtle.write_docstringdict()", "intent": "Create and write docstring-dictionary to a Python script with the given `filename` .", "question_id": 11168}
{"snippet": "turtle.write_docstringdict(filename=\"turtle_docstringdict\")", "intent": "Create and write docstring-dictionary to a Python script with the given `filename` .", "question_id": 11169}
{"snippet": "types.new_class(name)", "intent": "Creates a class object dynamically using the appropriate metaclass . The first three arguments are the components that make up a class definition header : the class `name` , the base classes ( in order ) , the keyword arguments ( such as metaclass ) .", "question_id": 11170}
{"snippet": "types.new_class(name, bases=())", "intent": "Creates a class object dynamically using the appropriate metaclass . The first three arguments are the components that make up a class definition header : the class `name` , the base classes ( in order ) , the keyword arguments ( such as metaclass ) . With arguments `bases`.", "question_id": 11171}
{"snippet": "types.new_class(name, kwds=None)", "intent": "Creates a class object dynamically using the appropriate metaclass . The first three arguments are the components that make up a class definition header : the class `name` , the base classes ( in order ) , the keyword arguments ( such as metaclass ) . With arguments `kwds`.", "question_id": 11172}
{"snippet": "types.new_class(name, exec_body=None)", "intent": "Creates a class object dynamically using the appropriate metaclass . The first three arguments are the components that make up a class definition header : the class `name` , the base classes ( in order ) , the keyword arguments ( such as metaclass ) . The `exec_body` argument is a callback that is used to populate the freshly created class namespace .", "question_id": 11173}
{"snippet": "types.new_class(name, bases=(), kwds=None)", "intent": "Creates a class object dynamically using the appropriate metaclass . The first three arguments are the components that make up a class definition header : the class `name` , the base classes ( in order ) , the keyword arguments ( such as metaclass ) . With arguments `bases`, `kwds`.", "question_id": 11174}
{"snippet": "types.new_class(name, bases=(), exec_body=None)", "intent": "Creates a class object dynamically using the appropriate metaclass . The first three arguments are the components that make up a class definition header : the class `name` , the base classes ( in order ) , the keyword arguments ( such as metaclass ) . The `exec_body` argument is a callback that is used to populate the freshly created class namespace . With arguments `bases`.", "question_id": 11175}
{"snippet": "types.new_class(name, kwds=None, exec_body=None)", "intent": "Creates a class object dynamically using the appropriate metaclass . The first three arguments are the components that make up a class definition header : the class `name` , the base classes ( in order ) , the keyword arguments ( such as metaclass ) . The `exec_body` argument is a callback that is used to populate the freshly created class namespace . With arguments `kwds`.", "question_id": 11176}
{"snippet": "types.new_class(name, bases=(), kwds=None, exec_body=None)", "intent": "Creates a class object dynamically using the appropriate metaclass . The first three arguments are the components that make up a class definition header : the class `name` , the base classes ( in order ) , the keyword arguments ( such as metaclass ) . The `exec_body` argument is a callback that is used to populate the freshly created class namespace . With arguments `bases`, `kwds`.", "question_id": 11177}
{"snippet": "types.prepare_class(name)", "intent": "Calculates the appropriate metaclass and creates the class namespace . The arguments are the components that make up a class definition header : the class `name` , the base classes ( in order ) and the keyword arguments ( such as metaclass ) .", "question_id": 11178}
{"snippet": "types.prepare_class(name, bases=())", "intent": "Calculates the appropriate metaclass and creates the class namespace . The arguments are the components that make up a class definition header : the class `name` , the base classes ( in order ) and the keyword arguments ( such as metaclass ) . With arguments `bases`.", "question_id": 11179}
{"snippet": "types.prepare_class(name, kwds=None)", "intent": "Calculates the appropriate metaclass and creates the class namespace . The arguments are the components that make up a class definition header : the class `name` , the base classes ( in order ) and the keyword arguments ( such as metaclass ) . The return value is a 3-tuple : metaclass , namespace , `kwds`", "question_id": 11180}
{"snippet": "types.prepare_class(name, bases=(), kwds=None)", "intent": "Calculates the appropriate metaclass and creates the class namespace . The arguments are the components that make up a class definition header : the class `name` , the base classes ( in order ) and the keyword arguments ( such as metaclass ) . The return value is a 3-tuple : metaclass , namespace , `kwds` With arguments `bases`.", "question_id": 11181}
{"snippet": "types.resolve_bases(bases)", "intent": "Resolve MRO entries dynamically as specified by PEP 560 . This function looks for items in `bases` that are not instances of type , and returns a tuple where each such object that has an __mro_entries__ method is replaced with an unpacked result of calling this method .", "question_id": 11182}
{"snippet": "types.FunctionType", "intent": "The type of user-defined functions and functions created by lambda  expressions.", "question_id": 11183}
{"snippet": "types.LambdaType", "intent": "The type of user-defined functions and functions created by lambda  expressions.", "question_id": 11184}
{"snippet": "types.GeneratorType", "intent": "The type of generator-iterator objects, created by generator functions.", "question_id": 11185}
{"snippet": "types.CoroutineType", "intent": "The type of coroutine objects, created by async def functions.", "question_id": 11186}
{"snippet": "types.AsyncGeneratorType", "intent": "The type of asynchronous generator-iterator objects, created by asynchronous generator functions.", "question_id": 11187}
{"snippet": "types.CodeType", "intent": "The type for code objects such as returned by compile().", "question_id": 11188}
{"snippet": "types.MethodType", "intent": "The type of methods of user-defined class instances.", "question_id": 11189}
{"snippet": "types.BuiltinFunctionType", "intent": "The type of built-in functions like len() or sys.exit(), and methods of built-in classes.", "question_id": 11190}
{"snippet": "types.BuiltinMethodType", "intent": "The type of built-in functions like len() or sys.exit(), and methods of built-in classes.", "question_id": 11191}
{"snippet": "types.WrapperDescriptorType", "intent": "The type of methods of some built-in data types and base classes such as object.__init__() or object.__lt__().", "question_id": 11192}
{"snippet": "types.MethodWrapperType", "intent": "The type of bound methods of some built-in data types and base classes.", "question_id": 11193}
{"snippet": "types.MethodDescriptorType", "intent": "The type of methods of some built-in data types such as str.join().", "question_id": 11194}
{"snippet": "types.ClassMethodDescriptorType", "intent": "The type of unbound class methods of some built-in data types such as dict.__dict__['fromkeys'].", "question_id": 11195}
{"snippet": "types.ModuleType(name)", "intent": "The type of modules . Constructor takes the `name` of the module to be created and optionally its docstring .", "question_id": 11196}
{"snippet": "types.ModuleType(name, doc=None)", "intent": "The type of modules . Constructor takes the `name` of the module to be created and optionally its docstring . With arguments `doc`.", "question_id": 11197}
{"snippet": "module_type.__doc__", "intent": "The docstring of the module.", "question_id": 11198}
{"snippet": "module_type.__loader__", "intent": "The loader which loaded the module.", "question_id": 11199}
{"snippet": "module_type.__name__", "intent": "The name of the module.", "question_id": 11200}
{"snippet": "module_type.__package__", "intent": "Which package a module belongs to.", "question_id": 11201}
{"snippet": "types.TracebackType(tb_next, tb_frame, tb_lasti, tb_lineno)", "intent": "The type of traceback objects such as found in sys.exc_info ( ) [ 2 ] . With arguments `tb_next`, `tb_frame`, `tb_lasti`, `tb_lineno`.", "question_id": 11202}
{"snippet": "types.FrameType", "intent": "The type of frame objects such as found in tb.tb_frame if tb is a traceback object.", "question_id": 11203}
{"snippet": "types.GetSetDescriptorType", "intent": "The type of objects defined in extension modules with PyGetSetDef, such as FrameType.f_locals or array.array.typecode.", "question_id": 11204}
{"snippet": "types.MemberDescriptorType", "intent": "The type of objects defined in extension modules with PyMemberDef, such as datetime.timedelta.days.", "question_id": 11205}
{"snippet": "types.MappingProxyType(mapping)", "intent": "Read-only proxy of a `mapping` .", "question_id": 11206}
{"snippet": "key in proxy", "intent": "Return True if the underlying mapping has a key key, else False.", "question_id": 11207}
{"snippet": "proxy[key]", "intent": "Return the item of the underlying mapping with key key.", "question_id": 11208}
{"snippet": "iter(proxy)", "intent": "Return an iterator over the keys of the underlying mapping . With arguments `proxy`.", "question_id": 11209}
{"snippet": "len(proxy)", "intent": "Return the number of items in the underlying mapping . With arguments `proxy`.", "question_id": 11210}
{"snippet": "mapping_proxy_type.copy()", "intent": "Return a shallow copy of the underlying mapping .", "question_id": 11211}
{"snippet": "mapping_proxy_type.get(key, default)", "intent": "Return the value for `key` if key is in the underlying mapping , else `default` .", "question_id": 11212}
{"snippet": "mapping_proxy_type.get(key)", "intent": "Return the value for `key` if key is in the underlying mapping , else `default` .", "question_id": 11213}
{"snippet": "mapping_proxy_type.items()", "intent": "Return a new view of the underlying mapping \u2019 s items ( ( key , value ) pairs ) .", "question_id": 11214}
{"snippet": "mapping_proxy_type.keys()", "intent": "Return a new view of the underlying mapping \u2019 s keys .", "question_id": 11215}
{"snippet": "mapping_proxy_type.values()", "intent": "Return a new view of the underlying mapping \u2019 s values .", "question_id": 11216}
{"snippet": "types.SimpleNamespace", "intent": "A simple object subclass that provides attribute access to its namespace, as well as a meaningful repr.", "question_id": 11217}
{"snippet": "types.DynamicClassAttribute()", "intent": "Route attribute access on a class to __getattr__ .", "question_id": 11218}
{"snippet": "types.DynamicClassAttribute(fget=None)", "intent": "Route attribute access on a class to __getattr__ . With arguments `fget`.", "question_id": 11219}
{"snippet": "types.DynamicClassAttribute(fset=None)", "intent": "Route attribute access on a class to __getattr__ . With arguments `fset`.", "question_id": 11220}
{"snippet": "types.DynamicClassAttribute(fdel=None)", "intent": "Route attribute access on a class to __getattr__ . With arguments `fdel`.", "question_id": 11221}
{"snippet": "types.DynamicClassAttribute(doc=None)", "intent": "Route attribute access on a class to __getattr__ . With arguments `doc`.", "question_id": 11222}
{"snippet": "types.DynamicClassAttribute(fget=None, fset=None)", "intent": "Route attribute access on a class to __getattr__ . With arguments `fget`, `fset`.", "question_id": 11223}
{"snippet": "types.DynamicClassAttribute(fget=None, fdel=None)", "intent": "Route attribute access on a class to __getattr__ . With arguments `fget`, `fdel`.", "question_id": 11224}
{"snippet": "types.DynamicClassAttribute(fget=None, doc=None)", "intent": "Route attribute access on a class to __getattr__ . With arguments `fget`, `doc`.", "question_id": 11225}
{"snippet": "types.DynamicClassAttribute(fset=None, fdel=None)", "intent": "Route attribute access on a class to __getattr__ . With arguments `fset`, `fdel`.", "question_id": 11226}
{"snippet": "types.DynamicClassAttribute(fset=None, doc=None)", "intent": "Route attribute access on a class to __getattr__ . With arguments `fset`, `doc`.", "question_id": 11227}
{"snippet": "types.coroutine(gen_func)", "intent": "This function transforms a generator function into a coroutine function which returns a generator-based coroutine . If `gen_func` is a generator function , it will be modified in-place .", "question_id": 11228}
{"snippet": "typing.TypeVar", "intent": "Type variable.", "question_id": 11229}
{"snippet": "typing.Generic", "intent": "Abstract base class for generic types.", "question_id": 11230}
{"snippet": "typing.Type(GenericCT_co)", "intent": "A variable annotated with C may accept a value of type C. In contrast , a variable annotated with Type [ C ] may accept values that are classes themselves \u2013 specifically , it will accept the class object of C. For example : With arguments `GenericCT_co`.", "question_id": 11231}
{"snippet": "typing.Type()", "intent": "A variable annotated with C may accept a value of type C. In contrast , a variable annotated with Type [ C ] may accept values that are classes themselves \u2013 specifically , it will accept the class object of C. For example :", "question_id": 11232}
{"snippet": "typing.Iterable(GenericT_co)", "intent": "A generic version of collections.abc.Iterable . With arguments `GenericT_co`.", "question_id": 11233}
{"snippet": "typing.Iterable()", "intent": "A generic version of collections.abc.Iterable .", "question_id": 11234}
{"snippet": "typing.Iterator(IterableT_co)", "intent": "A generic version of collections.abc.Iterator . With arguments `IterableT_co`.", "question_id": 11235}
{"snippet": "typing.Iterator()", "intent": "A generic version of collections.abc.Iterator .", "question_id": 11236}
{"snippet": "typing.Reversible(IterableT_co)", "intent": "A generic version of collections.abc.Reversible . With arguments `IterableT_co`.", "question_id": 11237}
{"snippet": "typing.Reversible()", "intent": "A generic version of collections.abc.Reversible .", "question_id": 11238}
{"snippet": "typing.SupportsInt", "intent": "An ABC with one abstract method __int__.", "question_id": 11239}
{"snippet": "typing.SupportsFloat", "intent": "An ABC with one abstract method __float__.", "question_id": 11240}
{"snippet": "typing.SupportsComplex", "intent": "An ABC with one abstract method __complex__.", "question_id": 11241}
{"snippet": "typing.SupportsBytes", "intent": "An ABC with one abstract method __bytes__.", "question_id": 11242}
{"snippet": "typing.SupportsAbs", "intent": "An ABC with one abstract method __abs__ that is covariant in its return type.", "question_id": 11243}
{"snippet": "typing.SupportsRound", "intent": "An ABC with one abstract method __round__ that is covariant in its return type.", "question_id": 11244}
{"snippet": "typing.Container(GenericT_co)", "intent": "A generic version of collections.abc.Container . With arguments `GenericT_co`.", "question_id": 11245}
{"snippet": "typing.Container()", "intent": "A generic version of collections.abc.Container .", "question_id": 11246}
{"snippet": "typing.Hashable", "intent": "An alias to collections.abc.Hashable", "question_id": 11247}
{"snippet": "typing.Sized", "intent": "An alias to collections.abc.Sized", "question_id": 11248}
{"snippet": "typing.Collection(Sized, IterableT_co, ContainerT_co)", "intent": "A generic version of collections.abc.Collection With arguments `Sized`, `IterableT_co`, `ContainerT_co`.", "question_id": 11249}
{"snippet": "typing.Collection(Sized, IterableT_co)", "intent": "A generic version of collections.abc.Collection With arguments `Sized`, `IterableT_co`.", "question_id": 11250}
{"snippet": "typing.Collection(Sized)", "intent": "A generic version of collections.abc.Collection With arguments `Sized`.", "question_id": 11251}
{"snippet": "typing.AbstractSet(Sized, CollectionT_co)", "intent": "A generic version of collections.abc.Set . With arguments `Sized`, `CollectionT_co`.", "question_id": 11252}
{"snippet": "typing.AbstractSet(Sized)", "intent": "A generic version of collections.abc.Set . With arguments `Sized`.", "question_id": 11253}
{"snippet": "typing.MutableSet(AbstractSetT)", "intent": "A generic version of collections.abc.MutableSet . With arguments `AbstractSetT`.", "question_id": 11254}
{"snippet": "typing.MutableSet()", "intent": "A generic version of collections.abc.MutableSet .", "question_id": 11255}
{"snippet": "typing.Mapping(Sized, CollectionKT, GenericVT_co)", "intent": "A generic version of collections.abc.Mapping . With arguments `Sized`, `CollectionKT`, `GenericVT_co`.", "question_id": 11256}
{"snippet": "typing.Mapping(Sized, CollectionKT)", "intent": "A generic version of collections.abc.Mapping . With arguments `Sized`, `CollectionKT`.", "question_id": 11257}
{"snippet": "typing.Mapping(Sized)", "intent": "A generic version of collections.abc.Mapping . With arguments `Sized`.", "question_id": 11258}
{"snippet": "typing.MutableMapping(MappingKT, VT)", "intent": "A generic version of collections.abc.MutableMapping . With arguments `MappingKT`, `VT`.", "question_id": 11259}
{"snippet": "typing.MutableMapping(MappingKT)", "intent": "A generic version of collections.abc.MutableMapping . With arguments `MappingKT`.", "question_id": 11260}
{"snippet": "typing.Sequence(ReversibleT_co, CollectionT_co)", "intent": "A generic version of collections.abc.Sequence . With arguments `ReversibleT_co`, `CollectionT_co`.", "question_id": 11261}
{"snippet": "typing.Sequence(ReversibleT_co)", "intent": "A generic version of collections.abc.Sequence . With arguments `ReversibleT_co`.", "question_id": 11262}
{"snippet": "typing.Sequence()", "intent": "A generic version of collections.abc.Sequence .", "question_id": 11263}
{"snippet": "typing.MutableSequence(SequenceT)", "intent": "A generic version of collections.abc.MutableSequence . With arguments `SequenceT`.", "question_id": 11264}
{"snippet": "typing.MutableSequence()", "intent": "A generic version of collections.abc.MutableSequence .", "question_id": 11265}
{"snippet": "typing.ByteString(Sequenceint)", "intent": "A generic version of collections.abc.ByteString . With arguments `Sequenceint`.", "question_id": 11266}
{"snippet": "typing.ByteString()", "intent": "A generic version of collections.abc.ByteString .", "question_id": 11267}
{"snippet": "typing.Deque(deque, MutableSequenceT)", "intent": "A generic version of collections.deque . With arguments `deque`, `MutableSequenceT`.", "question_id": 11268}
{"snippet": "typing.Deque(deque)", "intent": "A generic version of collections.deque . With arguments `deque`.", "question_id": 11269}
{"snippet": "typing.List(list, MutableSequenceT)", "intent": "Generic version of `list` . With arguments `MutableSequenceT`.", "question_id": 11270}
{"snippet": "typing.List(list)", "intent": "Generic version of `list` .", "question_id": 11271}
{"snippet": "typing.Set(set, MutableSetT)", "intent": "A generic version of builtins.set . With arguments `set`, `MutableSetT`.", "question_id": 11272}
{"snippet": "typing.Set(set)", "intent": "A generic version of builtins.set . With arguments `set`.", "question_id": 11273}
{"snippet": "typing.FrozenSet(frozenset, AbstractSetT_co)", "intent": "A generic version of builtins.frozenset . With arguments `frozenset`, `AbstractSetT_co`.", "question_id": 11274}
{"snippet": "typing.FrozenSet(frozenset)", "intent": "A generic version of builtins.frozenset . With arguments `frozenset`.", "question_id": 11275}
{"snippet": "typing.MappingView(Sized, IterableT_co)", "intent": "A generic version of collections.abc.MappingView . With arguments `Sized`, `IterableT_co`.", "question_id": 11276}
{"snippet": "typing.MappingView(Sized)", "intent": "A generic version of collections.abc.MappingView . With arguments `Sized`.", "question_id": 11277}
{"snippet": "typing.KeysView(MappingViewKT_co, AbstractSetKT_co)", "intent": "A generic version of collections.abc.KeysView . With arguments `MappingViewKT_co`, `AbstractSetKT_co`.", "question_id": 11278}
{"snippet": "typing.KeysView(MappingViewKT_co)", "intent": "A generic version of collections.abc.KeysView . With arguments `MappingViewKT_co`.", "question_id": 11279}
{"snippet": "typing.KeysView()", "intent": "A generic version of collections.abc.KeysView .", "question_id": 11280}
{"snippet": "typing.ItemsView(MappingView, GenericKT_co, VT_co)", "intent": "A generic version of collections.abc.ItemsView . With arguments `MappingView`, `GenericKT_co`, `VT_co`.", "question_id": 11281}
{"snippet": "typing.ItemsView(MappingView, GenericKT_co)", "intent": "A generic version of collections.abc.ItemsView . With arguments `MappingView`, `GenericKT_co`.", "question_id": 11282}
{"snippet": "typing.ValuesView(MappingViewVT_co)", "intent": "A generic version of collections.abc.ValuesView . With arguments `MappingViewVT_co`.", "question_id": 11283}
{"snippet": "typing.ValuesView()", "intent": "A generic version of collections.abc.ValuesView .", "question_id": 11284}
{"snippet": "typing.Awaitable(GenericT_co)", "intent": "A generic version of collections.abc.Awaitable . With arguments `GenericT_co`.", "question_id": 11285}
{"snippet": "typing.Awaitable()", "intent": "A generic version of collections.abc.Awaitable .", "question_id": 11286}
{"snippet": "typing.Coroutine(AwaitableV_co, GenericT_co T_contra, V_co)", "intent": "A generic version of collections.abc.Coroutine . With arguments `AwaitableV_co`, `GenericT_co T_contra`, `V_co`.", "question_id": 11287}
{"snippet": "typing.Coroutine(AwaitableV_co, GenericT_co T_contra)", "intent": "A generic version of collections.abc.Coroutine . With arguments `AwaitableV_co`, `GenericT_co T_contra`.", "question_id": 11288}
{"snippet": "typing.Coroutine(AwaitableV_co)", "intent": "A generic version of collections.abc.Coroutine . With arguments `AwaitableV_co`.", "question_id": 11289}
{"snippet": "typing.AsyncIterable(GenericT_co)", "intent": "A generic version of collections.abc.AsyncIterable . With arguments `GenericT_co`.", "question_id": 11290}
{"snippet": "typing.AsyncIterable()", "intent": "A generic version of collections.abc.AsyncIterable .", "question_id": 11291}
{"snippet": "typing.AsyncIterator(AsyncIterableT_co)", "intent": "A generic version of collections.abc.AsyncIterator . With arguments `AsyncIterableT_co`.", "question_id": 11292}
{"snippet": "typing.AsyncIterator()", "intent": "A generic version of collections.abc.AsyncIterator .", "question_id": 11293}
{"snippet": "typing.ContextManager(GenericT_co)", "intent": "A generic version of contextlib.AbstractContextManager . With arguments `GenericT_co`.", "question_id": 11294}
{"snippet": "typing.ContextManager()", "intent": "A generic version of contextlib.AbstractContextManager .", "question_id": 11295}
{"snippet": "typing.AsyncContextManager(GenericT_co)", "intent": "A generic version of contextlib.AbstractAsyncContextManager . With arguments `GenericT_co`.", "question_id": 11296}
{"snippet": "typing.AsyncContextManager()", "intent": "A generic version of contextlib.AbstractAsyncContextManager .", "question_id": 11297}
{"snippet": "typing.Dict(dict, MutableMappingKT, VT)", "intent": "A generic version of `dict` . With arguments `MutableMappingKT`, `VT`.", "question_id": 11298}
{"snippet": "typing.Dict(dict, MutableMappingKT)", "intent": "A generic version of `dict` . With arguments `MutableMappingKT`.", "question_id": 11299}
{"snippet": "typing.DefaultDict(collections.defaultdict, MutableMappingKT, VT)", "intent": "A generic version of `collections.defaultdict` . With arguments `MutableMappingKT`, `VT`.", "question_id": 11300}
{"snippet": "typing.DefaultDict(collections.defaultdict, MutableMappingKT)", "intent": "A generic version of `collections.defaultdict` . With arguments `MutableMappingKT`.", "question_id": 11301}
{"snippet": "typing.OrderedDict(collections.OrderedDict, MutableMappingKT, VT)", "intent": "A generic version of `collections.OrderedDict` . With arguments `MutableMappingKT`, `VT`.", "question_id": 11302}
{"snippet": "typing.OrderedDict(collections.OrderedDict, MutableMappingKT)", "intent": "A generic version of `collections.OrderedDict` . With arguments `MutableMappingKT`.", "question_id": 11303}
{"snippet": "typing.Counter(collections.Counter, DictT, int)", "intent": "A generic version of `collections.Counter` . With arguments `DictT`, `int`.", "question_id": 11304}
{"snippet": "typing.Counter(collections.Counter, DictT)", "intent": "A generic version of `collections.Counter` . With arguments `DictT`.", "question_id": 11305}
{"snippet": "typing.ChainMap(collections.ChainMap, MutableMappingKT, VT)", "intent": "A generic version of `collections.ChainMap` . With arguments `MutableMappingKT`, `VT`.", "question_id": 11306}
{"snippet": "typing.ChainMap(collections.ChainMap, MutableMappingKT)", "intent": "A generic version of `collections.ChainMap` . With arguments `MutableMappingKT`.", "question_id": 11307}
{"snippet": "typing.Generator(IteratorT_co, GenericT_co, T_contra, V_co)", "intent": "A generator can be annotated by the generic type Generator [ YieldType , SendType , ReturnType ] . With arguments `IteratorT_co`, `GenericT_co`, `T_contra`, `V_co`.", "question_id": 11308}
{"snippet": "typing.Generator(IteratorT_co, GenericT_co, T_contra)", "intent": "A generator can be annotated by the generic type Generator [ YieldType , SendType , ReturnType ] . With arguments `IteratorT_co`, `GenericT_co`, `T_contra`.", "question_id": 11309}
{"snippet": "typing.Generator(IteratorT_co, GenericT_co)", "intent": "A generator can be annotated by the generic type Generator [ YieldType , SendType , ReturnType ] . With arguments `IteratorT_co`, `GenericT_co`.", "question_id": 11310}
{"snippet": "typing.AsyncGenerator(AsyncIteratorT_co, GenericT_co, T_contra)", "intent": "An async generator can be annotated by the generic type AsyncGenerator [ YieldType , SendType ] . With arguments `AsyncIteratorT_co`, `GenericT_co`, `T_contra`.", "question_id": 11311}
{"snippet": "typing.AsyncGenerator(AsyncIteratorT_co, GenericT_co)", "intent": "An async generator can be annotated by the generic type AsyncGenerator [ YieldType , SendType ] . With arguments `AsyncIteratorT_co`, `GenericT_co`.", "question_id": 11312}
{"snippet": "typing.AsyncGenerator(AsyncIteratorT_co)", "intent": "An async generator can be annotated by the generic type AsyncGenerator [ YieldType , SendType ] . With arguments `AsyncIteratorT_co`.", "question_id": 11313}
{"snippet": "typing.Text", "intent": "Text is an alias for str.", "question_id": 11314}
{"snippet": "typing.IO", "intent": "Generic type IO[AnyStr] and its subclasses TextIO(IO[str]) and BinaryIO(IO[bytes]) represent the types of I/O streams such as returned by open().", "question_id": 11315}
{"snippet": "typing.TextIO", "intent": "Generic type IO[AnyStr] and its subclasses TextIO(IO[str]) and BinaryIO(IO[bytes]) represent the types of I/O streams such as returned by open().", "question_id": 11316}
{"snippet": "typing.BinaryIO", "intent": "Generic type IO[AnyStr] and its subclasses TextIO(IO[str]) and BinaryIO(IO[bytes]) represent the types of I/O streams such as returned by open().", "question_id": 11317}
{"snippet": "typing.Pattern", "intent": "These type aliases correspond to the return types from re.compile() and re.match().", "question_id": 11318}
{"snippet": "typing.Match", "intent": "These type aliases correspond to the return types from re.compile() and re.match().", "question_id": 11319}
{"snippet": "typing.NamedTuple", "intent": "Typed version of collections.namedtuple().", "question_id": 11320}
{"snippet": "typing.ForwardRef", "intent": "A class used for internal typing representation of string forward references.", "question_id": 11321}
{"snippet": "typing.NewType(typ)", "intent": "A helper function to indicate a distinct types to a typechecker , see NewType . With arguments `typ`.", "question_id": 11322}
{"snippet": "typing.cast(typ, val)", "intent": "Cast a value to a type . With arguments `typ`, `val`.", "question_id": 11323}
{"snippet": "typing.get_type_hints(obj, globals, locals)", "intent": "Return a dictionary containing type hints for a function , method , module or class object . In addition , forward references encoded as string literals are handled by evaluating them in `globals` and `locals` namespaces . With arguments `obj`.", "question_id": 11324}
{"snippet": "typing.get_type_hints(obj, globals)", "intent": "Return a dictionary containing type hints for a function , method , module or class object . In addition , forward references encoded as string literals are handled by evaluating them in `globals` and `locals` namespaces . With arguments `obj`.", "question_id": 11325}
{"snippet": "typing.get_type_hints(obj)", "intent": "Return a dictionary containing type hints for a function , method , module or class object . With arguments `obj`.", "question_id": 11326}
{"snippet": "@typing.overload", "intent": "The @overload decorator allows describing functions and methods that support multiple different combinations of argument types.", "question_id": 11327}
{"snippet": "@typing.no_type_check", "intent": "Decorator to indicate that annotations are not type hints.", "question_id": 11328}
{"snippet": "@typing.no_type_check_decorator", "intent": "Decorator to give another decorator the no_type_check() effect.", "question_id": 11329}
{"snippet": "@typing.type_check_only", "intent": "Decorator to mark a class or function to be unavailable at runtime.", "question_id": 11330}
{"snippet": "typing.Any", "intent": "Special type indicating an unconstrained type.", "question_id": 11331}
{"snippet": "typing.NoReturn", "intent": "Special type indicating that a function never returns.", "question_id": 11332}
{"snippet": "typing.Union", "intent": "Union type; Union[X, Y] means either X or Y.", "question_id": 11333}
{"snippet": "typing.Optional", "intent": "Optional type.", "question_id": 11334}
{"snippet": "typing.Tuple", "intent": "Tuple type; Tuple[X, Y] is the type of a tuple of two items with the first item of type X and the second of type Y.", "question_id": 11335}
{"snippet": "typing.Callable", "intent": "Callable type; Callable[[int], str] is a function of (int) -> str.", "question_id": 11336}
{"snippet": "typing.ClassVar", "intent": "Special type construct to mark class variables.", "question_id": 11337}
{"snippet": "typing.AnyStr", "intent": "AnyStr is a type variable defined as AnyStr = TypeVar('AnyStr', str, bytes).", "question_id": 11338}
{"snippet": "typing.TYPE_CHECKING", "intent": "A special constant that is assumed to be True by 3rd party static type checkers.", "question_id": 11339}
{"snippet": "unicodedata.lookup(name)", "intent": "Look up character by `name` .", "question_id": 11340}
{"snippet": "unicodedata.name(chr, default)", "intent": "Returns the name assigned to the character `chr` as a string . If no name is defined , `default` is returned , or , if not given , ValueError is raised .", "question_id": 11341}
{"snippet": "unicodedata.name(chr)", "intent": "Returns the name assigned to the character `chr` as a string .", "question_id": 11342}
{"snippet": "unicodedata.decimal(chr, default)", "intent": "Returns the decimal value assigned to the character `chr` as integer . If no such value is defined , `default` is returned , or , if not given , ValueError is raised .", "question_id": 11343}
{"snippet": "unicodedata.decimal(chr)", "intent": "Returns the decimal value assigned to the character `chr` as integer .", "question_id": 11344}
{"snippet": "unicodedata.digit(chr, default)", "intent": "Returns the digit value assigned to the character `chr` as integer . If no such value is defined , `default` is returned , or , if not given , ValueError is raised .", "question_id": 11345}
{"snippet": "unicodedata.digit(chr)", "intent": "Returns the digit value assigned to the character `chr` as integer .", "question_id": 11346}
{"snippet": "unicodedata.numeric(chr, default)", "intent": "Returns the numeric value assigned to the character `chr` as float . If no such value is defined , `default` is returned , or , if not given , ValueError is raised .", "question_id": 11347}
{"snippet": "unicodedata.numeric(chr)", "intent": "Returns the numeric value assigned to the character `chr` as float .", "question_id": 11348}
{"snippet": "unicodedata.category(chr)", "intent": "Returns the general category assigned to the character `chr` as string .", "question_id": 11349}
{"snippet": "unicodedata.bidirectional(chr)", "intent": "Returns the bidirectional class assigned to the character `chr` as string .", "question_id": 11350}
{"snippet": "unicodedata.combining(chr)", "intent": "Returns the canonical combining class assigned to the character `chr` as integer .", "question_id": 11351}
{"snippet": "unicodedata.east_asian_width(chr)", "intent": "Returns the east asian width assigned to the character `chr` as string .", "question_id": 11352}
{"snippet": "unicodedata.mirrored(chr)", "intent": "Returns the mirrored property assigned to the character `chr` as integer .", "question_id": 11353}
{"snippet": "unicodedata.decomposition(chr)", "intent": "Returns the character decomposition mapping assigned to the character `chr` as string .", "question_id": 11354}
{"snippet": "unicodedata.normalize(form, unistr)", "intent": "Return the normal `form` form for the Unicode string `unistr` .", "question_id": 11355}
{"snippet": "unicodedata.unidata_version", "intent": "The version of the Unicode database used in this module.", "question_id": 11356}
{"snippet": "unicodedata.ucd_3_2_0", "intent": "This is an object that has the same methods as the entire module, but uses the Unicode database version 3.2 instead, for applications that require this specific version of the Unicode database (such as IDNA).", "question_id": 11357}
{"snippet": "@unittest.skip(reason)", "intent": "Unconditionally skip the decorated test . `reason` should describe why the test is being skipped .", "question_id": 11358}
{"snippet": "@unittest.skipIf(condition, reason)", "intent": "Skip the decorated test if `condition` is true . With arguments `reason`.", "question_id": 11359}
{"snippet": "@unittest.skipUnless(condition, reason)", "intent": "Skip the decorated test unless `condition` is true . With arguments `reason`.", "question_id": 11360}
{"snippet": "@unittest.expectedFailure", "intent": "Mark the test as an expected failure.", "question_id": 11361}
{"snippet": "unittest.SkipTest(reason)", "intent": "This exception is raised to skip a test . With arguments `reason`.", "question_id": 11362}
{"snippet": "unittest.TestCase()", "intent": "Instances of the TestCase class represent the logical test units in the unittest universe .", "question_id": 11363}
{"snippet": "unittest.TestCase(methodName='runTest')", "intent": "Instances of the TestCase class represent the logical test units in the unittest universe . Each instance of TestCase will run a single base method : the method named `methodName` .", "question_id": 11364}
{"snippet": "test_case.setUp()", "intent": "Method called to prepare the test fixture .", "question_id": 11365}
{"snippet": "test_case.tearDown()", "intent": "Method called immediately after the test method has been called and the result recorded .", "question_id": 11366}
{"snippet": "test_case.setUpClass()", "intent": "A class method called before tests in an individual class are run .", "question_id": 11367}
{"snippet": "test_case.tearDownClass()", "intent": "A class method called after tests in an individual class have run .", "question_id": 11368}
{"snippet": "test_case.run()", "intent": "Run the test , collecting the `result` into the TestResult object passed as result .", "question_id": 11369}
{"snippet": "test_case.run(result=None)", "intent": "Run the test , collecting the `result` into the TestResult object passed as result .", "question_id": 11370}
{"snippet": "test_case.skipTest(reason)", "intent": "Calling this during a test method or setUp ( ) skips the current test . With arguments `reason`.", "question_id": 11371}
{"snippet": "test_case.subTest(**params)", "intent": "Return a context manager which executes the enclosed code block as a subtest . With arguments `**params`.", "question_id": 11372}
{"snippet": "test_case.subTest(**params, msg=None)", "intent": "Return a context manager which executes the enclosed code block as a subtest . `msg` and params are optional , arbitrary values which are displayed whenever a subtest fails , allowing you to identify them clearly . With arguments `**params`.", "question_id": 11373}
{"snippet": "test_case.debug()", "intent": "Run the test without collecting the result .", "question_id": 11374}
{"snippet": "test_case.assertEqual(first, second)", "intent": "Test that `first` and `second` are equal .", "question_id": 11375}
{"snippet": "test_case.assertEqual(first, second, msg=None)", "intent": "Test that `first` and `second` are equal . With arguments `msg`.", "question_id": 11376}
{"snippet": "test_case.assertNotEqual(first, second)", "intent": "Test that `first` and `second` are not equal .", "question_id": 11377}
{"snippet": "test_case.assertNotEqual(first, second, msg=None)", "intent": "Test that `first` and `second` are not equal . With arguments `msg`.", "question_id": 11378}
{"snippet": "test_case.assertTrue(expr)", "intent": "Test that `expr` is true ( or false ) .", "question_id": 11379}
{"snippet": "test_case.assertTrue(expr, msg=None)", "intent": "Test that `expr` is true ( or false ) . With arguments `msg`.", "question_id": 11380}
{"snippet": "test_case.assertFalse(expr)", "intent": "Test that `expr` is true ( or false ) .", "question_id": 11381}
{"snippet": "test_case.assertFalse(expr, msg=None)", "intent": "Test that `expr` is true ( or false ) . With arguments `msg`.", "question_id": 11382}
{"snippet": "test_case.assertIs(first, second)", "intent": "Test that `first` and `second` evaluate ( or don \u2019 t evaluate ) to the same object .", "question_id": 11383}
{"snippet": "test_case.assertIs(first, second, msg=None)", "intent": "Test that `first` and `second` evaluate ( or don \u2019 t evaluate ) to the same object . With arguments `msg`.", "question_id": 11384}
{"snippet": "test_case.assertIsNot(first, second)", "intent": "Test that `first` and `second` evaluate ( or don \u2019 t evaluate ) to the same object .", "question_id": 11385}
{"snippet": "test_case.assertIsNot(first, second, msg=None)", "intent": "Test that `first` and `second` evaluate ( or don \u2019 t evaluate ) to the same object . With arguments `msg`.", "question_id": 11386}
{"snippet": "test_case.assertIsNone(expr)", "intent": "Test that `expr` is ( or is not ) None .", "question_id": 11387}
{"snippet": "test_case.assertIsNone(expr, msg=None)", "intent": "Test that `expr` is ( or is not ) None . With arguments `msg`.", "question_id": 11388}
{"snippet": "test_case.assertIsNotNone(expr)", "intent": "Test that `expr` is ( or is not ) None .", "question_id": 11389}
{"snippet": "test_case.assertIsNotNone(expr, msg=None)", "intent": "Test that `expr` is ( or is not ) None . With arguments `msg`.", "question_id": 11390}
{"snippet": "test_case.assertIn(first, second)", "intent": "Test that `first` is ( or is not ) in `second` .", "question_id": 11391}
{"snippet": "test_case.assertIn(first, second, msg=None)", "intent": "Test that `first` is ( or is not ) in `second` . With arguments `msg`.", "question_id": 11392}
{"snippet": "test_case.assertNotIn(first, second)", "intent": "Test that `first` is ( or is not ) in `second` .", "question_id": 11393}
{"snippet": "test_case.assertNotIn(first, second, msg=None)", "intent": "Test that `first` is ( or is not ) in `second` . With arguments `msg`.", "question_id": 11394}
{"snippet": "test_case.assertIsInstance(obj, cls)", "intent": "Test that `obj` is ( or is not ) an instance of `cls` ( which can be a class or a tuple of classes , as supported by isinstance ( ) ) .", "question_id": 11395}
{"snippet": "test_case.assertIsInstance(obj, cls, msg=None)", "intent": "Test that `obj` is ( or is not ) an instance of `cls` ( which can be a class or a tuple of classes , as supported by isinstance ( ) ) . With arguments `msg`.", "question_id": 11396}
{"snippet": "test_case.assertNotIsInstance(obj, cls)", "intent": "Test that `obj` is ( or is not ) an instance of `cls` ( which can be a class or a tuple of classes , as supported by isinstance ( ) ) .", "question_id": 11397}
{"snippet": "test_case.assertNotIsInstance(obj, cls, msg=None)", "intent": "Test that `obj` is ( or is not ) an instance of `cls` ( which can be a class or a tuple of classes , as supported by isinstance ( ) ) . With arguments `msg`.", "question_id": 11398}
{"snippet": "test_case.assertRaises(exception, callable, *args, **kwds)", "intent": "Test that an `exception` is raised when `callable` is called with any positional or keyword arguments that are also passed to assertRaises ( ) . With arguments `*args`, `**kwds`.", "question_id": 11399}
{"snippet": "test_case.assertRaises(exception)", "intent": "Test that an `exception` is raised when callable is called with any positional or keyword arguments that are also passed to assertRaises ( ) .", "question_id": 11400}
{"snippet": "test_case.assertRaises(exception, msg=None)", "intent": "Test that an `exception` is raised when callable is called with any positional or keyword arguments that are also passed to assertRaises ( ) . If only the exception and possibly the `msg` arguments are given , return a context manager so that the code under test can be written inline rather than as a function :", "question_id": 11401}
{"snippet": "test_case.assertRaisesRegex(exception, regex, callable, *args, **kwds)", "intent": "Like assertRaises ( ) but also tests that `regex` matches on the string representation of the raised `exception` . With arguments `callable`, `*args`, `**kwds`.", "question_id": 11402}
{"snippet": "test_case.assertRaisesRegex(exception, regex)", "intent": "Like assertRaises ( ) but also tests that `regex` matches on the string representation of the raised `exception` .", "question_id": 11403}
{"snippet": "test_case.assertRaisesRegex(exception, regex, msg=None)", "intent": "Like assertRaises ( ) but also tests that `regex` matches on the string representation of the raised `exception` . With arguments `msg`.", "question_id": 11404}
{"snippet": "test_case.assertWarns(warning, callable, *args, **kwds)", "intent": "Test that a `warning` is triggered when `callable` is called with any positional or keyword arguments that are also passed to assertWarns ( ) . With arguments `*args`, `**kwds`.", "question_id": 11405}
{"snippet": "test_case.assertWarns(warning)", "intent": "Test that a `warning` is triggered when callable is called with any positional or keyword arguments that are also passed to assertWarns ( ) .", "question_id": 11406}
{"snippet": "test_case.assertWarns(warning, msg=None)", "intent": "Test that a `warning` is triggered when callable is called with any positional or keyword arguments that are also passed to assertWarns ( ) . If only the warning and possibly the `msg` arguments are given , return a context manager so that the code under test can be written inline rather than as a function :", "question_id": 11407}
{"snippet": "test_case.assertWarnsRegex(warning, regex, callable, *args, **kwds)", "intent": "Like assertWarns ( ) but also tests that `regex` matches on the message of the triggered `warning` . With arguments `callable`, `*args`, `**kwds`.", "question_id": 11408}
{"snippet": "test_case.assertWarnsRegex(warning, regex)", "intent": "Like assertWarns ( ) but also tests that `regex` matches on the message of the triggered `warning` .", "question_id": 11409}
{"snippet": "test_case.assertWarnsRegex(warning, regex, msg=None)", "intent": "Like assertWarns ( ) but also tests that `regex` matches on the message of the triggered `warning` . With arguments `msg`.", "question_id": 11410}
{"snippet": "test_case.assertLogs()", "intent": "A context manager to test that at least one message is logged on the `logger` or one of its children , with at least the given `level` .", "question_id": 11411}
{"snippet": "test_case.assertLogs(logger=None)", "intent": "A context manager to test that at least one message is logged on the `logger` or one of its children , with at least the given `level` .", "question_id": 11412}
{"snippet": "test_case.assertLogs(level=None)", "intent": "A context manager to test that at least one message is logged on the `logger` or one of its children , with at least the given `level` .", "question_id": 11413}
{"snippet": "test_case.assertLogs(logger=None, level=None)", "intent": "A context manager to test that at least one message is logged on the `logger` or one of its children , with at least the given `level` .", "question_id": 11414}
{"snippet": "test_case.records", "intent": "A list of logging.LogRecord objects of the matching log messages.", "question_id": 11415}
{"snippet": "test_case.output", "intent": "A list of str objects with the formatted output of matching messages.", "question_id": 11416}
{"snippet": "test_case.assertAlmostEqual(first, second)", "intent": "Test that `first` and `second` are approximately ( or not approximately ) equal by computing the difference , rounding to the given number of decimal `places` ( default 7 ) , and comparing to zero .", "question_id": 11417}
{"snippet": "test_case.assertAlmostEqual(first, second, places=7)", "intent": "Test that `first` and `second` are approximately ( or not approximately ) equal by computing the difference , rounding to the given number of decimal `places` ( default 7 ) , and comparing to zero .", "question_id": 11418}
{"snippet": "test_case.assertAlmostEqual(first, second, msg=None)", "intent": "Test that `first` and `second` are approximately ( or not approximately ) equal by computing the difference , rounding to the given number of decimal `places` ( default 7 ) , and comparing to zero . With arguments `msg`.", "question_id": 11419}
{"snippet": "test_case.assertAlmostEqual(first, second, delta=None)", "intent": "Test that `first` and `second` are approximately ( or not approximately ) equal by computing the difference , rounding to the given number of decimal `places` ( default 7 ) , and comparing to zero . If `delta` is supplied instead of places then the difference between first and second must be less or equal to ( or greater than ) delta .", "question_id": 11420}
{"snippet": "test_case.assertAlmostEqual(first, second, places=7, msg=None)", "intent": "Test that `first` and `second` are approximately ( or not approximately ) equal by computing the difference , rounding to the given number of decimal `places` ( default 7 ) , and comparing to zero . With arguments `msg`.", "question_id": 11421}
{"snippet": "test_case.assertAlmostEqual(first, second, places=7, delta=None)", "intent": "Test that `first` and `second` are approximately ( or not approximately ) equal by computing the difference , rounding to the given number of decimal `places` ( default 7 ) , and comparing to zero . If `delta` is supplied instead of places then the difference between first and second must be less or equal to ( or greater than ) delta .", "question_id": 11422}
{"snippet": "test_case.assertAlmostEqual(first, second, msg=None, delta=None)", "intent": "Test that `first` and `second` are approximately ( or not approximately ) equal by computing the difference , rounding to the given number of decimal `places` ( default 7 ) , and comparing to zero . If `delta` is supplied instead of places then the difference between first and second must be less or equal to ( or greater than ) delta . With arguments `msg`.", "question_id": 11423}
{"snippet": "test_case.assertAlmostEqual(first, second, places=7, msg=None, delta=None)", "intent": "Test that `first` and `second` are approximately ( or not approximately ) equal by computing the difference , rounding to the given number of decimal `places` ( default 7 ) , and comparing to zero . If `delta` is supplied instead of places then the difference between first and second must be less or equal to ( or greater than ) delta . With arguments `msg`.", "question_id": 11424}
{"snippet": "test_case.assertNotAlmostEqual(first, second)", "intent": "Test that `first` and `second` are approximately ( or not approximately ) equal by computing the difference , rounding to the given number of decimal `places` ( default 7 ) , and comparing to zero .", "question_id": 11425}
{"snippet": "test_case.assertNotAlmostEqual(first, second, places=7)", "intent": "Test that `first` and `second` are approximately ( or not approximately ) equal by computing the difference , rounding to the given number of decimal `places` ( default 7 ) , and comparing to zero .", "question_id": 11426}
{"snippet": "test_case.assertNotAlmostEqual(first, second, msg=None)", "intent": "Test that `first` and `second` are approximately ( or not approximately ) equal by computing the difference , rounding to the given number of decimal `places` ( default 7 ) , and comparing to zero . With arguments `msg`.", "question_id": 11427}
{"snippet": "test_case.assertNotAlmostEqual(first, second, delta=None)", "intent": "Test that `first` and `second` are approximately ( or not approximately ) equal by computing the difference , rounding to the given number of decimal `places` ( default 7 ) , and comparing to zero . If `delta` is supplied instead of places then the difference between first and second must be less or equal to ( or greater than ) delta .", "question_id": 11428}
{"snippet": "test_case.assertNotAlmostEqual(first, second, places=7, msg=None)", "intent": "Test that `first` and `second` are approximately ( or not approximately ) equal by computing the difference , rounding to the given number of decimal `places` ( default 7 ) , and comparing to zero . With arguments `msg`.", "question_id": 11429}
{"snippet": "test_case.assertNotAlmostEqual(first, second, places=7, delta=None)", "intent": "Test that `first` and `second` are approximately ( or not approximately ) equal by computing the difference , rounding to the given number of decimal `places` ( default 7 ) , and comparing to zero . If `delta` is supplied instead of places then the difference between first and second must be less or equal to ( or greater than ) delta .", "question_id": 11430}
{"snippet": "test_case.assertNotAlmostEqual(first, second, msg=None, delta=None)", "intent": "Test that `first` and `second` are approximately ( or not approximately ) equal by computing the difference , rounding to the given number of decimal `places` ( default 7 ) , and comparing to zero . If `delta` is supplied instead of places then the difference between first and second must be less or equal to ( or greater than ) delta . With arguments `msg`.", "question_id": 11431}
{"snippet": "test_case.assertNotAlmostEqual(first, second, places=7, msg=None, delta=None)", "intent": "Test that `first` and `second` are approximately ( or not approximately ) equal by computing the difference , rounding to the given number of decimal `places` ( default 7 ) , and comparing to zero . If `delta` is supplied instead of places then the difference between first and second must be less or equal to ( or greater than ) delta . With arguments `msg`.", "question_id": 11432}
{"snippet": "test_case.assertGreater(first, second)", "intent": "Test that `first` is respectively > , > = , < or < = than `second` depending on the method name .", "question_id": 11433}
{"snippet": "test_case.assertGreater(first, second, msg=None)", "intent": "Test that `first` is respectively > , > = , < or < = than `second` depending on the method name . With arguments `msg`.", "question_id": 11434}
{"snippet": "test_case.assertGreaterEqual(first, second)", "intent": "Test that `first` is respectively > , > = , < or < = than `second` depending on the method name .", "question_id": 11435}
{"snippet": "test_case.assertGreaterEqual(first, second, msg=None)", "intent": "Test that `first` is respectively > , > = , < or < = than `second` depending on the method name . With arguments `msg`.", "question_id": 11436}
{"snippet": "test_case.assertLess(first, second)", "intent": "Test that `first` is respectively > , > = , < or < = than `second` depending on the method name .", "question_id": 11437}
{"snippet": "test_case.assertLess(first, second, msg=None)", "intent": "Test that `first` is respectively > , > = , < or < = than `second` depending on the method name . With arguments `msg`.", "question_id": 11438}
{"snippet": "test_case.assertLessEqual(first, second)", "intent": "Test that `first` is respectively > , > = , < or < = than `second` depending on the method name .", "question_id": 11439}
{"snippet": "test_case.assertLessEqual(first, second, msg=None)", "intent": "Test that `first` is respectively > , > = , < or < = than `second` depending on the method name . With arguments `msg`.", "question_id": 11440}
{"snippet": "test_case.assertRegex(text, regex)", "intent": "Test that a `regex` search matches ( or does not match ) `text` .", "question_id": 11441}
{"snippet": "test_case.assertRegex(text, regex, msg=None)", "intent": "Test that a `regex` search matches ( or does not match ) `text` . With arguments `msg`.", "question_id": 11442}
{"snippet": "test_case.assertNotRegex(text, regex)", "intent": "Test that a `regex` search matches ( or does not match ) `text` .", "question_id": 11443}
{"snippet": "test_case.assertNotRegex(text, regex, msg=None)", "intent": "Test that a `regex` search matches ( or does not match ) `text` . With arguments `msg`.", "question_id": 11444}
{"snippet": "test_case.assertCountEqual(first, second)", "intent": "Test that sequence `first` contains the same elements as `second` , regardless of their order .", "question_id": 11445}
{"snippet": "test_case.assertCountEqual(first, second, msg=None)", "intent": "Test that sequence `first` contains the same elements as `second` , regardless of their order . With arguments `msg`.", "question_id": 11446}
{"snippet": "test_case.addTypeEqualityFunc(typeobj, function)", "intent": "Registers a type-specific method called by assertEqual ( ) to check if two objects of exactly the same `typeobj` ( not subclasses ) compare equal . `function` must take two positional arguments and a third msg=None keyword argument just as assertEqual ( ) does .", "question_id": 11447}
{"snippet": "test_case.assertMultiLineEqual(first, second)", "intent": "Test that the multiline string `first` is equal to the string `second` .", "question_id": 11448}
{"snippet": "test_case.assertMultiLineEqual(first, second, msg=None)", "intent": "Test that the multiline string `first` is equal to the string `second` . With arguments `msg`.", "question_id": 11449}
{"snippet": "test_case.assertSequenceEqual(first, second)", "intent": "Tests that two sequences are equal . If a `seq_type` is supplied , both `first` and `second` must be instances of seq_type or a failure will be raised .", "question_id": 11450}
{"snippet": "test_case.assertSequenceEqual(first, second, msg=None)", "intent": "Tests that two sequences are equal . If a `seq_type` is supplied , both `first` and `second` must be instances of seq_type or a failure will be raised . With arguments `msg`.", "question_id": 11451}
{"snippet": "test_case.assertSequenceEqual(first, second, seq_type=None)", "intent": "Tests that two sequences are equal . If a `seq_type` is supplied , both `first` and `second` must be instances of seq_type or a failure will be raised .", "question_id": 11452}
{"snippet": "test_case.assertSequenceEqual(first, second, msg=None, seq_type=None)", "intent": "Tests that two sequences are equal . If a `seq_type` is supplied , both `first` and `second` must be instances of seq_type or a failure will be raised . With arguments `msg`.", "question_id": 11453}
{"snippet": "test_case.assertListEqual(first, second)", "intent": "Tests that two lists or tuples are equal . With arguments `first`, `second`.", "question_id": 11454}
{"snippet": "test_case.assertListEqual(first, second, msg=None)", "intent": "Tests that two lists or tuples are equal . With arguments `first`, `second`, `msg`.", "question_id": 11455}
{"snippet": "test_case.assertTupleEqual(first, second)", "intent": "Tests that two lists or tuples are equal . With arguments `first`, `second`.", "question_id": 11456}
{"snippet": "test_case.assertTupleEqual(first, second, msg=None)", "intent": "Tests that two lists or tuples are equal . With arguments `first`, `second`, `msg`.", "question_id": 11457}
{"snippet": "test_case.assertSetEqual(first, second)", "intent": "Tests that two sets are equal . Fails if either of `first` or `second` does not have a set.difference ( ) method .", "question_id": 11458}
{"snippet": "test_case.assertSetEqual(first, second, msg=None)", "intent": "Tests that two sets are equal . Fails if either of `first` or `second` does not have a set.difference ( ) method . With arguments `msg`.", "question_id": 11459}
{"snippet": "test_case.assertDictEqual(first, second)", "intent": "Test that two dictionaries are equal . With arguments `first`, `second`.", "question_id": 11460}
{"snippet": "test_case.assertDictEqual(first, second, msg=None)", "intent": "Test that two dictionaries are equal . With arguments `first`, `second`, `msg`.", "question_id": 11461}
{"snippet": "test_case.fail()", "intent": "Signals a test failure unconditionally , with `msg` or None for the error message .", "question_id": 11462}
{"snippet": "test_case.fail(msg=None)", "intent": "Signals a test failure unconditionally , with `msg` or None for the error message .", "question_id": 11463}
{"snippet": "test_case.failureException", "intent": "This class attribute gives the exception raised by the test method.", "question_id": 11464}
{"snippet": "test_case.longMessage", "intent": "This class attribute determines what happens when a custom failure message is passed as the msg argument to an assertXYY call that fails.", "question_id": 11465}
{"snippet": "test_case.maxDiff", "intent": "This attribute controls the maximum length of diffs output by assert methods that report diffs on failure.", "question_id": 11466}
{"snippet": "test_case.countTestCases()", "intent": "Return the number of tests represented by this test object .", "question_id": 11467}
{"snippet": "test_case.defaultTestResult()", "intent": "Return an instance of the test result class that should be used for this test case class ( if no other result instance is provided to the run ( ) method ) .", "question_id": 11468}
{"snippet": "test_case.id()", "intent": "Return a string identifying the specific test case .", "question_id": 11469}
{"snippet": "test_case.shortDescription()", "intent": "Returns a description of the test , or None if no description has been provided .", "question_id": 11470}
{"snippet": "test_case.addCleanup(function, *args, **kwargs)", "intent": "Add a `function` to be called after tearDown ( ) to cleanup resources used during the test . With arguments `*args`, `**kwargs`.", "question_id": 11471}
{"snippet": "test_case.doCleanups()", "intent": "This method is called unconditionally after tearDown ( ) , or after setUp ( ) if setUp ( ) raises an exception .", "question_id": 11472}
{"snippet": "unittest.FunctionTestCase(testFunc)", "intent": "This class implements the portion of the TestCase interface which allows the test runner to drive the test , but does not provide the methods which test code can use to check and report errors . With arguments `testFunc`.", "question_id": 11473}
{"snippet": "unittest.FunctionTestCase(testFunc, setUp=None)", "intent": "This class implements the portion of the TestCase interface which allows the test runner to drive the test , but does not provide the methods which test code can use to check and report errors . With arguments `testFunc`, `setUp`.", "question_id": 11474}
{"snippet": "unittest.FunctionTestCase(testFunc, tearDown=None)", "intent": "This class implements the portion of the TestCase interface which allows the test runner to drive the test , but does not provide the methods which test code can use to check and report errors . With arguments `testFunc`, `tearDown`.", "question_id": 11475}
{"snippet": "unittest.FunctionTestCase(testFunc, description=None)", "intent": "This class implements the portion of the TestCase interface which allows the test runner to drive the test , but does not provide the methods which test code can use to check and report errors . With arguments `testFunc`, `description`.", "question_id": 11476}
{"snippet": "unittest.FunctionTestCase(testFunc, setUp=None, tearDown=None)", "intent": "This class implements the portion of the TestCase interface which allows the test runner to drive the test , but does not provide the methods which test code can use to check and report errors . With arguments `testFunc`, `setUp`, `tearDown`.", "question_id": 11477}
{"snippet": "unittest.FunctionTestCase(testFunc, setUp=None, description=None)", "intent": "This class implements the portion of the TestCase interface which allows the test runner to drive the test , but does not provide the methods which test code can use to check and report errors . With arguments `testFunc`, `setUp`, `description`.", "question_id": 11478}
{"snippet": "unittest.FunctionTestCase(testFunc, tearDown=None, description=None)", "intent": "This class implements the portion of the TestCase interface which allows the test runner to drive the test , but does not provide the methods which test code can use to check and report errors . With arguments `testFunc`, `tearDown`, `description`.", "question_id": 11479}
{"snippet": "unittest.FunctionTestCase(testFunc, setUp=None, tearDown=None, description=None)", "intent": "This class implements the portion of the TestCase interface which allows the test runner to drive the test , but does not provide the methods which test code can use to check and report errors . With arguments `testFunc`, `setUp`, `tearDown`, `description`.", "question_id": 11480}
{"snippet": "unittest.TestSuite()", "intent": "This class represents an aggregation of individual test cases and test suites .", "question_id": 11481}
{"snippet": "unittest.TestSuite(tests=())", "intent": "This class represents an aggregation of individual test cases and test suites . If `tests` is given , it must be an iterable of individual test cases or other test suites that will be used to build the suite initially .", "question_id": 11482}
{"snippet": "test_suite.addTest(test)", "intent": "Add a TestCase or TestSuite to the suite . With arguments `test`.", "question_id": 11483}
{"snippet": "test_suite.addTests(tests)", "intent": "Add all the `tests` from an iterable of TestCase and TestSuite instances to this test suite .", "question_id": 11484}
{"snippet": "test_suite.run(result)", "intent": "Run the tests associated with this suite , collecting the `result` into the test result object passed as result .", "question_id": 11485}
{"snippet": "test_suite.debug()", "intent": "Run the tests associated with this suite without collecting the result .", "question_id": 11486}
{"snippet": "test_suite.countTestCases()", "intent": "Return the number of tests represented by this test object , including all individual tests and sub-suites .", "question_id": 11487}
{"snippet": "test_suite.__iter__()", "intent": "Tests grouped by a TestSuite are always accessed by iteration .", "question_id": 11488}
{"snippet": "unittest.TestLoader", "intent": "The TestLoader class is used to create test suites from classes and modules.", "question_id": 11489}
{"snippet": "test_loader.errors", "intent": "A list of the non-fatal errors encountered while loading tests.", "question_id": 11490}
{"snippet": "test_loader.loadTestsFromTestCase(testCaseClass)", "intent": "Return a suite of all test cases contained in the TestCase-derived `testCaseClass` .", "question_id": 11491}
{"snippet": "test_loader.loadTestsFromModule(module)", "intent": "Return a suite of all test cases contained in the given `module` .", "question_id": 11492}
{"snippet": "test_loader.loadTestsFromModule(module, pattern=None)", "intent": "Return a suite of all test cases contained in the given `module` . The `pattern` argument is passed as the third argument to load_tests .", "question_id": 11493}
{"snippet": "test_loader.loadTestsFromName(name)", "intent": "Return a suite of all test cases given a string specifier . The specifier `name` is a \u201c dotted name \u201d that may resolve either to a `module` , a test case class , a test method within a test case class , a TestSuite instance , or a callable object which returns a TestCase or TestSuite instance .", "question_id": 11494}
{"snippet": "test_loader.loadTestsFromName(name, module=None)", "intent": "Return a suite of all test cases given a string specifier . The specifier `name` is a \u201c dotted name \u201d that may resolve either to a `module` , a test case class , a test method within a test case class , a TestSuite instance , or a callable object which returns a TestCase or TestSuite instance .", "question_id": 11495}
{"snippet": "test_loader.loadTestsFromNames(names)", "intent": "Similar to loadTestsFromName ( ) , but takes a sequence of `names` rather than a single name .", "question_id": 11496}
{"snippet": "test_loader.loadTestsFromNames(names, module=None)", "intent": "Similar to loadTestsFromName ( ) , but takes a sequence of `names` rather than a single name . With arguments `module`.", "question_id": 11497}
{"snippet": "test_loader.getTestCaseNames(testCaseClass)", "intent": "Return a sorted sequence of method names found within `testCaseClass` ; this should be a subclass of TestCase .", "question_id": 11498}
{"snippet": "test_loader.discover(start_dir)", "intent": "Find all the test modules by recursing into subdirectories from the specified start directory , and return a TestSuite object containing them . `start_dir` can be a dotted module name as well as a directory .", "question_id": 11499}
{"snippet": "test_loader.discover(start_dir, pattern='test*.py')", "intent": "Find all the test modules by recursing into subdirectories from the specified start directory , and return a TestSuite object containing them . `start_dir` can be a dotted module name as well as a directory . Only test files that match `pattern` will be loaded .", "question_id": 11500}
{"snippet": "test_loader.discover(start_dir, top_level_dir=None)", "intent": "Find all the test modules by recursing into subdirectories from the specified start directory , and return a TestSuite object containing them . `start_dir` can be a dotted module name as well as a directory . `top_level_dir` is stored so load_tests does not need to pass this argument in to loader.discover ( ) .", "question_id": 11501}
{"snippet": "test_loader.discover(start_dir, pattern='test*.py', top_level_dir=None)", "intent": "Find all the test modules by recursing into subdirectories from the specified start directory , and return a TestSuite object containing them . `start_dir` can be a dotted module name as well as a directory . Only test files that match `pattern` will be loaded . `top_level_dir` is stored so load_tests does not need to pass this argument in to loader.discover ( ) .", "question_id": 11502}
{"snippet": "test_loader.testMethodPrefix", "intent": "String giving the prefix of method names which will be interpreted as test methods.", "question_id": 11503}
{"snippet": "test_loader.sortTestMethodsUsing", "intent": "Function to be used to compare method names when sorting them in getTestCaseNames() and all the loadTestsFrom*() methods.", "question_id": 11504}
{"snippet": "test_loader.suiteClass", "intent": "Callable object that constructs a test suite from a list of tests.", "question_id": 11505}
{"snippet": "test_loader.testNamePatterns", "intent": "List of Unix shell-style wildcard test name patterns that test methods have to match to be included in test suites (see -v option).", "question_id": 11506}
{"snippet": "unittest.TestResult", "intent": "This class is used to compile information about which tests have succeeded and which have failed.", "question_id": 11507}
{"snippet": "test_result.errors", "intent": "A list containing 2-tuples of TestCase instances and strings holding formatted tracebacks.", "question_id": 11508}
{"snippet": "test_result.failures", "intent": "A list containing 2-tuples of TestCase instances and strings holding formatted tracebacks.", "question_id": 11509}
{"snippet": "test_result.skipped", "intent": "A list containing 2-tuples of TestCase instances and strings holding the reason for skipping the test.", "question_id": 11510}
{"snippet": "test_result.expectedFailures", "intent": "A list containing 2-tuples of TestCase instances and strings holding formatted tracebacks.", "question_id": 11511}
{"snippet": "test_result.unexpectedSuccesses", "intent": "A list containing TestCase instances that were marked as expected failures, but succeeded.", "question_id": 11512}
{"snippet": "test_result.shouldStop", "intent": "Set to True when the execution of tests should stop by stop().", "question_id": 11513}
{"snippet": "test_result.testsRun", "intent": "The total number of tests run so far.", "question_id": 11514}
{"snippet": "test_result.buffer", "intent": "If set to true, sys.stdout and sys.stderr will be buffered in between startTest() and stopTest() being called.", "question_id": 11515}
{"snippet": "test_result.failfast", "intent": "If set to true stop() will be called on the first failure or error, halting the test run.", "question_id": 11516}
{"snippet": "test_result.tb_locals", "intent": "If set to true then local variables will be shown in tracebacks.", "question_id": 11517}
{"snippet": "test_result.wasSuccessful()", "intent": "Return True if all tests run so far have passed , otherwise returns False .", "question_id": 11518}
{"snippet": "test_result.stop()", "intent": "This method can be called to signal that the set of tests being run should be aborted by setting the shouldStop attribute to True .", "question_id": 11519}
{"snippet": "test_result.startTest(test)", "intent": "Called when the `test` case test is about to be run .", "question_id": 11520}
{"snippet": "test_result.stopTest(test)", "intent": "Called after the `test` case test has been executed , regardless of the outcome .", "question_id": 11521}
{"snippet": "test_result.startTestRun()", "intent": "Called once before any tests are executed .", "question_id": 11522}
{"snippet": "test_result.stopTestRun()", "intent": "Called once after all tests are executed .", "question_id": 11523}
{"snippet": "test_result.addError(test, err)", "intent": "Called when the `test` case test raises an unexpected exception . `err` is a tuple of the form returned by sys.exc_info ( ) : ( type , value , traceback ) .", "question_id": 11524}
{"snippet": "test_result.addFailure(test, err)", "intent": "Called when the `test` case test signals a failure . `err` is a tuple of the form returned by sys.exc_info ( ) : ( type , value , traceback ) .", "question_id": 11525}
{"snippet": "test_result.addSuccess(test)", "intent": "Called when the `test` case test succeeds .", "question_id": 11526}
{"snippet": "test_result.addSkip(test, reason)", "intent": "Called when the `test` case test is skipped . `reason` is the reason the test gave for skipping .", "question_id": 11527}
{"snippet": "test_result.addExpectedFailure(test, err)", "intent": "Called when the `test` case test fails , but was marked with the expectedFailure ( ) decorator . The default implementation appends a tuple ( test , formatted_err ) to the instance \u2019 s expectedFailures attribute , where formatted_err is a formatted traceback derived from `err` .", "question_id": 11528}
{"snippet": "test_result.addUnexpectedSuccess(test)", "intent": "Called when the `test` case test was marked with the expectedFailure ( ) decorator , but succeeded .", "question_id": 11529}
{"snippet": "test_result.addSubTest(test, subtest, outcome)", "intent": "Called when a `subtest` finishes . `test` is the test case corresponding to the test method . If `outcome` is None , the subtest succeeded .", "question_id": 11530}
{"snippet": "unittest.TextTestResult(stream, descriptions, verbosity)", "intent": "A concrete implementation of TestResult used by the TextTestRunner . With arguments `stream`, `descriptions`, `verbosity`.", "question_id": 11531}
{"snippet": "unittest.defaultTestLoader", "intent": "Instance of the TestLoader class intended to be shared.", "question_id": 11532}
{"snippet": "unittest.TextTestRunner()", "intent": "A basic test runner implementation that outputs results to a `stream` .", "question_id": 11533}
{"snippet": "unittest.TextTestRunner(stream=None)", "intent": "A basic test runner implementation that outputs results to a `stream` .", "question_id": 11534}
{"snippet": "unittest.TextTestRunner(descriptions=True)", "intent": "A basic test runner implementation that outputs results to a `stream` . With arguments `descriptions`.", "question_id": 11535}
{"snippet": "unittest.TextTestRunner(verbosity=1)", "intent": "A basic test runner implementation that outputs results to a `stream` . With arguments `verbosity`.", "question_id": 11536}
{"snippet": "unittest.TextTestRunner(failfast=False)", "intent": "A basic test runner implementation that outputs results to a `stream` . With arguments `failfast`.", "question_id": 11537}
{"snippet": "unittest.TextTestRunner(buffer=False)", "intent": "A basic test runner implementation that outputs results to a `stream` . With arguments `buffer`.", "question_id": 11538}
{"snippet": "unittest.TextTestRunner(resultclass=None)", "intent": "A basic test runner implementation that outputs results to a `stream` . With arguments `resultclass`.", "question_id": 11539}
{"snippet": "unittest.TextTestRunner(warnings=None)", "intent": "A basic test runner implementation that outputs results to a `stream` . Deprecation `warnings` caused by deprecated unittest methods are also special-cased and , when the warning filters are 'default ' or 'always ' , they will appear only once per-module , in order to avoid too many warning messages .", "question_id": 11540}
{"snippet": "unittest.TextTestRunner(tb_locals=False)", "intent": "A basic test runner implementation that outputs results to a `stream` . With arguments `tb_locals`.", "question_id": 11541}
{"snippet": "unittest.TextTestRunner(stream=None, descriptions=True)", "intent": "A basic test runner implementation that outputs results to a `stream` . With arguments `descriptions`.", "question_id": 11542}
{"snippet": "text_test_runner._makeResult()", "intent": "This method returns the instance of TestResult used by run ( ) .", "question_id": 11543}
{"snippet": "text_test_runner.run(test)", "intent": "This method is the main public interface to the TextTestRunner . A TestResult is created by calling _makeResult ( ) and the `test` ( s ) are run and the results printed to stdout .", "question_id": 11544}
{"snippet": "unittest.main()", "intent": "A command-line program that loads a set of tests from `module` and runs them ; this is primarily for making test modules conveniently executable .", "question_id": 11545}
{"snippet": "unittest.main(module='__main__')", "intent": "A command-line program that loads a set of tests from `module` and runs them ; this is primarily for making test modules conveniently executable .", "question_id": 11546}
{"snippet": "unittest.main(defaultTest=None)", "intent": "A command-line program that loads a set of tests from `module` and runs them ; this is primarily for making test modules conveniently executable . The `defaultTest` argument is either the name of a single test or an iterable of test names to run if no test names are specified via `argv` .", "question_id": 11547}
{"snippet": "unittest.main(argv=None)", "intent": "A command-line program that loads a set of tests from `module` and runs them ; this is primarily for making test modules conveniently executable . The `defaultTest` argument is either the name of a single test or an iterable of test names to run if no test names are specified via `argv` .", "question_id": 11548}
{"snippet": "unittest.main(testRunner=None)", "intent": "A command-line program that loads a set of tests from `module` and runs them ; this is primarily for making test modules conveniently executable . The `testRunner` argument can either be a test runner class or an already created instance of it .", "question_id": 11549}
{"snippet": "unittest.main(testLoader=unittest.defaultTestLoader)", "intent": "A command-line program that loads a set of tests from `module` and runs them ; this is primarily for making test modules conveniently executable . The `testLoader` argument has to be a TestLoader instance , and defaults to defaultTestLoader .", "question_id": 11550}
{"snippet": "unittest.main(exit=True)", "intent": "A command-line program that loads a set of tests from `module` and runs them ; this is primarily for making test modules conveniently executable . By default main calls sys.exit ( ) with an `exit` code indicating success or failure of the tests run .", "question_id": 11551}
{"snippet": "unittest.main(verbosity=1)", "intent": "A command-line program that loads a set of tests from `module` and runs them ; this is primarily for making test modules conveniently executable . You can run tests with more detailed information by passing in the `verbosity` argument :", "question_id": 11552}
{"snippet": "unittest.main(failfast=None)", "intent": "A command-line program that loads a set of tests from `module` and runs them ; this is primarily for making test modules conveniently executable . The `failfast` , `catchbreak` and `buffer` parameters have the same effect as the same-name command-line options .", "question_id": 11553}
{"snippet": "unittest.main(catchbreak=None)", "intent": "A command-line program that loads a set of tests from `module` and runs them ; this is primarily for making test modules conveniently executable . The `failfast` , `catchbreak` and `buffer` parameters have the same effect as the same-name command-line options .", "question_id": 11554}
{"snippet": "unittest.installHandler()", "intent": "Install the control-c handler .", "question_id": 11555}
{"snippet": "unittest.registerResult(result)", "intent": "Register a TestResult object for control-c handling . Registering a `result` stores a weak reference to it , so it doesn \u2019 t prevent the result from being garbage collected .", "question_id": 11556}
{"snippet": "unittest.removeResult(result)", "intent": "Remove a registered `result` .", "question_id": 11557}
{"snippet": "unittest.removeHandler()", "intent": "When called without arguments this `function` removes the control-c handler if it has been installed .", "question_id": 11558}
{"snippet": "unittest.removeHandler(function=None)", "intent": "When called without arguments this `function` removes the control-c handler if it has been installed .", "question_id": 11559}
{"snippet": "unittest.mock.Mock(**kwargs)", "intent": "Create a new Mock object . With arguments `**kwargs`.", "question_id": 11560}
{"snippet": "unittest.mock.Mock(**kwargs, spec=None)", "intent": "Create a new Mock object . With arguments `**kwargs`, `spec`.", "question_id": 11561}
{"snippet": "unittest.mock.Mock(**kwargs, side_effect=None)", "intent": "Create a new Mock object . With arguments `**kwargs`, `side_effect`.", "question_id": 11562}
{"snippet": "unittest.mock.Mock(**kwargs, return_value=DEFAULT)", "intent": "Create a new Mock object . With arguments `**kwargs`, `return_value`.", "question_id": 11563}
{"snippet": "unittest.mock.Mock(**kwargs, wraps=None)", "intent": "Create a new Mock object . With arguments `**kwargs`, `wraps`.", "question_id": 11564}
{"snippet": "unittest.mock.Mock(**kwargs, name=None)", "intent": "Create a new Mock object . With arguments `**kwargs`, `name`.", "question_id": 11565}
{"snippet": "unittest.mock.Mock(**kwargs, spec_set=None)", "intent": "Create a new Mock object . With arguments `**kwargs`, `spec_set`.", "question_id": 11566}
{"snippet": "unittest.mock.Mock(**kwargs, unsafe=False)", "intent": "Create a new Mock object . With arguments `**kwargs`, `unsafe`.", "question_id": 11567}
{"snippet": "unittest.mock.Mock(**kwargs, spec=None, side_effect=None)", "intent": "Create a new Mock object . With arguments `**kwargs`, `spec`, `side_effect`.", "question_id": 11568}
{"snippet": "unittest.mock.Mock(**kwargs, spec=None, return_value=DEFAULT)", "intent": "Create a new Mock object . With arguments `**kwargs`, `spec`, `return_value`.", "question_id": 11569}
{"snippet": "mock.assert_called()", "intent": "Assert that the mock was called at least once .", "question_id": 11570}
{"snippet": "mock.assert_called_once()", "intent": "Assert that the mock was called exactly once .", "question_id": 11571}
{"snippet": "mock.assert_called_with(*args, **kwargs)", "intent": "This method is a convenient way of asserting that calls are made in a particular way : With arguments `*args`, `**kwargs`.", "question_id": 11572}
{"snippet": "mock.assert_called_once_with(*args, **kwargs)", "intent": "Assert that the mock was called exactly once and that that call was with the specified arguments . With arguments `*args`, `**kwargs`.", "question_id": 11573}
{"snippet": "mock.assert_any_call(*args, **kwargs)", "intent": "assert the mock has been called with the specified arguments . With arguments `*args`, `**kwargs`.", "question_id": 11574}
{"snippet": "mock.assert_has_calls(calls)", "intent": "assert the mock has been called with the specified `calls` .", "question_id": 11575}
{"snippet": "mock.assert_has_calls(calls, any_order=False)", "intent": "assert the mock has been called with the specified `calls` . If `any_order` is false ( the default ) then the calls must be sequential .", "question_id": 11576}
{"snippet": "mock.assert_not_called()", "intent": "Assert the mock was never called .", "question_id": 11577}
{"snippet": "mock.reset_mock()", "intent": "The reset_mock method resets all the call attributes on a mock object :", "question_id": 11578}
{"snippet": "mock.reset_mock(return_value=False)", "intent": "The reset_mock method resets all the call attributes on a mock object : In case you want to reset `return_value` or side_effect , then pass the corresponding parameter as True .", "question_id": 11579}
{"snippet": "mock.reset_mock(side_effect=False)", "intent": "The reset_mock method resets all the call attributes on a mock object : Note that reset_mock ( ) doesn \u2019 t clear the return value , `side_effect` or any child attributes you have set using normal assignment by default .", "question_id": 11580}
{"snippet": "mock.reset_mock(return_value=False, side_effect=False)", "intent": "The reset_mock method resets all the call attributes on a mock object : In case you want to reset `return_value` or side_effect , then pass the corresponding parameter as True . Note that reset_mock ( ) doesn \u2019 t clear the return value , `side_effect` or any child attributes you have set using normal assignment by default .", "question_id": 11581}
{"snippet": "mock.mock_add_spec(spec)", "intent": "Add a `spec` to a mock .", "question_id": 11582}
{"snippet": "mock.mock_add_spec(spec, spec_set=False)", "intent": "Add a `spec` to a mock . If `spec_set` is true then only attributes on the spec can be set .", "question_id": 11583}
{"snippet": "mock.attach_mock(mock, attribute)", "intent": "Attach a `mock` as an `attribute` of this one , replacing its name and parent .", "question_id": 11584}
{"snippet": "mock.configure_mock(**kwargs)", "intent": "Set attributes on the mock through keyword arguments . With arguments `**kwargs`.", "question_id": 11585}
{"snippet": "mock.__dir__()", "intent": "Mock objects limit the results of dir ( some_mock ) to useful results .", "question_id": 11586}
{"snippet": "mock._get_child_mock(**kw)", "intent": "Create the child mocks for attributes and return value . With arguments `**kw`.", "question_id": 11587}
{"snippet": "mock.called", "intent": "A boolean representing whether or not the mock object has been called:", "question_id": 11588}
{"snippet": "mock.call_count", "intent": "An integer telling you how many times the mock object has been called:", "question_id": 11589}
{"snippet": "mock.return_value", "intent": "Set this to configure the value returned by calling the mock:", "question_id": 11590}
{"snippet": "mock.side_effect", "intent": "This can either be a function to be called when the mock is called, an iterable or an exception (class or instance) to be raised.", "question_id": 11591}
{"snippet": "mock.call_args", "intent": "This is either None (if the mock hasn\u2019t been called), or the arguments that the mock was last called with.", "question_id": 11592}
{"snippet": "mock.call_args_list", "intent": "This is a list of all the calls made to the mock object in sequence (so the length of the list is the number of times it has been called).", "question_id": 11593}
{"snippet": "mock.method_calls", "intent": "As well as tracking calls to themselves, mocks also track calls to methods and attributes, and their methods and attributes:", "question_id": 11594}
{"snippet": "mock.mock_calls", "intent": "mock_calls records all calls to the mock object, its methods, magic methods and return value mocks.", "question_id": 11595}
{"snippet": "mock.__class__", "intent": "Normally the __class__ attribute of an object will return its type.", "question_id": 11596}
{"snippet": "unittest.mock.NonCallableMock(**kwargs)", "intent": "A non-callable version of Mock . With arguments `**kwargs`.", "question_id": 11597}
{"snippet": "unittest.mock.NonCallableMock(**kwargs, spec=None)", "intent": "A non-callable version of Mock . With arguments `**kwargs`, `spec`.", "question_id": 11598}
{"snippet": "unittest.mock.NonCallableMock(**kwargs, wraps=None)", "intent": "A non-callable version of Mock . With arguments `**kwargs`, `wraps`.", "question_id": 11599}
{"snippet": "unittest.mock.NonCallableMock(**kwargs, name=None)", "intent": "A non-callable version of Mock . With arguments `**kwargs`, `name`.", "question_id": 11600}
{"snippet": "unittest.mock.NonCallableMock(**kwargs, spec_set=None)", "intent": "A non-callable version of Mock . With arguments `**kwargs`, `spec_set`.", "question_id": 11601}
{"snippet": "unittest.mock.NonCallableMock(**kwargs, spec=None, wraps=None)", "intent": "A non-callable version of Mock . With arguments `**kwargs`, `spec`, `wraps`.", "question_id": 11602}
{"snippet": "unittest.mock.NonCallableMock(**kwargs, spec=None, name=None)", "intent": "A non-callable version of Mock . With arguments `**kwargs`, `spec`, `name`.", "question_id": 11603}
{"snippet": "unittest.mock.NonCallableMock(**kwargs, spec=None, spec_set=None)", "intent": "A non-callable version of Mock . With arguments `**kwargs`, `spec`, `spec_set`.", "question_id": 11604}
{"snippet": "unittest.mock.NonCallableMock(**kwargs, wraps=None, name=None)", "intent": "A non-callable version of Mock . With arguments `**kwargs`, `wraps`, `name`.", "question_id": 11605}
{"snippet": "unittest.mock.NonCallableMock(**kwargs, wraps=None, spec_set=None)", "intent": "A non-callable version of Mock . With arguments `**kwargs`, `wraps`, `spec_set`.", "question_id": 11606}
{"snippet": "unittest.mock.PropertyMock(*args, **kwargs)", "intent": "A mock intended to be used as a property , or other descriptor , on a class . With arguments `*args`, `**kwargs`.", "question_id": 11607}
{"snippet": "unittest.mock.patch(target, **kwargs)", "intent": "patch ( ) acts as a function decorator , class decorator or a context manager . Inside the body of the function or with statement , the `target` is patched with a `new` object . With arguments `**kwargs`.", "question_id": 11608}
{"snippet": "unittest.mock.patch(target, **kwargs, new=DEFAULT)", "intent": "patch ( ) acts as a function decorator , class decorator or a context manager . Inside the body of the function or with statement , the `target` is patched with a `new` object . With arguments `**kwargs`.", "question_id": 11609}
{"snippet": "unittest.mock.patch(target, **kwargs, spec=None)", "intent": "patch ( ) acts as a function decorator , class decorator or a context manager . Inside the body of the function or with statement , the `target` is patched with a `new` object . The `spec` and `spec_set` keyword arguments are passed to the MagicMock if patch is creating one for you . With arguments `**kwargs`.", "question_id": 11610}
{"snippet": "unittest.mock.patch(target, **kwargs, create=False)", "intent": "patch ( ) acts as a function decorator , class decorator or a context manager . Inside the body of the function or with statement , the `target` is patched with a `new` object . `new_callable` allows you to specify a different class , or callable object , that will be called to `create` the new object . With arguments `**kwargs`.", "question_id": 11611}
{"snippet": "unittest.mock.patch(target, **kwargs, spec_set=None)", "intent": "patch ( ) acts as a function decorator , class decorator or a context manager . Inside the body of the function or with statement , the `target` is patched with a `new` object . The `spec` and `spec_set` keyword arguments are passed to the MagicMock if patch is creating one for you . With arguments `**kwargs`.", "question_id": 11612}
{"snippet": "unittest.mock.patch(target, **kwargs, autospec=None)", "intent": "patch ( ) acts as a function decorator , class decorator or a context manager . Inside the body of the function or with statement , the `target` is patched with a `new` object . A more powerful form of spec is `autospec` . With arguments `**kwargs`.", "question_id": 11613}
{"snippet": "unittest.mock.patch(target, **kwargs, new_callable=None)", "intent": "patch ( ) acts as a function decorator , class decorator or a context manager . Inside the body of the function or with statement , the `target` is patched with a `new` object . `new_callable` allows you to specify a different class , or callable object , that will be called to `create` the new object . With arguments `**kwargs`.", "question_id": 11614}
{"snippet": "unittest.mock.patch(target, **kwargs, new=DEFAULT, spec=None)", "intent": "patch ( ) acts as a function decorator , class decorator or a context manager . Inside the body of the function or with statement , the `target` is patched with a `new` object . The `spec` and `spec_set` keyword arguments are passed to the MagicMock if patch is creating one for you . With arguments `**kwargs`.", "question_id": 11615}
{"snippet": "unittest.mock.patch(target, **kwargs, new=DEFAULT, create=False)", "intent": "patch ( ) acts as a function decorator , class decorator or a context manager . Inside the body of the function or with statement , the `target` is patched with a `new` object . `new_callable` allows you to specify a different class , or callable object , that will be called to `create` the new object . With arguments `**kwargs`.", "question_id": 11616}
{"snippet": "unittest.mock.patch(target, **kwargs, new=DEFAULT, spec_set=None)", "intent": "patch ( ) acts as a function decorator , class decorator or a context manager . Inside the body of the function or with statement , the `target` is patched with a `new` object . The `spec` and `spec_set` keyword arguments are passed to the MagicMock if patch is creating one for you . With arguments `**kwargs`.", "question_id": 11617}
{"snippet": "patch.object(target, attribute, **kwargs)", "intent": "patch the named member ( `attribute` ) on an object ( `target` ) with a mock object . With arguments `**kwargs`.", "question_id": 11618}
{"snippet": "patch.object(target, attribute, **kwargs, new=DEFAULT)", "intent": "patch the named member ( `attribute` ) on an object ( `target` ) with a mock object . Arguments `new` , `spec` , `create` , `spec_set` , `autospec` and `new_callable` have the same meaning as for patch ( ) . With arguments `**kwargs`.", "question_id": 11619}
{"snippet": "patch.object(target, attribute, **kwargs, spec=None)", "intent": "patch the named member ( `attribute` ) on an object ( `target` ) with a mock object . Arguments `new` , `spec` , `create` , `spec_set` , `autospec` and `new_callable` have the same meaning as for patch ( ) . With arguments `**kwargs`.", "question_id": 11620}
{"snippet": "patch.object(target, attribute, **kwargs, create=False)", "intent": "patch the named member ( `attribute` ) on an object ( `target` ) with a mock object . Arguments `new` , `spec` , `create` , `spec_set` , `autospec` and `new_callable` have the same meaning as for patch ( ) . With arguments `**kwargs`.", "question_id": 11621}
{"snippet": "patch.object(target, attribute, **kwargs, spec_set=None)", "intent": "patch the named member ( `attribute` ) on an object ( `target` ) with a mock object . Arguments `new` , `spec` , `create` , `spec_set` , `autospec` and `new_callable` have the same meaning as for patch ( ) . With arguments `**kwargs`.", "question_id": 11622}
{"snippet": "patch.object(target, attribute, **kwargs, autospec=None)", "intent": "patch the named member ( `attribute` ) on an object ( `target` ) with a mock object . Arguments `new` , `spec` , `create` , `spec_set` , `autospec` and `new_callable` have the same meaning as for patch ( ) . With arguments `**kwargs`.", "question_id": 11623}
{"snippet": "patch.object(target, attribute, **kwargs, new_callable=None)", "intent": "patch the named member ( `attribute` ) on an object ( `target` ) with a mock object . Arguments `new` , `spec` , `create` , `spec_set` , `autospec` and `new_callable` have the same meaning as for patch ( ) . With arguments `**kwargs`.", "question_id": 11624}
{"snippet": "patch.object(target, attribute, **kwargs, new=DEFAULT, spec=None)", "intent": "patch the named member ( `attribute` ) on an object ( `target` ) with a mock object . Arguments `new` , `spec` , `create` , `spec_set` , `autospec` and `new_callable` have the same meaning as for patch ( ) . With arguments `**kwargs`.", "question_id": 11625}
{"snippet": "patch.object(target, attribute, **kwargs, new=DEFAULT, create=False)", "intent": "patch the named member ( `attribute` ) on an object ( `target` ) with a mock object . Arguments `new` , `spec` , `create` , `spec_set` , `autospec` and `new_callable` have the same meaning as for patch ( ) . With arguments `**kwargs`.", "question_id": 11626}
{"snippet": "patch.object(target, attribute, **kwargs, new=DEFAULT, spec_set=None)", "intent": "patch the named member ( `attribute` ) on an object ( `target` ) with a mock object . Arguments `new` , `spec` , `create` , `spec_set` , `autospec` and `new_callable` have the same meaning as for patch ( ) . With arguments `**kwargs`.", "question_id": 11627}
{"snippet": "patch.dict(in_dict, **kwargs)", "intent": "Patch a dictionary , or dictionary like object , and restore the dictionary to its original state after the test . `in_dict` can be a dictionary or a mapping like container . With arguments `**kwargs`.", "question_id": 11628}
{"snippet": "patch.dict(in_dict, **kwargs, values=())", "intent": "Patch a dictionary , or dictionary like object , and restore the dictionary to its original state after the test . `in_dict` can be a dictionary or a mapping like container . `values` can be a dictionary of values to set in the dictionary . With arguments `**kwargs`.", "question_id": 11629}
{"snippet": "patch.dict(in_dict, **kwargs, clear=False)", "intent": "Patch a dictionary , or dictionary like object , and restore the dictionary to its original state after the test . `in_dict` can be a dictionary or a mapping like container . If `clear` is true then the dictionary will be cleared before the new values are set . With arguments `**kwargs`.", "question_id": 11630}
{"snippet": "patch.dict(in_dict, **kwargs, values=(), clear=False)", "intent": "Patch a dictionary , or dictionary like object , and restore the dictionary to its original state after the test . `in_dict` can be a dictionary or a mapping like container . `values` can be a dictionary of values to set in the dictionary . If `clear` is true then the dictionary will be cleared before the new values are set . With arguments `**kwargs`.", "question_id": 11631}
{"snippet": "patch.multiple(target, **kwargs)", "intent": "Perform multiple patches in a single call . With arguments `target`, `**kwargs`.", "question_id": 11632}
{"snippet": "patch.multiple(target, **kwargs, spec=None)", "intent": "Perform multiple patches in a single call . The arguments `spec` , `spec_set` , create , `autospec` and `new_callable` have the same meaning as for patch ( ) . With arguments `target`, `**kwargs`.", "question_id": 11633}
{"snippet": "patch.multiple(target, **kwargs, create=False)", "intent": "Perform multiple patches in a single call . Use DEFAULT as the value if you want patch.multiple ( ) to `create` mocks for you . With arguments `target`, `**kwargs`.", "question_id": 11634}
{"snippet": "patch.multiple(target, **kwargs, spec_set=None)", "intent": "Perform multiple patches in a single call . The arguments `spec` , `spec_set` , create , `autospec` and `new_callable` have the same meaning as for patch ( ) . With arguments `target`, `**kwargs`.", "question_id": 11635}
{"snippet": "patch.multiple(target, **kwargs, autospec=None)", "intent": "Perform multiple patches in a single call . The arguments `spec` , `spec_set` , create , `autospec` and `new_callable` have the same meaning as for patch ( ) . With arguments `target`, `**kwargs`.", "question_id": 11636}
{"snippet": "patch.multiple(target, **kwargs, new_callable=None)", "intent": "Perform multiple patches in a single call . The arguments `spec` , `spec_set` , create , `autospec` and `new_callable` have the same meaning as for patch ( ) . With arguments `target`, `**kwargs`.", "question_id": 11637}
{"snippet": "patch.multiple(target, **kwargs, spec=None, create=False)", "intent": "Perform multiple patches in a single call . The arguments `spec` , `spec_set` , create , `autospec` and `new_callable` have the same meaning as for patch ( ) . Use DEFAULT as the value if you want patch.multiple ( ) to `create` mocks for you . With arguments `target`, `**kwargs`.", "question_id": 11638}
{"snippet": "patch.multiple(target, **kwargs, spec=None, spec_set=None)", "intent": "Perform multiple patches in a single call . The arguments `spec` , `spec_set` , create , `autospec` and `new_callable` have the same meaning as for patch ( ) . With arguments `target`, `**kwargs`.", "question_id": 11639}
{"snippet": "patch.multiple(target, **kwargs, spec=None, autospec=None)", "intent": "Perform multiple patches in a single call . The arguments `spec` , `spec_set` , create , `autospec` and `new_callable` have the same meaning as for patch ( ) . With arguments `target`, `**kwargs`.", "question_id": 11640}
{"snippet": "patch.multiple(target, **kwargs, spec=None, new_callable=None)", "intent": "Perform multiple patches in a single call . The arguments `spec` , `spec_set` , create , `autospec` and `new_callable` have the same meaning as for patch ( ) . With arguments `target`, `**kwargs`.", "question_id": 11641}
{"snippet": "patch.stopall()", "intent": "Stop all active patches .", "question_id": 11642}
{"snippet": "unittest.mock.MagicMock(*args, **kw)", "intent": "MagicMock is a subclass of Mock with default implementations of most of the magic methods . With arguments `*args`, `**kw`.", "question_id": 11643}
{"snippet": "unittest.mock.NonCallableMagicMock(*args, **kw)", "intent": "A non-callable version of MagicMock . With arguments `*args`, `**kw`.", "question_id": 11644}
{"snippet": "unittest.mock.sentinel", "intent": "The sentinel object provides a convenient way of providing unique objects for your tests.", "question_id": 11645}
{"snippet": "unittest.mock.DEFAULT", "intent": "The DEFAULT object is a pre-created sentinel (actually sentinel.DEFAULT).", "question_id": 11646}
{"snippet": "unittest.mock.call(*args, **kwargs)", "intent": "call ( ) is a helper object for making simpler assertions , for comparing with call_args , call_args_list , mock_calls and method_calls . With arguments `*args`, `**kwargs`.", "question_id": 11647}
{"snippet": "call.call_list()", "intent": "For a call object that represents multiple calls , call_list ( ) returns a list of all the intermediate calls as well as the final call .", "question_id": 11648}
{"snippet": "unittest.mock.create_autospec(spec, **kwargs)", "intent": "Create a mock object using another object as a `spec` . With arguments `**kwargs`.", "question_id": 11649}
{"snippet": "unittest.mock.create_autospec(spec, **kwargs, spec_set=False)", "intent": "Create a mock object using another object as a `spec` . If `spec_set` is True then attempting to set attributes that don \u2019 t exist on the spec object will raise an AttributeError . With arguments `**kwargs`.", "question_id": 11650}
{"snippet": "unittest.mock.create_autospec(spec, **kwargs, instance=False)", "intent": "Create a mock object using another object as a `spec` . If a class is used as a spec then the return value of the mock ( the `instance` of the class ) will have the same spec . With arguments `**kwargs`.", "question_id": 11651}
{"snippet": "unittest.mock.create_autospec(spec, **kwargs, spec_set=False, instance=False)", "intent": "Create a mock object using another object as a `spec` . If `spec_set` is True then attempting to set attributes that don \u2019 t exist on the spec object will raise an AttributeError . If a class is used as a spec then the return value of the mock ( the `instance` of the class ) will have the same spec . With arguments `**kwargs`.", "question_id": 11652}
{"snippet": "unittest.mock.mock_open()", "intent": "A helper function to create a `mock` to replace the use of open ( ) .", "question_id": 11653}
{"snippet": "unittest.mock.mock_open(mock=None)", "intent": "A helper function to create a `mock` to replace the use of open ( ) .", "question_id": 11654}
{"snippet": "unittest.mock.mock_open(read_data=None)", "intent": "A helper function to create a `mock` to replace the use of open ( ) . `read_data` is a string for the read ( ) , readline ( ) , and readlines ( ) methods of the file handle to return .", "question_id": 11655}
{"snippet": "unittest.mock.mock_open(mock=None, read_data=None)", "intent": "A helper function to create a `mock` to replace the use of open ( ) . `read_data` is a string for the read ( ) , readline ( ) , and readlines ( ) methods of the file handle to return .", "question_id": 11656}
{"snippet": "unittest.mock.seal(mock)", "intent": "Seal will disable the automatic creation of mocks when accessing an attribute of the `mock` being sealed or any of its attributes that are already mocks recursively .", "question_id": 11657}
{"snippet": "urllib.error.URLError", "intent": "The handlers raise this exception (or derived exceptions) when they run into a problem.", "question_id": 11658}
{"snippet": "non_callable_magic_mock.reason", "intent": "The reason for this error.", "question_id": 11659}
{"snippet": "urllib.error.HTTPError", "intent": "Though being an exception (a subclass of URLError), an HTTPError can also function as a non-exceptional file-like return value (the same thing that urlopen() returns).", "question_id": 11660}
{"snippet": "non_callable_magic_mock.code", "intent": "An HTTP status code as defined in RFC 2616.", "question_id": 11661}
{"snippet": "non_callable_magic_mock.reason", "intent": "This is usually a string explaining the reason for this error.", "question_id": 11662}
{"snippet": "non_callable_magic_mock.headers", "intent": "The HTTP response headers for the HTTP request that caused the HTTPError.", "question_id": 11663}
{"snippet": "urllib.error.ContentTooShortError(msg, content)", "intent": "This exception is raised when the urlretrieve ( ) function detects that the amount of the downloaded data is less than the expected amount ( given by the Content-Length header ) . The `content` attribute stores the downloaded ( and supposedly truncated ) data . With arguments `msg`.", "question_id": 11664}
{"snippet": "urllib.parse.urlparse(urlstring)", "intent": "Parse a URL into six components , returning a 6-item named tuple . It should be the same type ( text or bytes ) as `urlstring` , except that the default value `` is always allowed , and is automatically converted to b '' if appropriate .", "question_id": 11665}
{"snippet": "urllib.parse.urlparse(urlstring, scheme='')", "intent": "Parse a URL into six components , returning a 6-item named tuple . It should be the same type ( text or bytes ) as `urlstring` , except that the default value `` is always allowed , and is automatically converted to b '' if appropriate . This corresponds to the general structure of a URL : `scheme` : //netloc/path ; parameters ? query # fragment .", "question_id": 11666}
{"snippet": "urllib.parse.urlparse(urlstring, allow_fragments=True)", "intent": "Parse a URL into six components , returning a 6-item named tuple . It should be the same type ( text or bytes ) as `urlstring` , except that the default value `` is always allowed , and is automatically converted to b '' if appropriate . If the `allow_fragments` argument is false , fragment identifiers are not recognized .", "question_id": 11667}
{"snippet": "urllib.parse.urlparse(urlstring, scheme='', allow_fragments=True)", "intent": "Parse a URL into six components , returning a 6-item named tuple . It should be the same type ( text or bytes ) as `urlstring` , except that the default value `` is always allowed , and is automatically converted to b '' if appropriate . This corresponds to the general structure of a URL : `scheme` : //netloc/path ; parameters ? query # fragment . If the `allow_fragments` argument is false , fragment identifiers are not recognized .", "question_id": 11668}
{"snippet": "urllib.parse.parse_qs(qs)", "intent": "Parse a query string given as a string argument ( data of type application/x-www-form-urlencoded ) . With arguments `qs`.", "question_id": 11669}
{"snippet": "urllib.parse.parse_qs(qs, keep_blank_values=False)", "intent": "Parse a query string given as a string argument ( data of type application/x-www-form-urlencoded ) . The optional argument `keep_blank_values` is a flag indicating whether blank values in percent-encoded queries should be treated as blank strings . With arguments `qs`.", "question_id": 11670}
{"snippet": "urllib.parse.parse_qs(qs, strict_parsing=False)", "intent": "Parse a query string given as a string argument ( data of type application/x-www-form-urlencoded ) . The optional argument `strict_parsing` is a flag indicating what to do with parsing `errors` . With arguments `qs`.", "question_id": 11671}
{"snippet": "urllib.parse.parse_qs(qs, encoding='utf-8')", "intent": "Parse a query string given as a string argument ( data of type application/x-www-form-urlencoded ) . The optional `encoding` and errors parameters specify how to decode percent-encoded sequences into Unicode characters , as accepted by the bytes.decode ( ) method . With arguments `qs`.", "question_id": 11672}
{"snippet": "urllib.parse.parse_qs(qs, errors='replace')", "intent": "Parse a query string given as a string argument ( data of type application/x-www-form-urlencoded ) . The optional argument `strict_parsing` is a flag indicating what to do with parsing `errors` . With arguments `qs`.", "question_id": 11673}
{"snippet": "urllib.parse.parse_qs(qs, max_num_fields=None)", "intent": "Parse a query string given as a string argument ( data of type application/x-www-form-urlencoded ) . The optional argument `max_num_fields` is the maximum number of fields to read . With arguments `qs`.", "question_id": 11674}
{"snippet": "urllib.parse.parse_qs(qs, keep_blank_values=False, strict_parsing=False)", "intent": "Parse a query string given as a string argument ( data of type application/x-www-form-urlencoded ) . The optional argument `keep_blank_values` is a flag indicating whether blank values in percent-encoded queries should be treated as blank strings . The optional argument `strict_parsing` is a flag indicating what to do with parsing `errors` . With arguments `qs`.", "question_id": 11675}
{"snippet": "urllib.parse.parse_qs(qs, keep_blank_values=False, encoding='utf-8')", "intent": "Parse a query string given as a string argument ( data of type application/x-www-form-urlencoded ) . The optional argument `keep_blank_values` is a flag indicating whether blank values in percent-encoded queries should be treated as blank strings . The optional `encoding` and errors parameters specify how to decode percent-encoded sequences into Unicode characters , as accepted by the bytes.decode ( ) method . With arguments `qs`.", "question_id": 11676}
{"snippet": "urllib.parse.parse_qs(qs, keep_blank_values=False, errors='replace')", "intent": "Parse a query string given as a string argument ( data of type application/x-www-form-urlencoded ) . The optional argument `keep_blank_values` is a flag indicating whether blank values in percent-encoded queries should be treated as blank strings . The optional argument `strict_parsing` is a flag indicating what to do with parsing `errors` . With arguments `qs`.", "question_id": 11677}
{"snippet": "urllib.parse.parse_qs(qs, keep_blank_values=False, max_num_fields=None)", "intent": "Parse a query string given as a string argument ( data of type application/x-www-form-urlencoded ) . The optional argument `keep_blank_values` is a flag indicating whether blank values in percent-encoded queries should be treated as blank strings . The optional argument `max_num_fields` is the maximum number of fields to read . With arguments `qs`.", "question_id": 11678}
{"snippet": "urllib.parse.parse_qsl(qs)", "intent": "Parse a query string given as a string argument ( data of type application/x-www-form-urlencoded ) . With arguments `qs`.", "question_id": 11679}
{"snippet": "urllib.parse.parse_qsl(qs, keep_blank_values=False)", "intent": "Parse a query string given as a string argument ( data of type application/x-www-form-urlencoded ) . The optional argument `keep_blank_values` is a flag indicating whether blank values in percent-encoded queries should be treated as blank strings . With arguments `qs`.", "question_id": 11680}
{"snippet": "urllib.parse.parse_qsl(qs, strict_parsing=False)", "intent": "Parse a query string given as a string argument ( data of type application/x-www-form-urlencoded ) . The optional argument `strict_parsing` is a flag indicating what to do with parsing `errors` . With arguments `qs`.", "question_id": 11681}
{"snippet": "urllib.parse.parse_qsl(qs, encoding='utf-8')", "intent": "Parse a query string given as a string argument ( data of type application/x-www-form-urlencoded ) . The optional `encoding` and errors parameters specify how to decode percent-encoded sequences into Unicode characters , as accepted by the bytes.decode ( ) method . With arguments `qs`.", "question_id": 11682}
{"snippet": "urllib.parse.parse_qsl(qs, errors='replace')", "intent": "Parse a query string given as a string argument ( data of type application/x-www-form-urlencoded ) . The optional argument `strict_parsing` is a flag indicating what to do with parsing `errors` . With arguments `qs`.", "question_id": 11683}
{"snippet": "urllib.parse.parse_qsl(qs, max_num_fields=None)", "intent": "Parse a query string given as a string argument ( data of type application/x-www-form-urlencoded ) . The optional argument `max_num_fields` is the maximum number of fields to read . With arguments `qs`.", "question_id": 11684}
{"snippet": "urllib.parse.parse_qsl(qs, keep_blank_values=False, strict_parsing=False)", "intent": "Parse a query string given as a string argument ( data of type application/x-www-form-urlencoded ) . The optional argument `keep_blank_values` is a flag indicating whether blank values in percent-encoded queries should be treated as blank strings . The optional argument `strict_parsing` is a flag indicating what to do with parsing `errors` . With arguments `qs`.", "question_id": 11685}
{"snippet": "urllib.parse.parse_qsl(qs, keep_blank_values=False, encoding='utf-8')", "intent": "Parse a query string given as a string argument ( data of type application/x-www-form-urlencoded ) . The optional argument `keep_blank_values` is a flag indicating whether blank values in percent-encoded queries should be treated as blank strings . The optional `encoding` and errors parameters specify how to decode percent-encoded sequences into Unicode characters , as accepted by the bytes.decode ( ) method . With arguments `qs`.", "question_id": 11686}
{"snippet": "urllib.parse.parse_qsl(qs, keep_blank_values=False, errors='replace')", "intent": "Parse a query string given as a string argument ( data of type application/x-www-form-urlencoded ) . The optional argument `keep_blank_values` is a flag indicating whether blank values in percent-encoded queries should be treated as blank strings . The optional argument `strict_parsing` is a flag indicating what to do with parsing `errors` . With arguments `qs`.", "question_id": 11687}
{"snippet": "urllib.parse.parse_qsl(qs, keep_blank_values=False, max_num_fields=None)", "intent": "Parse a query string given as a string argument ( data of type application/x-www-form-urlencoded ) . The optional argument `keep_blank_values` is a flag indicating whether blank values in percent-encoded queries should be treated as blank strings . The optional argument `max_num_fields` is the maximum number of fields to read . With arguments `qs`.", "question_id": 11688}
{"snippet": "urllib.parse.urlunparse(parts)", "intent": "Construct a URL from a tuple as returned by urlparse ( ) . The `parts` argument can be any six-item iterable .", "question_id": 11689}
{"snippet": "urllib.parse.urlsplit(urlstring)", "intent": "This is similar to urlparse ( ) , but does not split the params from the URL . With arguments `urlstring`.", "question_id": 11690}
{"snippet": "urllib.parse.urlsplit(urlstring, scheme='')", "intent": "This is similar to urlparse ( ) , but does not split the params from the URL . With arguments `urlstring`, `scheme`.", "question_id": 11691}
{"snippet": "urllib.parse.urlsplit(urlstring, allow_fragments=True)", "intent": "This is similar to urlparse ( ) , but does not split the params from the URL . With arguments `urlstring`, `allow_fragments`.", "question_id": 11692}
{"snippet": "urllib.parse.urlsplit(urlstring, scheme='', allow_fragments=True)", "intent": "This is similar to urlparse ( ) , but does not split the params from the URL . With arguments `urlstring`, `scheme`, `allow_fragments`.", "question_id": 11693}
{"snippet": "urllib.parse.urlunsplit(parts)", "intent": "Combine the elements of a tuple as returned by urlsplit ( ) into a complete URL as a string . The `parts` argument can be any five-item iterable .", "question_id": 11694}
{"snippet": "urllib.parse.urljoin(base, url)", "intent": "Construct a full ( \u201c absolute \u201d ) URL by combining a \u201c `base` URL \u201d ( base ) with another URL ( `url` ) .", "question_id": 11695}
{"snippet": "urllib.parse.urljoin(base, url, allow_fragments=True)", "intent": "Construct a full ( \u201c absolute \u201d ) URL by combining a \u201c `base` URL \u201d ( base ) with another URL ( `url` ) . The `allow_fragments` argument has the same meaning and default as for urlparse ( ) .", "question_id": 11696}
{"snippet": "urllib.parse.urldefrag(url)", "intent": "If `url` contains a fragment identifier , return a modified version of url with no fragment identifier , and the fragment identifier as a separate string .", "question_id": 11697}
{"snippet": "urllib.parse.SplitResult.geturl()", "intent": "Return the re-combined version of the original URL as a string .", "question_id": 11698}
{"snippet": "urllib.parse.DefragResult(url, fragment)", "intent": "Concrete class for urldefrag ( ) results containing str data . With arguments `url`, `fragment`.", "question_id": 11699}
{"snippet": "urllib.parse.ParseResult(scheme, netloc, path, params, query, fragment)", "intent": "Concrete class for urlparse ( ) results containing str data . With arguments `scheme`, `netloc`, `path`, `params`, `query`, `fragment`.", "question_id": 11700}
{"snippet": "urllib.parse.SplitResult(scheme, netloc, path, query, fragment)", "intent": "Concrete class for urlsplit ( ) results containing str data . With arguments `scheme`, `netloc`, `path`, `query`, `fragment`.", "question_id": 11701}
{"snippet": "urllib.parse.DefragResultBytes(url, fragment)", "intent": "Concrete class for urldefrag ( ) results containing bytes data . With arguments `url`, `fragment`.", "question_id": 11702}
{"snippet": "urllib.parse.ParseResultBytes(scheme, netloc, path, params, query, fragment)", "intent": "Concrete class for urlparse ( ) results containing bytes data . With arguments `scheme`, `netloc`, `path`, `params`, `query`, `fragment`.", "question_id": 11703}
{"snippet": "urllib.parse.SplitResultBytes(scheme, netloc, path, query, fragment)", "intent": "Concrete class for urlsplit ( ) results containing bytes data . With arguments `scheme`, `netloc`, `path`, `query`, `fragment`.", "question_id": 11704}
{"snippet": "urllib.parse.quote(string)", "intent": "Replace special characters in `string` using the % xx escape .", "question_id": 11705}
{"snippet": "urllib.parse.quote(string, safe='/')", "intent": "Replace special characters in `string` using the % xx escape . The optional `safe` parameter specifies additional ASCII characters that should not be quoted \u2014 its default value is '/ ' .", "question_id": 11706}
{"snippet": "urllib.parse.quote(string, encoding=None)", "intent": "Replace special characters in `string` using the % xx escape . The optional `encoding` and `errors` parameters specify how to deal with non-ASCII characters , as accepted by the str.encode ( ) method .", "question_id": 11707}
{"snippet": "urllib.parse.quote(string, errors=None)", "intent": "Replace special characters in `string` using the % xx escape . The optional `encoding` and `errors` parameters specify how to deal with non-ASCII characters , as accepted by the str.encode ( ) method .", "question_id": 11708}
{"snippet": "urllib.parse.quote(string, safe='/', encoding=None)", "intent": "Replace special characters in `string` using the % xx escape . The optional `safe` parameter specifies additional ASCII characters that should not be quoted \u2014 its default value is '/ ' . The optional `encoding` and `errors` parameters specify how to deal with non-ASCII characters , as accepted by the str.encode ( ) method .", "question_id": 11709}
{"snippet": "urllib.parse.quote(string, safe='/', errors=None)", "intent": "Replace special characters in `string` using the % xx escape . The optional `safe` parameter specifies additional ASCII characters that should not be quoted \u2014 its default value is '/ ' . The optional `encoding` and `errors` parameters specify how to deal with non-ASCII characters , as accepted by the str.encode ( ) method .", "question_id": 11710}
{"snippet": "urllib.parse.quote(string, encoding=None, errors=None)", "intent": "Replace special characters in `string` using the % xx escape . The optional `encoding` and `errors` parameters specify how to deal with non-ASCII characters , as accepted by the str.encode ( ) method .", "question_id": 11711}
{"snippet": "urllib.parse.quote(string, safe='/', encoding=None, errors=None)", "intent": "Replace special characters in `string` using the % xx escape . The optional `safe` parameter specifies additional ASCII characters that should not be quoted \u2014 its default value is '/ ' . The optional `encoding` and `errors` parameters specify how to deal with non-ASCII characters , as accepted by the str.encode ( ) method .", "question_id": 11712}
{"snippet": "urllib.parse.quote_plus(string)", "intent": "Like quote ( ) , but also replace spaces by plus signs , as required for quoting HTML form values when building up a query `string` to go into a URL .", "question_id": 11713}
{"snippet": "urllib.parse.quote_plus(string, safe='')", "intent": "Like quote ( ) , but also replace spaces by plus signs , as required for quoting HTML form values when building up a query `string` to go into a URL . Plus signs in the original string are escaped unless they are included in `safe` .", "question_id": 11714}
{"snippet": "urllib.parse.quote_plus(string, encoding=None)", "intent": "Like quote ( ) , but also replace spaces by plus signs , as required for quoting HTML form values when building up a query `string` to go into a URL . With arguments `encoding`.", "question_id": 11715}
{"snippet": "urllib.parse.quote_plus(string, errors=None)", "intent": "Like quote ( ) , but also replace spaces by plus signs , as required for quoting HTML form values when building up a query `string` to go into a URL . With arguments `errors`.", "question_id": 11716}
{"snippet": "urllib.parse.quote_plus(string, safe='', encoding=None)", "intent": "Like quote ( ) , but also replace spaces by plus signs , as required for quoting HTML form values when building up a query `string` to go into a URL . Plus signs in the original string are escaped unless they are included in `safe` . With arguments `encoding`.", "question_id": 11717}
{"snippet": "urllib.parse.quote_plus(string, safe='', errors=None)", "intent": "Like quote ( ) , but also replace spaces by plus signs , as required for quoting HTML form values when building up a query `string` to go into a URL . Plus signs in the original string are escaped unless they are included in `safe` . With arguments `errors`.", "question_id": 11718}
{"snippet": "urllib.parse.quote_plus(string, encoding=None, errors=None)", "intent": "Like quote ( ) , but also replace spaces by plus signs , as required for quoting HTML form values when building up a query `string` to go into a URL . With arguments `encoding`, `errors`.", "question_id": 11719}
{"snippet": "urllib.parse.quote_plus(string, safe='', encoding=None, errors=None)", "intent": "Like quote ( ) , but also replace spaces by plus signs , as required for quoting HTML form values when building up a query `string` to go into a URL . Plus signs in the original string are escaped unless they are included in `safe` . With arguments `encoding`, `errors`.", "question_id": 11720}
{"snippet": "urllib.parse.quote_from_bytes(bytes)", "intent": "Like quote ( ) , but accepts a `bytes` object rather than a str , and does not perform string-to-bytes encoding .", "question_id": 11721}
{"snippet": "urllib.parse.quote_from_bytes(bytes, safe='/')", "intent": "Like quote ( ) , but accepts a `bytes` object rather than a str , and does not perform string-to-bytes encoding . With arguments `safe`.", "question_id": 11722}
{"snippet": "urllib.parse.unquote(string)", "intent": "Replace % xx escapes by their single-character equivalent . `string` must be a str .", "question_id": 11723}
{"snippet": "urllib.parse.unquote(string, encoding='utf-8')", "intent": "Replace % xx escapes by their single-character equivalent . `string` must be a str . The optional `encoding` and `errors` parameters specify how to decode percent-encoded sequences into Unicode characters , as accepted by the bytes.decode ( ) method .", "question_id": 11724}
{"snippet": "urllib.parse.unquote(string, errors='replace')", "intent": "Replace % xx escapes by their single-character equivalent . `string` must be a str . The optional `encoding` and `errors` parameters specify how to decode percent-encoded sequences into Unicode characters , as accepted by the bytes.decode ( ) method .", "question_id": 11725}
{"snippet": "urllib.parse.unquote(string, encoding='utf-8', errors='replace')", "intent": "Replace % xx escapes by their single-character equivalent . `string` must be a str . The optional `encoding` and `errors` parameters specify how to decode percent-encoded sequences into Unicode characters , as accepted by the bytes.decode ( ) method .", "question_id": 11726}
{"snippet": "urllib.parse.unquote_plus(string)", "intent": "Like unquote ( ) , but also replace plus signs by spaces , as required for unquoting HTML form values . `string` must be a str .", "question_id": 11727}
{"snippet": "urllib.parse.unquote_plus(string, encoding='utf-8')", "intent": "Like unquote ( ) , but also replace plus signs by spaces , as required for unquoting HTML form values . `string` must be a str . With arguments `encoding`.", "question_id": 11728}
{"snippet": "urllib.parse.unquote_plus(string, errors='replace')", "intent": "Like unquote ( ) , but also replace plus signs by spaces , as required for unquoting HTML form values . `string` must be a str . With arguments `errors`.", "question_id": 11729}
{"snippet": "urllib.parse.unquote_plus(string, encoding='utf-8', errors='replace')", "intent": "Like unquote ( ) , but also replace plus signs by spaces , as required for unquoting HTML form values . `string` must be a str . With arguments `encoding`, `errors`.", "question_id": 11730}
{"snippet": "urllib.parse.unquote_to_bytes(string)", "intent": "Replace % xx escapes by their single-octet equivalent , and return a bytes object . `string` may be either a str or a bytes .", "question_id": 11731}
{"snippet": "urllib.parse.urlencode(query)", "intent": "Convert a mapping object or a sequence of two-element tuples , which may contain str or bytes objects , to a percent-encoded ASCII text string . When a sequence of two-element tuples is used as the `query` argument , the first element of each tuple is a key and the second is a value .", "question_id": 11732}
{"snippet": "urllib.parse.urlencode(query, doseq=False)", "intent": "Convert a mapping object or a sequence of two-element tuples , which may contain str or bytes objects , to a percent-encoded ASCII text string . When a sequence of two-element tuples is used as the `query` argument , the first element of each tuple is a key and the second is a value . The value element in itself can be a sequence and in that case , if the optional parameter `doseq` is evaluates to True , individual key=value pairs separated by ' & ' are generated for each element of the value sequence for the key .", "question_id": 11733}
{"snippet": "urllib.parse.urlencode(query, safe='')", "intent": "Convert a mapping object or a sequence of two-element tuples , which may contain str or bytes objects , to a percent-encoded ASCII text string . When a sequence of two-element tuples is used as the `query` argument , the first element of each tuple is a key and the second is a value . For maximum control of what is quoted , use quote and specify a value for `safe` .", "question_id": 11734}
{"snippet": "urllib.parse.urlencode(query, encoding=None)", "intent": "Convert a mapping object or a sequence of two-element tuples , which may contain str or bytes objects , to a percent-encoded ASCII text string . When a sequence of two-element tuples is used as the `query` argument , the first element of each tuple is a key and the second is a value . The safe , `encoding` , and `errors` parameters are passed down to quote_via ( the encoding and errors parameters are only passed when a query element is a str ) .", "question_id": 11735}
{"snippet": "urllib.parse.urlencode(query, errors=None)", "intent": "Convert a mapping object or a sequence of two-element tuples , which may contain str or bytes objects , to a percent-encoded ASCII text string . When a sequence of two-element tuples is used as the `query` argument , the first element of each tuple is a key and the second is a value . The safe , `encoding` , and `errors` parameters are passed down to quote_via ( the encoding and errors parameters are only passed when a query element is a str ) .", "question_id": 11736}
{"snippet": "urllib.parse.urlencode(query, quote_via=quote_plus)", "intent": "Convert a mapping object or a sequence of two-element tuples , which may contain str or bytes objects , to a percent-encoded ASCII text string . When a sequence of two-element tuples is used as the `query` argument , the first element of each tuple is a key and the second is a value . The resulting string is a series of key=value pairs separated by ' & ' characters , where both key and value are quoted using the `quote_via` function .", "question_id": 11737}
{"snippet": "urllib.parse.urlencode(query, doseq=False, safe='')", "intent": "Convert a mapping object or a sequence of two-element tuples , which may contain str or bytes objects , to a percent-encoded ASCII text string . When a sequence of two-element tuples is used as the `query` argument , the first element of each tuple is a key and the second is a value . The value element in itself can be a sequence and in that case , if the optional parameter `doseq` is evaluates to True , individual key=value pairs separated by ' & ' are generated for each element of the value sequence for the key . For maximum control of what is quoted , use quote and specify a value for `safe` .", "question_id": 11738}
{"snippet": "urllib.parse.urlencode(query, doseq=False, encoding=None)", "intent": "Convert a mapping object or a sequence of two-element tuples , which may contain str or bytes objects , to a percent-encoded ASCII text string . When a sequence of two-element tuples is used as the `query` argument , the first element of each tuple is a key and the second is a value . The value element in itself can be a sequence and in that case , if the optional parameter `doseq` is evaluates to True , individual key=value pairs separated by ' & ' are generated for each element of the value sequence for the key . The safe , `encoding` , and `errors` parameters are passed down to quote_via ( the encoding and errors parameters are only passed when a query element is a str ) .", "question_id": 11739}
{"snippet": "urllib.parse.urlencode(query, doseq=False, errors=None)", "intent": "Convert a mapping object or a sequence of two-element tuples , which may contain str or bytes objects , to a percent-encoded ASCII text string . When a sequence of two-element tuples is used as the `query` argument , the first element of each tuple is a key and the second is a value . The value element in itself can be a sequence and in that case , if the optional parameter `doseq` is evaluates to True , individual key=value pairs separated by ' & ' are generated for each element of the value sequence for the key . The safe , `encoding` , and `errors` parameters are passed down to quote_via ( the encoding and errors parameters are only passed when a query element is a str ) .", "question_id": 11740}
{"snippet": "urllib.parse.urlencode(query, doseq=False, quote_via=quote_plus)", "intent": "Convert a mapping object or a sequence of two-element tuples , which may contain str or bytes objects , to a percent-encoded ASCII text string . When a sequence of two-element tuples is used as the `query` argument , the first element of each tuple is a key and the second is a value . The value element in itself can be a sequence and in that case , if the optional parameter `doseq` is evaluates to True , individual key=value pairs separated by ' & ' are generated for each element of the value sequence for the key . The resulting string is a series of key=value pairs separated by ' & ' characters , where both key and value are quoted using the `quote_via` function .", "question_id": 11741}
{"snippet": "urllib.request.urlopen(url, timeout)", "intent": "Open the URL `url` , which can be either a string or a Request object . The optional `timeout` parameter specifies a timeout in seconds for blocking operations like the connection attempt ( if not specified , the global default timeout setting will be used ) .", "question_id": 11742}
{"snippet": "urllib.request.urlopen(url, timeout, data=None)", "intent": "Open the URL `url` , which can be either a string or a Request object . The optional `timeout` parameter specifies a timeout in seconds for blocking operations like the connection attempt ( if not specified , the global default timeout setting will be used ) . `data` must be an object specifying additional data to be sent to the server , or None if no such data is needed .", "question_id": 11743}
{"snippet": "urllib.request.urlopen(url, timeout, cafile=None)", "intent": "Open the URL `url` , which can be either a string or a Request object . The optional `timeout` parameter specifies a timeout in seconds for blocking operations like the connection attempt ( if not specified , the global default timeout setting will be used ) . The optional `cafile` and `capath` parameters specify a set of trusted CA certificates for HTTPS requests .", "question_id": 11744}
{"snippet": "urllib.request.urlopen(url, timeout, capath=None)", "intent": "Open the URL `url` , which can be either a string or a Request object . The optional `timeout` parameter specifies a timeout in seconds for blocking operations like the connection attempt ( if not specified , the global default timeout setting will be used ) . The optional `cafile` and `capath` parameters specify a set of trusted CA certificates for HTTPS requests .", "question_id": 11745}
{"snippet": "urllib.request.urlopen(url, timeout, cadefault=False)", "intent": "Open the URL `url` , which can be either a string or a Request object . The optional `timeout` parameter specifies a timeout in seconds for blocking operations like the connection attempt ( if not specified , the global default timeout setting will be used ) . The `cadefault` parameter is ignored .", "question_id": 11746}
{"snippet": "urllib.request.urlopen(url, timeout, context=None)", "intent": "Open the URL `url` , which can be either a string or a Request object . The optional `timeout` parameter specifies a timeout in seconds for blocking operations like the connection attempt ( if not specified , the global default timeout setting will be used ) . If `context` is specified , it must be a ssl.SSLContext instance describing the various SSL options .", "question_id": 11747}
{"snippet": "urllib.request.urlopen(url, timeout, data=None, cafile=None)", "intent": "Open the URL `url` , which can be either a string or a Request object . The optional `timeout` parameter specifies a timeout in seconds for blocking operations like the connection attempt ( if not specified , the global default timeout setting will be used ) . `data` must be an object specifying additional data to be sent to the server , or None if no such data is needed . The optional `cafile` and `capath` parameters specify a set of trusted CA certificates for HTTPS requests .", "question_id": 11748}
{"snippet": "urllib.request.urlopen(url, timeout, data=None, capath=None)", "intent": "Open the URL `url` , which can be either a string or a Request object . The optional `timeout` parameter specifies a timeout in seconds for blocking operations like the connection attempt ( if not specified , the global default timeout setting will be used ) . `data` must be an object specifying additional data to be sent to the server , or None if no such data is needed . The optional `cafile` and `capath` parameters specify a set of trusted CA certificates for HTTPS requests .", "question_id": 11749}
{"snippet": "urllib.request.urlopen(url, timeout, data=None, cadefault=False)", "intent": "Open the URL `url` , which can be either a string or a Request object . The optional `timeout` parameter specifies a timeout in seconds for blocking operations like the connection attempt ( if not specified , the global default timeout setting will be used ) . `data` must be an object specifying additional data to be sent to the server , or None if no such data is needed . The `cadefault` parameter is ignored .", "question_id": 11750}
{"snippet": "urllib.request.urlopen(url, timeout, data=None, context=None)", "intent": "Open the URL `url` , which can be either a string or a Request object . The optional `timeout` parameter specifies a timeout in seconds for blocking operations like the connection attempt ( if not specified , the global default timeout setting will be used ) . `data` must be an object specifying additional data to be sent to the server , or None if no such data is needed . If `context` is specified , it must be a ssl.SSLContext instance describing the various SSL options .", "question_id": 11751}
{"snippet": "urllib.request.urlopen(url)", "intent": "Open the URL `url` , which can be either a string or a Request object .", "question_id": 11752}
{"snippet": "urllib.request.urlopen(url, data=None)", "intent": "Open the URL `url` , which can be either a string or a Request object . `data` must be an object specifying additional data to be sent to the server , or None if no such data is needed .", "question_id": 11753}
{"snippet": "urllib.request.urlopen(url, cafile=None)", "intent": "Open the URL `url` , which can be either a string or a Request object . The optional `cafile` and `capath` parameters specify a set of trusted CA certificates for HTTPS requests .", "question_id": 11754}
{"snippet": "urllib.request.urlopen(url, capath=None)", "intent": "Open the URL `url` , which can be either a string or a Request object . The optional `cafile` and `capath` parameters specify a set of trusted CA certificates for HTTPS requests .", "question_id": 11755}
{"snippet": "urllib.request.urlopen(url, cadefault=False)", "intent": "Open the URL `url` , which can be either a string or a Request object . The `cadefault` parameter is ignored .", "question_id": 11756}
{"snippet": "urllib.request.urlopen(url, context=None)", "intent": "Open the URL `url` , which can be either a string or a Request object . If `context` is specified , it must be a ssl.SSLContext instance describing the various SSL options .", "question_id": 11757}
{"snippet": "urllib.request.urlopen(url, data=None, cafile=None)", "intent": "Open the URL `url` , which can be either a string or a Request object . `data` must be an object specifying additional data to be sent to the server , or None if no such data is needed . The optional `cafile` and `capath` parameters specify a set of trusted CA certificates for HTTPS requests .", "question_id": 11758}
{"snippet": "urllib.request.urlopen(url, data=None, capath=None)", "intent": "Open the URL `url` , which can be either a string or a Request object . `data` must be an object specifying additional data to be sent to the server , or None if no such data is needed . The optional `cafile` and `capath` parameters specify a set of trusted CA certificates for HTTPS requests .", "question_id": 11759}
{"snippet": "urllib.request.urlopen(url, data=None, cadefault=False)", "intent": "Open the URL `url` , which can be either a string or a Request object . `data` must be an object specifying additional data to be sent to the server , or None if no such data is needed . The `cadefault` parameter is ignored .", "question_id": 11760}
{"snippet": "urllib.request.urlopen(url, data=None, context=None)", "intent": "Open the URL `url` , which can be either a string or a Request object . `data` must be an object specifying additional data to be sent to the server , or None if no such data is needed . If `context` is specified , it must be a ssl.SSLContext instance describing the various SSL options .", "question_id": 11761}
{"snippet": "urllib.request.install_opener(opener)", "intent": "Install an OpenerDirector instance as the default global `opener` .", "question_id": 11762}
{"snippet": "urllib.request.build_opener(handler)", "intent": "Return an OpenerDirector instance , which chains the handlers in the order given . With arguments `handler`.", "question_id": 11763}
{"snippet": "urllib.request.build_opener()", "intent": "Return an OpenerDirector instance , which chains the handlers in the order given .", "question_id": 11764}
{"snippet": "urllib.request.pathname2url(path)", "intent": "Convert the pathname `path` from the local syntax for a path to the form used in the path component of a URL .", "question_id": 11765}
{"snippet": "urllib.request.url2pathname(path)", "intent": "Convert the `path` component path from a percent-encoded URL to the local syntax for a path .", "question_id": 11766}
{"snippet": "urllib.request.getproxies()", "intent": "This helper function returns a dictionary of scheme to proxy server URL mappings .", "question_id": 11767}
{"snippet": "urllib.request.Request(url)", "intent": "This class is an abstraction of a URL request . `url` should be a string containing a valid URL .", "question_id": 11768}
{"snippet": "urllib.request.Request(url, data=None)", "intent": "This class is an abstraction of a URL request . `url` should be a string containing a valid URL . `data` must be an object specifying additional data to send to the server , or None if no such data is needed .", "question_id": 11769}
{"snippet": "urllib.request.Request(url, headers={})", "intent": "This class is an abstraction of a URL request . `url` should be a string containing a valid URL . If no Content-Length nor Transfer-Encoding header field has been provided , HTTPHandler will set these `headers` according to the type of data .", "question_id": 11770}
{"snippet": "urllib.request.Request(url, origin_req_host=None)", "intent": "This class is an abstraction of a URL request . `url` should be a string containing a valid URL . `origin_req_host` should be the request-host of the origin transaction , as defined by RFC 2965 .", "question_id": 11771}
{"snippet": "urllib.request.Request(url, unverifiable=False)", "intent": "This class is an abstraction of a URL request . `url` should be a string containing a valid URL . `unverifiable` should indicate whether the request is unverifiable , as defined by RFC 2965 .", "question_id": 11772}
{"snippet": "urllib.request.Request(url, method=None)", "intent": "This class is an abstraction of a URL request . `url` should be a string containing a valid URL . For an HTTP POST request `method` , data should be a buffer in the standard application/x-www-form-urlencoded format .", "question_id": 11773}
{"snippet": "urllib.request.Request(url, data=None, headers={})", "intent": "This class is an abstraction of a URL request . `url` should be a string containing a valid URL . `data` must be an object specifying additional data to send to the server , or None if no such data is needed . If no Content-Length nor Transfer-Encoding header field has been provided , HTTPHandler will set these `headers` according to the type of data .", "question_id": 11774}
{"snippet": "urllib.request.Request(url, data=None, origin_req_host=None)", "intent": "This class is an abstraction of a URL request . `url` should be a string containing a valid URL . `data` must be an object specifying additional data to send to the server , or None if no such data is needed . `origin_req_host` should be the request-host of the origin transaction , as defined by RFC 2965 .", "question_id": 11775}
{"snippet": "urllib.request.Request(url, data=None, unverifiable=False)", "intent": "This class is an abstraction of a URL request . `url` should be a string containing a valid URL . `data` must be an object specifying additional data to send to the server , or None if no such data is needed . `unverifiable` should indicate whether the request is unverifiable , as defined by RFC 2965 .", "question_id": 11776}
{"snippet": "urllib.request.Request(url, data=None, method=None)", "intent": "This class is an abstraction of a URL request . `url` should be a string containing a valid URL . `data` must be an object specifying additional data to send to the server , or None if no such data is needed . For an HTTP POST request `method` , data should be a buffer in the standard application/x-www-form-urlencoded format .", "question_id": 11777}
{"snippet": "urllib.request.OpenerDirector", "intent": "The OpenerDirector class opens URLs via BaseHandlers chained together.", "question_id": 11778}
{"snippet": "urllib.request.BaseHandler", "intent": "This is the base class for all registered handlers \u2014 and handles only the simple mechanics of registration.", "question_id": 11779}
{"snippet": "urllib.request.HTTPDefaultErrorHandler", "intent": "A class which defines a default handler for HTTP error responses; all responses are turned into HTTPError exceptions.", "question_id": 11780}
{"snippet": "urllib.request.HTTPRedirectHandler", "intent": "A class to handle redirections.", "question_id": 11781}
{"snippet": "urllib.request.HTTPCookieProcessor()", "intent": "A class to handle HTTP Cookies .", "question_id": 11782}
{"snippet": "urllib.request.HTTPCookieProcessor(cookiejar=None)", "intent": "A class to handle HTTP Cookies . With arguments `cookiejar`.", "question_id": 11783}
{"snippet": "urllib.request.ProxyHandler()", "intent": "Cause requests to go through a proxy .", "question_id": 11784}
{"snippet": "urllib.request.ProxyHandler(proxies=None)", "intent": "Cause requests to go through a proxy . If `proxies` is given , it must be a dictionary mapping protocol names to URLs of proxies .", "question_id": 11785}
{"snippet": "urllib.request.HTTPPasswordMgr", "intent": "Keep a database of  (realm, uri) -> (user, password) mappings.", "question_id": 11786}
{"snippet": "urllib.request.HTTPPasswordMgrWithDefaultRealm", "intent": "Keep a database of  (realm, uri) -> (user, password) mappings.", "question_id": 11787}
{"snippet": "urllib.request.HTTPPasswordMgrWithPriorAuth", "intent": "A variant of HTTPPasswordMgrWithDefaultRealm that also has a database of uri -> is_authenticated mappings.", "question_id": 11788}
{"snippet": "urllib.request.AbstractBasicAuthHandler()", "intent": "This is a mixin class that helps with HTTP authentication , both to the remote host and to a proxy .", "question_id": 11789}
{"snippet": "urllib.request.AbstractBasicAuthHandler(password_mgr=None)", "intent": "This is a mixin class that helps with HTTP authentication , both to the remote host and to a proxy . `password_mgr` , if given , should be something that is compatible with HTTPPasswordMgr ; refer to section HTTPPasswordMgr Objects for information on the interface that must be supported .", "question_id": 11790}
{"snippet": "urllib.request.HTTPBasicAuthHandler()", "intent": "Handle authentication with the remote host .", "question_id": 11791}
{"snippet": "urllib.request.HTTPBasicAuthHandler(password_mgr=None)", "intent": "Handle authentication with the remote host . `password_mgr` , if given , should be something that is compatible with HTTPPasswordMgr ; refer to section HTTPPasswordMgr Objects for information on the interface that must be supported .", "question_id": 11792}
{"snippet": "urllib.request.ProxyBasicAuthHandler()", "intent": "Handle authentication with the proxy .", "question_id": 11793}
{"snippet": "urllib.request.ProxyBasicAuthHandler(password_mgr=None)", "intent": "Handle authentication with the proxy . `password_mgr` , if given , should be something that is compatible with HTTPPasswordMgr ; refer to section HTTPPasswordMgr Objects for information on the interface that must be supported .", "question_id": 11794}
{"snippet": "urllib.request.AbstractDigestAuthHandler()", "intent": "This is a mixin class that helps with HTTP authentication , both to the remote host and to a proxy .", "question_id": 11795}
{"snippet": "urllib.request.AbstractDigestAuthHandler(password_mgr=None)", "intent": "This is a mixin class that helps with HTTP authentication , both to the remote host and to a proxy . `password_mgr` , if given , should be something that is compatible with HTTPPasswordMgr ; refer to section HTTPPasswordMgr Objects for information on the interface that must be supported .", "question_id": 11796}
{"snippet": "urllib.request.HTTPDigestAuthHandler()", "intent": "Handle authentication with the remote host .", "question_id": 11797}
{"snippet": "urllib.request.HTTPDigestAuthHandler(password_mgr=None)", "intent": "Handle authentication with the remote host . `password_mgr` , if given , should be something that is compatible with HTTPPasswordMgr ; refer to section HTTPPasswordMgr Objects for information on the interface that must be supported .", "question_id": 11798}
{"snippet": "urllib.request.ProxyDigestAuthHandler()", "intent": "Handle authentication with the proxy .", "question_id": 11799}
{"snippet": "urllib.request.ProxyDigestAuthHandler(password_mgr=None)", "intent": "Handle authentication with the proxy . `password_mgr` , if given , should be something that is compatible with HTTPPasswordMgr ; refer to section HTTPPasswordMgr Objects for information on the interface that must be supported .", "question_id": 11800}
{"snippet": "urllib.request.HTTPHandler", "intent": "A class to handle opening of HTTP URLs.", "question_id": 11801}
{"snippet": "urllib.request.HTTPSHandler()", "intent": "A class to handle opening of HTTPS URLs .", "question_id": 11802}
{"snippet": "urllib.request.HTTPSHandler(debuglevel=0)", "intent": "A class to handle opening of HTTPS URLs . With arguments `debuglevel`.", "question_id": 11803}
{"snippet": "urllib.request.HTTPSHandler(context=None)", "intent": "A class to handle opening of HTTPS URLs . `context` and `check_hostname` have the same meaning as in http.client.HTTPSConnection .", "question_id": 11804}
{"snippet": "urllib.request.HTTPSHandler(check_hostname=None)", "intent": "A class to handle opening of HTTPS URLs . `context` and `check_hostname` have the same meaning as in http.client.HTTPSConnection .", "question_id": 11805}
{"snippet": "urllib.request.HTTPSHandler(debuglevel=0, context=None)", "intent": "A class to handle opening of HTTPS URLs . `context` and `check_hostname` have the same meaning as in http.client.HTTPSConnection . With arguments `debuglevel`.", "question_id": 11806}
{"snippet": "urllib.request.HTTPSHandler(debuglevel=0, check_hostname=None)", "intent": "A class to handle opening of HTTPS URLs . `context` and `check_hostname` have the same meaning as in http.client.HTTPSConnection . With arguments `debuglevel`.", "question_id": 11807}
{"snippet": "urllib.request.HTTPSHandler(context=None, check_hostname=None)", "intent": "A class to handle opening of HTTPS URLs . `context` and `check_hostname` have the same meaning as in http.client.HTTPSConnection .", "question_id": 11808}
{"snippet": "urllib.request.HTTPSHandler(debuglevel=0, context=None, check_hostname=None)", "intent": "A class to handle opening of HTTPS URLs . `context` and `check_hostname` have the same meaning as in http.client.HTTPSConnection . With arguments `debuglevel`.", "question_id": 11809}
{"snippet": "urllib.request.FileHandler", "intent": "Open local files.", "question_id": 11810}
{"snippet": "urllib.request.DataHandler", "intent": "Open data URLs.", "question_id": 11811}
{"snippet": "urllib.request.FTPHandler", "intent": "Open FTP URLs.", "question_id": 11812}
{"snippet": "urllib.request.CacheFTPHandler", "intent": "Open FTP URLs, keeping a cache of open FTP connections to minimize delays.", "question_id": 11813}
{"snippet": "urllib.request.UnknownHandler", "intent": "A catch-all class to handle unknown URLs.", "question_id": 11814}
{"snippet": "urllib.request.HTTPErrorProcessor", "intent": "Process HTTP error responses.", "question_id": 11815}
{"snippet": "Request.full_url", "intent": "The original URL passed to the constructor.", "question_id": 11816}
{"snippet": "Request.type", "intent": "The URI scheme.", "question_id": 11817}
{"snippet": "Request.host", "intent": "The URI authority, typically a host, but may also contain a port separated by a colon.", "question_id": 11818}
{"snippet": "Request.origin_req_host", "intent": "The original host for the request, without port.", "question_id": 11819}
{"snippet": "Request.selector", "intent": "The URI path.", "question_id": 11820}
{"snippet": "Request.data", "intent": "The entity body for the request, or None if not specified.", "question_id": 11821}
{"snippet": "Request.unverifiable", "intent": "boolean, indicates whether the request is unverifiable as defined by RFC 2965.", "question_id": 11822}
{"snippet": "Request.method", "intent": "The HTTP request method to use.", "question_id": 11823}
{"snippet": "Request.get_method()", "intent": "Return a string indicating the HTTP request method .", "question_id": 11824}
{"snippet": "Request.add_header(key, val)", "intent": "Add another header to the request . Note that there can not be more than one header with the same name , and later calls will overwrite previous calls in case the `key` collides . With arguments `val`.", "question_id": 11825}
{"snippet": "Request.add_unredirected_header(key, header)", "intent": "Add a `header` that will not be added to a redirected request . With arguments `key`.", "question_id": 11826}
{"snippet": "Request.has_header(header)", "intent": "Return whether the instance has the named `header` ( checks both regular and unredirected ) .", "question_id": 11827}
{"snippet": "Request.remove_header(header)", "intent": "Remove named `header` from the request instance ( both from regular and unredirected headers ) .", "question_id": 11828}
{"snippet": "Request.get_full_url()", "intent": "Return the URL given in the constructor .", "question_id": 11829}
{"snippet": "Request.set_proxy(host, type)", "intent": "Prepare the request by connecting to a proxy server . The `host` and `type` will replace those of the instance , and the instance \u2019 s selector will be the original URL given in the constructor .", "question_id": 11830}
{"snippet": "Request.get_header(header_name)", "intent": "Return the value of the given header . With arguments `header_name`.", "question_id": 11831}
{"snippet": "Request.get_header(header_name, default=None)", "intent": "Return the value of the given header . If the header is not present , return the `default` value . With arguments `header_name`.", "question_id": 11832}
{"snippet": "Request.header_items()", "intent": "Return a list of tuples ( header_name , header_value ) of the Request headers .", "question_id": 11833}
{"snippet": "OpenerDirector.add_handler(handler)", "intent": "`handler` should be an instance of BaseHandler .", "question_id": 11834}
{"snippet": "OpenerDirector.open(url, timeout)", "intent": "Open the given `url` ( which can be a request object or a string ) , optionally passing the given `data` . The optional `timeout` parameter specifies a timeout in seconds for blocking operations like the connection attempt ( if not specified , the global default timeout setting will be used ) .", "question_id": 11835}
{"snippet": "OpenerDirector.open(url, timeout, data=None)", "intent": "Open the given `url` ( which can be a request object or a string ) , optionally passing the given `data` . The optional `timeout` parameter specifies a timeout in seconds for blocking operations like the connection attempt ( if not specified , the global default timeout setting will be used ) .", "question_id": 11836}
{"snippet": "OpenerDirector.open(url)", "intent": "Open the given `url` ( which can be a request object or a string ) , optionally passing the given `data` .", "question_id": 11837}
{"snippet": "OpenerDirector.open(url, data=None)", "intent": "Open the given `url` ( which can be a request object or a string ) , optionally passing the given `data` .", "question_id": 11838}
{"snippet": "OpenerDirector.error(proto, *args)", "intent": "Handle an error of the given protocol . With arguments `proto`, `*args`.", "question_id": 11839}
{"snippet": "BaseHandler.add_parent(director)", "intent": "Add a `director` as parent .", "question_id": 11840}
{"snippet": "BaseHandler.close()", "intent": "Remove any parents .", "question_id": 11841}
{"snippet": "BaseHandler.parent", "intent": "A valid OpenerDirector, which can be used to open using a different protocol, or handle errors.", "question_id": 11842}
{"snippet": "BaseHandler.default_open(req)", "intent": "This method is not defined in BaseHandler , but subclasses should define it if they want to catch all URLs . With arguments `req`.", "question_id": 11843}
{"snippet": "BaseHandler.<protocol>_open(req)", "intent": "This method is not defined in BaseHandler , but subclasses should define it if they want to handle URLs with the given protocol . With arguments `req`.", "question_id": 11844}
{"snippet": "BaseHandler.unknown_open(req)", "intent": "This method is not defined in BaseHandler , but subclasses should define it if they want to catch all URLs with no specific registered handler to open it . With arguments `req`.", "question_id": 11845}
{"snippet": "BaseHandler.http_error_default(req, fp, code, msg, hdrs)", "intent": "This method is not defined in BaseHandler , but subclasses should override it if they intend to provide a catch-all for otherwise unhandled HTTP errors . `req` will be a Request object , `fp` will be a file-like object with the HTTP error body , `code` will be the three-digit code of the error , `msg` will be the user-visible explanation of the code and `hdrs` will be a mapping object with the headers of the error .", "question_id": 11846}
{"snippet": "BaseHandler.http_error_<nnn>(req, fp, code, msg, hdrs)", "intent": "nnn should be a three-digit HTTP error `code` . With arguments `req`, `fp`, `msg`, `hdrs`.", "question_id": 11847}
{"snippet": "BaseHandler.<protocol>_request(req)", "intent": "This method is not defined in BaseHandler , but subclasses should define it if they want to pre-process requests of the given protocol . `req` will be a Request object .", "question_id": 11848}
{"snippet": "BaseHandler.<protocol>_response(req, response)", "intent": "This method is not defined in BaseHandler , but subclasses should define it if they want to post-process responses of the given protocol . `req` will be a Request object . `response` will be an object implementing the same interface as the return value of urlopen ( ) .", "question_id": 11849}
{"snippet": "HTTPRedirectHandler.redirect_request(req, fp, code, msg, hdrs, newurl)", "intent": "Return a Request or None in response to a redirect . If a redirection should take place , return a new Request to allow http_error_30* ( ) to perform the redirect to `newurl` . With arguments `req`, `fp`, `code`, `msg`, `hdrs`.", "question_id": 11850}
{"snippet": "HTTPRedirectHandler.http_error_301(req, fp, code, msg, hdrs)", "intent": "Redirect to the Location : or URI : URL . With arguments `req`, `fp`, `code`, `msg`, `hdrs`.", "question_id": 11851}
{"snippet": "HTTPRedirectHandler.http_error_302(req, fp, code, msg, hdrs)", "intent": "The same as http_error_301 ( ) , but called for the \u2018 found \u2019 response . With arguments `req`, `fp`, `code`, `msg`, `hdrs`.", "question_id": 11852}
{"snippet": "HTTPRedirectHandler.http_error_303(req, fp, code, msg, hdrs)", "intent": "The same as http_error_301 ( ) , but called for the \u2018 see other \u2019 response . With arguments `req`, `fp`, `code`, `msg`, `hdrs`.", "question_id": 11853}
{"snippet": "HTTPRedirectHandler.http_error_307(req, fp, code, msg, hdrs)", "intent": "The same as http_error_301 ( ) , but called for the \u2018 temporary redirect \u2019 response . With arguments `req`, `fp`, `code`, `msg`, `hdrs`.", "question_id": 11854}
{"snippet": "HTTPCookieProcessor.cookiejar", "intent": "The http.cookiejar.CookieJar in which cookies are stored.", "question_id": 11855}
{"snippet": "ProxyHandler.<protocol>_open(request)", "intent": "The ProxyHandler will have a method < protocol > _open ( ) for every protocol which has a proxy in the proxies dictionary given in the constructor . With arguments `request`.", "question_id": 11856}
{"snippet": "HTTPPasswordMgr.add_password(realm, uri, user, passwd)", "intent": "`uri` can be either a single URI , or a sequence of URIs . `realm` , `user` and `passwd` must be strings .", "question_id": 11857}
{"snippet": "HTTPPasswordMgr.find_user_password(realm, authuri)", "intent": "Get user/password for given `realm` and URI , if any . With arguments `authuri`.", "question_id": 11858}
{"snippet": "HTTPPasswordMgrWithPriorAuth.add_password(realm, uri, user, passwd)", "intent": "`realm` , `uri` , `user` , `passwd` are as for HTTPPasswordMgr.add_password ( ) .", "question_id": 11859}
{"snippet": "HTTPPasswordMgrWithPriorAuth.add_password(realm, uri, user, passwd, is_authenticated=False)", "intent": "`realm` , `uri` , `user` , `passwd` are as for HTTPPasswordMgr.add_password ( ) . `is_authenticated` sets the initial value of the is_authenticated flag for the given URI or list of URIs .", "question_id": 11860}
{"snippet": "HTTPPasswordMgr.find_user_password(realm, authuri)", "intent": "Same as for HTTPPasswordMgrWithDefaultRealm objects With arguments `realm`, `authuri`.", "question_id": 11861}
{"snippet": "HTTPPasswordMgrWithPriorAuth.update_authenticated(self, uri)", "intent": "Update the `is_authenticated` flag for the given `uri` or list of URIs . With arguments `self`.", "question_id": 11862}
{"snippet": "HTTPPasswordMgrWithPriorAuth.update_authenticated(self, uri, is_authenticated=False)", "intent": "Update the `is_authenticated` flag for the given `uri` or list of URIs . With arguments `self`.", "question_id": 11863}
{"snippet": "HTTPPasswordMgrWithPriorAuth.is_authenticated(self, authuri)", "intent": "Returns the current state of the is_authenticated flag for the given URI . With arguments `self`, `authuri`.", "question_id": 11864}
{"snippet": "AbstractBasicAuthHandler.http_error_auth_reqed(authreq, host, req, headers)", "intent": "Handle an authentication request by getting a user/password pair , and re-trying the request . `authreq` should be the name of the header where the information about the realm is included in the request , `host` specifies the URL and path to authenticate for , `req` should be the ( failed ) Request object , and `headers` should be the error headers .", "question_id": 11865}
{"snippet": "HTTPBasicAuthHandler.http_error_401(req, fp, code, msg, hdrs)", "intent": "Retry the request with authentication information , if available . With arguments `req`, `fp`, `code`, `msg`, `hdrs`.", "question_id": 11866}
{"snippet": "ProxyBasicAuthHandler.http_error_407(req, fp, code, msg, hdrs)", "intent": "Retry the request with authentication information , if available . With arguments `req`, `fp`, `code`, `msg`, `hdrs`.", "question_id": 11867}
{"snippet": "AbstractDigestAuthHandler.http_error_auth_reqed(authreq, host, req, headers)", "intent": "`authreq` should be the name of the header where the information about the realm is included in the request , `host` should be the host to authenticate to , `req` should be the ( failed ) Request object , and `headers` should be the error headers .", "question_id": 11868}
{"snippet": "HTTPDigestAuthHandler.http_error_401(req, fp, code, msg, hdrs)", "intent": "Retry the request with authentication information , if available . With arguments `req`, `fp`, `code`, `msg`, `hdrs`.", "question_id": 11869}
{"snippet": "ProxyDigestAuthHandler.http_error_407(req, fp, code, msg, hdrs)", "intent": "Retry the request with authentication information , if available . With arguments `req`, `fp`, `code`, `msg`, `hdrs`.", "question_id": 11870}
{"snippet": "HTTPHandler.http_open(req)", "intent": "Send an HTTP request , which can be either GET or POST , depending on req.has_data ( ) . With arguments `req`.", "question_id": 11871}
{"snippet": "HTTPSHandler.https_open(req)", "intent": "Send an HTTPS request , which can be either GET or POST , depending on req.has_data ( ) . With arguments `req`.", "question_id": 11872}
{"snippet": "FileHandler.file_open(req)", "intent": "Open the file locally , if there is no host name , or the host name is 'localhost ' . With arguments `req`.", "question_id": 11873}
{"snippet": "DataHandler.data_open(req)", "intent": "Read a data URL . With arguments `req`.", "question_id": 11874}
{"snippet": "FTPHandler.ftp_open(req)", "intent": "Open the FTP file indicated by `req` .", "question_id": 11875}
{"snippet": "CacheFTPHandler.setTimeout(t)", "intent": "Set timeout of connections to `t` seconds .", "question_id": 11876}
{"snippet": "CacheFTPHandler.setMaxConns(m)", "intent": "Set maximum number of cached connections to `m` .", "question_id": 11877}
{"snippet": "UnknownHandler.unknown_open()", "intent": "Raise a URLError exception .", "question_id": 11878}
{"snippet": "HTTPErrorProcessor.http_response(request, response)", "intent": "Process HTTP error responses . For 200 error codes , the `response` object is returned immediately . With arguments `request`.", "question_id": 11879}
{"snippet": "HTTPErrorProcessor.https_response(request, response)", "intent": "Process HTTPS error responses . With arguments `request`, `response`.", "question_id": 11880}
{"snippet": "urllib.request.urlretrieve(url)", "intent": "Copy a network object denoted by a URL to a local file . If the `url` uses the http : scheme identifier , the optional `data` argument may be given to specify a POST request ( normally the request type is GET ) .", "question_id": 11881}
{"snippet": "urllib.request.urlretrieve(url, filename=None)", "intent": "Copy a network object denoted by a URL to a local file . If the `url` uses the http : scheme identifier , the optional `data` argument may be given to specify a POST request ( normally the request type is GET ) . If the URL points to a local file , the object will not be copied unless `filename` is supplied .", "question_id": 11882}
{"snippet": "urllib.request.urlretrieve(url, reporthook=None)", "intent": "Copy a network object denoted by a URL to a local file . If the `url` uses the http : scheme identifier , the optional `data` argument may be given to specify a POST request ( normally the request type is GET ) . With arguments `reporthook`.", "question_id": 11883}
{"snippet": "urllib.request.urlretrieve(url, data=None)", "intent": "Copy a network object denoted by a URL to a local file . If the `url` uses the http : scheme identifier , the optional `data` argument may be given to specify a POST request ( normally the request type is GET ) .", "question_id": 11884}
{"snippet": "urllib.request.urlretrieve(url, filename=None, reporthook=None)", "intent": "Copy a network object denoted by a URL to a local file . If the `url` uses the http : scheme identifier , the optional `data` argument may be given to specify a POST request ( normally the request type is GET ) . If the URL points to a local file , the object will not be copied unless `filename` is supplied . With arguments `reporthook`.", "question_id": 11885}
{"snippet": "urllib.request.urlretrieve(url, filename=None, data=None)", "intent": "Copy a network object denoted by a URL to a local file . If the `url` uses the http : scheme identifier , the optional `data` argument may be given to specify a POST request ( normally the request type is GET ) . If the URL points to a local file , the object will not be copied unless `filename` is supplied .", "question_id": 11886}
{"snippet": "urllib.request.urlretrieve(url, reporthook=None, data=None)", "intent": "Copy a network object denoted by a URL to a local file . If the `url` uses the http : scheme identifier , the optional `data` argument may be given to specify a POST request ( normally the request type is GET ) . With arguments `reporthook`.", "question_id": 11887}
{"snippet": "urllib.request.urlretrieve(url, filename=None, reporthook=None, data=None)", "intent": "Copy a network object denoted by a URL to a local file . If the `url` uses the http : scheme identifier , the optional `data` argument may be given to specify a POST request ( normally the request type is GET ) . If the URL points to a local file , the object will not be copied unless `filename` is supplied . With arguments `reporthook`.", "question_id": 11888}
{"snippet": "urllib.request.urlcleanup()", "intent": "Cleans up temporary files that may have been left behind by previous calls to urlretrieve ( ) .", "question_id": 11889}
{"snippet": "urllib.request.URLopener(**x509)", "intent": "Base class for opening and reading URLs . With arguments `**x509`.", "question_id": 11890}
{"snippet": "urllib.request.URLopener(**x509, proxies=None)", "intent": "Base class for opening and reading URLs . The optional `proxies` parameter should be a dictionary mapping scheme names to proxy URLs , where an empty dictionary turns proxies off completely . With arguments `**x509`.", "question_id": 11891}
{"snippet": "ur_lopener.open(fullurl)", "intent": "Open `fullurl` using the appropriate protocol .", "question_id": 11892}
{"snippet": "ur_lopener.open(fullurl, data=None)", "intent": "Open `fullurl` using the appropriate protocol . The `data` argument has the same meaning as the data argument of urlopen ( ) .", "question_id": 11893}
{"snippet": "ur_lopener.open_unknown(fullurl)", "intent": "Overridable interface to open unknown URL types . With arguments `fullurl`.", "question_id": 11894}
{"snippet": "ur_lopener.open_unknown(fullurl, data=None)", "intent": "Overridable interface to open unknown URL types . With arguments `fullurl`, `data`.", "question_id": 11895}
{"snippet": "ur_lopener.retrieve(url)", "intent": "Retrieves the contents of `url` and places it in `filename` .", "question_id": 11896}
{"snippet": "ur_lopener.retrieve(url, filename=None)", "intent": "Retrieves the contents of `url` and places it in `filename` .", "question_id": 11897}
{"snippet": "ur_lopener.retrieve(url, reporthook=None)", "intent": "Retrieves the contents of `url` and places it in `filename` . If `reporthook` is given , it must be a function accepting three numeric parameters : A chunk number , the maximum size chunks are read in and the total size of the download ( -1 if unknown ) .", "question_id": 11898}
{"snippet": "ur_lopener.retrieve(url, data=None)", "intent": "Retrieves the contents of `url` and places it in `filename` . It will be called once at the start and after each chunk of `data` is read from the network .", "question_id": 11899}
{"snippet": "ur_lopener.retrieve(url, filename=None, reporthook=None)", "intent": "Retrieves the contents of `url` and places it in `filename` . If `reporthook` is given , it must be a function accepting three numeric parameters : A chunk number , the maximum size chunks are read in and the total size of the download ( -1 if unknown ) .", "question_id": 11900}
{"snippet": "ur_lopener.retrieve(url, filename=None, data=None)", "intent": "Retrieves the contents of `url` and places it in `filename` . It will be called once at the start and after each chunk of `data` is read from the network .", "question_id": 11901}
{"snippet": "ur_lopener.retrieve(url, reporthook=None, data=None)", "intent": "Retrieves the contents of `url` and places it in `filename` . If `reporthook` is given , it must be a function accepting three numeric parameters : A chunk number , the maximum size chunks are read in and the total size of the download ( -1 if unknown ) . It will be called once at the start and after each chunk of `data` is read from the network .", "question_id": 11902}
{"snippet": "ur_lopener.retrieve(url, filename=None, reporthook=None, data=None)", "intent": "Retrieves the contents of `url` and places it in `filename` . If `reporthook` is given , it must be a function accepting three numeric parameters : A chunk number , the maximum size chunks are read in and the total size of the download ( -1 if unknown ) . It will be called once at the start and after each chunk of `data` is read from the network .", "question_id": 11903}
{"snippet": "ur_lopener.version", "intent": "Variable that specifies the user agent of the opener object.", "question_id": 11904}
{"snippet": "urllib.request.FancyURLopener()", "intent": "FancyURLopener subclasses URLopener providing default handling for the following HTTP response codes : 301 , 302 , 303 , 307 and 401 .", "question_id": 11905}
{"snippet": "fancy_ur_lopener.prompt_user_passwd(host, realm)", "intent": "Return information needed to authenticate the user at the given `host` in the specified security `realm` .", "question_id": 11906}
{"snippet": "urllib.robotparser.RobotFileParser()", "intent": "This class provides methods to read , parse and answer questions about the robots.txt file at `url` .", "question_id": 11907}
{"snippet": "urllib.robotparser.RobotFileParser(url='')", "intent": "This class provides methods to read , parse and answer questions about the robots.txt file at `url` .", "question_id": 11908}
{"snippet": "robot_file_parser.set_url(url)", "intent": "Sets the URL referring to a robots.txt file . With arguments `url`.", "question_id": 11909}
{"snippet": "robot_file_parser.read()", "intent": "Reads the robots.txt URL and feeds it to the parser .", "question_id": 11910}
{"snippet": "robot_file_parser.parse(lines)", "intent": "Parses the `lines` argument .", "question_id": 11911}
{"snippet": "robot_file_parser.can_fetch(useragent, url)", "intent": "Returns True if the `useragent` is allowed to fetch the `url` according to the rules contained in the parsed robots.txt file .", "question_id": 11912}
{"snippet": "robot_file_parser.mtime()", "intent": "Returns the time the robots.txt file was last fetched .", "question_id": 11913}
{"snippet": "robot_file_parser.modified()", "intent": "Sets the time the robots.txt file was last fetched to the current time .", "question_id": 11914}
{"snippet": "robot_file_parser.crawl_delay(useragent)", "intent": "Returns the value of the Crawl-delay parameter from robots.txt for the `useragent` in question .", "question_id": 11915}
{"snippet": "robot_file_parser.request_rate(useragent)", "intent": "Returns the contents of the Request-rate parameter from robots.txt as a named tuple RequestRate ( requests , seconds ) . If there is no such parameter or it doesn \u2019 t apply to the `useragent` specified or the robots.txt entry for this parameter has invalid syntax , return None .", "question_id": 11916}
{"snippet": "uu.encode(in_file, out_file)", "intent": "Uuencode file `in_file` into file `out_file` .", "question_id": 11917}
{"snippet": "uu.encode(in_file, out_file, name=None)", "intent": "Uuencode file `in_file` into file `out_file` . The uuencoded file will have the header specifying `name` and `mode` as the defaults for the results of decoding the file .", "question_id": 11918}
{"snippet": "uu.encode(in_file, out_file, mode=None)", "intent": "Uuencode file `in_file` into file `out_file` . The uuencoded file will have the header specifying `name` and `mode` as the defaults for the results of decoding the file .", "question_id": 11919}
{"snippet": "uu.encode(in_file, out_file, backtick=False)", "intent": "Uuencode file `in_file` into file `out_file` . If `backtick` is true , zeros are represented by ' ` ' instead of spaces .", "question_id": 11920}
{"snippet": "uu.encode(in_file, out_file, name=None, mode=None)", "intent": "Uuencode file `in_file` into file `out_file` . The uuencoded file will have the header specifying `name` and `mode` as the defaults for the results of decoding the file .", "question_id": 11921}
{"snippet": "uu.encode(in_file, out_file, name=None, backtick=False)", "intent": "Uuencode file `in_file` into file `out_file` . The uuencoded file will have the header specifying `name` and `mode` as the defaults for the results of decoding the file . If `backtick` is true , zeros are represented by ' ` ' instead of spaces .", "question_id": 11922}
{"snippet": "uu.encode(in_file, out_file, mode=None, backtick=False)", "intent": "Uuencode file `in_file` into file `out_file` . The uuencoded file will have the header specifying `name` and `mode` as the defaults for the results of decoding the file . If `backtick` is true , zeros are represented by ' ` ' instead of spaces .", "question_id": 11923}
{"snippet": "uu.encode(in_file, out_file, name=None, mode=None, backtick=False)", "intent": "Uuencode file `in_file` into file `out_file` . The uuencoded file will have the header specifying `name` and `mode` as the defaults for the results of decoding the file . If `backtick` is true , zeros are represented by ' ` ' instead of spaces .", "question_id": 11924}
{"snippet": "uu.decode(in_file)", "intent": "This call decodes uuencoded file `in_file` placing the result on file `out_file` .", "question_id": 11925}
{"snippet": "uu.decode(in_file, out_file=None)", "intent": "This call decodes uuencoded file `in_file` placing the result on file `out_file` .", "question_id": 11926}
{"snippet": "uu.decode(in_file, mode=None)", "intent": "This call decodes uuencoded file `in_file` placing the result on file `out_file` . If out_file is a pathname , `mode` is used to set the permission bits if the file must be created .", "question_id": 11927}
{"snippet": "uu.decode(in_file, quiet=False)", "intent": "This call decodes uuencoded file `in_file` placing the result on file `out_file` . Setting `quiet` to a true value silences this warning .", "question_id": 11928}
{"snippet": "uu.decode(in_file, out_file=None, mode=None)", "intent": "This call decodes uuencoded file `in_file` placing the result on file `out_file` . If out_file is a pathname , `mode` is used to set the permission bits if the file must be created .", "question_id": 11929}
{"snippet": "uu.decode(in_file, out_file=None, quiet=False)", "intent": "This call decodes uuencoded file `in_file` placing the result on file `out_file` . Setting `quiet` to a true value silences this warning .", "question_id": 11930}
{"snippet": "uu.decode(in_file, mode=None, quiet=False)", "intent": "This call decodes uuencoded file `in_file` placing the result on file `out_file` . If out_file is a pathname , `mode` is used to set the permission bits if the file must be created . Setting `quiet` to a true value silences this warning .", "question_id": 11931}
{"snippet": "uu.decode(in_file, out_file=None, mode=None, quiet=False)", "intent": "This call decodes uuencoded file `in_file` placing the result on file `out_file` . If out_file is a pathname , `mode` is used to set the permission bits if the file must be created . Setting `quiet` to a true value silences this warning .", "question_id": 11932}
{"snippet": "uu.Error", "intent": "Subclass of Exception, this can be raised by uu.decode() under various situations, such as described above, but also including a badly formatted header, or truncated input file.", "question_id": 11933}
{"snippet": "robot_file_parser.safe", "intent": "The UUID was generated by the platform in a multiprocessing-safe way.", "question_id": 11934}
{"snippet": "robot_file_parser.unsafe", "intent": "The UUID was not generated in a multiprocessing-safe way.", "question_id": 11935}
{"snippet": "robot_file_parser.unknown", "intent": "The platform does not provide information on whether the UUID was generated safely or not.", "question_id": 11936}
{"snippet": "uuid.UUID()", "intent": "Create a UUID from either a string of 32 hexadecimal digits , a string of 16 `bytes` in big-endian order as the bytes argument , a string of 16 bytes in little-endian order as the `bytes_le` argument , a tuple of six integers ( 32-bit time_low , 16-bit time_mid , 16-bit time_hi_version , 8-bit clock_seq_hi_variant , 8-bit clock_seq_low , 48-bit node ) as the `fields` argument , or a single 128-bit integer as the `int` argument .", "question_id": 11937}
{"snippet": "uuid.UUID(hex=None)", "intent": "Create a UUID from either a string of 32 hexadecimal digits , a string of 16 `bytes` in big-endian order as the bytes argument , a string of 16 bytes in little-endian order as the `bytes_le` argument , a tuple of six integers ( 32-bit time_low , 16-bit time_mid , 16-bit time_hi_version , 8-bit clock_seq_hi_variant , 8-bit clock_seq_low , 48-bit node ) as the `fields` argument , or a single 128-bit integer as the `int` argument . When a string of `hex` digits is given , curly braces , hyphens , and a URN prefix are all optional .", "question_id": 11938}
{"snippet": "uuid.UUID(bytes=None)", "intent": "Create a UUID from either a string of 32 hexadecimal digits , a string of 16 `bytes` in big-endian order as the bytes argument , a string of 16 bytes in little-endian order as the `bytes_le` argument , a tuple of six integers ( 32-bit time_low , 16-bit time_mid , 16-bit time_hi_version , 8-bit clock_seq_hi_variant , 8-bit clock_seq_low , 48-bit node ) as the `fields` argument , or a single 128-bit integer as the `int` argument .", "question_id": 11939}
{"snippet": "uuid.UUID(bytes_le=None)", "intent": "Create a UUID from either a string of 32 hexadecimal digits , a string of 16 `bytes` in big-endian order as the bytes argument , a string of 16 bytes in little-endian order as the `bytes_le` argument , a tuple of six integers ( 32-bit time_low , 16-bit time_mid , 16-bit time_hi_version , 8-bit clock_seq_hi_variant , 8-bit clock_seq_low , 48-bit node ) as the `fields` argument , or a single 128-bit integer as the `int` argument .", "question_id": 11940}
{"snippet": "uuid.UUID(fields=None)", "intent": "Create a UUID from either a string of 32 hexadecimal digits , a string of 16 `bytes` in big-endian order as the bytes argument , a string of 16 bytes in little-endian order as the `bytes_le` argument , a tuple of six integers ( 32-bit time_low , 16-bit time_mid , 16-bit time_hi_version , 8-bit clock_seq_hi_variant , 8-bit clock_seq_low , 48-bit node ) as the `fields` argument , or a single 128-bit integer as the `int` argument .", "question_id": 11941}
{"snippet": "uuid.UUID(int=None)", "intent": "Create a UUID from either a string of 32 hexadecimal digits , a string of 16 `bytes` in big-endian order as the bytes argument , a string of 16 bytes in little-endian order as the `bytes_le` argument , a tuple of six integers ( 32-bit time_low , 16-bit time_mid , 16-bit time_hi_version , 8-bit clock_seq_hi_variant , 8-bit clock_seq_low , 48-bit node ) as the `fields` argument , or a single 128-bit integer as the `int` argument .", "question_id": 11942}
{"snippet": "uuid.UUID(version=None)", "intent": "Create a UUID from either a string of 32 hexadecimal digits , a string of 16 `bytes` in big-endian order as the bytes argument , a string of 16 bytes in little-endian order as the `bytes_le` argument , a tuple of six integers ( 32-bit time_low , 16-bit time_mid , 16-bit time_hi_version , 8-bit clock_seq_hi_variant , 8-bit clock_seq_low , 48-bit node ) as the `fields` argument , or a single 128-bit integer as the `int` argument . The `version` argument is optional ; if given , the resulting UUID will have its variant and version number set according to RFC 4122 , overriding bits in the given hex , bytes , bytes_le , fields , or int .", "question_id": 11943}
{"snippet": "uuid.UUID(is_safe=SafeUUID.unknown)", "intent": "Create a UUID from either a string of 32 hexadecimal digits , a string of 16 `bytes` in big-endian order as the bytes argument , a string of 16 bytes in little-endian order as the `bytes_le` argument , a tuple of six integers ( 32-bit time_low , 16-bit time_mid , 16-bit time_hi_version , 8-bit clock_seq_hi_variant , 8-bit clock_seq_low , 48-bit node ) as the `fields` argument , or a single 128-bit integer as the `int` argument . With arguments `is_safe`.", "question_id": 11944}
{"snippet": "uuid.UUID(hex=None, bytes=None)", "intent": "Create a UUID from either a string of 32 hexadecimal digits , a string of 16 `bytes` in big-endian order as the bytes argument , a string of 16 bytes in little-endian order as the `bytes_le` argument , a tuple of six integers ( 32-bit time_low , 16-bit time_mid , 16-bit time_hi_version , 8-bit clock_seq_hi_variant , 8-bit clock_seq_low , 48-bit node ) as the `fields` argument , or a single 128-bit integer as the `int` argument . When a string of `hex` digits is given , curly braces , hyphens , and a URN prefix are all optional .", "question_id": 11945}
{"snippet": "uuid.UUID(hex=None, bytes_le=None)", "intent": "Create a UUID from either a string of 32 hexadecimal digits , a string of 16 `bytes` in big-endian order as the bytes argument , a string of 16 bytes in little-endian order as the `bytes_le` argument , a tuple of six integers ( 32-bit time_low , 16-bit time_mid , 16-bit time_hi_version , 8-bit clock_seq_hi_variant , 8-bit clock_seq_low , 48-bit node ) as the `fields` argument , or a single 128-bit integer as the `int` argument . When a string of `hex` digits is given , curly braces , hyphens , and a URN prefix are all optional .", "question_id": 11946}
{"snippet": "UUID.bytes", "intent": "The UUID as a 16-byte string (containing the six integer fields in big-endian byte order).", "question_id": 11947}
{"snippet": "UUID.bytes_le", "intent": "The UUID as a 16-byte string (with time_low, time_mid, and time_hi_version in little-endian byte order).", "question_id": 11948}
{"snippet": "UUID.fields", "intent": "A tuple of the six integer fields of the UUID, which are also available as six individual attributes and two derived attributes:", "question_id": 11949}
{"snippet": "UUID.hex", "intent": "The UUID as a 32-character hexadecimal string.", "question_id": 11950}
{"snippet": "UUID.int", "intent": "The UUID as a 128-bit integer.", "question_id": 11951}
{"snippet": "UUID.urn", "intent": "The UUID as a URN as specified in RFC 4122.", "question_id": 11952}
{"snippet": "UUID.variant", "intent": "The UUID variant, which determines the internal layout of the UUID.", "question_id": 11953}
{"snippet": "UUID.version", "intent": "The UUID version number (1 through 5, meaningful only when the variant is RFC_4122).", "question_id": 11954}
{"snippet": "UUID.is_safe", "intent": "An enumeration of SafeUUID which indicates whether the platform generated the UUID in a multiprocessing-safe way.", "question_id": 11955}
{"snippet": "uuid.getnode()", "intent": "Get the hardware address as a 48-bit positive integer .", "question_id": 11956}
{"snippet": "uuid.uuid1()", "intent": "Generate a UUID from a host ID , sequence number , and the current time .", "question_id": 11957}
{"snippet": "uuid.uuid1(node=None)", "intent": "Generate a UUID from a host ID , sequence number , and the current time . If `node` is not given , getnode ( ) is used to obtain the hardware address .", "question_id": 11958}
{"snippet": "uuid.uuid1(clock_seq=None)", "intent": "Generate a UUID from a host ID , sequence number , and the current time . If `clock_seq` is given , it is used as the sequence number ; otherwise a random 14-bit sequence number is chosen .", "question_id": 11959}
{"snippet": "uuid.uuid1(node=None, clock_seq=None)", "intent": "Generate a UUID from a host ID , sequence number , and the current time . If `node` is not given , getnode ( ) is used to obtain the hardware address . If `clock_seq` is given , it is used as the sequence number ; otherwise a random 14-bit sequence number is chosen .", "question_id": 11960}
{"snippet": "uuid.uuid3(namespace, name)", "intent": "Generate a UUID based on the MD5 hash of a `namespace` identifier ( which is a UUID ) and a `name` ( which is a string ) .", "question_id": 11961}
{"snippet": "uuid.uuid4()", "intent": "Generate a random UUID .", "question_id": 11962}
{"snippet": "uuid.uuid5(namespace, name)", "intent": "Generate a UUID based on the SHA-1 hash of a `namespace` identifier ( which is a UUID ) and a `name` ( which is a string ) .", "question_id": 11963}
{"snippet": "uuid.NAMESPACE_DNS", "intent": "When this namespace is specified, the name string is a fully-qualified domain name.", "question_id": 11964}
{"snippet": "uuid.NAMESPACE_URL", "intent": "When this namespace is specified, the name string is a URL.", "question_id": 11965}
{"snippet": "uuid.NAMESPACE_OID", "intent": "When this namespace is specified, the name string is an ISO OID.", "question_id": 11966}
{"snippet": "uuid.NAMESPACE_X500", "intent": "When this namespace is specified, the name string is an X.500 DN in DER or a text output format.", "question_id": 11967}
{"snippet": "uuid.RESERVED_NCS", "intent": "Reserved for NCS compatibility.", "question_id": 11968}
{"snippet": "uuid.RFC_4122", "intent": "Specifies the UUID layout given in RFC 4122.", "question_id": 11969}
{"snippet": "uuid.RESERVED_MICROSOFT", "intent": "Reserved for Microsoft compatibility.", "question_id": 11970}
{"snippet": "uuid.RESERVED_FUTURE", "intent": "Reserved for future definition.", "question_id": 11971}
{"snippet": "venv.EnvBuilder()", "intent": "The EnvBuilder class accepts the following keyword arguments on instantiation :", "question_id": 11972}
{"snippet": "venv.EnvBuilder(system_site_packages=False)", "intent": "The EnvBuilder class accepts the following keyword arguments on instantiation : With arguments `system_site_packages`.", "question_id": 11973}
{"snippet": "venv.EnvBuilder(clear=False)", "intent": "The EnvBuilder class accepts the following keyword arguments on instantiation : With arguments `clear`.", "question_id": 11974}
{"snippet": "venv.EnvBuilder(symlinks=False)", "intent": "The EnvBuilder class accepts the following keyword arguments on instantiation : With arguments `symlinks`.", "question_id": 11975}
{"snippet": "venv.EnvBuilder(upgrade=False)", "intent": "The EnvBuilder class accepts the following keyword arguments on instantiation : With arguments `upgrade`.", "question_id": 11976}
{"snippet": "venv.EnvBuilder(with_pip=False)", "intent": "The EnvBuilder class accepts the following keyword arguments on instantiation : With arguments `with_pip`.", "question_id": 11977}
{"snippet": "venv.EnvBuilder(prompt=None)", "intent": "The EnvBuilder class accepts the following keyword arguments on instantiation : With arguments `prompt`.", "question_id": 11978}
{"snippet": "venv.EnvBuilder(system_site_packages=False, clear=False)", "intent": "The EnvBuilder class accepts the following keyword arguments on instantiation : With arguments `system_site_packages`, `clear`.", "question_id": 11979}
{"snippet": "venv.EnvBuilder(system_site_packages=False, symlinks=False)", "intent": "The EnvBuilder class accepts the following keyword arguments on instantiation : With arguments `system_site_packages`, `symlinks`.", "question_id": 11980}
{"snippet": "venv.EnvBuilder(system_site_packages=False, upgrade=False)", "intent": "The EnvBuilder class accepts the following keyword arguments on instantiation : With arguments `system_site_packages`, `upgrade`.", "question_id": 11981}
{"snippet": "env_builder.create(env_dir)", "intent": "Create a virtual environment by specifying the target directory ( absolute or relative to the current directory ) which is to contain the virtual environment . With arguments `env_dir`.", "question_id": 11982}
{"snippet": "env_builder.ensure_directories(env_dir)", "intent": "Creates the environment directory and all necessary directories , and returns a context object . With arguments `env_dir`.", "question_id": 11983}
{"snippet": "env_builder.create_configuration(context)", "intent": "Creates the pyvenv.cfg configuration file in the environment . With arguments `context`.", "question_id": 11984}
{"snippet": "env_builder.setup_python(context)", "intent": "Creates a copy or symlink to the Python executable in the environment . With arguments `context`.", "question_id": 11985}
{"snippet": "env_builder.setup_scripts(context)", "intent": "Installs activation scripts appropriate to the platform into the virtual environment . With arguments `context`.", "question_id": 11986}
{"snippet": "env_builder.post_setup(context)", "intent": "A placeholder method which can be overridden in third party implementations to pre-install packages in the virtual environment or perform other post-creation steps . With arguments `context`.", "question_id": 11987}
{"snippet": "env_builder.install_scripts(context, path)", "intent": "`path` is the path to a directory that should contain subdirectories \u201c common \u201d , \u201c posix \u201d , \u201c nt \u201d , each containing scripts destined for the bin directory in the environment . With arguments `context`.", "question_id": 11988}
{"snippet": "venv.create(env_dir)", "intent": "Create an EnvBuilder with the given keyword arguments , and call its create ( ) method with the `env_dir` argument .", "question_id": 11989}
{"snippet": "venv.create(env_dir, system_site_packages=False)", "intent": "Create an EnvBuilder with the given keyword arguments , and call its create ( ) method with the `env_dir` argument . With arguments `system_site_packages`.", "question_id": 11990}
{"snippet": "venv.create(env_dir, clear=False)", "intent": "Create an EnvBuilder with the given keyword arguments , and call its create ( ) method with the `env_dir` argument . With arguments `clear`.", "question_id": 11991}
{"snippet": "venv.create(env_dir, symlinks=False)", "intent": "Create an EnvBuilder with the given keyword arguments , and call its create ( ) method with the `env_dir` argument . With arguments `symlinks`.", "question_id": 11992}
{"snippet": "venv.create(env_dir, with_pip=False)", "intent": "Create an EnvBuilder with the given keyword arguments , and call its create ( ) method with the `env_dir` argument . With arguments `with_pip`.", "question_id": 11993}
{"snippet": "venv.create(env_dir, prompt=None)", "intent": "Create an EnvBuilder with the given keyword arguments , and call its create ( ) method with the `env_dir` argument . With arguments `prompt`.", "question_id": 11994}
{"snippet": "venv.create(env_dir, system_site_packages=False, clear=False)", "intent": "Create an EnvBuilder with the given keyword arguments , and call its create ( ) method with the `env_dir` argument . With arguments `system_site_packages`, `clear`.", "question_id": 11995}
{"snippet": "venv.create(env_dir, system_site_packages=False, symlinks=False)", "intent": "Create an EnvBuilder with the given keyword arguments , and call its create ( ) method with the `env_dir` argument . With arguments `system_site_packages`, `symlinks`.", "question_id": 11996}
{"snippet": "venv.create(env_dir, system_site_packages=False, with_pip=False)", "intent": "Create an EnvBuilder with the given keyword arguments , and call its create ( ) method with the `env_dir` argument . With arguments `system_site_packages`, `with_pip`.", "question_id": 11997}
{"snippet": "venv.create(env_dir, system_site_packages=False, prompt=None)", "intent": "Create an EnvBuilder with the given keyword arguments , and call its create ( ) method with the `env_dir` argument . With arguments `system_site_packages`, `prompt`.", "question_id": 11998}
{"snippet": "warnings.warn(message)", "intent": "Issue a warning , or maybe ignore it or raise an exception . Alternatively `message` can be a Warning instance , in which case category will be ignored and message.__class__ will be used .", "question_id": 11999}
{"snippet": "warnings.warn(message, category=None)", "intent": "Issue a warning , or maybe ignore it or raise an exception . Alternatively `message` can be a Warning instance , in which case category will be ignored and message.__class__ will be used . The `category` argument , if given , must be a warning category class ( see above ) ; it defaults to UserWarning .", "question_id": 12000}
{"snippet": "warnings.warn(message, stacklevel=1)", "intent": "Issue a warning , or maybe ignore it or raise an exception . Alternatively `message` can be a Warning instance , in which case category will be ignored and message.__class__ will be used . The `stacklevel` argument can be used by wrapper functions written in Python , like this :", "question_id": 12001}
{"snippet": "warnings.warn(message, source=None)", "intent": "Issue a warning , or maybe ignore it or raise an exception . Alternatively `message` can be a Warning instance , in which case category will be ignored and message.__class__ will be used . This makes the warning refer to deprecation ( ) \u2019 s caller , rather than to the `source` of deprecation ( ) itself ( since the latter would defeat the purpose of the warning message ) .", "question_id": 12002}
{"snippet": "warnings.warn(message, category=None, stacklevel=1)", "intent": "Issue a warning , or maybe ignore it or raise an exception . Alternatively `message` can be a Warning instance , in which case category will be ignored and message.__class__ will be used . The `category` argument , if given , must be a warning category class ( see above ) ; it defaults to UserWarning . The `stacklevel` argument can be used by wrapper functions written in Python , like this :", "question_id": 12003}
{"snippet": "warnings.warn(message, category=None, source=None)", "intent": "Issue a warning , or maybe ignore it or raise an exception . Alternatively `message` can be a Warning instance , in which case category will be ignored and message.__class__ will be used . The `category` argument , if given , must be a warning category class ( see above ) ; it defaults to UserWarning . This makes the warning refer to deprecation ( ) \u2019 s caller , rather than to the `source` of deprecation ( ) itself ( since the latter would defeat the purpose of the warning message ) .", "question_id": 12004}
{"snippet": "warnings.warn(message, stacklevel=1, source=None)", "intent": "Issue a warning , or maybe ignore it or raise an exception . Alternatively `message` can be a Warning instance , in which case category will be ignored and message.__class__ will be used . The `stacklevel` argument can be used by wrapper functions written in Python , like this : This makes the warning refer to deprecation ( ) \u2019 s caller , rather than to the `source` of deprecation ( ) itself ( since the latter would defeat the purpose of the warning message ) .", "question_id": 12005}
{"snippet": "warnings.warn(message, category=None, stacklevel=1, source=None)", "intent": "Issue a warning , or maybe ignore it or raise an exception . Alternatively `message` can be a Warning instance , in which case category will be ignored and message.__class__ will be used . The `category` argument , if given , must be a warning category class ( see above ) ; it defaults to UserWarning . The `stacklevel` argument can be used by wrapper functions written in Python , like this : This makes the warning refer to deprecation ( ) \u2019 s caller , rather than to the `source` of deprecation ( ) itself ( since the latter would defeat the purpose of the warning message ) .", "question_id": 12006}
{"snippet": "warnings.warn_explicit(message, category, filename, lineno)", "intent": "This is a low-level interface to the functionality of warn ( ) , passing in explicitly the `message` , `category` , `filename` and line number , and optionally the `module` name and the `registry` ( which should be the __warningregistry__ dictionary of the module ) . With arguments `lineno`.", "question_id": 12007}
{"snippet": "warnings.warn_explicit(message, category, filename, lineno, module=None)", "intent": "This is a low-level interface to the functionality of warn ( ) , passing in explicitly the `message` , `category` , `filename` and line number , and optionally the `module` name and the `registry` ( which should be the __warningregistry__ dictionary of the module ) . With arguments `lineno`.", "question_id": 12008}
{"snippet": "warnings.warn_explicit(message, category, filename, lineno, registry=None)", "intent": "This is a low-level interface to the functionality of warn ( ) , passing in explicitly the `message` , `category` , `filename` and line number , and optionally the `module` name and the `registry` ( which should be the __warningregistry__ dictionary of the module ) . With arguments `lineno`.", "question_id": 12009}
{"snippet": "warnings.warn_explicit(message, category, filename, lineno, module_globals=None)", "intent": "This is a low-level interface to the functionality of warn ( ) , passing in explicitly the `message` , `category` , `filename` and line number , and optionally the `module` name and the `registry` ( which should be the __warningregistry__ dictionary of the module ) . `module_globals` , if supplied , should be the global namespace in use by the code for which the warning is issued . With arguments `lineno`.", "question_id": 12010}
{"snippet": "warnings.warn_explicit(message, category, filename, lineno, source=None)", "intent": "This is a low-level interface to the functionality of warn ( ) , passing in explicitly the `message` , `category` , `filename` and line number , and optionally the `module` name and the `registry` ( which should be the __warningregistry__ dictionary of the module ) . ( This argument is used to support displaying `source` for modules found in zipfiles or other non-filesystem import sources ) . With arguments `lineno`.", "question_id": 12011}
{"snippet": "warnings.warn_explicit(message, category, filename, lineno, module=None, registry=None)", "intent": "This is a low-level interface to the functionality of warn ( ) , passing in explicitly the `message` , `category` , `filename` and line number , and optionally the `module` name and the `registry` ( which should be the __warningregistry__ dictionary of the module ) . With arguments `lineno`.", "question_id": 12012}
{"snippet": "warnings.warn_explicit(message, category, filename, lineno, module=None, module_globals=None)", "intent": "This is a low-level interface to the functionality of warn ( ) , passing in explicitly the `message` , `category` , `filename` and line number , and optionally the `module` name and the `registry` ( which should be the __warningregistry__ dictionary of the module ) . `module_globals` , if supplied , should be the global namespace in use by the code for which the warning is issued . With arguments `lineno`.", "question_id": 12013}
{"snippet": "warnings.warn_explicit(message, category, filename, lineno, module=None, source=None)", "intent": "This is a low-level interface to the functionality of warn ( ) , passing in explicitly the `message` , `category` , `filename` and line number , and optionally the `module` name and the `registry` ( which should be the __warningregistry__ dictionary of the module ) . ( This argument is used to support displaying `source` for modules found in zipfiles or other non-filesystem import sources ) . With arguments `lineno`.", "question_id": 12014}
{"snippet": "warnings.warn_explicit(message, category, filename, lineno, registry=None, module_globals=None)", "intent": "This is a low-level interface to the functionality of warn ( ) , passing in explicitly the `message` , `category` , `filename` and line number , and optionally the `module` name and the `registry` ( which should be the __warningregistry__ dictionary of the module ) . `module_globals` , if supplied , should be the global namespace in use by the code for which the warning is issued . With arguments `lineno`.", "question_id": 12015}
{"snippet": "warnings.warn_explicit(message, category, filename, lineno, registry=None, source=None)", "intent": "This is a low-level interface to the functionality of warn ( ) , passing in explicitly the `message` , `category` , `filename` and line number , and optionally the `module` name and the `registry` ( which should be the __warningregistry__ dictionary of the module ) . ( This argument is used to support displaying `source` for modules found in zipfiles or other non-filesystem import sources ) . With arguments `lineno`.", "question_id": 12016}
{"snippet": "warnings.showwarning(message, category, filename, lineno)", "intent": "Write a warning to a `file` . The default implementation calls formatwarning ( `message` , `category` , `filename` , `lineno` , `line` ) and writes the resulting string to file , which defaults to sys.stderr .", "question_id": 12017}
{"snippet": "warnings.showwarning(message, category, filename, lineno, file=None)", "intent": "Write a warning to a `file` . The default implementation calls formatwarning ( `message` , `category` , `filename` , `lineno` , `line` ) and writes the resulting string to file , which defaults to sys.stderr .", "question_id": 12018}
{"snippet": "warnings.showwarning(message, category, filename, lineno, line=None)", "intent": "Write a warning to a `file` . The default implementation calls formatwarning ( `message` , `category` , `filename` , `lineno` , `line` ) and writes the resulting string to file , which defaults to sys.stderr .", "question_id": 12019}
{"snippet": "warnings.showwarning(message, category, filename, lineno, file=None, line=None)", "intent": "Write a warning to a `file` . The default implementation calls formatwarning ( `message` , `category` , `filename` , `lineno` , `line` ) and writes the resulting string to file , which defaults to sys.stderr .", "question_id": 12020}
{"snippet": "warnings.formatwarning(message, category, filename, lineno)", "intent": "Format a warning the standard way . `line` is a line of source code to be included in the warning `message` ; if line is not supplied , formatwarning ( ) will try to read the line specified by `filename` and `lineno` . With arguments `category`.", "question_id": 12021}
{"snippet": "warnings.formatwarning(message, category, filename, lineno, line=None)", "intent": "Format a warning the standard way . `line` is a line of source code to be included in the warning `message` ; if line is not supplied , formatwarning ( ) will try to read the line specified by `filename` and `lineno` . With arguments `category`.", "question_id": 12022}
{"snippet": "warnings.filterwarnings(action)", "intent": "Insert an entry into the list of warnings filter specifications . With arguments `action`.", "question_id": 12023}
{"snippet": "warnings.filterwarnings(action, message='')", "intent": "Insert an entry into the list of warnings filter specifications . This checks the types of the arguments , compiles the `message` and `module` regular expressions , and inserts them as a tuple in the list of warnings filters . With arguments `action`.", "question_id": 12024}
{"snippet": "warnings.filterwarnings(action, category=Warning)", "intent": "Insert an entry into the list of warnings filter specifications . With arguments `action`, `category`.", "question_id": 12025}
{"snippet": "warnings.filterwarnings(action, module='')", "intent": "Insert an entry into the list of warnings filter specifications . This checks the types of the arguments , compiles the `message` and `module` regular expressions , and inserts them as a tuple in the list of warnings filters . With arguments `action`.", "question_id": 12026}
{"snippet": "warnings.filterwarnings(action, lineno=0)", "intent": "Insert an entry into the list of warnings filter specifications . With arguments `action`, `lineno`.", "question_id": 12027}
{"snippet": "warnings.filterwarnings(action, append=False)", "intent": "Insert an entry into the list of warnings filter specifications . The entry is inserted at the front by default ; if `append` is true , it is inserted at the end . With arguments `action`.", "question_id": 12028}
{"snippet": "warnings.filterwarnings(action, message='', category=Warning)", "intent": "Insert an entry into the list of warnings filter specifications . This checks the types of the arguments , compiles the `message` and `module` regular expressions , and inserts them as a tuple in the list of warnings filters . With arguments `action`, `category`.", "question_id": 12029}
{"snippet": "warnings.filterwarnings(action, message='', module='')", "intent": "Insert an entry into the list of warnings filter specifications . This checks the types of the arguments , compiles the `message` and `module` regular expressions , and inserts them as a tuple in the list of warnings filters . With arguments `action`.", "question_id": 12030}
{"snippet": "warnings.filterwarnings(action, message='', lineno=0)", "intent": "Insert an entry into the list of warnings filter specifications . This checks the types of the arguments , compiles the `message` and `module` regular expressions , and inserts them as a tuple in the list of warnings filters . With arguments `action`, `lineno`.", "question_id": 12031}
{"snippet": "warnings.filterwarnings(action, message='', append=False)", "intent": "Insert an entry into the list of warnings filter specifications . This checks the types of the arguments , compiles the `message` and `module` regular expressions , and inserts them as a tuple in the list of warnings filters . The entry is inserted at the front by default ; if `append` is true , it is inserted at the end . With arguments `action`.", "question_id": 12032}
{"snippet": "warnings.simplefilter(action)", "intent": "Insert a simple entry into the list of warnings filter specifications . With arguments `action`.", "question_id": 12033}
{"snippet": "warnings.simplefilter(action, category=Warning)", "intent": "Insert a simple entry into the list of warnings filter specifications . The meaning of the function parameters is as for filterwarnings ( ) , but regular expressions are not needed as the filter inserted always matches any message in any module as long as the `category` and line number match . With arguments `action`.", "question_id": 12034}
{"snippet": "warnings.simplefilter(action, lineno=0)", "intent": "Insert a simple entry into the list of warnings filter specifications . With arguments `action`, `lineno`.", "question_id": 12035}
{"snippet": "warnings.simplefilter(action, append=False)", "intent": "Insert a simple entry into the list of warnings filter specifications . With arguments `action`, `append`.", "question_id": 12036}
{"snippet": "warnings.simplefilter(action, category=Warning, lineno=0)", "intent": "Insert a simple entry into the list of warnings filter specifications . The meaning of the function parameters is as for filterwarnings ( ) , but regular expressions are not needed as the filter inserted always matches any message in any module as long as the `category` and line number match . With arguments `action`, `lineno`.", "question_id": 12037}
{"snippet": "warnings.simplefilter(action, category=Warning, append=False)", "intent": "Insert a simple entry into the list of warnings filter specifications . The meaning of the function parameters is as for filterwarnings ( ) , but regular expressions are not needed as the filter inserted always matches any message in any module as long as the `category` and line number match . With arguments `action`, `append`.", "question_id": 12038}
{"snippet": "warnings.simplefilter(action, lineno=0, append=False)", "intent": "Insert a simple entry into the list of warnings filter specifications . With arguments `action`, `lineno`, `append`.", "question_id": 12039}
{"snippet": "warnings.simplefilter(action, category=Warning, lineno=0, append=False)", "intent": "Insert a simple entry into the list of warnings filter specifications . The meaning of the function parameters is as for filterwarnings ( ) , but regular expressions are not needed as the filter inserted always matches any message in any module as long as the `category` and line number match . With arguments `action`, `lineno`, `append`.", "question_id": 12040}
{"snippet": "warnings.resetwarnings()", "intent": "Reset the warnings filter .", "question_id": 12041}
{"snippet": "warnings.catch_warnings()", "intent": "A context manager that copies and , upon exit , restores the warnings filter and the showwarning ( ) function .", "question_id": 12042}
{"snippet": "warnings.catch_warnings(record=False)", "intent": "A context manager that copies and , upon exit , restores the warnings filter and the showwarning ( ) function . If the `record` argument is False ( the default ) the context manager returns None on entry .", "question_id": 12043}
{"snippet": "warnings.catch_warnings(module=None)", "intent": "A context manager that copies and , upon exit , restores the warnings filter and the showwarning ( ) function . The `module` argument takes a module that will be used instead of the module returned when you import warnings whose filter will be protected .", "question_id": 12044}
{"snippet": "warnings.catch_warnings(record=False, module=None)", "intent": "A context manager that copies and , upon exit , restores the warnings filter and the showwarning ( ) function . If the `record` argument is False ( the default ) the context manager returns None on entry . The `module` argument takes a module that will be used instead of the module returned when you import warnings whose filter will be protected .", "question_id": 12045}
{"snippet": "wave.open(file)", "intent": "If `file` is a string , open the file by that name , otherwise treat it as a file-like object .", "question_id": 12046}
{"snippet": "wave.open(file, mode=None)", "intent": "If `file` is a string , open the file by that name , otherwise treat it as a file-like object . `mode` can be :", "question_id": 12047}
{"snippet": "wave.openfp(file, mode)", "intent": "A synonym for open ( ) , maintained for backwards compatibility . With arguments `file`, `mode`.", "question_id": 12048}
{"snippet": "wave.Error", "intent": "An error raised when something is impossible because it violates the WAV specification or hits an implementation deficiency.", "question_id": 12049}
{"snippet": "Wave_read.close()", "intent": "Close the stream if it was opened by wave , and make the instance unusable .", "question_id": 12050}
{"snippet": "Wave_read.getnchannels()", "intent": "Returns number of audio channels ( 1 for mono , 2 for stereo ) .", "question_id": 12051}
{"snippet": "Wave_read.getsampwidth()", "intent": "Returns sample width in bytes .", "question_id": 12052}
{"snippet": "Wave_read.getframerate()", "intent": "Returns sampling frequency .", "question_id": 12053}
{"snippet": "Wave_read.getnframes()", "intent": "Returns number of audio frames .", "question_id": 12054}
{"snippet": "Wave_read.getcomptype()", "intent": "Returns compression type ( 'NONE ' is the only supported type ) .", "question_id": 12055}
{"snippet": "Wave_read.getcompname()", "intent": "Human-readable version of getcomptype ( ) .", "question_id": 12056}
{"snippet": "Wave_read.getparams()", "intent": "Returns a namedtuple ( ) ( nchannels , sampwidth , framerate , nframes , comptype , compname ) , equivalent to output of the get* ( ) methods .", "question_id": 12057}
{"snippet": "Wave_read.readframes(n)", "intent": "Reads and returns at most `n` frames of audio , as a bytes object .", "question_id": 12058}
{"snippet": "Wave_read.rewind()", "intent": "Rewind the file pointer to the beginning of the audio stream .", "question_id": 12059}
{"snippet": "Wave_read.getmarkers()", "intent": "Returns None .", "question_id": 12060}
{"snippet": "Wave_read.getmark(id)", "intent": "Raise an error . With arguments `id`.", "question_id": 12061}
{"snippet": "Wave_read.setpos(pos)", "intent": "Set the file pointer to the specified position . With arguments `pos`.", "question_id": 12062}
{"snippet": "Wave_read.tell()", "intent": "Return current file pointer position .", "question_id": 12063}
{"snippet": "Wave_write.close()", "intent": "Make sure nframes is correct , and close the file if it was opened by wave .", "question_id": 12064}
{"snippet": "Wave_write.setnchannels(n)", "intent": "Set the number of channels . With arguments `n`.", "question_id": 12065}
{"snippet": "Wave_write.setsampwidth(n)", "intent": "Set the sample width to `n` bytes .", "question_id": 12066}
{"snippet": "Wave_write.setframerate(n)", "intent": "Set the frame rate to `n` .", "question_id": 12067}
{"snippet": "Wave_write.setnframes(n)", "intent": "Set the number of frames to n. This will be changed later if the number of frames actually written is different ( this update attempt will raise an error if the output stream is not seekable ) . With arguments `n`.", "question_id": 12068}
{"snippet": "Wave_write.setcomptype(type, name)", "intent": "Set the compression `type` and description . With arguments `name`.", "question_id": 12069}
{"snippet": "Wave_write.setparams(tuple)", "intent": "The `tuple` should be ( nchannels , sampwidth , framerate , nframes , comptype , compname ) , with values valid for the set* ( ) methods .", "question_id": 12070}
{"snippet": "Wave_write.tell()", "intent": "Return current position in the file , with the same disclaimer for the Wave_read.tell ( ) and Wave_read.setpos ( ) methods .", "question_id": 12071}
{"snippet": "Wave_write.writeframesraw(data)", "intent": "Write audio frames , without correcting nframes . With arguments `data`.", "question_id": 12072}
{"snippet": "Wave_write.writeframes(data)", "intent": "Write audio frames and make sure nframes is correct . It will raise an error if the output stream is not seekable and the total number of frames that have been written after `data` has been written does not match the previously set value for nframes .", "question_id": 12073}
{"snippet": "weakref.ref(object, callback)", "intent": "Return a weak reference to `object` . If `callback` is provided and not None , and the returned weakref object is still alive , the callback will be called when the object is about to be finalized ; the weak reference object will be passed as the only parameter to the callback ; the referent will no longer be available .", "question_id": 12074}
{"snippet": "weakref.ref(object)", "intent": "Return a weak reference to `object` .", "question_id": 12075}
{"snippet": "ref.__callback__", "intent": "This read-only attribute returns the callback currently associated to the weakref.", "question_id": 12076}
{"snippet": "weakref.proxy(object, callback)", "intent": "Return a proxy to `object` which uses a weak reference . `callback` is the same as the parameter of the same name to the ref ( ) function .", "question_id": 12077}
{"snippet": "weakref.proxy(object)", "intent": "Return a proxy to `object` which uses a weak reference .", "question_id": 12078}
{"snippet": "weakref.getweakrefcount(object)", "intent": "Return the number of weak references and proxies which refer to `object` .", "question_id": 12079}
{"snippet": "weakref.getweakrefs(object)", "intent": "Return a list of all weak reference and proxy objects which refer to `object` .", "question_id": 12080}
{"snippet": "weakref.WeakKeyDictionary(dict)", "intent": "Mapping class that references keys weakly . With arguments `dict`.", "question_id": 12081}
{"snippet": "weakref.WeakKeyDictionary()", "intent": "Mapping class that references keys weakly .", "question_id": 12082}
{"snippet": "WeakKeyDictionary.keyrefs()", "intent": "Return an iterable of the weak references to the keys .", "question_id": 12083}
{"snippet": "weakref.WeakValueDictionary(dict)", "intent": "Mapping class that references values weakly . With arguments `dict`.", "question_id": 12084}
{"snippet": "weakref.WeakValueDictionary()", "intent": "Mapping class that references values weakly .", "question_id": 12085}
{"snippet": "WeakValueDictionary.valuerefs()", "intent": "Return an iterable of the weak references to the values .", "question_id": 12086}
{"snippet": "weakref.WeakSet(elements)", "intent": "Set class that keeps weak references to its `elements` .", "question_id": 12087}
{"snippet": "weakref.WeakSet()", "intent": "Set class that keeps weak references to its `elements` .", "question_id": 12088}
{"snippet": "weakref.WeakMethod(method)", "intent": "A custom ref subclass which simulates a weak reference to a bound `method` ( i.e. , a method defined on a class and looked up on an instance ) .", "question_id": 12089}
{"snippet": "weakref.finalize(obj, func, *args, **kwargs)", "intent": "Return a callable finalizer object which will be called when `obj` is garbage collected . Calling a live finalizer returns the result of evaluating `func` ( *arg , `**kwargs` ) , whereas calling a dead finalizer returns None . With arguments `*args`.", "question_id": 12090}
{"snippet": "finalize.__call__()", "intent": "If self is alive then mark it as dead and return the result of calling func ( *args , **kwargs ) .", "question_id": 12091}
{"snippet": "finalize.detach()", "intent": "If self is alive then mark it as dead and return the tuple ( obj , func , args , kwargs ) .", "question_id": 12092}
{"snippet": "finalize.peek()", "intent": "If self is alive then return the tuple ( obj , func , args , kwargs ) .", "question_id": 12093}
{"snippet": "finalize.alive", "intent": "Property which is true if the finalizer is alive, false otherwise.", "question_id": 12094}
{"snippet": "finalize.atexit", "intent": "A writable boolean property which by default is true.", "question_id": 12095}
{"snippet": "weakref.ReferenceType", "intent": "The type object for weak references objects.", "question_id": 12096}
{"snippet": "weakref.ProxyType", "intent": "The type object for proxies of objects which are not callable.", "question_id": 12097}
{"snippet": "weakref.CallableProxyType", "intent": "The type object for proxies of callable objects.", "question_id": 12098}
{"snippet": "weakref.ProxyTypes", "intent": "Sequence containing all the type objects for proxies.", "question_id": 12099}
{"snippet": "weakref.ReferenceError", "intent": "Exception raised when a proxy object is used but the underlying object has been collected.", "question_id": 12100}
{"snippet": "webbrowser.Error", "intent": "Exception raised when a browser control error occurs.", "question_id": 12101}
{"snippet": "webbrowser.open(url)", "intent": "Display `url` using the default browser .", "question_id": 12102}
{"snippet": "webbrowser.open(url, new=0)", "intent": "Display `url` using the default browser . If `new` is 0 , the url is opened in the same browser window if possible .", "question_id": 12103}
{"snippet": "webbrowser.open(url, autoraise=True)", "intent": "Display `url` using the default browser . If `autoraise` is True , the window is raised if possible ( note that under many window managers this will occur regardless of the setting of this variable ) .", "question_id": 12104}
{"snippet": "webbrowser.open(url, new=0, autoraise=True)", "intent": "Display `url` using the default browser . If `new` is 0 , the url is opened in the same browser window if possible . If `autoraise` is True , the window is raised if possible ( note that under many window managers this will occur regardless of the setting of this variable ) .", "question_id": 12105}
{"snippet": "webbrowser.open_new(url)", "intent": "Open `url` in a new window of the default browser , if possible , otherwise , open url in the only browser window .", "question_id": 12106}
{"snippet": "webbrowser.open_new_tab(url)", "intent": "Open `url` in a new page ( \u201c tab \u201d ) of the default browser , if possible , otherwise equivalent to open_new ( ) .", "question_id": 12107}
{"snippet": "webbrowser.get()", "intent": "Return a controller object for the browser type `using` .", "question_id": 12108}
{"snippet": "webbrowser.get(using=None)", "intent": "Return a controller object for the browser type `using` .", "question_id": 12109}
{"snippet": "webbrowser.register(name, constructor)", "intent": "Register the browser type `name` . If `instance` is not provided , or is None , `constructor` will be called without parameters to create an instance when needed .", "question_id": 12110}
{"snippet": "webbrowser.register(name, constructor, instance=None)", "intent": "Register the browser type `name` . If `instance` is not provided , or is None , `constructor` will be called without parameters to create an instance when needed .", "question_id": 12111}
{"snippet": "webbrowser.register(name, constructor, preferred=False)", "intent": "Register the browser type `name` . If `instance` is not provided , or is None , `constructor` will be called without parameters to create an instance when needed . Setting `preferred` to True makes this browser a preferred result for a get ( ) call with no argument .", "question_id": 12112}
{"snippet": "webbrowser.register(name, constructor, instance=None, preferred=False)", "intent": "Register the browser type `name` . If `instance` is not provided , or is None , `constructor` will be called without parameters to create an instance when needed . Setting `preferred` to True makes this browser a preferred result for a get ( ) call with no argument .", "question_id": 12113}
{"snippet": "controller.open(url)", "intent": "Display `url` using the browser handled by this controller .", "question_id": 12114}
{"snippet": "controller.open(url, new=0)", "intent": "Display `url` using the browser handled by this controller . If `new` is 1 , a new browser window is opened if possible .", "question_id": 12115}
{"snippet": "controller.open(url, autoraise=True)", "intent": "Display `url` using the browser handled by this controller . With arguments `autoraise`.", "question_id": 12116}
{"snippet": "controller.open(url, new=0, autoraise=True)", "intent": "Display `url` using the browser handled by this controller . If `new` is 1 , a new browser window is opened if possible . With arguments `autoraise`.", "question_id": 12117}
{"snippet": "controller.open_new(url)", "intent": "Open `url` in a new window of the browser handled by this controller , if possible , otherwise , open url in the only browser window .", "question_id": 12118}
{"snippet": "controller.open_new_tab(url)", "intent": "Open `url` in a new page ( \u201c tab \u201d ) of the browser handled by this controller , if possible , otherwise equivalent to open_new ( ) .", "question_id": 12119}
{"snippet": "winreg.CloseKey(hkey)", "intent": "Closes a previously opened registry key . The `hkey` argument specifies a previously opened key .", "question_id": 12120}
{"snippet": "winreg.ConnectRegistry(computer_name, key)", "intent": "Establishes a connection to a predefined registry handle on another computer , and returns a handle object . `computer_name` is the name of the remote computer , of the form r '' \\\\computername '' . `key` is the predefined handle to connect to .", "question_id": 12121}
{"snippet": "winreg.CreateKey(key, sub_key)", "intent": "Creates or opens the specified `key` , returning a handle object . `sub_key` is a string that names the key this method opens or creates .", "question_id": 12122}
{"snippet": "winreg.CreateKeyEx(key, sub_key)", "intent": "Creates or opens the specified `key` , returning a handle object . `sub_key` is a string that names the key this method opens or creates .", "question_id": 12123}
{"snippet": "winreg.CreateKeyEx(key, sub_key, reserved=0)", "intent": "Creates or opens the specified `key` , returning a handle object . `sub_key` is a string that names the key this method opens or creates . `reserved` is a reserved integer , and must be zero .", "question_id": 12124}
{"snippet": "winreg.CreateKeyEx(key, sub_key, access=KEY_WRITE)", "intent": "Creates or opens the specified `key` , returning a handle object . `sub_key` is a string that names the key this method opens or creates . `access` is an integer that specifies an access mask that describes the desired security access for the key .", "question_id": 12125}
{"snippet": "winreg.CreateKeyEx(key, sub_key, reserved=0, access=KEY_WRITE)", "intent": "Creates or opens the specified `key` , returning a handle object . `sub_key` is a string that names the key this method opens or creates . `reserved` is a reserved integer , and must be zero . `access` is an integer that specifies an access mask that describes the desired security access for the key .", "question_id": 12126}
{"snippet": "winreg.DeleteKey(key, sub_key)", "intent": "Deletes the specified `key` . `sub_key` is a string that must be a subkey of the key identified by the key parameter .", "question_id": 12127}
{"snippet": "winreg.DeleteKeyEx(key, sub_key)", "intent": "Deletes the specified `key` . `sub_key` is a string that must be a subkey of the key identified by the key parameter .", "question_id": 12128}
{"snippet": "winreg.DeleteKeyEx(key, sub_key, access=KEY_WOW64_64KEY)", "intent": "Deletes the specified `key` . `sub_key` is a string that must be a subkey of the key identified by the key parameter . `access` is an integer that specifies an access mask that describes the desired security access for the key .", "question_id": 12129}
{"snippet": "winreg.DeleteKeyEx(key, sub_key, reserved=0)", "intent": "Deletes the specified `key` . `sub_key` is a string that must be a subkey of the key identified by the key parameter . `reserved` is a reserved integer , and must be zero .", "question_id": 12130}
{"snippet": "winreg.DeleteKeyEx(key, sub_key, access=KEY_WOW64_64KEY, reserved=0)", "intent": "Deletes the specified `key` . `sub_key` is a string that must be a subkey of the key identified by the key parameter . `access` is an integer that specifies an access mask that describes the desired security access for the key . `reserved` is a reserved integer , and must be zero .", "question_id": 12131}
{"snippet": "winreg.DeleteValue(key, value)", "intent": "Removes a named `value` from a registry `key` .", "question_id": 12132}
{"snippet": "winreg.EnumKey(key, index)", "intent": "Enumerates subkeys of an open registry `key` , returning a string . `index` is an integer that identifies the index of the key to retrieve .", "question_id": 12133}
{"snippet": "winreg.EnumValue(key, index)", "intent": "Enumerates values of an open registry `key` , returning a tuple . `index` is an integer that identifies the index of the value to retrieve .", "question_id": 12134}
{"snippet": "winreg.ExpandEnvironmentStrings(str)", "intent": "Expands environment variable placeholders % NAME % in strings like REG_EXPAND_SZ : With arguments `str`.", "question_id": 12135}
{"snippet": "winreg.FlushKey(key)", "intent": "Writes all the attributes of a `key` to the registry .", "question_id": 12136}
{"snippet": "winreg.LoadKey(key, sub_key, file_name)", "intent": "Creates a subkey under the specified `key` and stores registration information from a specified file into that subkey . `sub_key` is a string that identifies the subkey to load . `file_name` is the name of the file to load registry data from .", "question_id": 12137}
{"snippet": "winreg.OpenKey(key, sub_key)", "intent": "Opens the specified `key` , returning a handle object . `sub_key` is a string that identifies the sub_key to open .", "question_id": 12138}
{"snippet": "winreg.OpenKey(key, sub_key, reserved=0)", "intent": "Opens the specified `key` , returning a handle object . `sub_key` is a string that identifies the sub_key to open . `reserved` is a reserved integer , and must be zero .", "question_id": 12139}
{"snippet": "winreg.OpenKey(key, sub_key, access=KEY_READ)", "intent": "Opens the specified `key` , returning a handle object . `sub_key` is a string that identifies the sub_key to open . `access` is an integer that specifies an access mask that describes the desired security access for the key .", "question_id": 12140}
{"snippet": "winreg.OpenKey(key, sub_key, reserved=0, access=KEY_READ)", "intent": "Opens the specified `key` , returning a handle object . `sub_key` is a string that identifies the sub_key to open . `reserved` is a reserved integer , and must be zero . `access` is an integer that specifies an access mask that describes the desired security access for the key .", "question_id": 12141}
{"snippet": "winreg.OpenKeyEx(key, sub_key)", "intent": "Opens the specified `key` , returning a handle object . `sub_key` is a string that identifies the sub_key to open .", "question_id": 12142}
{"snippet": "winreg.OpenKeyEx(key, sub_key, reserved=0)", "intent": "Opens the specified `key` , returning a handle object . `sub_key` is a string that identifies the sub_key to open . `reserved` is a reserved integer , and must be zero .", "question_id": 12143}
{"snippet": "winreg.OpenKeyEx(key, sub_key, access=KEY_READ)", "intent": "Opens the specified `key` , returning a handle object . `sub_key` is a string that identifies the sub_key to open . `access` is an integer that specifies an access mask that describes the desired security access for the key .", "question_id": 12144}
{"snippet": "winreg.OpenKeyEx(key, sub_key, reserved=0, access=KEY_READ)", "intent": "Opens the specified `key` , returning a handle object . `sub_key` is a string that identifies the sub_key to open . `reserved` is a reserved integer , and must be zero . `access` is an integer that specifies an access mask that describes the desired security access for the key .", "question_id": 12145}
{"snippet": "winreg.QueryInfoKey(key)", "intent": "Returns information about a `key` , as a tuple .", "question_id": 12146}
{"snippet": "winreg.QueryValue(key, sub_key)", "intent": "Retrieves the unnamed value for a `key` , as a string . `sub_key` is a string that holds the name of the subkey with which the value is associated .", "question_id": 12147}
{"snippet": "winreg.QueryValueEx(key, value_name)", "intent": "Retrieves the type and data for a specified value name associated with an open registry `key` . `value_name` is a string indicating the value to query .", "question_id": 12148}
{"snippet": "winreg.SaveKey(key, file_name)", "intent": "Saves the specified `key` , and all its subkeys to the specified file . `file_name` is the name of the file to save registry data to .", "question_id": 12149}
{"snippet": "winreg.SetValue(key, sub_key, type, value)", "intent": "Associates a `value` with a specified `key` . `sub_key` is a string that names the subkey with which the value is associated . `type` is an integer that specifies the type of the data .", "question_id": 12150}
{"snippet": "winreg.SetValueEx(key, value_name, reserved, type, value)", "intent": "Stores data in the `value` field of an open registry `key` . `value_name` is a string that names the subkey with which the value is associated . `reserved` can be anything \u2013 zero is always passed to the API . `type` is an integer that specifies the type of the data .", "question_id": 12151}
{"snippet": "winreg.DisableReflectionKey(key)", "intent": "Disables registry reflection for 32-bit processes running on a 64-bit operating system . `key` is an already open key , or one of the predefined HKEY_* constants .", "question_id": 12152}
{"snippet": "winreg.EnableReflectionKey(key)", "intent": "Restores registry reflection for the specified disabled `key` .", "question_id": 12153}
{"snippet": "winreg.QueryReflectionKey(key)", "intent": "Determines the reflection state for the specified `key` .", "question_id": 12154}
{"snippet": "winreg.HKEY_CLASSES_ROOT", "intent": "Registry entries subordinate to this key define types (or classes) of documents and the properties associated with those types.", "question_id": 12155}
{"snippet": "winreg.HKEY_CURRENT_USER", "intent": "Registry entries subordinate to this key define the preferences of the current user.", "question_id": 12156}
{"snippet": "winreg.HKEY_LOCAL_MACHINE", "intent": "Registry entries subordinate to this key define the physical state of the computer, including data about the bus type, system memory, and installed hardware and software.", "question_id": 12157}
{"snippet": "winreg.HKEY_USERS", "intent": "Registry entries subordinate to this key define the default user configuration for new users on the local computer and the user configuration for the current user.", "question_id": 12158}
{"snippet": "winreg.HKEY_PERFORMANCE_DATA", "intent": "Registry entries subordinate to this key allow you to access performance data.", "question_id": 12159}
{"snippet": "winreg.HKEY_CURRENT_CONFIG", "intent": "Contains information about the current hardware profile of the local computer system.", "question_id": 12160}
{"snippet": "winreg.HKEY_DYN_DATA", "intent": "This key is not used in versions of Windows after 98.", "question_id": 12161}
{"snippet": "winreg.KEY_ALL_ACCESS", "intent": "Combines the STANDARD_RIGHTS_REQUIRED, KEY_QUERY_VALUE, KEY_SET_VALUE, KEY_CREATE_SUB_KEY, KEY_ENUMERATE_SUB_KEYS, KEY_NOTIFY, and KEY_CREATE_LINK access rights.", "question_id": 12162}
{"snippet": "winreg.KEY_WRITE", "intent": "Combines the STANDARD_RIGHTS_WRITE, KEY_SET_VALUE, and KEY_CREATE_SUB_KEY access rights.", "question_id": 12163}
{"snippet": "winreg.KEY_READ", "intent": "Combines the STANDARD_RIGHTS_READ, KEY_QUERY_VALUE, KEY_ENUMERATE_SUB_KEYS, and KEY_NOTIFY values.", "question_id": 12164}
{"snippet": "winreg.KEY_EXECUTE", "intent": "Equivalent to KEY_READ.", "question_id": 12165}
{"snippet": "winreg.KEY_QUERY_VALUE", "intent": "Required to query the values of a registry key.", "question_id": 12166}
{"snippet": "winreg.KEY_SET_VALUE", "intent": "Required to create, delete, or set a registry value.", "question_id": 12167}
{"snippet": "winreg.KEY_CREATE_SUB_KEY", "intent": "Required to create a subkey of a registry key.", "question_id": 12168}
{"snippet": "winreg.KEY_ENUMERATE_SUB_KEYS", "intent": "Required to enumerate the subkeys of a registry key.", "question_id": 12169}
{"snippet": "winreg.KEY_NOTIFY", "intent": "Required to request change notifications for a registry key or for subkeys of a registry key.", "question_id": 12170}
{"snippet": "winreg.KEY_CREATE_LINK", "intent": "Reserved for system use.", "question_id": 12171}
{"snippet": "winreg.KEY_WOW64_64KEY", "intent": "Indicates that an application on 64-bit Windows should operate on the 64-bit registry view.", "question_id": 12172}
{"snippet": "winreg.KEY_WOW64_32KEY", "intent": "Indicates that an application on 64-bit Windows should operate on the 32-bit registry view.", "question_id": 12173}
{"snippet": "winreg.REG_BINARY", "intent": "Binary data in any form.", "question_id": 12174}
{"snippet": "winreg.REG_DWORD", "intent": "32-bit number.", "question_id": 12175}
{"snippet": "winreg.REG_DWORD_LITTLE_ENDIAN", "intent": "A 32-bit number in little-endian format.", "question_id": 12176}
{"snippet": "winreg.REG_DWORD_BIG_ENDIAN", "intent": "A 32-bit number in big-endian format.", "question_id": 12177}
{"snippet": "winreg.REG_EXPAND_SZ", "intent": "Null-terminated string containing references to environment variables (%PATH%).", "question_id": 12178}
{"snippet": "winreg.REG_LINK", "intent": "A Unicode symbolic link.", "question_id": 12179}
{"snippet": "winreg.REG_MULTI_SZ", "intent": "A sequence of null-terminated strings, terminated by two null characters.", "question_id": 12180}
{"snippet": "winreg.REG_NONE", "intent": "No defined value type.", "question_id": 12181}
{"snippet": "winreg.REG_QWORD", "intent": "A 64-bit number.", "question_id": 12182}
{"snippet": "winreg.REG_QWORD_LITTLE_ENDIAN", "intent": "A 64-bit number in little-endian format.", "question_id": 12183}
{"snippet": "winreg.REG_RESOURCE_LIST", "intent": "A device-driver resource list.", "question_id": 12184}
{"snippet": "winreg.REG_FULL_RESOURCE_DESCRIPTOR", "intent": "A hardware setting.", "question_id": 12185}
{"snippet": "winreg.REG_RESOURCE_REQUIREMENTS_LIST", "intent": "A hardware resource list.", "question_id": 12186}
{"snippet": "winreg.REG_SZ", "intent": "A null-terminated string.", "question_id": 12187}
{"snippet": "PyHKEY.Close()", "intent": "Closes the underlying Windows handle .", "question_id": 12188}
{"snippet": "PyHKEY.Detach()", "intent": "Detaches the Windows handle from the handle object .", "question_id": 12189}
{"snippet": "PyHKEY.__enter__()", "intent": "The HKEY object implements __enter__ ( ) and __exit__ ( ) and thus supports the context protocol for the with statement :", "question_id": 12190}
{"snippet": "PyHKEY.__exit__(*exc_info)", "intent": "The HKEY object implements __enter__ ( ) and __exit__ ( ) and thus supports the context protocol for the with statement : With arguments `*exc_info`.", "question_id": 12191}
{"snippet": "winsound.Beep(frequency, duration)", "intent": "Beep the PC \u2019 s speaker . The `frequency` parameter specifies frequency , in hertz , of the sound , and must be in the range 37 through 32,767 . The `duration` parameter specifies the number of milliseconds the sound should last .", "question_id": 12192}
{"snippet": "winsound.PlaySound(sound, flags)", "intent": "Call the underlying PlaySound ( ) function from the Platform API . The `sound` parameter may be a filename , a system sound alias , audio data as a bytes-like object , or None . Its interpretation depends on the value of `flags` , which can be a bitwise ORed combination of the constants described below .", "question_id": 12193}
{"snippet": "winsound.MessageBeep()", "intent": "Call the underlying MessageBeep ( ) function from the Platform API .", "question_id": 12194}
{"snippet": "winsound.MessageBeep(type=MB_OK)", "intent": "Call the underlying MessageBeep ( ) function from the Platform API . The `type` argument specifies which sound to play ; possible values are -1 , MB_ICONASTERISK , MB_ICONEXCLAMATION , MB_ICONHAND , MB_ICONQUESTION , and MB_OK , all described below .", "question_id": 12195}
{"snippet": "winsound.SND_FILENAME", "intent": "The sound parameter is the name of a WAV file.", "question_id": 12196}
{"snippet": "winsound.SND_ALIAS", "intent": "The sound parameter is a sound association name from the registry.", "question_id": 12197}
{"snippet": "winsound.SND_LOOP", "intent": "Play the sound repeatedly.", "question_id": 12198}
{"snippet": "winsound.SND_MEMORY", "intent": "The sound parameter to PlaySound() is a memory image of a WAV file, as a bytes-like object.", "question_id": 12199}
{"snippet": "winsound.SND_PURGE", "intent": "Stop playing all instances of the specified sound.", "question_id": 12200}
{"snippet": "winsound.SND_ASYNC", "intent": "Return immediately, allowing sounds to play asynchronously.", "question_id": 12201}
{"snippet": "winsound.SND_NODEFAULT", "intent": "If the specified sound cannot be found, do not play the system default sound.", "question_id": 12202}
{"snippet": "winsound.SND_NOSTOP", "intent": "Do not interrupt sounds currently playing.", "question_id": 12203}
{"snippet": "winsound.SND_NOWAIT", "intent": "Return immediately if the sound driver is busy.", "question_id": 12204}
{"snippet": "winsound.MB_ICONASTERISK", "intent": "Play the SystemDefault sound.", "question_id": 12205}
{"snippet": "winsound.MB_ICONEXCLAMATION", "intent": "Play the SystemExclamation sound.", "question_id": 12206}
{"snippet": "winsound.MB_ICONHAND", "intent": "Play the SystemHand sound.", "question_id": 12207}
{"snippet": "winsound.MB_ICONQUESTION", "intent": "Play the SystemQuestion sound.", "question_id": 12208}
{"snippet": "winsound.MB_OK", "intent": "Play the SystemDefault sound.", "question_id": 12209}
{"snippet": "wsgiref.util.guess_scheme(environ)", "intent": "Return a guess for whether wsgi.url_scheme should be \u201c http \u201d or \u201c https \u201d , by checking for a HTTPS environment variable in the `environ` dictionary .", "question_id": 12210}
{"snippet": "wsgiref.util.request_uri(environ)", "intent": "Return the full request URI , optionally including the query string , using the algorithm found in the \u201c URL Reconstruction \u201d section of PEP 3333 . With arguments `environ`.", "question_id": 12211}
{"snippet": "wsgiref.util.request_uri(environ, include_query=True)", "intent": "Return the full request URI , optionally including the query string , using the algorithm found in the \u201c URL Reconstruction \u201d section of PEP 3333 . If `include_query` is false , the query string is not included in the resulting URI . With arguments `environ`.", "question_id": 12212}
{"snippet": "wsgiref.util.application_uri(environ)", "intent": "Similar to request_uri ( ) , except that the PATH_INFO and QUERY_STRING variables are ignored . With arguments `environ`.", "question_id": 12213}
{"snippet": "wsgiref.util.shift_path_info(environ)", "intent": "Shift a single name from PATH_INFO to SCRIPT_NAME and return the name . The `environ` dictionary is modified in-place ; use a copy if you need to keep the original PATH_INFO or SCRIPT_NAME intact .", "question_id": 12214}
{"snippet": "wsgiref.util.setup_testing_defaults(environ)", "intent": "Update `environ` with trivial defaults for testing purposes .", "question_id": 12215}
{"snippet": "wsgiref.util.is_hop_by_hop(header_name)", "intent": "Return true if \u2018 `header_name` \u2019 is an HTTP/1.1 \u201c Hop-by-Hop \u201d header , as defined by RFC 2616 .", "question_id": 12216}
{"snippet": "wsgiref.util.FileWrapper(filelike)", "intent": "A wrapper to convert a file-like object to an iterator . As the object is iterated over , the optional `blksize` parameter will be repeatedly passed to the `filelike` object \u2019 s read ( ) method to obtain bytestrings to yield .", "question_id": 12217}
{"snippet": "wsgiref.util.FileWrapper(filelike, blksize=8192)", "intent": "A wrapper to convert a file-like object to an iterator . As the object is iterated over , the optional `blksize` parameter will be repeatedly passed to the `filelike` object \u2019 s read ( ) method to obtain bytestrings to yield .", "question_id": 12218}
{"snippet": "wsgiref.headers.Headers(headers)", "intent": "Create a mapping-like object wrapping `headers` , which must be a list of header name/value tuples as described in PEP 3333 .", "question_id": 12219}
{"snippet": "wsgiref.headers.Headers()", "intent": "Create a mapping-like object wrapping `headers` , which must be a list of header name/value tuples as described in PEP 3333 .", "question_id": 12220}
{"snippet": "headers.get_all(name)", "intent": "Return a list of all the values for the named header . If no fields exist with the given `name` , returns an empty list .", "question_id": 12221}
{"snippet": "headers.add_header(name, value, **_params)", "intent": "Add a ( possibly multi-valued ) header , with optional MIME parameters specified via keyword arguments . `name` is the header field to add . If the parameter `value` is a string , it is added to the header value parameters in the form name= '' value '' . With arguments `**_params`.", "question_id": 12222}
{"snippet": "wsgiref.simple_server.make_server(host, port, app)", "intent": "Create a new WSGI server listening on `host` and `port` , accepting connections for `app` .", "question_id": 12223}
{"snippet": "wsgiref.simple_server.make_server(host, port, app, server_class=WSGIServer)", "intent": "Create a new WSGI server listening on `host` and `port` , accepting connections for `app` . The return value is an instance of the supplied `server_class` , and will process requests using the specified `handler_class` .", "question_id": 12224}
{"snippet": "wsgiref.simple_server.make_server(host, port, app, handler_class=WSGIRequestHandler)", "intent": "Create a new WSGI server listening on `host` and `port` , accepting connections for `app` . The return value is an instance of the supplied `server_class` , and will process requests using the specified `handler_class` .", "question_id": 12225}
{"snippet": "wsgiref.simple_server.make_server(host, port, app, server_class=WSGIServer, handler_class=WSGIRequestHandler)", "intent": "Create a new WSGI server listening on `host` and `port` , accepting connections for `app` . The return value is an instance of the supplied `server_class` , and will process requests using the specified `handler_class` .", "question_id": 12226}
{"snippet": "wsgiref.simple_server.demo_app(environ, start_response)", "intent": "This function is a small but complete WSGI application that returns a text page containing the message \u201c Hello world ! \u201d and a list of the key/value pairs provided in the `environ` parameter . With arguments `start_response`.", "question_id": 12227}
{"snippet": "wsgiref.simple_server.WSGIServer(server_address, RequestHandlerClass)", "intent": "Create a WSGIServer instance . `server_address` should be a ( host , port ) tuple , and `RequestHandlerClass` should be the subclass of http.server.BaseHTTPRequestHandler that will be used to process requests .", "question_id": 12228}
{"snippet": "wsgi_server.set_app(application)", "intent": "Sets the callable `application` as the WSGI application that will receive requests .", "question_id": 12229}
{"snippet": "wsgi_server.get_app()", "intent": "Returns the currently-set application callable .", "question_id": 12230}
{"snippet": "wsgiref.simple_server.WSGIRequestHandler(request, client_address, server)", "intent": "Create an HTTP handler for the given `request` ( i.e . a socket ) , `client_address` ( a ( host , port ) tuple ) , and `server` ( WSGIServer instance ) .", "question_id": 12231}
{"snippet": "wsgi_request_handler.get_environ()", "intent": "Returns a dictionary containing the WSGI environment for a request .", "question_id": 12232}
{"snippet": "wsgi_request_handler.get_stderr()", "intent": "Return the object that should be used as the wsgi.errors stream .", "question_id": 12233}
{"snippet": "wsgi_request_handler.handle()", "intent": "Process the HTTP request .", "question_id": 12234}
{"snippet": "wsgiref.validate.validator(application)", "intent": "Wrap `application` and return a new WSGI application object .", "question_id": 12235}
{"snippet": "wsgiref.handlers.CGIHandler", "intent": "CGI-based invocation via sys.stdin, sys.stdout, sys.stderr and os.environ.", "question_id": 12236}
{"snippet": "wsgiref.handlers.IISCGIHandler", "intent": "A specialized alternative to CGIHandler, for use when deploying on Microsoft\u2019s IIS web server, without having set the config allowPathInfo option (IIS>=7) or metabase allowPathInfoForScriptMappings (IIS<7).", "question_id": 12237}
{"snippet": "wsgiref.handlers.BaseCGIHandler(stdin, stdout, stderr, environ)", "intent": "Similar to CGIHandler , but instead of using the sys and os modules , the CGI environment and I/O streams are specified explicitly . With arguments `stdin`, `stdout`, `stderr`, `environ`.", "question_id": 12238}
{"snippet": "wsgiref.handlers.BaseCGIHandler(stdin, stdout, stderr, environ, multithread=True)", "intent": "Similar to CGIHandler , but instead of using the sys and os modules , the CGI environment and I/O streams are specified explicitly . The `multithread` and `multiprocess` values are used to set the wsgi.multithread and wsgi.multiprocess flags for any applications run by the handler instance . With arguments `stdin`, `stdout`, `stderr`, `environ`.", "question_id": 12239}
{"snippet": "wsgiref.handlers.BaseCGIHandler(stdin, stdout, stderr, environ, multiprocess=False)", "intent": "Similar to CGIHandler , but instead of using the sys and os modules , the CGI environment and I/O streams are specified explicitly . The `multithread` and `multiprocess` values are used to set the wsgi.multithread and wsgi.multiprocess flags for any applications run by the handler instance . With arguments `stdin`, `stdout`, `stderr`, `environ`.", "question_id": 12240}
{"snippet": "wsgiref.handlers.BaseCGIHandler(stdin, stdout, stderr, environ, multithread=True, multiprocess=False)", "intent": "Similar to CGIHandler , but instead of using the sys and os modules , the CGI environment and I/O streams are specified explicitly . The `multithread` and `multiprocess` values are used to set the wsgi.multithread and wsgi.multiprocess flags for any applications run by the handler instance . With arguments `stdin`, `stdout`, `stderr`, `environ`.", "question_id": 12241}
{"snippet": "wsgiref.handlers.SimpleHandler(stdin, stdout, stderr, environ)", "intent": "Similar to BaseCGIHandler , but designed for use with HTTP origin servers . The supplied environment and streams are stored in the `stdin` , `stdout` , `stderr` , and `environ` attributes .", "question_id": 12242}
{"snippet": "wsgiref.handlers.SimpleHandler(stdin, stdout, stderr, environ, multithread=True)", "intent": "Similar to BaseCGIHandler , but designed for use with HTTP origin servers . The supplied environment and streams are stored in the `stdin` , `stdout` , `stderr` , and `environ` attributes . With arguments `multithread`.", "question_id": 12243}
{"snippet": "wsgiref.handlers.SimpleHandler(stdin, stdout, stderr, environ, multiprocess=False)", "intent": "Similar to BaseCGIHandler , but designed for use with HTTP origin servers . The supplied environment and streams are stored in the `stdin` , `stdout` , `stderr` , and `environ` attributes . With arguments `multiprocess`.", "question_id": 12244}
{"snippet": "wsgiref.handlers.SimpleHandler(stdin, stdout, stderr, environ, multithread=True, multiprocess=False)", "intent": "Similar to BaseCGIHandler , but designed for use with HTTP origin servers . The supplied environment and streams are stored in the `stdin` , `stdout` , `stderr` , and `environ` attributes . With arguments `multithread`, `multiprocess`.", "question_id": 12245}
{"snippet": "wsgiref.handlers.BaseHandler", "intent": "This is an abstract base class for running WSGI applications.", "question_id": 12246}
{"snippet": "base_handler.run(app)", "intent": "Run the specified WSGI application , `app` .", "question_id": 12247}
{"snippet": "base_handler._write(data)", "intent": "Buffer the bytes `data` for transmission to the client .", "question_id": 12248}
{"snippet": "base_handler._flush()", "intent": "Force buffered data to be transmitted to the client .", "question_id": 12249}
{"snippet": "base_handler.get_stdin()", "intent": "Return an input stream object suitable for use as the wsgi.input of the request currently being processed .", "question_id": 12250}
{"snippet": "base_handler.get_stderr()", "intent": "Return an output stream object suitable for use as the wsgi.errors of the request currently being processed .", "question_id": 12251}
{"snippet": "base_handler.add_cgi_vars()", "intent": "Insert CGI variables for the current request into the environ attribute .", "question_id": 12252}
{"snippet": "base_handler.wsgi_multithread", "intent": "The value to be used for the wsgi.multithread environment variable.", "question_id": 12253}
{"snippet": "base_handler.wsgi_multiprocess", "intent": "The value to be used for the wsgi.multiprocess environment variable.", "question_id": 12254}
{"snippet": "base_handler.wsgi_run_once", "intent": "The value to be used for the wsgi.run_once environment variable.", "question_id": 12255}
{"snippet": "base_handler.os_environ", "intent": "The default environment variables to be included in every request\u2019s WSGI environment.", "question_id": 12256}
{"snippet": "base_handler.server_software", "intent": "If the origin_server attribute is set, this attribute\u2019s value is used to set the default SERVER_SOFTWARE WSGI environment variable, and also to set a default Server: header in HTTP responses.", "question_id": 12257}
{"snippet": "base_handler.get_scheme()", "intent": "Return the URL scheme being used for the current request .", "question_id": 12258}
{"snippet": "base_handler.setup_environ()", "intent": "Set the environ attribute to a fully-populated WSGI environment .", "question_id": 12259}
{"snippet": "base_handler.log_exception(exc_info)", "intent": "Log the `exc_info` tuple in the server log .", "question_id": 12260}
{"snippet": "base_handler.traceback_limit", "intent": "The maximum number of frames to include in tracebacks output by the default log_exception() method.", "question_id": 12261}
{"snippet": "base_handler.error_output(environ, start_response)", "intent": "This method is a WSGI application to generate an error page for the user . This method can access the current error information using sys.exc_info ( ) , and should pass that information to `start_response` when calling it ( as described in the \u201c Error Handling \u201d section of PEP 3333 ) . With arguments `environ`.", "question_id": 12262}
{"snippet": "base_handler.error_status", "intent": "The HTTP status used for error responses.", "question_id": 12263}
{"snippet": "base_handler.error_headers", "intent": "The HTTP headers used for error responses.", "question_id": 12264}
{"snippet": "base_handler.error_body", "intent": "The error response body.", "question_id": 12265}
{"snippet": "base_handler.wsgi_file_wrapper", "intent": "A wsgi.file_wrapper factory, or None.", "question_id": 12266}
{"snippet": "base_handler.sendfile()", "intent": "Override to implement platform-specific file transmission .", "question_id": 12267}
{"snippet": "base_handler.origin_server", "intent": "This attribute should be set to a true value if the handler\u2019s _write() and _flush() are being used to communicate directly to the client, rather than via a CGI-like gateway protocol that wants the HTTP status in a special Status: header.", "question_id": 12268}
{"snippet": "base_handler.http_version", "intent": "If origin_server is true, this string attribute is used to set the HTTP version of the response set to the client.", "question_id": 12269}
{"snippet": "wsgiref.handlers.read_environ()", "intent": "Transcode CGI variables from os.environ to PEP 3333 \u201c bytes in unicode \u201d strings , returning a new dictionary .", "question_id": 12270}
{"snippet": "xdrlib.Packer", "intent": "Packer is the class for packing data into XDR representation.", "question_id": 12271}
{"snippet": "xdrlib.Unpacker(data)", "intent": "Unpacker is the complementary class which unpacks XDR `data` values from a string buffer .", "question_id": 12272}
{"snippet": "Packer.get_buffer()", "intent": "Returns the current pack buffer as a string .", "question_id": 12273}
{"snippet": "Packer.reset()", "intent": "Resets the pack buffer to the empty string .", "question_id": 12274}
{"snippet": "Packer.pack_float(value)", "intent": "Packs the single-precision floating point number `value` .", "question_id": 12275}
{"snippet": "Packer.pack_double(value)", "intent": "Packs the double-precision floating point number `value` .", "question_id": 12276}
{"snippet": "Packer.pack_fstring(n, s)", "intent": "Packs a fixed length string , s. `n` is the length of the string but it is not packed into the data buffer . With arguments `s`.", "question_id": 12277}
{"snippet": "Packer.pack_fopaque(n, data)", "intent": "Packs a fixed length opaque `data` stream , similarly to pack_fstring ( ) . With arguments `n`.", "question_id": 12278}
{"snippet": "Packer.pack_string(s)", "intent": "Packs a variable length string , s. The length of the string is first packed as an unsigned integer , then the string data is packed with pack_fstring ( ) . With arguments `s`.", "question_id": 12279}
{"snippet": "Packer.pack_opaque(data)", "intent": "Packs a variable length opaque `data` string , similarly to pack_string ( ) .", "question_id": 12280}
{"snippet": "Packer.pack_bytes(bytes)", "intent": "Packs a variable length byte stream , similarly to pack_string ( ) . With arguments `bytes`.", "question_id": 12281}
{"snippet": "Packer.pack_list(list, pack_item)", "intent": "Packs a `list` of homogeneous items . `pack_item` is the function that is called to pack the individual item .", "question_id": 12282}
{"snippet": "Packer.pack_farray(n, array, pack_item)", "intent": "Packs a fixed length list ( `array` ) of homogeneous items . `n` is the length of the list ; it is not packed into the buffer , but a ValueError exception is raised if len ( array ) is not equal to n. As above , `pack_item` is the function used to pack each element .", "question_id": 12283}
{"snippet": "Packer.pack_array(list, pack_item)", "intent": "Packs a variable length `list` of homogeneous items . With arguments `pack_item`.", "question_id": 12284}
{"snippet": "Unpacker.reset(data)", "intent": "Resets the string buffer with the given `data` .", "question_id": 12285}
{"snippet": "Unpacker.get_position()", "intent": "Returns the current unpack position in the data buffer .", "question_id": 12286}
{"snippet": "Unpacker.set_position(position)", "intent": "Sets the data buffer unpack `position` to position .", "question_id": 12287}
{"snippet": "Unpacker.get_buffer()", "intent": "Returns the current unpack data buffer as a string .", "question_id": 12288}
{"snippet": "Unpacker.done()", "intent": "Indicates unpack completion .", "question_id": 12289}
{"snippet": "Unpacker.unpack_float()", "intent": "Unpacks a single-precision floating point number .", "question_id": 12290}
{"snippet": "Unpacker.unpack_double()", "intent": "Unpacks a double-precision floating point number , similarly to unpack_float ( ) .", "question_id": 12291}
{"snippet": "Unpacker.unpack_fstring(n)", "intent": "Unpacks and returns a fixed length string . `n` is the number of characters expected .", "question_id": 12292}
{"snippet": "Unpacker.unpack_fopaque(n)", "intent": "Unpacks and returns a fixed length opaque data stream , similarly to unpack_fstring ( ) . With arguments `n`.", "question_id": 12293}
{"snippet": "Unpacker.unpack_string()", "intent": "Unpacks and returns a variable length string .", "question_id": 12294}
{"snippet": "Unpacker.unpack_opaque()", "intent": "Unpacks and returns a variable length opaque data string , similarly to unpack_string ( ) .", "question_id": 12295}
{"snippet": "Unpacker.unpack_bytes()", "intent": "Unpacks and returns a variable length byte stream , similarly to unpack_string ( ) .", "question_id": 12296}
{"snippet": "Unpacker.unpack_list(unpack_item)", "intent": "Unpacks and returns a list of homogeneous items . `unpack_item` is the function that is called to unpack the items .", "question_id": 12297}
{"snippet": "Unpacker.unpack_farray(n, unpack_item)", "intent": "Unpacks and returns ( as a list ) a fixed length array of homogeneous items . `n` is number of list elements to expect in the buffer . As above , `unpack_item` is the function used to unpack each element .", "question_id": 12298}
{"snippet": "Unpacker.unpack_array(unpack_item)", "intent": "Unpacks and returns a variable length list of homogeneous items . With arguments `unpack_item`.", "question_id": 12299}
{"snippet": "xdrlib.Error", "intent": "The base exception class.", "question_id": 12300}
{"snippet": "xdrlib.ConversionError", "intent": "Class derived from Error.", "question_id": 12301}
{"snippet": "xml.dom.registerDOMImplementation(name, factory)", "intent": "Register the `factory` function with the `name` name .", "question_id": 12302}
{"snippet": "xml.dom.getDOMImplementation()", "intent": "Return a suitable DOM implementation .", "question_id": 12303}
{"snippet": "xml.dom.getDOMImplementation(name=None)", "intent": "Return a suitable DOM implementation . The `name` is either well-known , the module name of a DOM implementation , or None .", "question_id": 12304}
{"snippet": "xml.dom.getDOMImplementation(features=())", "intent": "Return a suitable DOM implementation . The `features` list must be a sequence of ( feature , version ) pairs which are passed to the hasFeature ( ) method on available DOMImplementation objects .", "question_id": 12305}
{"snippet": "xml.dom.getDOMImplementation(name=None, features=())", "intent": "Return a suitable DOM implementation . The `name` is either well-known , the module name of a DOM implementation , or None . The `features` list must be a sequence of ( feature , version ) pairs which are passed to the hasFeature ( ) method on available DOMImplementation objects .", "question_id": 12306}
{"snippet": "xml.dom.EMPTY_NAMESPACE", "intent": "The value used to indicate that no namespace is associated with a node in the DOM.", "question_id": 12307}
{"snippet": "xml.dom.XML_NAMESPACE", "intent": "The namespace URI associated with the reserved prefix xml, as defined by Namespaces in XML (section 4).", "question_id": 12308}
{"snippet": "xml.dom.XMLNS_NAMESPACE", "intent": "The namespace URI for namespace declarations, as defined by Document Object Model (DOM) Level 2 Core Specification (section 1.1.8).", "question_id": 12309}
{"snippet": "xml.dom.XHTML_NAMESPACE", "intent": "The URI of the XHTML namespace as defined by XHTML 1.0: The Extensible HyperText Markup Language (section 3.1.1).", "question_id": 12310}
{"snippet": "DOMImplementation.hasFeature(feature, version)", "intent": "Return true if the `feature` identified by the pair of strings feature and `version` is implemented .", "question_id": 12311}
{"snippet": "DOMImplementation.createDocument(namespaceUri, qualifiedName, doctype)", "intent": "Return a new Document object ( the root of the DOM ) , with a child Element object having the given `namespaceUri` and `qualifiedName` . The `doctype` must be a DocumentType object created by createDocumentType ( ) , or None .", "question_id": 12312}
{"snippet": "DOMImplementation.createDocumentType(qualifiedName, publicId, systemId)", "intent": "Return a new DocumentType object that encapsulates the given `qualifiedName` , `publicId` , and `systemId` strings , representing the information contained in an XML document type declaration .", "question_id": 12313}
{"snippet": "Node.nodeType", "intent": "An integer representing the node type.", "question_id": 12314}
{"snippet": "Node.parentNode", "intent": "The parent of the current node, or None for the document node.", "question_id": 12315}
{"snippet": "Node.attributes", "intent": "A NamedNodeMap of attribute objects.", "question_id": 12316}
{"snippet": "Node.previousSibling", "intent": "The node that immediately precedes this one with the same parent.", "question_id": 12317}
{"snippet": "Node.nextSibling", "intent": "The node that immediately follows this one with the same parent.", "question_id": 12318}
{"snippet": "Node.childNodes", "intent": "A list of nodes contained within this node.", "question_id": 12319}
{"snippet": "Node.firstChild", "intent": "The first child of the node, if there are any, or None.", "question_id": 12320}
{"snippet": "Node.lastChild", "intent": "The last child of the node, if there are any, or None.", "question_id": 12321}
{"snippet": "Node.localName", "intent": "The part of the tagName following the colon if there is one, else the entire tagName.", "question_id": 12322}
{"snippet": "Node.prefix", "intent": "The part of the tagName preceding the colon if there is one, else the empty string.", "question_id": 12323}
{"snippet": "Node.namespaceURI", "intent": "The namespace associated with the element name.", "question_id": 12324}
{"snippet": "Node.nodeName", "intent": "This has a different meaning for each node type; see the DOM specification for details.", "question_id": 12325}
{"snippet": "Node.nodeValue", "intent": "This has a different meaning for each node type; see the DOM specification for details.", "question_id": 12326}
{"snippet": "Node.hasAttributes()", "intent": "Returns true if the node has any attributes .", "question_id": 12327}
{"snippet": "Node.hasChildNodes()", "intent": "Returns true if the node has any child nodes .", "question_id": 12328}
{"snippet": "Node.isSameNode(other)", "intent": "Returns true if `other` refers to the same node as this node .", "question_id": 12329}
{"snippet": "Node.appendChild(newChild)", "intent": "Add a new child node to this node at the end of the list of children , returning `newChild` .", "question_id": 12330}
{"snippet": "Node.insertBefore(newChild, refChild)", "intent": "Insert a new child node before an existing child . `newChild` is returned . It must be the case that `refChild` is a child of this node ; if not , ValueError is raised .", "question_id": 12331}
{"snippet": "Node.removeChild(oldChild)", "intent": "Remove a child node . `oldChild` must be a child of this node ; if not , ValueError is raised .", "question_id": 12332}
{"snippet": "Node.replaceChild(newChild, oldChild)", "intent": "Replace an existing node with a new node . It must be the case that `oldChild` is a child of this node ; if not , ValueError is raised . With arguments `newChild`.", "question_id": 12333}
{"snippet": "Node.normalize()", "intent": "Join adjacent text nodes so that all stretches of text are stored as single Text instances .", "question_id": 12334}
{"snippet": "Node.cloneNode(deep)", "intent": "Clone this node . Setting `deep` means to clone all child nodes as well .", "question_id": 12335}
{"snippet": "NodeList.item(i)", "intent": "Return the `i` \u2019 th item from the sequence , if there is one , or None .", "question_id": 12336}
{"snippet": "NodeList.length", "intent": "The number of nodes in the sequence.", "question_id": 12337}
{"snippet": "DocumentType.publicId", "intent": "The public identifier for the external subset of the document type definition.", "question_id": 12338}
{"snippet": "DocumentType.systemId", "intent": "The system identifier for the external subset of the document type definition.", "question_id": 12339}
{"snippet": "DocumentType.internalSubset", "intent": "A string giving the complete internal subset from the document.", "question_id": 12340}
{"snippet": "DocumentType.name", "intent": "The name of the root element as given in the DOCTYPE declaration, if present.", "question_id": 12341}
{"snippet": "DocumentType.entities", "intent": "This is a NamedNodeMap giving the definitions of external entities.", "question_id": 12342}
{"snippet": "DocumentType.notations", "intent": "This is a NamedNodeMap giving the definitions of notations.", "question_id": 12343}
{"snippet": "Document.documentElement", "intent": "The one and only root element of the document.", "question_id": 12344}
{"snippet": "Document.createElement(tagName)", "intent": "Create and return a new element node . With arguments `tagName`.", "question_id": 12345}
{"snippet": "Document.createElementNS(namespaceURI, tagName)", "intent": "Create and return a new element with a namespace . The `tagName` may have a prefix . With arguments `namespaceURI`.", "question_id": 12346}
{"snippet": "Document.createTextNode(data)", "intent": "Create and return a text node containing the `data` passed as a parameter .", "question_id": 12347}
{"snippet": "Document.createComment(data)", "intent": "Create and return a comment node containing the `data` passed as a parameter .", "question_id": 12348}
{"snippet": "Document.createProcessingInstruction(target, data)", "intent": "Create and return a processing instruction node containing the `target` and `data` passed as parameters .", "question_id": 12349}
{"snippet": "Document.createAttribute(name)", "intent": "Create and return an attribute node . With arguments `name`.", "question_id": 12350}
{"snippet": "Document.createAttributeNS(namespaceURI, qualifiedName)", "intent": "Create and return an attribute node with a namespace . With arguments `namespaceURI`, `qualifiedName`.", "question_id": 12351}
{"snippet": "Document.getElementsByTagName(tagName)", "intent": "Search for all descendants ( direct children , children \u2019 s children , etc . ) With arguments `tagName`.", "question_id": 12352}
{"snippet": "Document.getElementsByTagNameNS(namespaceURI, localName)", "intent": "Search for all descendants ( direct children , children \u2019 s children , etc . ) With arguments `namespaceURI`, `localName`.", "question_id": 12353}
{"snippet": "Element.tagName", "intent": "The element type name.", "question_id": 12354}
{"snippet": "Element.getElementsByTagName(tagName)", "intent": "Same as equivalent method in the Document class . With arguments `tagName`.", "question_id": 12355}
{"snippet": "Element.getElementsByTagNameNS(namespaceURI, localName)", "intent": "Same as equivalent method in the Document class . With arguments `namespaceURI`, `localName`.", "question_id": 12356}
{"snippet": "Element.hasAttribute(name)", "intent": "Returns true if the element has an attribute named by `name` .", "question_id": 12357}
{"snippet": "Element.hasAttributeNS(namespaceURI, localName)", "intent": "Returns true if the element has an attribute named by `namespaceURI` and `localName` .", "question_id": 12358}
{"snippet": "Element.getAttribute(name)", "intent": "Return the value of the attribute named by `name` as a string .", "question_id": 12359}
{"snippet": "Element.getAttributeNode(attrname)", "intent": "Return the Attr node for the attribute named by `attrname` .", "question_id": 12360}
{"snippet": "Element.getAttributeNS(namespaceURI, localName)", "intent": "Return the value of the attribute named by `namespaceURI` and `localName` as a string .", "question_id": 12361}
{"snippet": "Element.getAttributeNodeNS(namespaceURI, localName)", "intent": "Return an attribute value as a node , given a `namespaceURI` and `localName` .", "question_id": 12362}
{"snippet": "Element.removeAttribute(name)", "intent": "Remove an attribute by `name` .", "question_id": 12363}
{"snippet": "Element.removeAttributeNode(oldAttr)", "intent": "Remove and return `oldAttr` from the attribute list , if present .", "question_id": 12364}
{"snippet": "Element.removeAttributeNS(namespaceURI, localName)", "intent": "Remove an attribute by name . Note that it uses a `localName` , not a qname . With arguments `namespaceURI`.", "question_id": 12365}
{"snippet": "Element.setAttribute(name, value)", "intent": "Set an attribute `value` from a string . With arguments `name`.", "question_id": 12366}
{"snippet": "Element.setAttributeNode(newAttr)", "intent": "Add a new attribute node to the element , replacing an existing attribute if necessary if the name attribute matches . If `newAttr` is already in use , InuseAttributeErr will be raised .", "question_id": 12367}
{"snippet": "Element.setAttributeNodeNS(newAttr)", "intent": "Add a new attribute node to the element , replacing an existing attribute if necessary if the namespaceURI and localName attributes match . If `newAttr` is already in use , InuseAttributeErr will be raised .", "question_id": 12368}
{"snippet": "Element.setAttributeNS(namespaceURI, qname, value)", "intent": "Set an attribute `value` from a string , given a `namespaceURI` and a `qname` .", "question_id": 12369}
{"snippet": "Attr.name", "intent": "The attribute name.", "question_id": 12370}
{"snippet": "Attr.localName", "intent": "The part of the name following the colon if there is one, else the entire name.", "question_id": 12371}
{"snippet": "Attr.prefix", "intent": "The part of the name preceding the colon if there is one, else the empty string.", "question_id": 12372}
{"snippet": "Attr.value", "intent": "The text value of the attribute.", "question_id": 12373}
{"snippet": "NamedNodeMap.length", "intent": "The length of the attribute list.", "question_id": 12374}
{"snippet": "NamedNodeMap.item(index)", "intent": "Return an attribute with a particular `index` .", "question_id": 12375}
{"snippet": "Comment.data", "intent": "The content of the comment as a string.", "question_id": 12376}
{"snippet": "Text.data", "intent": "The content of the text node as a string.", "question_id": 12377}
{"snippet": "ProcessingInstruction.target", "intent": "The content of the processing instruction up to the first whitespace character.", "question_id": 12378}
{"snippet": "ProcessingInstruction.data", "intent": "The content of the processing instruction following the first whitespace character.", "question_id": 12379}
{"snippet": "xml.dom.DOMException", "intent": "Base exception class used for all specific DOM exceptions.", "question_id": 12380}
{"snippet": "xml.dom.DomstringSizeErr", "intent": "Raised when a specified range of text does not fit into a string.", "question_id": 12381}
{"snippet": "xml.dom.HierarchyRequestErr", "intent": "Raised when an attempt is made to insert a node where the node type is not allowed.", "question_id": 12382}
{"snippet": "xml.dom.IndexSizeErr", "intent": "Raised when an index or size parameter to a method is negative or exceeds the allowed values.", "question_id": 12383}
{"snippet": "xml.dom.InuseAttributeErr", "intent": "Raised when an attempt is made to insert an Attr node that is already present elsewhere in the document.", "question_id": 12384}
{"snippet": "xml.dom.InvalidAccessErr", "intent": "Raised if a parameter or an operation is not supported on the underlying object.", "question_id": 12385}
{"snippet": "xml.dom.InvalidCharacterErr", "intent": "This exception is raised when a string parameter contains a character that is not permitted in the context it\u2019s being used in by the XML 1.0 recommendation.", "question_id": 12386}
{"snippet": "xml.dom.InvalidModificationErr", "intent": "Raised when an attempt is made to modify the type of a node.", "question_id": 12387}
{"snippet": "xml.dom.InvalidStateErr", "intent": "Raised when an attempt is made to use an object that is not defined or is no longer usable.", "question_id": 12388}
{"snippet": "xml.dom.NamespaceErr", "intent": "If an attempt is made to change any object in a way that is not permitted with regard to the Namespaces in XML recommendation, this exception is raised.", "question_id": 12389}
{"snippet": "xml.dom.NotFoundErr", "intent": "Exception when a node does not exist in the referenced context.", "question_id": 12390}
{"snippet": "xml.dom.NotSupportedErr", "intent": "Raised when the implementation does not support the requested type of object or operation.", "question_id": 12391}
{"snippet": "xml.dom.NoDataAllowedErr", "intent": "This is raised if data is specified for a node which does not support data.", "question_id": 12392}
{"snippet": "xml.dom.NoModificationAllowedErr", "intent": "Raised on attempts to modify an object where modifications are not allowed (such as for read-only nodes).", "question_id": 12393}
{"snippet": "xml.dom.SyntaxErr", "intent": "Raised when an invalid or illegal string is specified.", "question_id": 12394}
{"snippet": "xml.dom.WrongDocumentErr", "intent": "Raised when a node is inserted in a different document than it currently belongs to, and the implementation does not support migrating the node from one document to the other.", "question_id": 12395}
{"snippet": "xml.dom.minidom.parse(filename_or_file)", "intent": "Return a Document from the given input . `filename_or_file` may be either a file name , or a file-like object .", "question_id": 12396}
{"snippet": "xml.dom.minidom.parse(filename_or_file, parser=None)", "intent": "Return a Document from the given input . `filename_or_file` may be either a file name , or a file-like object . `parser` , if given , must be a SAX2 parser object .", "question_id": 12397}
{"snippet": "xml.dom.minidom.parse(filename_or_file, bufsize=None)", "intent": "Return a Document from the given input . `filename_or_file` may be either a file name , or a file-like object . With arguments `bufsize`.", "question_id": 12398}
{"snippet": "xml.dom.minidom.parse(filename_or_file, parser=None, bufsize=None)", "intent": "Return a Document from the given input . `filename_or_file` may be either a file name , or a file-like object . `parser` , if given , must be a SAX2 parser object . With arguments `bufsize`.", "question_id": 12399}
{"snippet": "xml.dom.minidom.parseString(string)", "intent": "Return a Document that represents the `string` .", "question_id": 12400}
{"snippet": "xml.dom.minidom.parseString(string, parser=None)", "intent": "Return a Document that represents the `string` . With arguments `parser`.", "question_id": 12401}
{"snippet": "Node.unlink()", "intent": "Break internal references within the DOM so that it will be garbage collected on versions of Python without cyclic GC .", "question_id": 12402}
{"snippet": "Node.writexml(writer)", "intent": "Write XML to the `writer` object .", "question_id": 12403}
{"snippet": "Node.writexml(writer, indent=\"\")", "intent": "Write XML to the `writer` object . The `indent` parameter is the indentation of the current node .", "question_id": 12404}
{"snippet": "Node.writexml(writer, addindent=\"\")", "intent": "Write XML to the `writer` object . The `addindent` parameter is the incremental indentation to use for subnodes of the current one .", "question_id": 12405}
{"snippet": "Node.writexml(writer, newl=\"\")", "intent": "Write XML to the `writer` object . The `newl` parameter specifies the string to use to terminate newlines .", "question_id": 12406}
{"snippet": "Node.writexml(writer, indent=\"\", addindent=\"\")", "intent": "Write XML to the `writer` object . The `indent` parameter is the indentation of the current node . The `addindent` parameter is the incremental indentation to use for subnodes of the current one .", "question_id": 12407}
{"snippet": "Node.writexml(writer, indent=\"\", newl=\"\")", "intent": "Write XML to the `writer` object . The `indent` parameter is the indentation of the current node . The `newl` parameter specifies the string to use to terminate newlines .", "question_id": 12408}
{"snippet": "Node.writexml(writer, addindent=\"\", newl=\"\")", "intent": "Write XML to the `writer` object . The `addindent` parameter is the incremental indentation to use for subnodes of the current one . The `newl` parameter specifies the string to use to terminate newlines .", "question_id": 12409}
{"snippet": "Node.writexml(writer, indent=\"\", addindent=\"\", newl=\"\")", "intent": "Write XML to the `writer` object . The `indent` parameter is the indentation of the current node . The `addindent` parameter is the incremental indentation to use for subnodes of the current one . The `newl` parameter specifies the string to use to terminate newlines .", "question_id": 12410}
{"snippet": "Node.toxml()", "intent": "Return a string or byte string containing the XML represented by the DOM node .", "question_id": 12411}
{"snippet": "Node.toxml(encoding=None)", "intent": "Return a string or byte string containing the XML represented by the DOM node . With an explicit `encoding` 1 argument , the result is a byte string in the specified encoding .", "question_id": 12412}
{"snippet": "Node.toprettyxml()", "intent": "Return a pretty-printed version of the document .", "question_id": 12413}
{"snippet": "Node.toprettyxml(indent=\"\\t\")", "intent": "Return a pretty-printed version of the document . `indent` specifies the indentation string and defaults to a tabulator ; `newl` specifies the string emitted at the end of each line and defaults to \\n .", "question_id": 12414}
{"snippet": "Node.toprettyxml(newl=\"\\n\")", "intent": "Return a pretty-printed version of the document . `indent` specifies the indentation string and defaults to a tabulator ; `newl` specifies the string emitted at the end of each line and defaults to \\n .", "question_id": 12415}
{"snippet": "Node.toprettyxml(encoding=None)", "intent": "Return a pretty-printed version of the document . The `encoding` argument behaves like the corresponding argument of toxml ( ) .", "question_id": 12416}
{"snippet": "Node.toprettyxml(indent=\"\\t\", newl=\"\\n\")", "intent": "Return a pretty-printed version of the document . `indent` specifies the indentation string and defaults to a tabulator ; `newl` specifies the string emitted at the end of each line and defaults to \\n .", "question_id": 12417}
{"snippet": "Node.toprettyxml(indent=\"\\t\", encoding=None)", "intent": "Return a pretty-printed version of the document . `indent` specifies the indentation string and defaults to a tabulator ; `newl` specifies the string emitted at the end of each line and defaults to \\n . The `encoding` argument behaves like the corresponding argument of toxml ( ) .", "question_id": 12418}
{"snippet": "Node.toprettyxml(newl=\"\\n\", encoding=None)", "intent": "Return a pretty-printed version of the document . `indent` specifies the indentation string and defaults to a tabulator ; `newl` specifies the string emitted at the end of each line and defaults to \\n . The `encoding` argument behaves like the corresponding argument of toxml ( ) .", "question_id": 12419}
{"snippet": "Node.toprettyxml(indent=\"\\t\", newl=\"\\n\", encoding=None)", "intent": "Return a pretty-printed version of the document . `indent` specifies the indentation string and defaults to a tabulator ; `newl` specifies the string emitted at the end of each line and defaults to \\n . The `encoding` argument behaves like the corresponding argument of toxml ( ) .", "question_id": 12420}
{"snippet": "xml.dom.pulldom.PullDom()", "intent": "Subclass of xml.sax.handler.ContentHandler .", "question_id": 12421}
{"snippet": "xml.dom.pulldom.PullDom(documentFactory=None)", "intent": "Subclass of xml.sax.handler.ContentHandler . With arguments `documentFactory`.", "question_id": 12422}
{"snippet": "xml.dom.pulldom.SAX2DOM()", "intent": "Subclass of xml.sax.handler.ContentHandler .", "question_id": 12423}
{"snippet": "xml.dom.pulldom.SAX2DOM(documentFactory=None)", "intent": "Subclass of xml.sax.handler.ContentHandler . With arguments `documentFactory`.", "question_id": 12424}
{"snippet": "xml.dom.pulldom.parse(stream_or_string)", "intent": "Return a DOMEventStream from the given input . `stream_or_string` may be either a file name , or a file-like object .", "question_id": 12425}
{"snippet": "xml.dom.pulldom.parse(stream_or_string, parser=None)", "intent": "Return a DOMEventStream from the given input . `stream_or_string` may be either a file name , or a file-like object . `parser` , if given , must be an XMLReader object .", "question_id": 12426}
{"snippet": "xml.dom.pulldom.parse(stream_or_string, bufsize=None)", "intent": "Return a DOMEventStream from the given input . `stream_or_string` may be either a file name , or a file-like object . With arguments `bufsize`.", "question_id": 12427}
{"snippet": "xml.dom.pulldom.parse(stream_or_string, parser=None, bufsize=None)", "intent": "Return a DOMEventStream from the given input . `stream_or_string` may be either a file name , or a file-like object . `parser` , if given , must be an XMLReader object . With arguments `bufsize`.", "question_id": 12428}
{"snippet": "xml.dom.pulldom.parseString(string)", "intent": "Return a DOMEventStream that represents the ( Unicode ) `string` .", "question_id": 12429}
{"snippet": "xml.dom.pulldom.parseString(string, parser=None)", "intent": "Return a DOMEventStream that represents the ( Unicode ) `string` . With arguments `parser`.", "question_id": 12430}
{"snippet": "xml.dom.pulldom.default_bufsize", "intent": "Default value for the bufsize parameter to parse().", "question_id": 12431}
{"snippet": "sax2_dom.getEvent()", "intent": "Return a tuple containing event and the current node as xml.dom.minidom.Document if event equals START_DOCUMENT , xml.dom.minidom.Element if event equals START_ELEMENT or END_ELEMENT or xml.dom.minidom.Text if event equals CHARACTERS .", "question_id": 12432}
{"snippet": "sax2_dom.expandNode(node)", "intent": "Expands all children of `node` into node .", "question_id": 12433}
{"snippet": "xml.etree.ElementTree.Comment()", "intent": "Comment element factory .", "question_id": 12434}
{"snippet": "xml.etree.ElementTree.Comment(text=None)", "intent": "Comment element factory . `text` is a string containing the comment string .", "question_id": 12435}
{"snippet": "xml.etree.ElementTree.dump(elem)", "intent": "Writes an element tree or element structure to sys.stdout . `elem` is an element tree or an individual element .", "question_id": 12436}
{"snippet": "xml.etree.ElementTree.fromstring(text)", "intent": "Parses an XML section from a string constant . `text` is a string containing XML data .", "question_id": 12437}
{"snippet": "xml.etree.ElementTree.fromstring(text, parser=None)", "intent": "Parses an XML section from a string constant . `text` is a string containing XML data . `parser` is an optional parser instance .", "question_id": 12438}
{"snippet": "xml.etree.ElementTree.fromstringlist(sequence)", "intent": "Parses an XML document from a `sequence` of string fragments .", "question_id": 12439}
{"snippet": "xml.etree.ElementTree.fromstringlist(sequence, parser=None)", "intent": "Parses an XML document from a `sequence` of string fragments . `parser` is an optional parser instance .", "question_id": 12440}
{"snippet": "xml.etree.ElementTree.iselement(element)", "intent": "Checks if an object appears to be a valid `element` object .", "question_id": 12441}
{"snippet": "xml.etree.ElementTree.iterparse(source)", "intent": "Parses an XML section into an element tree incrementally , and reports what \u2019 s going on to the user . `source` is a filename or file object containing XML data .", "question_id": 12442}
{"snippet": "xml.etree.ElementTree.iterparse(source, events=None)", "intent": "Parses an XML section into an element tree incrementally , and reports what \u2019 s going on to the user . `source` is a filename or file object containing XML data . `events` is a sequence of events to report back .", "question_id": 12443}
{"snippet": "xml.etree.ElementTree.iterparse(source, parser=None)", "intent": "Parses an XML section into an element tree incrementally , and reports what \u2019 s going on to the user . `source` is a filename or file object containing XML data . `parser` is an optional parser instance .", "question_id": 12444}
{"snippet": "xml.etree.ElementTree.iterparse(source, events=None, parser=None)", "intent": "Parses an XML section into an element tree incrementally , and reports what \u2019 s going on to the user . `source` is a filename or file object containing XML data . `events` is a sequence of events to report back . `parser` is an optional parser instance .", "question_id": 12445}
{"snippet": "xml.etree.ElementTree.parse(source)", "intent": "Parses an XML section into an element tree . `source` is a filename or file object containing XML data .", "question_id": 12446}
{"snippet": "xml.etree.ElementTree.parse(source, parser=None)", "intent": "Parses an XML section into an element tree . `source` is a filename or file object containing XML data . `parser` is an optional parser instance .", "question_id": 12447}
{"snippet": "xml.etree.ElementTree.ProcessingInstruction(target)", "intent": "PI element factory . `target` is a string containing the PI target .", "question_id": 12448}
{"snippet": "xml.etree.ElementTree.ProcessingInstruction(target, text=None)", "intent": "PI element factory . `target` is a string containing the PI target . `text` is a string containing the PI contents , if given .", "question_id": 12449}
{"snippet": "xml.etree.ElementTree.register_namespace(prefix, uri)", "intent": "Registers a namespace `prefix` . `uri` is a namespace uri .", "question_id": 12450}
{"snippet": "xml.etree.ElementTree.SubElement(parent, tag, **extra)", "intent": "Subelement factory . `parent` is the parent element . `tag` is the subelement name . With arguments `**extra`.", "question_id": 12451}
{"snippet": "xml.etree.ElementTree.SubElement(parent, tag, **extra, attrib={})", "intent": "Subelement factory . `parent` is the parent element . `tag` is the subelement name . `attrib` is an optional dictionary , containing element attributes . With arguments `**extra`.", "question_id": 12452}
{"snippet": "xml.etree.ElementTree.tostring(element)", "intent": "Generates a string representation of an XML `element` , including all subelements .", "question_id": 12453}
{"snippet": "xml.etree.ElementTree.tostring(element, encoding=\"us-ascii\")", "intent": "Generates a string representation of an XML `element` , including all subelements . `encoding` 1 is the output encoding ( default is US-ASCII ) .", "question_id": 12454}
{"snippet": "xml.etree.ElementTree.tostring(element, method=\"xml\")", "intent": "Generates a string representation of an XML `element` , including all subelements . `method` is either `` xml '' , `` html '' or `` text '' ( default is `` xml '' ) .", "question_id": 12455}
{"snippet": "xml.etree.ElementTree.tostring(element, short_empty_elements=True)", "intent": "Generates a string representation of an XML `element` , including all subelements . `short_empty_elements` has the same meaning as in ElementTree.write ( ) .", "question_id": 12456}
{"snippet": "xml.etree.ElementTree.tostring(element, encoding=\"us-ascii\", method=\"xml\")", "intent": "Generates a string representation of an XML `element` , including all subelements . `encoding` 1 is the output encoding ( default is US-ASCII ) . `method` is either `` xml '' , `` html '' or `` text '' ( default is `` xml '' ) .", "question_id": 12457}
{"snippet": "xml.etree.ElementTree.tostring(element, encoding=\"us-ascii\", short_empty_elements=True)", "intent": "Generates a string representation of an XML `element` , including all subelements . `encoding` 1 is the output encoding ( default is US-ASCII ) . `short_empty_elements` has the same meaning as in ElementTree.write ( ) .", "question_id": 12458}
{"snippet": "xml.etree.ElementTree.tostring(element, method=\"xml\", short_empty_elements=True)", "intent": "Generates a string representation of an XML `element` , including all subelements . `method` is either `` xml '' , `` html '' or `` text '' ( default is `` xml '' ) . `short_empty_elements` has the same meaning as in ElementTree.write ( ) .", "question_id": 12459}
{"snippet": "xml.etree.ElementTree.tostring(element, encoding=\"us-ascii\", method=\"xml\", short_empty_elements=True)", "intent": "Generates a string representation of an XML `element` , including all subelements . `encoding` 1 is the output encoding ( default is US-ASCII ) . `method` is either `` xml '' , `` html '' or `` text '' ( default is `` xml '' ) . `short_empty_elements` has the same meaning as in ElementTree.write ( ) .", "question_id": 12460}
{"snippet": "xml.etree.ElementTree.tostringlist(element)", "intent": "Generates a string representation of an XML `element` , including all subelements .", "question_id": 12461}
{"snippet": "xml.etree.ElementTree.tostringlist(element, encoding=\"us-ascii\")", "intent": "Generates a string representation of an XML `element` , including all subelements . `encoding` 1 is the output encoding ( default is US-ASCII ) .", "question_id": 12462}
{"snippet": "xml.etree.ElementTree.tostringlist(element, method=\"xml\")", "intent": "Generates a string representation of an XML `element` , including all subelements . `method` is either `` xml '' , `` html '' or `` text '' ( default is `` xml '' ) .", "question_id": 12463}
{"snippet": "xml.etree.ElementTree.tostringlist(element, short_empty_elements=True)", "intent": "Generates a string representation of an XML `element` , including all subelements . `short_empty_elements` has the same meaning as in ElementTree.write ( ) .", "question_id": 12464}
{"snippet": "xml.etree.ElementTree.tostringlist(element, encoding=\"us-ascii\", method=\"xml\")", "intent": "Generates a string representation of an XML `element` , including all subelements . `encoding` 1 is the output encoding ( default is US-ASCII ) . `method` is either `` xml '' , `` html '' or `` text '' ( default is `` xml '' ) .", "question_id": 12465}
{"snippet": "xml.etree.ElementTree.tostringlist(element, encoding=\"us-ascii\", short_empty_elements=True)", "intent": "Generates a string representation of an XML `element` , including all subelements . `encoding` 1 is the output encoding ( default is US-ASCII ) . `short_empty_elements` has the same meaning as in ElementTree.write ( ) .", "question_id": 12466}
{"snippet": "xml.etree.ElementTree.tostringlist(element, method=\"xml\", short_empty_elements=True)", "intent": "Generates a string representation of an XML `element` , including all subelements . `method` is either `` xml '' , `` html '' or `` text '' ( default is `` xml '' ) . `short_empty_elements` has the same meaning as in ElementTree.write ( ) .", "question_id": 12467}
{"snippet": "xml.etree.ElementTree.tostringlist(element, encoding=\"us-ascii\", method=\"xml\", short_empty_elements=True)", "intent": "Generates a string representation of an XML `element` , including all subelements . `encoding` 1 is the output encoding ( default is US-ASCII ) . `method` is either `` xml '' , `` html '' or `` text '' ( default is `` xml '' ) . `short_empty_elements` has the same meaning as in ElementTree.write ( ) .", "question_id": 12468}
{"snippet": "xml.etree.ElementTree.XML(text)", "intent": "Parses an XML section from a string constant . `text` is a string containing XML data .", "question_id": 12469}
{"snippet": "xml.etree.ElementTree.XML(text, parser=None)", "intent": "Parses an XML section from a string constant . `text` is a string containing XML data . `parser` is an optional parser instance .", "question_id": 12470}
{"snippet": "xml.etree.ElementTree.XMLID(text)", "intent": "Parses an XML section from a string constant , and also returns a dictionary which maps from element id : s to elements . `text` is a string containing XML data .", "question_id": 12471}
{"snippet": "xml.etree.ElementTree.XMLID(text, parser=None)", "intent": "Parses an XML section from a string constant , and also returns a dictionary which maps from element id : s to elements . `text` is a string containing XML data . `parser` is an optional parser instance .", "question_id": 12472}
{"snippet": "xml.etree.ElementInclude.default_loader(href, parse)", "intent": "Default loader . `href` is a URL . `parse` is for parse mode either \u201c xml \u201d or \u201c text \u201d .", "question_id": 12473}
{"snippet": "xml.etree.ElementInclude.default_loader(href, parse, encoding=None)", "intent": "Default loader . `href` is a URL . `parse` is for parse mode either \u201c xml \u201d or \u201c text \u201d . `encoding` is an optional text encoding .", "question_id": 12474}
{"snippet": "xml.etree.ElementInclude.include(elem)", "intent": "This function expands XInclude directives . `elem` is the root element .", "question_id": 12475}
{"snippet": "xml.etree.ElementInclude.include(elem, loader=None)", "intent": "This function expands XInclude directives . `elem` is the root element . `loader` is an optional resource loader .", "question_id": 12476}
{"snippet": "xml.etree.ElementTree.Element(tag, **extra)", "intent": "Element class . `tag` is the element name . With arguments `**extra`.", "question_id": 12477}
{"snippet": "xml.etree.ElementTree.Element(tag, **extra, attrib={})", "intent": "Element class . `tag` is the element name . `attrib` is an optional dictionary , containing element attributes . With arguments `**extra`.", "question_id": 12478}
{"snippet": "element.tag", "intent": "A string identifying what kind of data this element represents (the element type, in other words).", "question_id": 12479}
{"snippet": "element.text", "intent": "These attributes can be used to hold additional data associated with the element.", "question_id": 12480}
{"snippet": "element.tail", "intent": "These attributes can be used to hold additional data associated with the element.", "question_id": 12481}
{"snippet": "element.attrib", "intent": "A dictionary containing the element\u2019s attributes.", "question_id": 12482}
{"snippet": "element.clear()", "intent": "Resets an element .", "question_id": 12483}
{"snippet": "element.get(key)", "intent": "Gets the element attribute named `key` .", "question_id": 12484}
{"snippet": "element.get(key, default=None)", "intent": "Gets the element attribute named `key` . Returns the attribute value , or `default` if the attribute was not found .", "question_id": 12485}
{"snippet": "element.items()", "intent": "Returns the element attributes as a sequence of ( name , value ) pairs .", "question_id": 12486}
{"snippet": "element.keys()", "intent": "Returns the elements attribute names as a list .", "question_id": 12487}
{"snippet": "element.set(key, value)", "intent": "Set the attribute `key` on the element to `value` .", "question_id": 12488}
{"snippet": "element.append(subelement)", "intent": "Adds the element `subelement` to the end of this element \u2019 s internal list of subelements .", "question_id": 12489}
{"snippet": "element.extend(subelements)", "intent": "Appends `subelements` from a sequence object with zero or more elements .", "question_id": 12490}
{"snippet": "element.find(match)", "intent": "Finds the first subelement matching `match` .", "question_id": 12491}
{"snippet": "element.find(match, namespaces=None)", "intent": "Finds the first subelement matching `match` . `namespaces` is an optional mapping from namespace prefix to full name .", "question_id": 12492}
{"snippet": "element.findall(match)", "intent": "Finds all matching subelements , by tag name or path . With arguments `match`.", "question_id": 12493}
{"snippet": "element.findall(match, namespaces=None)", "intent": "Finds all matching subelements , by tag name or path . `namespaces` is an optional mapping from namespace prefix to full name . With arguments `match`.", "question_id": 12494}
{"snippet": "element.findtext(match)", "intent": "Finds text for the first subelement matching `match` .", "question_id": 12495}
{"snippet": "element.findtext(match, default=None)", "intent": "Finds text for the first subelement matching `match` . Returns the text content of the first matching element , or `default` if no element was found .", "question_id": 12496}
{"snippet": "element.findtext(match, namespaces=None)", "intent": "Finds text for the first subelement matching `match` . `namespaces` is an optional mapping from namespace prefix to full name .", "question_id": 12497}
{"snippet": "element.findtext(match, default=None, namespaces=None)", "intent": "Finds text for the first subelement matching `match` . Returns the text content of the first matching element , or `default` if no element was found . `namespaces` is an optional mapping from namespace prefix to full name .", "question_id": 12498}
{"snippet": "element.insert(index, subelement)", "intent": "Inserts `subelement` at the given position in this element . With arguments `index`.", "question_id": 12499}
{"snippet": "element.iter()", "intent": "Creates a tree iterator with the current element as the root .", "question_id": 12500}
{"snippet": "element.iter(tag=None)", "intent": "Creates a tree iterator with the current element as the root . If `tag` is not None or '* ' , only elements whose tag equals tag are returned from the iterator .", "question_id": 12501}
{"snippet": "element.iterfind(match)", "intent": "Finds all matching subelements , by tag name or path . With arguments `match`.", "question_id": 12502}
{"snippet": "element.iterfind(match, namespaces=None)", "intent": "Finds all matching subelements , by tag name or path . `namespaces` is an optional mapping from namespace prefix to full name . With arguments `match`.", "question_id": 12503}
{"snippet": "element.itertext()", "intent": "Creates a text iterator .", "question_id": 12504}
{"snippet": "element.makeelement(tag, attrib)", "intent": "Creates a new element object of the same type as this element . With arguments `tag`, `attrib`.", "question_id": 12505}
{"snippet": "element.remove(subelement)", "intent": "Removes `subelement` from the element .", "question_id": 12506}
{"snippet": "xml.etree.ElementTree.ElementTree()", "intent": "ElementTree wrapper class .", "question_id": 12507}
{"snippet": "xml.etree.ElementTree.ElementTree(element=None)", "intent": "ElementTree wrapper class . This class represents an entire `element` hierarchy , and adds some extra support for serialization to and from standard XML .", "question_id": 12508}
{"snippet": "xml.etree.ElementTree.ElementTree(file=None)", "intent": "ElementTree wrapper class . The tree is initialized with the contents of the XML `file` if given .", "question_id": 12509}
{"snippet": "xml.etree.ElementTree.ElementTree(element=None, file=None)", "intent": "ElementTree wrapper class . This class represents an entire `element` hierarchy , and adds some extra support for serialization to and from standard XML . The tree is initialized with the contents of the XML `file` if given .", "question_id": 12510}
{"snippet": "element_tree._setroot(element)", "intent": "Replaces the root `element` for this tree .", "question_id": 12511}
{"snippet": "element_tree.find(match)", "intent": "Same as Element.find ( ) , starting at the root of the tree . With arguments `match`.", "question_id": 12512}
{"snippet": "element_tree.find(match, namespaces=None)", "intent": "Same as Element.find ( ) , starting at the root of the tree . With arguments `match`, `namespaces`.", "question_id": 12513}
{"snippet": "element_tree.findall(match)", "intent": "Same as Element.findall ( ) , starting at the root of the tree . With arguments `match`.", "question_id": 12514}
{"snippet": "element_tree.findall(match, namespaces=None)", "intent": "Same as Element.findall ( ) , starting at the root of the tree . With arguments `match`, `namespaces`.", "question_id": 12515}
{"snippet": "element_tree.findtext(match)", "intent": "Same as Element.findtext ( ) , starting at the root of the tree . With arguments `match`.", "question_id": 12516}
{"snippet": "element_tree.findtext(match, default=None)", "intent": "Same as Element.findtext ( ) , starting at the root of the tree . With arguments `match`, `default`.", "question_id": 12517}
{"snippet": "element_tree.findtext(match, namespaces=None)", "intent": "Same as Element.findtext ( ) , starting at the root of the tree . With arguments `match`, `namespaces`.", "question_id": 12518}
{"snippet": "element_tree.findtext(match, default=None, namespaces=None)", "intent": "Same as Element.findtext ( ) , starting at the root of the tree . With arguments `match`, `default`, `namespaces`.", "question_id": 12519}
{"snippet": "element_tree.getroot()", "intent": "Returns the root element for this tree .", "question_id": 12520}
{"snippet": "element_tree.iter()", "intent": "Creates and returns a tree iterator for the root element .", "question_id": 12521}
{"snippet": "element_tree.iter(tag=None)", "intent": "Creates and returns a tree iterator for the root element . `tag` is the tag to look for ( default is to return all elements ) .", "question_id": 12522}
{"snippet": "element_tree.iterfind(match)", "intent": "Same as Element.iterfind ( ) , starting at the root of the tree . With arguments `match`.", "question_id": 12523}
{"snippet": "element_tree.iterfind(match, namespaces=None)", "intent": "Same as Element.iterfind ( ) , starting at the root of the tree . With arguments `match`, `namespaces`.", "question_id": 12524}
{"snippet": "element_tree.parse(source)", "intent": "Loads an external XML section into this element tree . `source` is a file name or file object .", "question_id": 12525}
{"snippet": "element_tree.parse(source, parser=None)", "intent": "Loads an external XML section into this element tree . `source` is a file name or file object . `parser` is an optional parser instance .", "question_id": 12526}
{"snippet": "element_tree.write(file)", "intent": "Writes the element tree to a `file` , as XML .", "question_id": 12527}
{"snippet": "element_tree.write(file, encoding=\"us-ascii\")", "intent": "Writes the element tree to a `file` , as XML . `encoding` 1 is the output encoding ( default is US-ASCII ) .", "question_id": 12528}
{"snippet": "element_tree.write(file, xml_declaration=None)", "intent": "Writes the element tree to a `file` , as XML . `xml_declaration` controls if an XML declaration should be added to the file .", "question_id": 12529}
{"snippet": "element_tree.write(file, default_namespace=None)", "intent": "Writes the element tree to a `file` , as XML . `default_namespace` sets the default XML namespace ( for \u201c xmlns \u201d ) .", "question_id": 12530}
{"snippet": "element_tree.write(file, method=\"xml\")", "intent": "Writes the element tree to a `file` , as XML . `method` is either `` xml '' , `` html '' or `` text '' ( default is `` xml '' ) .", "question_id": 12531}
{"snippet": "element_tree.write(file, short_empty_elements=True)", "intent": "Writes the element tree to a `file` , as XML . The keyword-only `short_empty_elements` parameter controls the formatting of elements that contain no content .", "question_id": 12532}
{"snippet": "element_tree.write(file, encoding=\"us-ascii\", xml_declaration=None)", "intent": "Writes the element tree to a `file` , as XML . `encoding` 1 is the output encoding ( default is US-ASCII ) . `xml_declaration` controls if an XML declaration should be added to the file .", "question_id": 12533}
{"snippet": "element_tree.write(file, encoding=\"us-ascii\", default_namespace=None)", "intent": "Writes the element tree to a `file` , as XML . `encoding` 1 is the output encoding ( default is US-ASCII ) . `default_namespace` sets the default XML namespace ( for \u201c xmlns \u201d ) .", "question_id": 12534}
{"snippet": "element_tree.write(file, encoding=\"us-ascii\", method=\"xml\")", "intent": "Writes the element tree to a `file` , as XML . `encoding` 1 is the output encoding ( default is US-ASCII ) . `method` is either `` xml '' , `` html '' or `` text '' ( default is `` xml '' ) .", "question_id": 12535}
{"snippet": "element_tree.write(file, encoding=\"us-ascii\", short_empty_elements=True)", "intent": "Writes the element tree to a `file` , as XML . `encoding` 1 is the output encoding ( default is US-ASCII ) . The keyword-only `short_empty_elements` parameter controls the formatting of elements that contain no content .", "question_id": 12536}
{"snippet": "xml.etree.ElementTree.QName(text_or_uri)", "intent": "QName wrapper . `text_or_uri` is a string containing the QName value , in the form { uri } local , or , if the `tag` argument is given , the URI part of a QName .", "question_id": 12537}
{"snippet": "xml.etree.ElementTree.QName(text_or_uri, tag=None)", "intent": "QName wrapper . `text_or_uri` is a string containing the QName value , in the form { uri } local , or , if the `tag` argument is given , the URI part of a QName .", "question_id": 12538}
{"snippet": "xml.etree.ElementTree.TreeBuilder()", "intent": "Generic element structure builder .", "question_id": 12539}
{"snippet": "xml.etree.ElementTree.TreeBuilder(element_factory=None)", "intent": "Generic element structure builder . `element_factory` , when given , must be a callable accepting two positional arguments : a tag and a dict of attributes .", "question_id": 12540}
{"snippet": "tree_builder.close()", "intent": "Flushes the builder buffers , and returns the toplevel document element .", "question_id": 12541}
{"snippet": "tree_builder.data(data)", "intent": "Adds text to the current element . `data` is a string .", "question_id": 12542}
{"snippet": "tree_builder.end(tag)", "intent": "Closes the current element . `tag` is the element name .", "question_id": 12543}
{"snippet": "tree_builder.start(tag, attrs)", "intent": "Opens a new element . `tag` is the element name . `attrs` is a dictionary containing element attributes .", "question_id": 12544}
{"snippet": "tree_builder.doctype(name, pubid, system)", "intent": "Handles a doctype declaration . `name` is the doctype name . `pubid` is the public identifier . `system` is the system identifier .", "question_id": 12545}
{"snippet": "xml.etree.ElementTree.XMLParser()", "intent": "This class is the low-level building block of the module .", "question_id": 12546}
{"snippet": "xml.etree.ElementTree.XMLParser(html=0)", "intent": "This class is the low-level building block of the module . The `html` argument was historically used for backwards compatibility and is now deprecated .", "question_id": 12547}
{"snippet": "xml.etree.ElementTree.XMLParser(target=None)", "intent": "This class is the low-level building block of the module . It can be fed XML data incrementally with the feed ( ) method , and parsing events are translated to a push API - by invoking callbacks on the `target` object .", "question_id": 12548}
{"snippet": "xml.etree.ElementTree.XMLParser(encoding=None)", "intent": "This class is the low-level building block of the module . If `encoding` 1 is given , the value overrides the encoding specified in the XML file .", "question_id": 12549}
{"snippet": "xml.etree.ElementTree.XMLParser(html=0, target=None)", "intent": "This class is the low-level building block of the module . The `html` argument was historically used for backwards compatibility and is now deprecated . It can be fed XML data incrementally with the feed ( ) method , and parsing events are translated to a push API - by invoking callbacks on the `target` object .", "question_id": 12550}
{"snippet": "xml.etree.ElementTree.XMLParser(html=0, encoding=None)", "intent": "This class is the low-level building block of the module . The `html` argument was historically used for backwards compatibility and is now deprecated . If `encoding` 1 is given , the value overrides the encoding specified in the XML file .", "question_id": 12551}
{"snippet": "xml.etree.ElementTree.XMLParser(target=None, encoding=None)", "intent": "This class is the low-level building block of the module . It can be fed XML data incrementally with the feed ( ) method , and parsing events are translated to a push API - by invoking callbacks on the `target` object . If `encoding` 1 is given , the value overrides the encoding specified in the XML file .", "question_id": 12552}
{"snippet": "xml.etree.ElementTree.XMLParser(html=0, target=None, encoding=None)", "intent": "This class is the low-level building block of the module . The `html` argument was historically used for backwards compatibility and is now deprecated . It can be fed XML data incrementally with the feed ( ) method , and parsing events are translated to a push API - by invoking callbacks on the `target` object . If `encoding` 1 is given , the value overrides the encoding specified in the XML file .", "question_id": 12553}
{"snippet": "xml_parser.close()", "intent": "Finishes feeding data to the parser .", "question_id": 12554}
{"snippet": "xml_parser.feed(data)", "intent": "Feeds `data` to the parser .", "question_id": 12555}
{"snippet": "xml.etree.ElementTree.XMLPullParser()", "intent": "A pull parser suitable for non-blocking applications .", "question_id": 12556}
{"snippet": "xml.etree.ElementTree.XMLPullParser(events=None)", "intent": "A pull parser suitable for non-blocking applications . Its input-side API is similar to that of XMLParser , but instead of pushing calls to a callback target , XMLPullParser collects an internal list of parsing `events` and lets the user read from it .", "question_id": 12557}
{"snippet": "xml_pull_parser.feed(data)", "intent": "Feed the given bytes `data` to the parser .", "question_id": 12558}
{"snippet": "xml_pull_parser.close()", "intent": "Signal the parser that the data stream is terminated .", "question_id": 12559}
{"snippet": "xml_pull_parser.read_events()", "intent": "Return an iterator over the events which have been encountered in the data fed to the parser .", "question_id": 12560}
{"snippet": "xml.etree.ElementTree.ParseError", "intent": "XML parse error, raised by the various parsing methods in this module when parsing fails.", "question_id": 12561}
{"snippet": "parse_error.code", "intent": "A numeric error code from the expat parser.", "question_id": 12562}
{"snippet": "parse_error.position", "intent": "A tuple of line, column numbers, specifying where the error occurred.", "question_id": 12563}
{"snippet": "xml.sax.handler.ContentHandler", "intent": "This is the main callback interface in SAX, and the one most important to applications.", "question_id": 12564}
{"snippet": "xml.sax.handler.DTDHandler", "intent": "Handle DTD events.", "question_id": 12565}
{"snippet": "xml.sax.handler.EntityResolver", "intent": "Basic interface for resolving entities.", "question_id": 12566}
{"snippet": "xml.sax.handler.ErrorHandler", "intent": "Interface used by the parser to present error and warning messages to the application.", "question_id": 12567}
{"snippet": "xml.sax.handler.all_features", "intent": "List of all features.", "question_id": 12568}
{"snippet": "xml.sax.handler.all_properties", "intent": "List of all known property names.", "question_id": 12569}
{"snippet": "ContentHandler.setDocumentLocator(locator)", "intent": "Called by the parser to give the application a `locator` for locating the origin of document events .", "question_id": 12570}
{"snippet": "ContentHandler.startDocument()", "intent": "Receive notification of the beginning of a document .", "question_id": 12571}
{"snippet": "ContentHandler.endDocument()", "intent": "Receive notification of the end of a document .", "question_id": 12572}
{"snippet": "ContentHandler.startPrefixMapping(prefix, uri)", "intent": "Begin the scope of a prefix-URI Namespace mapping . With arguments `prefix`, `uri`.", "question_id": 12573}
{"snippet": "ContentHandler.endPrefixMapping(prefix)", "intent": "End the scope of a prefix-URI mapping . With arguments `prefix`.", "question_id": 12574}
{"snippet": "ContentHandler.startElement(name, attrs)", "intent": "Signals the start of an element in non-namespace mode . The `name` parameter contains the raw XML 1.0 name of the element type as a string and the `attrs` parameter holds an object of the Attributes interface ( see The Attributes Interface ) containing the attributes of the element .", "question_id": 12575}
{"snippet": "ContentHandler.endElement(name)", "intent": "Signals the end of an element in non-namespace mode . The `name` parameter contains the name of the element type , just as with the startElement ( ) event .", "question_id": 12576}
{"snippet": "ContentHandler.startElementNS(name, qname, attrs)", "intent": "Signals the start of an element in namespace mode . The `name` parameter contains the name of the element type as a ( uri , localname ) tuple , the `qname` parameter contains the raw XML 1.0 name used in the source document , and the `attrs` parameter holds an instance of the AttributesNS interface ( see The AttributesNS Interface ) containing the attributes of the element .", "question_id": 12577}
{"snippet": "ContentHandler.endElementNS(name, qname)", "intent": "Signals the end of an element in namespace mode . The `name` parameter contains the name of the element type , just as with the startElementNS ( ) method , likewise the `qname` parameter .", "question_id": 12578}
{"snippet": "ContentHandler.characters(content)", "intent": "Receive notification of character data . `content` may be a string or bytes instance ; the expat reader module always produces strings .", "question_id": 12579}
{"snippet": "ContentHandler.ignorableWhitespace(whitespace)", "intent": "Receive notification of ignorable `whitespace` in element content .", "question_id": 12580}
{"snippet": "ContentHandler.processingInstruction(target, data)", "intent": "Receive notification of a processing instruction . With arguments `target`, `data`.", "question_id": 12581}
{"snippet": "ContentHandler.skippedEntity(name)", "intent": "Receive notification of a skipped entity . With arguments `name`.", "question_id": 12582}
{"snippet": "DTDHandler.notationDecl(name, publicId, systemId)", "intent": "Handle a notation declaration event . With arguments `name`, `publicId`, `systemId`.", "question_id": 12583}
{"snippet": "DTDHandler.unparsedEntityDecl(name, publicId, systemId, ndata)", "intent": "Handle an unparsed entity declaration event . With arguments `name`, `publicId`, `systemId`, `ndata`.", "question_id": 12584}
{"snippet": "EntityResolver.resolveEntity(publicId, systemId)", "intent": "Resolve the system identifier of an entity and return either the system identifier to read from as a string , or an InputSource to read from . The default implementation returns `systemId` . With arguments `publicId`.", "question_id": 12585}
{"snippet": "ErrorHandler.error(exception)", "intent": "Called when the parser encounters a recoverable error . If this method does not raise an `exception` , parsing may continue , but further document information should not be expected by the application .", "question_id": 12586}
{"snippet": "ErrorHandler.fatalError(exception)", "intent": "Called when the parser encounters an error it can not recover from ; parsing is expected to terminate when this method returns . With arguments `exception`.", "question_id": 12587}
{"snippet": "ErrorHandler.warning(exception)", "intent": "Called when the parser presents minor warning information to the application . Raising an `exception` in this method will cause parsing to end .", "question_id": 12588}
{"snippet": "xml.sax.make_parser()", "intent": "Create and return a SAX XMLReader object .", "question_id": 12589}
{"snippet": "xml.sax.make_parser(parser_list=)", "intent": "Create and return a SAX XMLReader object . If `parser_list` is provided , it must be a list of strings which name modules that have a function named create_parser ( ) .", "question_id": 12590}
{"snippet": "xml.sax.make_parser()", "intent": "Create and return a SAX XMLReader object .", "question_id": 12591}
{"snippet": "xml.sax.make_parser(parser_list=)", "intent": "Create and return a SAX XMLReader object . If `parser_list` is provided , it must be a list of strings which name modules that have a function named create_parser ( ) .", "question_id": 12592}
{"snippet": "xml.sax.parse(filename_or_stream, handler)", "intent": "Create a SAX parser and use it to parse a document . The document , passed in as `filename_or_stream` , can be a filename or a file object . The `handler` parameter needs to be a SAX ContentHandler instance .", "question_id": 12593}
{"snippet": "xml.sax.parse(filename_or_stream, handler, error_handler=handler.ErrorHandler())", "intent": "Create a SAX parser and use it to parse a document . The document , passed in as `filename_or_stream` , can be a filename or a file object . The `handler` parameter needs to be a SAX ContentHandler instance . If `error_handler` is given , it must be a SAX ErrorHandler instance ; if omitted , SAXParseException will be raised on all errors .", "question_id": 12594}
{"snippet": "xml.sax.parseString(string, handler)", "intent": "Similar to parse ( ) , but parses from a buffer `string` received as a parameter . With arguments `handler`.", "question_id": 12595}
{"snippet": "xml.sax.parseString(string, handler, error_handler=handler.ErrorHandler())", "intent": "Similar to parse ( ) , but parses from a buffer `string` received as a parameter . With arguments `handler`, `error_handler`.", "question_id": 12596}
{"snippet": "xml.sax.SAXException(msg)", "intent": "Encapsulate an XML error or warning . When instantiated , `msg` should be a human-readable description of the error .", "question_id": 12597}
{"snippet": "xml.sax.SAXException(msg, exception=None)", "intent": "Encapsulate an XML error or warning . When instantiated , `msg` should be a human-readable description of the error . Note that although the handlers defined in the ErrorHandler interface receive instances of this `exception` , it is not required to actually raise the exception \u2014 it is also useful as a container for information .", "question_id": 12598}
{"snippet": "xml.sax.SAXParseException(msg, exception, locator)", "intent": "Subclass of SAXException raised on parse errors . With arguments `msg`, `exception`, `locator`.", "question_id": 12599}
{"snippet": "xml.sax.SAXNotRecognizedException(msg)", "intent": "Subclass of SAXException raised when a SAX XMLReader is confronted with an unrecognized feature or property . With arguments `msg`.", "question_id": 12600}
{"snippet": "xml.sax.SAXNotRecognizedException(msg, exception=None)", "intent": "Subclass of SAXException raised when a SAX XMLReader is confronted with an unrecognized feature or property . With arguments `msg`, `exception`.", "question_id": 12601}
{"snippet": "xml.sax.SAXNotSupportedException(msg)", "intent": "Subclass of SAXException raised when a SAX XMLReader is asked to enable a feature that is not supported , or to set a property to a value that the implementation does not support . With arguments `msg`.", "question_id": 12602}
{"snippet": "xml.sax.SAXNotSupportedException(msg, exception=None)", "intent": "Subclass of SAXException raised when a SAX XMLReader is asked to enable a feature that is not supported , or to set a property to a value that the implementation does not support . With arguments `msg`, `exception`.", "question_id": 12603}
{"snippet": "SAXException.getMessage()", "intent": "Return a human-readable message describing the error condition .", "question_id": 12604}
{"snippet": "SAXException.getException()", "intent": "Return an encapsulated exception object , or None .", "question_id": 12605}
{"snippet": "xml.sax.xmlreader.XMLReader", "intent": "Base class which can be inherited by SAX parsers.", "question_id": 12606}
{"snippet": "xml.sax.xmlreader.IncrementalParser", "intent": "In some cases, it is desirable not to parse an input source at once, but to feed chunks of the document as they get available.", "question_id": 12607}
{"snippet": "xml.sax.xmlreader.Locator", "intent": "Interface for associating a SAX event with a document location.", "question_id": 12608}
{"snippet": "xml.sax.xmlreader.InputSource()", "intent": "Encapsulation of the information needed by the XMLReader to read entities .", "question_id": 12609}
{"snippet": "xml.sax.xmlreader.InputSource(system_id=None)", "intent": "Encapsulation of the information needed by the XMLReader to read entities . With arguments `system_id`.", "question_id": 12610}
{"snippet": "xml.sax.xmlreader.AttributesImpl(attrs)", "intent": "This is an implementation of the Attributes interface ( see section The Attributes Interface ) . Objects of this class should be instantiated by readers ; `attrs` must be a dictionary-like object containing a mapping from attribute names to attribute values .", "question_id": 12611}
{"snippet": "xml.sax.xmlreader.AttributesNSImpl(attrs, qnames)", "intent": "Namespace-aware variant of AttributesImpl , which will be passed to startElementNS ( ) . With arguments `attrs`, `qnames`.", "question_id": 12612}
{"snippet": "XMLReader.parse(source)", "intent": "Process an input `source` , producing SAX events .", "question_id": 12613}
{"snippet": "XMLReader.getContentHandler()", "intent": "Return the current ContentHandler .", "question_id": 12614}
{"snippet": "XMLReader.setContentHandler(handler)", "intent": "Set the current ContentHandler . With arguments `handler`.", "question_id": 12615}
{"snippet": "XMLReader.getDTDHandler()", "intent": "Return the current DTDHandler .", "question_id": 12616}
{"snippet": "XMLReader.setDTDHandler(handler)", "intent": "Set the current DTDHandler . With arguments `handler`.", "question_id": 12617}
{"snippet": "XMLReader.getEntityResolver()", "intent": "Return the current EntityResolver .", "question_id": 12618}
{"snippet": "XMLReader.setEntityResolver(handler)", "intent": "Set the current EntityResolver . With arguments `handler`.", "question_id": 12619}
{"snippet": "XMLReader.getErrorHandler()", "intent": "Return the current ErrorHandler .", "question_id": 12620}
{"snippet": "XMLReader.setErrorHandler(handler)", "intent": "Set the current error `handler` .", "question_id": 12621}
{"snippet": "XMLReader.setLocale(locale)", "intent": "Allow an application to set the `locale` for errors and warnings .", "question_id": 12622}
{"snippet": "XMLReader.getFeature(featurename)", "intent": "Return the current setting for feature `featurename` .", "question_id": 12623}
{"snippet": "XMLReader.setFeature(featurename, value)", "intent": "Set the `featurename` to `value` .", "question_id": 12624}
{"snippet": "XMLReader.getProperty(propertyname)", "intent": "Return the current setting for property `propertyname` .", "question_id": 12625}
{"snippet": "XMLReader.setProperty(propertyname, value)", "intent": "Set the `propertyname` to `value` .", "question_id": 12626}
{"snippet": "IncrementalParser.feed(data)", "intent": "Process a chunk of `data` .", "question_id": 12627}
{"snippet": "IncrementalParser.close()", "intent": "Assume the end of the document .", "question_id": 12628}
{"snippet": "IncrementalParser.reset()", "intent": "This method is called after close has been called to reset the parser so that it is ready to parse new documents .", "question_id": 12629}
{"snippet": "Locator.getColumnNumber()", "intent": "Return the column number where the current event begins .", "question_id": 12630}
{"snippet": "Locator.getLineNumber()", "intent": "Return the line number where the current event begins .", "question_id": 12631}
{"snippet": "Locator.getPublicId()", "intent": "Return the public identifier for the current event .", "question_id": 12632}
{"snippet": "Locator.getSystemId()", "intent": "Return the system identifier for the current event .", "question_id": 12633}
{"snippet": "InputSource.setPublicId(id)", "intent": "Sets the public identifier of this InputSource . With arguments `id`.", "question_id": 12634}
{"snippet": "InputSource.getPublicId()", "intent": "Returns the public identifier of this InputSource .", "question_id": 12635}
{"snippet": "InputSource.setSystemId(id)", "intent": "Sets the system identifier of this InputSource . With arguments `id`.", "question_id": 12636}
{"snippet": "InputSource.getSystemId()", "intent": "Returns the system identifier of this InputSource .", "question_id": 12637}
{"snippet": "InputSource.setEncoding(encoding)", "intent": "Sets the character `encoding` of this InputSource .", "question_id": 12638}
{"snippet": "InputSource.getEncoding()", "intent": "Get the character encoding of this InputSource .", "question_id": 12639}
{"snippet": "InputSource.setByteStream(bytefile)", "intent": "Set the byte stream ( a binary file ) for this input source . With arguments `bytefile`.", "question_id": 12640}
{"snippet": "InputSource.getByteStream()", "intent": "Get the byte stream for this input source .", "question_id": 12641}
{"snippet": "InputSource.setCharacterStream(charfile)", "intent": "Set the character stream ( a text file ) for this input source . With arguments `charfile`.", "question_id": 12642}
{"snippet": "InputSource.getCharacterStream()", "intent": "Get the character stream for this input source .", "question_id": 12643}
{"snippet": "Attributes.getLength()", "intent": "Return the number of attributes .", "question_id": 12644}
{"snippet": "Attributes.getNames()", "intent": "Return the names of the attributes .", "question_id": 12645}
{"snippet": "Attributes.getType(name)", "intent": "Returns the type of the attribute `name` , which is normally 'CDATA ' .", "question_id": 12646}
{"snippet": "Attributes.getValue(name)", "intent": "Return the value of attribute `name` .", "question_id": 12647}
{"snippet": "AttributesNS.getValueByQName(name)", "intent": "Return the value for a qualified `name` .", "question_id": 12648}
{"snippet": "AttributesNS.getNameByQName(name)", "intent": "Return the ( namespace , localname ) pair for a qualified `name` .", "question_id": 12649}
{"snippet": "AttributesNS.getQNameByName(name)", "intent": "Return the qualified `name` for a ( namespace , localname ) pair .", "question_id": 12650}
{"snippet": "AttributesNS.getQNames()", "intent": "Return the qualified names of all attributes .", "question_id": 12651}
{"snippet": "xml.sax.saxutils.escape(data)", "intent": "Escape ' & ' , ' < ' , and ' > ' in a string of `data` .", "question_id": 12652}
{"snippet": "xml.sax.saxutils.escape(data, entities={})", "intent": "Escape ' & ' , ' < ' , and ' > ' in a string of `data` . You can escape other strings of data by passing a dictionary as the optional `entities` parameter .", "question_id": 12653}
{"snippet": "xml.sax.saxutils.unescape(data)", "intent": "Unescape ' & amp ; ' , ' & lt ; ' , and ' & gt ; ' in a string of `data` .", "question_id": 12654}
{"snippet": "xml.sax.saxutils.unescape(data, entities={})", "intent": "Unescape ' & amp ; ' , ' & lt ; ' , and ' & gt ; ' in a string of `data` . You can unescape other strings of data by passing a dictionary as the optional `entities` parameter .", "question_id": 12655}
{"snippet": "xml.sax.saxutils.quoteattr(data)", "intent": "Similar to escape ( ) , but also prepares `data` to be used as an attribute value .", "question_id": 12656}
{"snippet": "xml.sax.saxutils.quoteattr(data, entities={})", "intent": "Similar to escape ( ) , but also prepares `data` to be used as an attribute value . With arguments `entities`.", "question_id": 12657}
{"snippet": "xml.sax.saxutils.XMLGenerator()", "intent": "This class implements the ContentHandler interface by writing SAX events back into an XML document .", "question_id": 12658}
{"snippet": "xml.sax.saxutils.XMLGenerator(out=None)", "intent": "This class implements the ContentHandler interface by writing SAX events back into an XML document . `out` should be a file-like object which will default to sys.stdout .", "question_id": 12659}
{"snippet": "xml.sax.saxutils.XMLGenerator(encoding='iso-8859-1')", "intent": "This class implements the ContentHandler interface by writing SAX events back into an XML document . `encoding` is the encoding of the output stream which defaults to 'iso-8859-1 ' .", "question_id": 12660}
{"snippet": "xml.sax.saxutils.XMLGenerator(short_empty_elements=False)", "intent": "This class implements the ContentHandler interface by writing SAX events back into an XML document . `short_empty_elements` controls the formatting of elements that contain no content : if False ( the default ) they are emitted as a pair of start/end tags , if set to True they are emitted as a single self-closed tag .", "question_id": 12661}
{"snippet": "xml.sax.saxutils.XMLGenerator(out=None, encoding='iso-8859-1')", "intent": "This class implements the ContentHandler interface by writing SAX events back into an XML document . `out` should be a file-like object which will default to sys.stdout . `encoding` is the encoding of the output stream which defaults to 'iso-8859-1 ' .", "question_id": 12662}
{"snippet": "xml.sax.saxutils.XMLGenerator(out=None, short_empty_elements=False)", "intent": "This class implements the ContentHandler interface by writing SAX events back into an XML document . `out` should be a file-like object which will default to sys.stdout . `short_empty_elements` controls the formatting of elements that contain no content : if False ( the default ) they are emitted as a pair of start/end tags , if set to True they are emitted as a single self-closed tag .", "question_id": 12663}
{"snippet": "xml.sax.saxutils.XMLGenerator(encoding='iso-8859-1', short_empty_elements=False)", "intent": "This class implements the ContentHandler interface by writing SAX events back into an XML document . `encoding` is the encoding of the output stream which defaults to 'iso-8859-1 ' . `short_empty_elements` controls the formatting of elements that contain no content : if False ( the default ) they are emitted as a pair of start/end tags , if set to True they are emitted as a single self-closed tag .", "question_id": 12664}
{"snippet": "xml.sax.saxutils.XMLGenerator(out=None, encoding='iso-8859-1', short_empty_elements=False)", "intent": "This class implements the ContentHandler interface by writing SAX events back into an XML document . `out` should be a file-like object which will default to sys.stdout . `encoding` is the encoding of the output stream which defaults to 'iso-8859-1 ' . `short_empty_elements` controls the formatting of elements that contain no content : if False ( the default ) they are emitted as a pair of start/end tags , if set to True they are emitted as a single self-closed tag .", "question_id": 12665}
{"snippet": "xml.sax.saxutils.XMLFilterBase(base)", "intent": "This class is designed to sit between an XMLReader and the client application \u2019 s event handlers . With arguments `base`.", "question_id": 12666}
{"snippet": "xml.sax.saxutils.prepare_input_source(source)", "intent": "This function takes an input `source` and an optional `base` URL and returns a fully resolved InputSource object ready for reading .", "question_id": 12667}
{"snippet": "xml.sax.saxutils.prepare_input_source(source, base='')", "intent": "This function takes an input `source` and an optional `base` URL and returns a fully resolved InputSource object ready for reading .", "question_id": 12668}
{"snippet": "xmlrpc.client.ServerProxy(uri)", "intent": "A ServerProxy instance is an object that manages communication with a remote XML-RPC server . With arguments `uri`.", "question_id": 12669}
{"snippet": "xmlrpc.client.ServerProxy(uri, transport=None)", "intent": "A ServerProxy instance is an object that manages communication with a remote XML-RPC server . The optional second argument is a `transport` factory instance ; by default it is an internal SafeTransport instance for https : URLs and an internal HTTP Transport instance otherwise . With arguments `uri`.", "question_id": 12670}
{"snippet": "xmlrpc.client.ServerProxy(uri, encoding=None)", "intent": "A ServerProxy instance is an object that manages communication with a remote XML-RPC server . The optional third argument is an `encoding` , by default UTF-8 . With arguments `uri`.", "question_id": 12671}
{"snippet": "xmlrpc.client.ServerProxy(uri, verbose=False)", "intent": "A ServerProxy instance is an object that manages communication with a remote XML-RPC server . With arguments `uri`, `verbose`.", "question_id": 12672}
{"snippet": "xmlrpc.client.ServerProxy(uri, allow_none=False)", "intent": "A ServerProxy instance is an object that manages communication with a remote XML-RPC server . If `allow_none` is true , the Python constant None will be translated into XML ; the default behaviour is for None to raise a TypeError . With arguments `uri`.", "question_id": 12673}
{"snippet": "xmlrpc.client.ServerProxy(uri, use_datetime=False)", "intent": "A ServerProxy instance is an object that manages communication with a remote XML-RPC server . The obsolete `use_datetime` flag is similar to use_builtin_types but it applies only to date/time values . With arguments `uri`.", "question_id": 12674}
{"snippet": "xmlrpc.client.ServerProxy(uri, use_builtin_types=False)", "intent": "A ServerProxy instance is an object that manages communication with a remote XML-RPC server . The `use_builtin_types` flag can be used to cause date/time values to be presented as datetime.datetime objects and binary data to be presented as bytes objects ; this flag is false by default . With arguments `uri`.", "question_id": 12675}
{"snippet": "xmlrpc.client.ServerProxy(uri, context=None)", "intent": "A ServerProxy instance is an object that manages communication with a remote XML-RPC server . If an HTTPS URL is provided , `context` may be ssl.SSLContext and configures the SSL settings of the underlying HTTPS connection . With arguments `uri`.", "question_id": 12676}
{"snippet": "xmlrpc.client.ServerProxy(uri, transport=None, encoding=None)", "intent": "A ServerProxy instance is an object that manages communication with a remote XML-RPC server . The optional second argument is a `transport` factory instance ; by default it is an internal SafeTransport instance for https : URLs and an internal HTTP Transport instance otherwise . The optional third argument is an `encoding` , by default UTF-8 . With arguments `uri`.", "question_id": 12677}
{"snippet": "xmlrpc.client.ServerProxy(uri, transport=None, verbose=False)", "intent": "A ServerProxy instance is an object that manages communication with a remote XML-RPC server . The optional second argument is a `transport` factory instance ; by default it is an internal SafeTransport instance for https : URLs and an internal HTTP Transport instance otherwise . With arguments `uri`, `verbose`.", "question_id": 12678}
{"snippet": "ServerProxy.system.listMethods()", "intent": "This method returns a list of strings , one for each ( non-system ) method supported by the XML-RPC server .", "question_id": 12679}
{"snippet": "ServerProxy.system.methodSignature(name)", "intent": "This method takes one parameter , the `name` of a method implemented by the XML-RPC server .", "question_id": 12680}
{"snippet": "ServerProxy.system.methodHelp(name)", "intent": "This method takes one parameter , the `name` of a method implemented by the XML-RPC server .", "question_id": 12681}
{"snippet": "xmlrpc.client.DateTime", "intent": "This class may be initialized with seconds since the epoch, a time tuple, an ISO 8601 time/date string, or a datetime.datetime instance.", "question_id": 12682}
{"snippet": "date_time.decode(string)", "intent": "Accept a `string` as the instance \u2019 s new time value .", "question_id": 12683}
{"snippet": "date_time.encode(out)", "intent": "Write the XML-RPC encoding of this DateTime item to the `out` stream object .", "question_id": 12684}
{"snippet": "xmlrpc.client.Binary", "intent": "This class may be initialized from bytes data (which may include NULs).", "question_id": 12685}
{"snippet": "binary.data", "intent": "The binary data encapsulated by the Binary instance.", "question_id": 12686}
{"snippet": "binary.decode(bytes)", "intent": "Accept a base64 `bytes` object and decode it as the instance \u2019 s new data .", "question_id": 12687}
{"snippet": "binary.encode(out)", "intent": "Write the XML-RPC base 64 encoding of this binary item to the `out` stream object .", "question_id": 12688}
{"snippet": "xmlrpc.client.Fault", "intent": "A Fault object encapsulates the content of an XML-RPC fault tag.", "question_id": 12689}
{"snippet": "fault.faultCode", "intent": "A string indicating the fault type.", "question_id": 12690}
{"snippet": "fault.faultString", "intent": "A string containing a diagnostic message associated with the fault.", "question_id": 12691}
{"snippet": "xmlrpc.client.ProtocolError", "intent": "A ProtocolError object describes a protocol error in the underlying transport layer (such as a 404 \u2018not found\u2019 error if the server named by the URI does not exist).", "question_id": 12692}
{"snippet": "protocol_error.url", "intent": "The URI or URL that triggered the error.", "question_id": 12693}
{"snippet": "protocol_error.errcode", "intent": "The error code.", "question_id": 12694}
{"snippet": "protocol_error.errmsg", "intent": "The error message or diagnostic string.", "question_id": 12695}
{"snippet": "protocol_error.headers", "intent": "A dict containing the headers of the HTTP/HTTPS request that triggered the error.", "question_id": 12696}
{"snippet": "xmlrpc.client.MultiCall(server)", "intent": "Create an object used to boxcar method calls . `server` is the eventual target of the call .", "question_id": 12697}
{"snippet": "xmlrpc.client.dumps(params)", "intent": "Convert `params` into an XML-RPC request .", "question_id": 12698}
{"snippet": "xmlrpc.client.dumps(params, methodname=None)", "intent": "Convert `params` into an XML-RPC request . With arguments `methodname`.", "question_id": 12699}
{"snippet": "xmlrpc.client.dumps(params, methodresponse=None)", "intent": "Convert `params` into an XML-RPC request . or into a response if `methodresponse` is true .", "question_id": 12700}
{"snippet": "xmlrpc.client.dumps(params, encoding=None)", "intent": "Convert `params` into an XML-RPC request . If methodresponse is true , only a single value can be returned , meaning that params must be of length 1. `encoding` , if supplied , is the encoding to use in the generated XML ; the default is UTF-8 .", "question_id": 12701}
{"snippet": "xmlrpc.client.dumps(params, allow_none=False)", "intent": "Convert `params` into an XML-RPC request . Python \u2019 s None value can not be used in standard XML-RPC ; to allow using it via an extension , provide a true value for `allow_none` .", "question_id": 12702}
{"snippet": "xmlrpc.client.dumps(params, methodname=None, methodresponse=None)", "intent": "Convert `params` into an XML-RPC request . or into a response if `methodresponse` is true . With arguments `methodname`.", "question_id": 12703}
{"snippet": "xmlrpc.client.dumps(params, methodname=None, encoding=None)", "intent": "Convert `params` into an XML-RPC request . If methodresponse is true , only a single value can be returned , meaning that params must be of length 1. `encoding` , if supplied , is the encoding to use in the generated XML ; the default is UTF-8 . With arguments `methodname`.", "question_id": 12704}
{"snippet": "xmlrpc.client.dumps(params, methodname=None, allow_none=False)", "intent": "Convert `params` into an XML-RPC request . Python \u2019 s None value can not be used in standard XML-RPC ; to allow using it via an extension , provide a true value for `allow_none` . With arguments `methodname`.", "question_id": 12705}
{"snippet": "xmlrpc.client.dumps(params, methodresponse=None, encoding=None)", "intent": "Convert `params` into an XML-RPC request . or into a response if `methodresponse` is true . If methodresponse is true , only a single value can be returned , meaning that params must be of length 1. `encoding` , if supplied , is the encoding to use in the generated XML ; the default is UTF-8 .", "question_id": 12706}
{"snippet": "xmlrpc.client.dumps(params, methodresponse=None, allow_none=False)", "intent": "Convert `params` into an XML-RPC request . or into a response if `methodresponse` is true . Python \u2019 s None value can not be used in standard XML-RPC ; to allow using it via an extension , provide a true value for `allow_none` .", "question_id": 12707}
{"snippet": "xmlrpc.client.loads(data)", "intent": "Convert an XML-RPC request or response into Python objects , a ( params , methodname ) . The `use_builtin_types` flag can be used to cause date/time values to be presented as datetime.datetime objects and binary `data` to be presented as bytes objects ; this flag is false by default .", "question_id": 12708}
{"snippet": "xmlrpc.client.loads(data, use_datetime=False)", "intent": "Convert an XML-RPC request or response into Python objects , a ( params , methodname ) . The `use_builtin_types` flag can be used to cause date/time values to be presented as datetime.datetime objects and binary `data` to be presented as bytes objects ; this flag is false by default . The obsolete `use_datetime` flag is similar to use_builtin_types but it applies only to date/time values .", "question_id": 12709}
{"snippet": "xmlrpc.client.loads(data, use_builtin_types=False)", "intent": "Convert an XML-RPC request or response into Python objects , a ( params , methodname ) . The `use_builtin_types` flag can be used to cause date/time values to be presented as datetime.datetime objects and binary `data` to be presented as bytes objects ; this flag is false by default .", "question_id": 12710}
{"snippet": "xmlrpc.client.loads(data, use_datetime=False, use_builtin_types=False)", "intent": "Convert an XML-RPC request or response into Python objects , a ( params , methodname ) . The `use_builtin_types` flag can be used to cause date/time values to be presented as datetime.datetime objects and binary `data` to be presented as bytes objects ; this flag is false by default . The obsolete `use_datetime` flag is similar to use_builtin_types but it applies only to date/time values .", "question_id": 12711}
{"snippet": "xmlrpc.server.SimpleXMLRPCServer(addr)", "intent": "Create a new server instance . The `addr` and requestHandler parameters are passed to the socketserver.TCPServer constructor .", "question_id": 12712}
{"snippet": "xmlrpc.server.SimpleXMLRPCServer(addr, requestHandler=SimpleXMLRPCRequestHandler)", "intent": "Create a new server instance . The `addr` and requestHandler parameters are passed to the socketserver.TCPServer constructor . The `requestHandler` parameter should be a factory for request handler instances ; it defaults to SimpleXMLRPCRequestHandler .", "question_id": 12713}
{"snippet": "xmlrpc.server.SimpleXMLRPCServer(addr, logRequests=True)", "intent": "Create a new server instance . The `addr` and requestHandler parameters are passed to the socketserver.TCPServer constructor . If `logRequests` is true ( the default ) , requests will be logged ; setting this parameter to false will turn off logging .", "question_id": 12714}
{"snippet": "xmlrpc.server.SimpleXMLRPCServer(addr, allow_none=False)", "intent": "Create a new server instance . The `addr` and requestHandler parameters are passed to the socketserver.TCPServer constructor . The `allow_none` and `encoding` parameters are passed on to xmlrpc.client and control the XML-RPC responses that will be returned from the server .", "question_id": 12715}
{"snippet": "xmlrpc.server.SimpleXMLRPCServer(addr, encoding=None)", "intent": "Create a new server instance . The `addr` and requestHandler parameters are passed to the socketserver.TCPServer constructor . The `allow_none` and `encoding` parameters are passed on to xmlrpc.client and control the XML-RPC responses that will be returned from the server .", "question_id": 12716}
{"snippet": "xmlrpc.server.SimpleXMLRPCServer(addr, bind_and_activate=True)", "intent": "Create a new server instance . The `addr` and requestHandler parameters are passed to the socketserver.TCPServer constructor . The `bind_and_activate` parameter controls whether server_bind ( ) and server_activate ( ) are called immediately by the constructor ; it defaults to true .", "question_id": 12717}
{"snippet": "xmlrpc.server.SimpleXMLRPCServer(addr, use_builtin_types=False)", "intent": "Create a new server instance . The `addr` and requestHandler parameters are passed to the socketserver.TCPServer constructor . The `use_builtin_types` parameter is passed to the loads ( ) function and controls which types are processed when date/times values or binary data are received ; it defaults to false .", "question_id": 12718}
{"snippet": "xmlrpc.server.SimpleXMLRPCServer(addr, requestHandler=SimpleXMLRPCRequestHandler, logRequests=True)", "intent": "Create a new server instance . The `addr` and requestHandler parameters are passed to the socketserver.TCPServer constructor . The `requestHandler` parameter should be a factory for request handler instances ; it defaults to SimpleXMLRPCRequestHandler . If `logRequests` is true ( the default ) , requests will be logged ; setting this parameter to false will turn off logging .", "question_id": 12719}
{"snippet": "xmlrpc.server.SimpleXMLRPCServer(addr, requestHandler=SimpleXMLRPCRequestHandler, allow_none=False)", "intent": "Create a new server instance . The `addr` and requestHandler parameters are passed to the socketserver.TCPServer constructor . The `requestHandler` parameter should be a factory for request handler instances ; it defaults to SimpleXMLRPCRequestHandler . The `allow_none` and `encoding` parameters are passed on to xmlrpc.client and control the XML-RPC responses that will be returned from the server .", "question_id": 12720}
{"snippet": "xmlrpc.server.SimpleXMLRPCServer(addr, requestHandler=SimpleXMLRPCRequestHandler, encoding=None)", "intent": "Create a new server instance . The `addr` and requestHandler parameters are passed to the socketserver.TCPServer constructor . The `requestHandler` parameter should be a factory for request handler instances ; it defaults to SimpleXMLRPCRequestHandler . The `allow_none` and `encoding` parameters are passed on to xmlrpc.client and control the XML-RPC responses that will be returned from the server .", "question_id": 12721}
{"snippet": "xmlrpc.server.CGIXMLRPCRequestHandler()", "intent": "Create a new instance to handle XML-RPC requests in a CGI environment .", "question_id": 12722}
{"snippet": "xmlrpc.server.CGIXMLRPCRequestHandler(allow_none=False)", "intent": "Create a new instance to handle XML-RPC requests in a CGI environment . The `allow_none` and `encoding` parameters are passed on to xmlrpc.client and control the XML-RPC responses that will be returned from the server .", "question_id": 12723}
{"snippet": "xmlrpc.server.CGIXMLRPCRequestHandler(encoding=None)", "intent": "Create a new instance to handle XML-RPC requests in a CGI environment . The `allow_none` and `encoding` parameters are passed on to xmlrpc.client and control the XML-RPC responses that will be returned from the server .", "question_id": 12724}
{"snippet": "xmlrpc.server.CGIXMLRPCRequestHandler(use_builtin_types=False)", "intent": "Create a new instance to handle XML-RPC requests in a CGI environment . The `use_builtin_types` parameter is passed to the loads ( ) function and controls which types are processed when date/times values or binary data are received ; it defaults to false .", "question_id": 12725}
{"snippet": "xmlrpc.server.CGIXMLRPCRequestHandler(allow_none=False, encoding=None)", "intent": "Create a new instance to handle XML-RPC requests in a CGI environment . The `allow_none` and `encoding` parameters are passed on to xmlrpc.client and control the XML-RPC responses that will be returned from the server .", "question_id": 12726}
{"snippet": "xmlrpc.server.CGIXMLRPCRequestHandler(allow_none=False, use_builtin_types=False)", "intent": "Create a new instance to handle XML-RPC requests in a CGI environment . The `allow_none` and `encoding` parameters are passed on to xmlrpc.client and control the XML-RPC responses that will be returned from the server . The `use_builtin_types` parameter is passed to the loads ( ) function and controls which types are processed when date/times values or binary data are received ; it defaults to false .", "question_id": 12727}
{"snippet": "xmlrpc.server.CGIXMLRPCRequestHandler(encoding=None, use_builtin_types=False)", "intent": "Create a new instance to handle XML-RPC requests in a CGI environment . The `allow_none` and `encoding` parameters are passed on to xmlrpc.client and control the XML-RPC responses that will be returned from the server . The `use_builtin_types` parameter is passed to the loads ( ) function and controls which types are processed when date/times values or binary data are received ; it defaults to false .", "question_id": 12728}
{"snippet": "xmlrpc.server.CGIXMLRPCRequestHandler(allow_none=False, encoding=None, use_builtin_types=False)", "intent": "Create a new instance to handle XML-RPC requests in a CGI environment . The `allow_none` and `encoding` parameters are passed on to xmlrpc.client and control the XML-RPC responses that will be returned from the server . The `use_builtin_types` parameter is passed to the loads ( ) function and controls which types are processed when date/times values or binary data are received ; it defaults to false .", "question_id": 12729}
{"snippet": "xmlrpc.server.SimpleXMLRPCRequestHandler", "intent": "Create a new request handler instance.", "question_id": 12730}
{"snippet": "SimpleXMLRPCServer.register_function()", "intent": "Register a `function` that can respond to XML-RPC requests .", "question_id": 12731}
{"snippet": "SimpleXMLRPCServer.register_function(function=None)", "intent": "Register a `function` that can respond to XML-RPC requests .", "question_id": 12732}
{"snippet": "SimpleXMLRPCServer.register_function(name=None)", "intent": "Register a `function` that can respond to XML-RPC requests . If `name` is given , it will be the method name associated with function , otherwise function.__name__ will be used .", "question_id": 12733}
{"snippet": "SimpleXMLRPCServer.register_function(function=None, name=None)", "intent": "Register a `function` that can respond to XML-RPC requests . If `name` is given , it will be the method name associated with function , otherwise function.__name__ will be used .", "question_id": 12734}
{"snippet": "SimpleXMLRPCServer.register_instance(instance)", "intent": "Register an object which is used to expose method names which have not been registered using register_function ( ) . If `instance` contains a _dispatch ( ) method , it is called with the requested method name and the parameters from the request .", "question_id": 12735}
{"snippet": "SimpleXMLRPCServer.register_instance(instance, allow_dotted_names=False)", "intent": "Register an object which is used to expose method names which have not been registered using register_function ( ) . If `instance` contains a _dispatch ( ) method , it is called with the requested method name and the parameters from the request . If the optional `allow_dotted_names` argument is true and the instance does not have a _dispatch ( ) method , then if the requested method name contains periods , each component of the method name is searched for individually , with the effect that a simple hierarchical search is performed .", "question_id": 12736}
{"snippet": "SimpleXMLRPCServer.register_introspection_functions()", "intent": "Registers the XML-RPC introspection functions system.listMethods , system.methodHelp and system.methodSignature .", "question_id": 12737}
{"snippet": "SimpleXMLRPCServer.register_multicall_functions()", "intent": "Registers the XML-RPC multicall function system.multicall .", "question_id": 12738}
{"snippet": "SimpleXMLRPCRequestHandler.rpc_paths", "intent": "An attribute value that must be a tuple listing valid path portions of the URL for receiving XML-RPC requests.", "question_id": 12739}
{"snippet": "CGIXMLRPCRequestHandler.register_function()", "intent": "Register a `function` that can respond to XML-RPC requests .", "question_id": 12740}
{"snippet": "CGIXMLRPCRequestHandler.register_function(function=None)", "intent": "Register a `function` that can respond to XML-RPC requests .", "question_id": 12741}
{"snippet": "CGIXMLRPCRequestHandler.register_function(name=None)", "intent": "Register a `function` that can respond to XML-RPC requests . If `name` is given , it will be the method name associated with function , otherwise function.__name__ will be used .", "question_id": 12742}
{"snippet": "CGIXMLRPCRequestHandler.register_function(function=None, name=None)", "intent": "Register a `function` that can respond to XML-RPC requests . If `name` is given , it will be the method name associated with function , otherwise function.__name__ will be used .", "question_id": 12743}
{"snippet": "CGIXMLRPCRequestHandler.register_instance(instance)", "intent": "Register an object which is used to expose method names which have not been registered using register_function ( ) . If `instance` contains a _dispatch ( ) method , it is called with the requested method name and the parameters from the request ; the return value is returned to the client as the result .", "question_id": 12744}
{"snippet": "CGIXMLRPCRequestHandler.register_introspection_functions()", "intent": "Register the XML-RPC introspection functions system.listMethods , system.methodHelp and system.methodSignature .", "question_id": 12745}
{"snippet": "CGIXMLRPCRequestHandler.register_multicall_functions()", "intent": "Register the XML-RPC multicall function system.multicall .", "question_id": 12746}
{"snippet": "CGIXMLRPCRequestHandler.handle_request()", "intent": "Handle an XML-RPC request .", "question_id": 12747}
{"snippet": "CGIXMLRPCRequestHandler.handle_request(request_text=None)", "intent": "Handle an XML-RPC request . If `request_text` is given , it should be the POST data provided by the HTTP server , otherwise the contents of stdin will be used .", "question_id": 12748}
{"snippet": "xmlrpc.server.DocXMLRPCServer(addr)", "intent": "Create a new server instance . With arguments `addr`.", "question_id": 12749}
{"snippet": "xmlrpc.server.DocXMLRPCServer(addr, requestHandler=DocXMLRPCRequestHandler)", "intent": "Create a new server instance . All parameters have the same meaning as for SimpleXMLRPCServer ; `requestHandler` defaults to DocXMLRPCRequestHandler . With arguments `addr`.", "question_id": 12750}
{"snippet": "xmlrpc.server.DocXMLRPCServer(addr, logRequests=True)", "intent": "Create a new server instance . With arguments `addr`, `logRequests`.", "question_id": 12751}
{"snippet": "xmlrpc.server.DocXMLRPCServer(addr, allow_none=False)", "intent": "Create a new server instance . With arguments `addr`, `allow_none`.", "question_id": 12752}
{"snippet": "xmlrpc.server.DocXMLRPCServer(addr, encoding=None)", "intent": "Create a new server instance . With arguments `addr`, `encoding`.", "question_id": 12753}
{"snippet": "xmlrpc.server.DocXMLRPCServer(addr, bind_and_activate=True)", "intent": "Create a new server instance . With arguments `addr`, `bind_and_activate`.", "question_id": 12754}
{"snippet": "xmlrpc.server.DocXMLRPCServer(addr, use_builtin_types=True)", "intent": "Create a new server instance . With arguments `addr`, `use_builtin_types`.", "question_id": 12755}
{"snippet": "xmlrpc.server.DocXMLRPCServer(addr, requestHandler=DocXMLRPCRequestHandler, logRequests=True)", "intent": "Create a new server instance . All parameters have the same meaning as for SimpleXMLRPCServer ; `requestHandler` defaults to DocXMLRPCRequestHandler . With arguments `addr`, `logRequests`.", "question_id": 12756}
{"snippet": "xmlrpc.server.DocXMLRPCServer(addr, requestHandler=DocXMLRPCRequestHandler, allow_none=False)", "intent": "Create a new server instance . All parameters have the same meaning as for SimpleXMLRPCServer ; `requestHandler` defaults to DocXMLRPCRequestHandler . With arguments `addr`, `allow_none`.", "question_id": 12757}
{"snippet": "xmlrpc.server.DocXMLRPCServer(addr, requestHandler=DocXMLRPCRequestHandler, encoding=None)", "intent": "Create a new server instance . All parameters have the same meaning as for SimpleXMLRPCServer ; `requestHandler` defaults to DocXMLRPCRequestHandler . With arguments `addr`, `encoding`.", "question_id": 12758}
{"snippet": "xmlrpc.server.DocCGIXMLRPCRequestHandler", "intent": "Create a new instance to handle XML-RPC requests in a CGI environment.", "question_id": 12759}
{"snippet": "xmlrpc.server.DocXMLRPCRequestHandler", "intent": "Create a new request handler instance.", "question_id": 12760}
{"snippet": "DocXMLRPCServer.set_server_title(server_title)", "intent": "Set the title used in the generated HTML documentation . With arguments `server_title`.", "question_id": 12761}
{"snippet": "DocXMLRPCServer.set_server_name(server_name)", "intent": "Set the name used in the generated HTML documentation . With arguments `server_name`.", "question_id": 12762}
{"snippet": "DocXMLRPCServer.set_server_documentation(server_documentation)", "intent": "Set the description used in the generated HTML documentation . With arguments `server_documentation`.", "question_id": 12763}
{"snippet": "DocCGIXMLRPCRequestHandler.set_server_title(server_title)", "intent": "Set the title used in the generated HTML documentation . With arguments `server_title`.", "question_id": 12764}
{"snippet": "DocCGIXMLRPCRequestHandler.set_server_name(server_name)", "intent": "Set the name used in the generated HTML documentation . With arguments `server_name`.", "question_id": 12765}
{"snippet": "DocCGIXMLRPCRequestHandler.set_server_documentation(server_documentation)", "intent": "Set the description used in the generated HTML documentation . With arguments `server_documentation`.", "question_id": 12766}
{"snippet": "zipapp.create_archive(source)", "intent": "Create an application archive from `source` .", "question_id": 12767}
{"snippet": "zipapp.create_archive(source, target=None)", "intent": "Create an application archive from `source` . The `target` argument determines where the resulting archive will be written :", "question_id": 12768}
{"snippet": "zipapp.create_archive(source, interpreter=None)", "intent": "Create an application archive from `source` . The `interpreter` argument specifies the name of the Python interpreter with which the archive will be executed .", "question_id": 12769}
{"snippet": "zipapp.create_archive(source, main=None)", "intent": "Create an application archive from `source` . The `main` argument specifies the name of a callable which will be used as the main program for the archive .", "question_id": 12770}
{"snippet": "zipapp.create_archive(source, filter=None)", "intent": "Create an application archive from `source` . The optional `filter` argument specifies a callback function that is passed a Path object representing the path to the file being added ( relative to the source directory ) .", "question_id": 12771}
{"snippet": "zipapp.create_archive(source, compressed=False)", "intent": "Create an application archive from `source` . The optional `compressed` argument determines whether files are compressed .", "question_id": 12772}
{"snippet": "zipapp.create_archive(source, target=None, interpreter=None)", "intent": "Create an application archive from `source` . The `target` argument determines where the resulting archive will be written : The `interpreter` argument specifies the name of the Python interpreter with which the archive will be executed .", "question_id": 12773}
{"snippet": "zipapp.create_archive(source, target=None, main=None)", "intent": "Create an application archive from `source` . The `target` argument determines where the resulting archive will be written : The `main` argument specifies the name of a callable which will be used as the main program for the archive .", "question_id": 12774}
{"snippet": "zipapp.create_archive(source, target=None, filter=None)", "intent": "Create an application archive from `source` . The `target` argument determines where the resulting archive will be written : The optional `filter` argument specifies a callback function that is passed a Path object representing the path to the file being added ( relative to the source directory ) .", "question_id": 12775}
{"snippet": "zipapp.create_archive(source, target=None, compressed=False)", "intent": "Create an application archive from `source` . The `target` argument determines where the resulting archive will be written : The optional `compressed` argument determines whether files are compressed .", "question_id": 12776}
{"snippet": "zipapp.get_interpreter(archive)", "intent": "Return the interpreter specified in the # ! line at the start of the `archive` .", "question_id": 12777}
{"snippet": "zipfile.BadZipFile", "intent": "The error raised for bad ZIP files.", "question_id": 12778}
{"snippet": "zipfile.BadZipfile", "intent": "Alias of BadZipFile, for compatibility with older Python versions.", "question_id": 12779}
{"snippet": "zipfile.LargeZipFile", "intent": "The error raised when a ZIP file would require ZIP64 functionality but that has not been enabled.", "question_id": 12780}
{"snippet": "zipfile.ZipFile", "intent": "The class for reading and writing ZIP files.", "question_id": 12781}
{"snippet": "zipfile.PyZipFile", "intent": "Class for creating ZIP archives containing Python libraries.", "question_id": 12782}
{"snippet": "zipfile.ZipInfo(1, 1, 0, 0, 0))", "intent": "Class used to represent information about a member of an archive . With arguments `1`, `1`, `0`, `0`, `0)`.", "question_id": 12783}
{"snippet": "zipfile.ZipInfo(1, 1, 0, 0, 0), filename='NoName')", "intent": "Class used to represent information about a member of an archive . `filename` should be the full name of the archive member , and `date_time` should be a tuple containing six fields which describe the time of the last modification to the file ; the fields are described in section ZipInfo Objects . With arguments `1`, `1`, `0`, `0`, `0)`.", "question_id": 12784}
{"snippet": "zipfile.ZipInfo(1, 1, 0, 0, 0), date_time=(1980)", "intent": "Class used to represent information about a member of an archive . `filename` should be the full name of the archive member , and `date_time` should be a tuple containing six fields which describe the time of the last modification to the file ; the fields are described in section ZipInfo Objects . With arguments `1`, `1`, `0`, `0`, `0)`.", "question_id": 12785}
{"snippet": "zipfile.ZipInfo(1, 1, 0, 0, 0), filename='NoName', date_time=(1980)", "intent": "Class used to represent information about a member of an archive . `filename` should be the full name of the archive member , and `date_time` should be a tuple containing six fields which describe the time of the last modification to the file ; the fields are described in section ZipInfo Objects . With arguments `1`, `1`, `0`, `0`, `0)`.", "question_id": 12786}
{"snippet": "zipfile.is_zipfile(filename)", "intent": "Returns True if `filename` is a valid ZIP file based on its magic number , otherwise returns False .", "question_id": 12787}
{"snippet": "zipfile.ZIP_STORED", "intent": "The numeric constant for an uncompressed archive member.", "question_id": 12788}
{"snippet": "zipfile.ZIP_DEFLATED", "intent": "The numeric constant for the usual ZIP compression method.", "question_id": 12789}
{"snippet": "zipfile.ZIP_BZIP2", "intent": "The numeric constant for the BZIP2 compression method.", "question_id": 12790}
{"snippet": "zipfile.ZIP_LZMA", "intent": "The numeric constant for the LZMA compression method.", "question_id": 12791}
{"snippet": "zipfile.ZipFile(file)", "intent": "Open a ZIP `file` , where file can be a path to a file ( a string ) , a file-like object or a path-like object .", "question_id": 12792}
{"snippet": "zipfile.ZipFile(file, mode='r')", "intent": "Open a ZIP `file` , where file can be a path to a file ( a string ) , a file-like object or a path-like object . The `mode` parameter should be ' r ' to read an existing file , ' w ' to truncate and write a new file , ' a ' to append to an existing file , or ' x ' to exclusively create and write a new file .", "question_id": 12793}
{"snippet": "zipfile.ZipFile(file, compression=ZIP_STORED)", "intent": "Open a ZIP `file` , where file can be a path to a file ( a string ) , a file-like object or a path-like object . `compression` is the ZIP compression method to use when writing the archive , and should be ZIP_STORED , ZIP_DEFLATED , ZIP_BZIP2 or ZIP_LZMA ; unrecognized values will cause NotImplementedError to be raised .", "question_id": 12794}
{"snippet": "zipfile.ZipFile(file, allowZip64=True)", "intent": "Open a ZIP `file` , where file can be a path to a file ( a string ) , a file-like object or a path-like object . If `allowZip64` is True ( the default ) zipfile will create ZIP files that use the ZIP64 extensions when the zipfile is larger than 4 GiB .", "question_id": 12795}
{"snippet": "zipfile.ZipFile(file, compresslevel=None)", "intent": "Open a ZIP `file` , where file can be a path to a file ( a string ) , a file-like object or a path-like object . The `compresslevel` parameter controls the compression level to use when writing files to the archive .", "question_id": 12796}
{"snippet": "zipfile.ZipFile(file, mode='r', compression=ZIP_STORED)", "intent": "Open a ZIP `file` , where file can be a path to a file ( a string ) , a file-like object or a path-like object . The `mode` parameter should be ' r ' to read an existing file , ' w ' to truncate and write a new file , ' a ' to append to an existing file , or ' x ' to exclusively create and write a new file . `compression` is the ZIP compression method to use when writing the archive , and should be ZIP_STORED , ZIP_DEFLATED , ZIP_BZIP2 or ZIP_LZMA ; unrecognized values will cause NotImplementedError to be raised .", "question_id": 12797}
{"snippet": "zipfile.ZipFile(file, mode='r', allowZip64=True)", "intent": "Open a ZIP `file` , where file can be a path to a file ( a string ) , a file-like object or a path-like object . The `mode` parameter should be ' r ' to read an existing file , ' w ' to truncate and write a new file , ' a ' to append to an existing file , or ' x ' to exclusively create and write a new file . If `allowZip64` is True ( the default ) zipfile will create ZIP files that use the ZIP64 extensions when the zipfile is larger than 4 GiB .", "question_id": 12798}
{"snippet": "zipfile.ZipFile(file, mode='r', compresslevel=None)", "intent": "Open a ZIP `file` , where file can be a path to a file ( a string ) , a file-like object or a path-like object . The `mode` parameter should be ' r ' to read an existing file , ' w ' to truncate and write a new file , ' a ' to append to an existing file , or ' x ' to exclusively create and write a new file . The `compresslevel` parameter controls the compression level to use when writing files to the archive .", "question_id": 12799}
{"snippet": "zipfile.ZipFile(file, compression=ZIP_STORED, allowZip64=True)", "intent": "Open a ZIP `file` , where file can be a path to a file ( a string ) , a file-like object or a path-like object . `compression` is the ZIP compression method to use when writing the archive , and should be ZIP_STORED , ZIP_DEFLATED , ZIP_BZIP2 or ZIP_LZMA ; unrecognized values will cause NotImplementedError to be raised . If `allowZip64` is True ( the default ) zipfile will create ZIP files that use the ZIP64 extensions when the zipfile is larger than 4 GiB .", "question_id": 12800}
{"snippet": "zipfile.ZipFile(file, compression=ZIP_STORED, compresslevel=None)", "intent": "Open a ZIP `file` , where file can be a path to a file ( a string ) , a file-like object or a path-like object . `compression` is the ZIP compression method to use when writing the archive , and should be ZIP_STORED , ZIP_DEFLATED , ZIP_BZIP2 or ZIP_LZMA ; unrecognized values will cause NotImplementedError to be raised . The `compresslevel` parameter controls the compression level to use when writing files to the archive .", "question_id": 12801}
{"snippet": "ZipFile.close()", "intent": "Close the archive file .", "question_id": 12802}
{"snippet": "ZipFile.getinfo(name)", "intent": "Return a ZipInfo object with information about the archive member `name` .", "question_id": 12803}
{"snippet": "ZipFile.infolist()", "intent": "Return a list containing a ZipInfo object for each member of the archive .", "question_id": 12804}
{"snippet": "ZipFile.namelist()", "intent": "Return a list of archive members by name .", "question_id": 12805}
{"snippet": "ZipFile.open(name)", "intent": "Access a member of the archive as a binary file-like object . `name` can be either the name of a file within the archive or a ZipInfo object .", "question_id": 12806}
{"snippet": "ZipFile.open(name, mode='r')", "intent": "Access a member of the archive as a binary file-like object . `name` can be either the name of a file within the archive or a ZipInfo object . The `mode` parameter , if included , must be ' r ' ( the default ) or ' w ' .", "question_id": 12807}
{"snippet": "ZipFile.open(name, pwd=None)", "intent": "Access a member of the archive as a binary file-like object . `name` can be either the name of a file within the archive or a ZipInfo object . `pwd` is the password used to decrypt encrypted ZIP files .", "question_id": 12808}
{"snippet": "ZipFile.open(name, force_zip64=False)", "intent": "Access a member of the archive as a binary file-like object . `name` can be either the name of a file within the archive or a ZipInfo object . With arguments `force_zip64`.", "question_id": 12809}
{"snippet": "ZipFile.open(name, mode='r', pwd=None)", "intent": "Access a member of the archive as a binary file-like object . `name` can be either the name of a file within the archive or a ZipInfo object . The `mode` parameter , if included , must be ' r ' ( the default ) or ' w ' . `pwd` is the password used to decrypt encrypted ZIP files .", "question_id": 12810}
{"snippet": "ZipFile.open(name, mode='r', force_zip64=False)", "intent": "Access a member of the archive as a binary file-like object . `name` can be either the name of a file within the archive or a ZipInfo object . The `mode` parameter , if included , must be ' r ' ( the default ) or ' w ' . With arguments `force_zip64`.", "question_id": 12811}
{"snippet": "ZipFile.open(name, pwd=None, force_zip64=False)", "intent": "Access a member of the archive as a binary file-like object . `name` can be either the name of a file within the archive or a ZipInfo object . `pwd` is the password used to decrypt encrypted ZIP files . With arguments `force_zip64`.", "question_id": 12812}
{"snippet": "ZipFile.open(name, mode='r', pwd=None, force_zip64=False)", "intent": "Access a member of the archive as a binary file-like object . `name` can be either the name of a file within the archive or a ZipInfo object . The `mode` parameter , if included , must be ' r ' ( the default ) or ' w ' . `pwd` is the password used to decrypt encrypted ZIP files . With arguments `force_zip64`.", "question_id": 12813}
{"snippet": "ZipFile.extract(member)", "intent": "Extract a `member` from the archive to the current working directory ; member must be its full name or a ZipInfo object .", "question_id": 12814}
{"snippet": "ZipFile.extract(member, path=None)", "intent": "Extract a `member` from the archive to the current working directory ; member must be its full name or a ZipInfo object . `path` specifies a different directory to extract to .", "question_id": 12815}
{"snippet": "ZipFile.extract(member, pwd=None)", "intent": "Extract a `member` from the archive to the current working directory ; member must be its full name or a ZipInfo object . `pwd` is the password used for encrypted files .", "question_id": 12816}
{"snippet": "ZipFile.extract(member, path=None, pwd=None)", "intent": "Extract a `member` from the archive to the current working directory ; member must be its full name or a ZipInfo object . `path` specifies a different directory to extract to . `pwd` is the password used for encrypted files .", "question_id": 12817}
{"snippet": "ZipFile.extractall()", "intent": "Extract all `members` from the archive to the current working directory .", "question_id": 12818}
{"snippet": "ZipFile.extractall(path=None)", "intent": "Extract all `members` from the archive to the current working directory . `path` specifies a different directory to extract to .", "question_id": 12819}
{"snippet": "ZipFile.extractall(members=None)", "intent": "Extract all `members` from the archive to the current working directory .", "question_id": 12820}
{"snippet": "ZipFile.extractall(pwd=None)", "intent": "Extract all `members` from the archive to the current working directory . `pwd` is the password used for encrypted files .", "question_id": 12821}
{"snippet": "ZipFile.extractall(path=None, members=None)", "intent": "Extract all `members` from the archive to the current working directory . `path` specifies a different directory to extract to .", "question_id": 12822}
{"snippet": "ZipFile.extractall(path=None, pwd=None)", "intent": "Extract all `members` from the archive to the current working directory . `path` specifies a different directory to extract to . `pwd` is the password used for encrypted files .", "question_id": 12823}
{"snippet": "ZipFile.extractall(members=None, pwd=None)", "intent": "Extract all `members` from the archive to the current working directory . `pwd` is the password used for encrypted files .", "question_id": 12824}
{"snippet": "ZipFile.extractall(path=None, members=None, pwd=None)", "intent": "Extract all `members` from the archive to the current working directory . `path` specifies a different directory to extract to . `pwd` is the password used for encrypted files .", "question_id": 12825}
{"snippet": "ZipFile.printdir()", "intent": "Print a table of contents for the archive to sys.stdout .", "question_id": 12826}
{"snippet": "ZipFile.setpassword(pwd)", "intent": "Set `pwd` as default password to extract encrypted files .", "question_id": 12827}
{"snippet": "ZipFile.read(name)", "intent": "Return the bytes of the file `name` in the archive .", "question_id": 12828}
{"snippet": "ZipFile.read(name, pwd=None)", "intent": "Return the bytes of the file `name` in the archive . `pwd` is the password used for encrypted files and , if specified , it will override the default password set with setpassword ( ) .", "question_id": 12829}
{"snippet": "ZipFile.testzip()", "intent": "Read all the files in the archive and check their CRC \u2019 s and file headers .", "question_id": 12830}
{"snippet": "ZipFile.write(filename)", "intent": "Write the file named `filename` to the archive , giving it the archive name `arcname` ( by default , this will be the same as filename , but without a drive letter and with leading path separators removed ) .", "question_id": 12831}
{"snippet": "ZipFile.write(filename, arcname=None)", "intent": "Write the file named `filename` to the archive , giving it the archive name `arcname` ( by default , this will be the same as filename , but without a drive letter and with leading path separators removed ) .", "question_id": 12832}
{"snippet": "ZipFile.write(filename, compress_type=None)", "intent": "Write the file named `filename` to the archive , giving it the archive name `arcname` ( by default , this will be the same as filename , but without a drive letter and with leading path separators removed ) . If given , `compress_type` overrides the value given for the compression parameter to the constructor for the new entry .", "question_id": 12833}
{"snippet": "ZipFile.write(filename, compresslevel=None)", "intent": "Write the file named `filename` to the archive , giving it the archive name `arcname` ( by default , this will be the same as filename , but without a drive letter and with leading path separators removed ) . Similarly , `compresslevel` will override the constructor if given .", "question_id": 12834}
{"snippet": "ZipFile.write(filename, arcname=None, compress_type=None)", "intent": "Write the file named `filename` to the archive , giving it the archive name `arcname` ( by default , this will be the same as filename , but without a drive letter and with leading path separators removed ) . If given , `compress_type` overrides the value given for the compression parameter to the constructor for the new entry .", "question_id": 12835}
{"snippet": "ZipFile.write(filename, arcname=None, compresslevel=None)", "intent": "Write the file named `filename` to the archive , giving it the archive name `arcname` ( by default , this will be the same as filename , but without a drive letter and with leading path separators removed ) . Similarly , `compresslevel` will override the constructor if given .", "question_id": 12836}
{"snippet": "ZipFile.write(filename, compress_type=None, compresslevel=None)", "intent": "Write the file named `filename` to the archive , giving it the archive name `arcname` ( by default , this will be the same as filename , but without a drive letter and with leading path separators removed ) . If given , `compress_type` overrides the value given for the compression parameter to the constructor for the new entry . Similarly , `compresslevel` will override the constructor if given .", "question_id": 12837}
{"snippet": "ZipFile.write(filename, arcname=None, compress_type=None, compresslevel=None)", "intent": "Write the file named `filename` to the archive , giving it the archive name `arcname` ( by default , this will be the same as filename , but without a drive letter and with leading path separators removed ) . If given , `compress_type` overrides the value given for the compression parameter to the constructor for the new entry . Similarly , `compresslevel` will override the constructor if given .", "question_id": 12838}
{"snippet": "ZipFile.writestr(zinfo_or_arcname, data)", "intent": "Write a file into the archive . `zinfo_or_arcname` is either the file name it will be given in the archive , or a ZipInfo instance . The contents is `data` , which may be either a str or a bytes instance ; if it is a str , it is encoded as UTF-8 first .", "question_id": 12839}
{"snippet": "ZipFile.writestr(zinfo_or_arcname, data, compress_type=None)", "intent": "Write a file into the archive . `zinfo_or_arcname` is either the file name it will be given in the archive , or a ZipInfo instance . The contents is `data` , which may be either a str or a bytes instance ; if it is a str , it is encoded as UTF-8 first . If given , `compress_type` overrides the value given for the compression parameter to the constructor for the new entry , or in the zinfo_or_arcname ( if that is a ZipInfo instance ) .", "question_id": 12840}
{"snippet": "ZipFile.writestr(zinfo_or_arcname, data, compresslevel=None)", "intent": "Write a file into the archive . `zinfo_or_arcname` is either the file name it will be given in the archive , or a ZipInfo instance . The contents is `data` , which may be either a str or a bytes instance ; if it is a str , it is encoded as UTF-8 first . Similarly , `compresslevel` will override the constructor if given .", "question_id": 12841}
{"snippet": "ZipFile.writestr(zinfo_or_arcname, data, compress_type=None, compresslevel=None)", "intent": "Write a file into the archive . `zinfo_or_arcname` is either the file name it will be given in the archive , or a ZipInfo instance . The contents is `data` , which may be either a str or a bytes instance ; if it is a str , it is encoded as UTF-8 first . If given , `compress_type` overrides the value given for the compression parameter to the constructor for the new entry , or in the zinfo_or_arcname ( if that is a ZipInfo instance ) . Similarly , `compresslevel` will override the constructor if given .", "question_id": 12842}
{"snippet": "ZipFile.filename", "intent": "Name of the ZIP file.", "question_id": 12843}
{"snippet": "ZipFile.debug", "intent": "The level of debug output to use.", "question_id": 12844}
{"snippet": "ZipFile.comment", "intent": "The comment associated with the ZIP file as a bytes object.", "question_id": 12845}
{"snippet": "zipfile.PyZipFile(file)", "intent": "Instances have one method in addition to those of ZipFile objects : With arguments `file`.", "question_id": 12846}
{"snippet": "zipfile.PyZipFile(file, mode='r')", "intent": "Instances have one method in addition to those of ZipFile objects : With arguments `file`, `mode`.", "question_id": 12847}
{"snippet": "zipfile.PyZipFile(file, compression=ZIP_STORED)", "intent": "Instances have one method in addition to those of ZipFile objects : With arguments `file`, `compression`.", "question_id": 12848}
{"snippet": "zipfile.PyZipFile(file, allowZip64=True)", "intent": "Instances have one method in addition to those of ZipFile objects : With arguments `file`, `allowZip64`.", "question_id": 12849}
{"snippet": "zipfile.PyZipFile(file, optimize=-1)", "intent": "Instances have one method in addition to those of ZipFile objects : With arguments `file`, `optimize`.", "question_id": 12850}
{"snippet": "zipfile.PyZipFile(file, mode='r', compression=ZIP_STORED)", "intent": "Instances have one method in addition to those of ZipFile objects : With arguments `file`, `mode`, `compression`.", "question_id": 12851}
{"snippet": "zipfile.PyZipFile(file, mode='r', allowZip64=True)", "intent": "Instances have one method in addition to those of ZipFile objects : With arguments `file`, `mode`, `allowZip64`.", "question_id": 12852}
{"snippet": "zipfile.PyZipFile(file, mode='r', optimize=-1)", "intent": "Instances have one method in addition to those of ZipFile objects : With arguments `file`, `mode`, `optimize`.", "question_id": 12853}
{"snippet": "zipfile.PyZipFile(file, compression=ZIP_STORED, allowZip64=True)", "intent": "Instances have one method in addition to those of ZipFile objects : With arguments `file`, `compression`, `allowZip64`.", "question_id": 12854}
{"snippet": "zipfile.PyZipFile(file, compression=ZIP_STORED, optimize=-1)", "intent": "Instances have one method in addition to those of ZipFile objects : With arguments `file`, `compression`, `optimize`.", "question_id": 12855}
{"snippet": "py_zip_file.writepy(pathname)", "intent": "Search for files *.py and add the corresponding file to the archive . If `pathname` is a file , the filename must end with .py , and just the ( corresponding *.pyc ) file is added at the top level ( no path information ) .", "question_id": 12856}
{"snippet": "py_zip_file.writepy(pathname, basename='')", "intent": "Search for files *.py and add the corresponding file to the archive . If `pathname` is a file , the filename must end with .py , and just the ( corresponding *.pyc ) file is added at the top level ( no path information ) . `basename` is intended for internal use only .", "question_id": 12857}
{"snippet": "py_zip_file.writepy(pathname, filterfunc=None)", "intent": "Search for files *.py and add the corresponding file to the archive . If `pathname` is a file , the filename must end with .py , and just the ( corresponding *.pyc ) file is added at the top level ( no path information ) . `filterfunc` , if given , must be a function taking a single string argument .", "question_id": 12858}
{"snippet": "py_zip_file.writepy(pathname, basename='', filterfunc=None)", "intent": "Search for files *.py and add the corresponding file to the archive . If `pathname` is a file , the filename must end with .py , and just the ( corresponding *.pyc ) file is added at the top level ( no path information ) . `basename` is intended for internal use only . `filterfunc` , if given , must be a function taking a single string argument .", "question_id": 12859}
{"snippet": "ZipInfo.from_file(filename)", "intent": "Construct a ZipInfo instance for a file on the filesystem , in preparation for adding it to a zip file . `filename` should be the path to a file or directory on the filesystem .", "question_id": 12860}
{"snippet": "ZipInfo.from_file(filename, arcname=None)", "intent": "Construct a ZipInfo instance for a file on the filesystem , in preparation for adding it to a zip file . `filename` should be the path to a file or directory on the filesystem . If `arcname` is specified , it is used as the name within the archive .", "question_id": 12861}
{"snippet": "ZipInfo.is_dir()", "intent": "Return True if this archive member is a directory .", "question_id": 12862}
{"snippet": "ZipInfo.filename", "intent": "Name of the file in the archive.", "question_id": 12863}
{"snippet": "ZipInfo.date_time", "intent": "The time and date of the last modification to the archive member.", "question_id": 12864}
{"snippet": "ZipInfo.compress_type", "intent": "Type of compression for the archive member.", "question_id": 12865}
{"snippet": "ZipInfo.comment", "intent": "Comment for the individual archive member as a bytes object.", "question_id": 12866}
{"snippet": "ZipInfo.extra", "intent": "Expansion field data.", "question_id": 12867}
{"snippet": "ZipInfo.create_system", "intent": "System which created ZIP archive.", "question_id": 12868}
{"snippet": "ZipInfo.create_version", "intent": "PKZIP version which created ZIP archive.", "question_id": 12869}
{"snippet": "ZipInfo.extract_version", "intent": "PKZIP version needed to extract archive.", "question_id": 12870}
{"snippet": "ZipInfo.reserved", "intent": "Must be zero.", "question_id": 12871}
{"snippet": "ZipInfo.flag_bits", "intent": "ZIP flag bits.", "question_id": 12872}
{"snippet": "ZipInfo.volume", "intent": "Volume number of file header.", "question_id": 12873}
{"snippet": "ZipInfo.internal_attr", "intent": "Internal attributes.", "question_id": 12874}
{"snippet": "ZipInfo.external_attr", "intent": "External file attributes.", "question_id": 12875}
{"snippet": "ZipInfo.header_offset", "intent": "Byte offset to the file header.", "question_id": 12876}
{"snippet": "ZipInfo.CRC", "intent": "CRC-32 of the uncompressed file.", "question_id": 12877}
{"snippet": "ZipInfo.compress_size", "intent": "Size of the compressed data.", "question_id": 12878}
{"snippet": "ZipInfo.file_size", "intent": "Size of the uncompressed file.", "question_id": 12879}
{"snippet": "zipimport.ZipImportError", "intent": "Exception raised by zipimporter objects.", "question_id": 12880}
{"snippet": "zipimport.zipimporter(archivepath)", "intent": "Create a new zipimporter instance . `archivepath` must be a path to a ZIP file , or to a specific path within a ZIP file .", "question_id": 12881}
{"snippet": "zipimporter.find_module(fullname, path)", "intent": "Search for a module specified by `fullname` . The optional `path` argument is ignored\u2014it \u2019 s there for compatibility with the importer protocol .", "question_id": 12882}
{"snippet": "zipimporter.find_module(fullname)", "intent": "Search for a module specified by `fullname` .", "question_id": 12883}
{"snippet": "zipimporter.get_code(fullname)", "intent": "Return the code object for the specified module . With arguments `fullname`.", "question_id": 12884}
{"snippet": "zipimporter.get_data(pathname)", "intent": "Return the data associated with `pathname` .", "question_id": 12885}
{"snippet": "zipimporter.get_filename(fullname)", "intent": "Return the value __file__ would be set to if the specified module was imported . With arguments `fullname`.", "question_id": 12886}
{"snippet": "zipimporter.get_source(fullname)", "intent": "Return the source code for the specified module . With arguments `fullname`.", "question_id": 12887}
{"snippet": "zipimporter.is_package(fullname)", "intent": "Return True if the module specified by `fullname` is a package .", "question_id": 12888}
{"snippet": "zipimporter.load_module(fullname)", "intent": "Load the module specified by `fullname` .", "question_id": 12889}
{"snippet": "zipimporter.archive", "intent": "The file name of the importer\u2019s associated ZIP file, without a possible subpath.", "question_id": 12890}
{"snippet": "zipimporter.prefix", "intent": "The subpath within the ZIP file where modules are searched.", "question_id": 12891}
{"snippet": "zlib.error", "intent": "Exception raised on compression and decompression errors.", "question_id": 12892}
{"snippet": "zlib.adler32(data, value)", "intent": "Computes an Adler-32 checksum of `data` . If `value` is present , it is used as the starting value of the checksum ; otherwise , a default value of 1 is used .", "question_id": 12893}
{"snippet": "zlib.adler32(data)", "intent": "Computes an Adler-32 checksum of `data` .", "question_id": 12894}
{"snippet": "zlib.compress(data)", "intent": "Compresses the bytes in `data` , returning a bytes object containing compressed data .", "question_id": 12895}
{"snippet": "zlib.compress(data, level=-1)", "intent": "Compresses the bytes in `data` , returning a bytes object containing compressed data . `level` is an integer from 0 to 9 or -1 controlling the level of compression ; 1 ( Z_BEST_SPEED ) is fastest and produces the least compression , 9 ( Z_BEST_COMPRESSION ) is slowest and produces the most .", "question_id": 12896}
{"snippet": "zlib.compressobj(zdict)", "intent": "Returns a compression object , to be used for compressing data streams that won \u2019 t fit into memory at once . `zdict` is a predefined compression dictionary .", "question_id": 12897}
{"snippet": "zlib.compressobj(zdict, level=-1)", "intent": "Returns a compression object , to be used for compressing data streams that won \u2019 t fit into memory at once . `zdict` is a predefined compression dictionary . `level` is the compression level \u2013 an integer from 0 to 9 or -1 .", "question_id": 12898}
{"snippet": "zlib.compressobj(zdict, method=DEFLATED)", "intent": "Returns a compression object , to be used for compressing data streams that won \u2019 t fit into memory at once . `zdict` is a predefined compression dictionary . `method` is the compression algorithm .", "question_id": 12899}
{"snippet": "zlib.compressobj(zdict, wbits=MAX_WBITS)", "intent": "Returns a compression object , to be used for compressing data streams that won \u2019 t fit into memory at once . `zdict` is a predefined compression dictionary . The `wbits` argument controls the size of the history buffer ( or the \u201c window size \u201d ) used when compressing data , and whether a header and trailer is included in the output .", "question_id": 12900}
{"snippet": "zlib.compressobj(zdict, memLevel=DEF_MEM_LEVEL)", "intent": "Returns a compression object , to be used for compressing data streams that won \u2019 t fit into memory at once . `zdict` is a predefined compression dictionary . The `memLevel` argument controls the amount of memory used for the internal compression state .", "question_id": 12901}
{"snippet": "zlib.compressobj(zdict, strategy=Z_DEFAULT_STRATEGY)", "intent": "Returns a compression object , to be used for compressing data streams that won \u2019 t fit into memory at once . `zdict` is a predefined compression dictionary . `strategy` is used to tune the compression algorithm .", "question_id": 12902}
{"snippet": "zlib.compressobj(zdict, level=-1, method=DEFLATED)", "intent": "Returns a compression object , to be used for compressing data streams that won \u2019 t fit into memory at once . `zdict` is a predefined compression dictionary . `level` is the compression level \u2013 an integer from 0 to 9 or -1 . `method` is the compression algorithm .", "question_id": 12903}
{"snippet": "zlib.compressobj(zdict, level=-1, wbits=MAX_WBITS)", "intent": "Returns a compression object , to be used for compressing data streams that won \u2019 t fit into memory at once . `zdict` is a predefined compression dictionary . `level` is the compression level \u2013 an integer from 0 to 9 or -1 . The `wbits` argument controls the size of the history buffer ( or the \u201c window size \u201d ) used when compressing data , and whether a header and trailer is included in the output .", "question_id": 12904}
{"snippet": "zlib.compressobj(zdict, level=-1, memLevel=DEF_MEM_LEVEL)", "intent": "Returns a compression object , to be used for compressing data streams that won \u2019 t fit into memory at once . `zdict` is a predefined compression dictionary . `level` is the compression level \u2013 an integer from 0 to 9 or -1 . The `memLevel` argument controls the amount of memory used for the internal compression state .", "question_id": 12905}
{"snippet": "zlib.compressobj(zdict, level=-1, strategy=Z_DEFAULT_STRATEGY)", "intent": "Returns a compression object , to be used for compressing data streams that won \u2019 t fit into memory at once . `zdict` is a predefined compression dictionary . `level` is the compression level \u2013 an integer from 0 to 9 or -1 . `strategy` is used to tune the compression algorithm .", "question_id": 12906}
{"snippet": "zlib.compressobj()", "intent": "Returns a compression object , to be used for compressing data streams that won \u2019 t fit into memory at once .", "question_id": 12907}
{"snippet": "zlib.compressobj(level=-1)", "intent": "Returns a compression object , to be used for compressing data streams that won \u2019 t fit into memory at once . `level` is the compression level \u2013 an integer from 0 to 9 or -1 .", "question_id": 12908}
{"snippet": "zlib.compressobj(method=DEFLATED)", "intent": "Returns a compression object , to be used for compressing data streams that won \u2019 t fit into memory at once . `method` is the compression algorithm .", "question_id": 12909}
{"snippet": "zlib.compressobj(wbits=MAX_WBITS)", "intent": "Returns a compression object , to be used for compressing data streams that won \u2019 t fit into memory at once . The `wbits` argument controls the size of the history buffer ( or the \u201c window size \u201d ) used when compressing data , and whether a header and trailer is included in the output .", "question_id": 12910}
{"snippet": "zlib.compressobj(memLevel=DEF_MEM_LEVEL)", "intent": "Returns a compression object , to be used for compressing data streams that won \u2019 t fit into memory at once . The `memLevel` argument controls the amount of memory used for the internal compression state .", "question_id": 12911}
{"snippet": "zlib.compressobj(strategy=Z_DEFAULT_STRATEGY)", "intent": "Returns a compression object , to be used for compressing data streams that won \u2019 t fit into memory at once . `strategy` is used to tune the compression algorithm .", "question_id": 12912}
{"snippet": "zlib.compressobj(level=-1, method=DEFLATED)", "intent": "Returns a compression object , to be used for compressing data streams that won \u2019 t fit into memory at once . `level` is the compression level \u2013 an integer from 0 to 9 or -1 . `method` is the compression algorithm .", "question_id": 12913}
{"snippet": "zlib.compressobj(level=-1, wbits=MAX_WBITS)", "intent": "Returns a compression object , to be used for compressing data streams that won \u2019 t fit into memory at once . `level` is the compression level \u2013 an integer from 0 to 9 or -1 . The `wbits` argument controls the size of the history buffer ( or the \u201c window size \u201d ) used when compressing data , and whether a header and trailer is included in the output .", "question_id": 12914}
{"snippet": "zlib.compressobj(level=-1, memLevel=DEF_MEM_LEVEL)", "intent": "Returns a compression object , to be used for compressing data streams that won \u2019 t fit into memory at once . `level` is the compression level \u2013 an integer from 0 to 9 or -1 . The `memLevel` argument controls the amount of memory used for the internal compression state .", "question_id": 12915}
{"snippet": "zlib.compressobj(level=-1, strategy=Z_DEFAULT_STRATEGY)", "intent": "Returns a compression object , to be used for compressing data streams that won \u2019 t fit into memory at once . `level` is the compression level \u2013 an integer from 0 to 9 or -1 . `strategy` is used to tune the compression algorithm .", "question_id": 12916}
{"snippet": "zlib.crc32(data, value)", "intent": "Computes a CRC ( Cyclic Redundancy Check ) checksum of `data` . If `value` is present , it is used as the starting value of the checksum ; otherwise , a default value of 0 is used .", "question_id": 12917}
{"snippet": "zlib.crc32(data)", "intent": "Computes a CRC ( Cyclic Redundancy Check ) checksum of `data` .", "question_id": 12918}
{"snippet": "zlib.decompress(data)", "intent": "Decompresses the bytes in `data` , returning a bytes object containing the uncompressed data .", "question_id": 12919}
{"snippet": "zlib.decompress(data, wbits=MAX_WBITS)", "intent": "Decompresses the bytes in `data` , returning a bytes object containing the uncompressed data . The `wbits` parameter depends on the format of data , and is discussed further below .", "question_id": 12920}
{"snippet": "zlib.decompress(data, bufsize=DEF_BUF_SIZE)", "intent": "Decompresses the bytes in `data` , returning a bytes object containing the uncompressed data . If `bufsize` is given , it is used as the initial size of the output buffer .", "question_id": 12921}
{"snippet": "zlib.decompress(data, wbits=MAX_WBITS, bufsize=DEF_BUF_SIZE)", "intent": "Decompresses the bytes in `data` , returning a bytes object containing the uncompressed data . The `wbits` parameter depends on the format of data , and is discussed further below . If `bufsize` is given , it is used as the initial size of the output buffer .", "question_id": 12922}
{"snippet": "zlib.decompressobj(zdict)", "intent": "Returns a decompression object , to be used for decompressing data streams that won \u2019 t fit into memory at once . The `zdict` parameter specifies a predefined compression dictionary .", "question_id": 12923}
{"snippet": "zlib.decompressobj(zdict, wbits=MAX_WBITS)", "intent": "Returns a decompression object , to be used for decompressing data streams that won \u2019 t fit into memory at once . The `zdict` parameter specifies a predefined compression dictionary . The `wbits` parameter controls the size of the history buffer ( or the \u201c window size \u201d ) , and what header and trailer format is expected .", "question_id": 12924}
{"snippet": "zlib.decompressobj()", "intent": "Returns a decompression object , to be used for decompressing data streams that won \u2019 t fit into memory at once .", "question_id": 12925}
{"snippet": "zlib.decompressobj(wbits=MAX_WBITS)", "intent": "Returns a decompression object , to be used for decompressing data streams that won \u2019 t fit into memory at once . The `wbits` parameter controls the size of the history buffer ( or the \u201c window size \u201d ) , and what header and trailer format is expected .", "question_id": 12926}
{"snippet": "Compress.compress(data)", "intent": "Compress `data` , returning a bytes object containing compressed data for at least part of the data in data .", "question_id": 12927}
{"snippet": "Compress.flush(mode)", "intent": "All pending input is processed , and a bytes object containing the remaining compressed output is returned . `mode` can be selected from the constants Z_NO_FLUSH , Z_PARTIAL_FLUSH , Z_SYNC_FLUSH , Z_FULL_FLUSH , Z_BLOCK ( zlib 1.2.3.4 ) , or Z_FINISH , defaulting to Z_FINISH .", "question_id": 12928}
{"snippet": "Compress.flush()", "intent": "All pending input is processed , and a bytes object containing the remaining compressed output is returned .", "question_id": 12929}
{"snippet": "Compress.copy()", "intent": "Returns a copy of the compression object .", "question_id": 12930}
{"snippet": "Decompress.unused_data", "intent": "A bytes object which contains any bytes past the end of the compressed data.", "question_id": 12931}
{"snippet": "Decompress.unconsumed_tail", "intent": "A bytes object that contains any data that was not consumed by the last decompress() call because it exceeded the limit for the uncompressed data buffer.", "question_id": 12932}
{"snippet": "Decompress.eof", "intent": "A boolean indicating whether the end of the compressed data stream has been reached.", "question_id": 12933}
{"snippet": "Decompress.decompress(data)", "intent": "Decompress `data` , returning a bytes object containing the uncompressed data corresponding to at least part of the data in string .", "question_id": 12934}
{"snippet": "Decompress.decompress(data, max_length=0)", "intent": "Decompress `data` , returning a bytes object containing the uncompressed data corresponding to at least part of the data in string . If the optional parameter `max_length` is non-zero then the return value will be no longer than max_length .", "question_id": 12935}
{"snippet": "Decompress.flush(length)", "intent": "All pending input is processed , and a bytes object containing the remaining uncompressed output is returned . The optional parameter `length` sets the initial size of the output buffer .", "question_id": 12936}
{"snippet": "Decompress.flush()", "intent": "All pending input is processed , and a bytes object containing the remaining uncompressed output is returned .", "question_id": 12937}
{"snippet": "Decompress.copy()", "intent": "Returns a copy of the decompression object .", "question_id": 12938}
{"snippet": "zlib.ZLIB_VERSION", "intent": "The version string of the zlib library that was used for building the module.", "question_id": 12939}
{"snippet": "zlib.ZLIB_RUNTIME_VERSION", "intent": "The version string of the zlib library actually loaded by the interpreter.", "question_id": 12940}
{"snippet": "_thread.error", "intent": "Raised on thread-specific errors.", "question_id": 12941}
{"snippet": "_thread.LockType", "intent": "This is the type of lock objects.", "question_id": 12942}
{"snippet": "_thread.start_new_thread(function, args, kwargs)", "intent": "Start a new thread and return its identifier . The thread executes the `function` function with the argument list `args` ( which must be a tuple ) . The optional `kwargs` argument specifies a dictionary of keyword arguments .", "question_id": 12943}
{"snippet": "_thread.start_new_thread(function, args)", "intent": "Start a new thread and return its identifier . The thread executes the `function` function with the argument list `args` ( which must be a tuple ) .", "question_id": 12944}
{"snippet": "_thread.interrupt_main()", "intent": "Simulate the effect of a signal.SIGINT signal arriving in the main thread .", "question_id": 12945}
{"snippet": "_thread.exit()", "intent": "Raise the SystemExit exception .", "question_id": 12946}
{"snippet": "_thread.allocate_lock()", "intent": "Return a new lock object .", "question_id": 12947}
{"snippet": "_thread.get_ident()", "intent": "Return the \u2018 thread identifier \u2019 of the current thread .", "question_id": 12948}
{"snippet": "_thread.stack_size(size)", "intent": "Return the thread stack `size` used when creating new threads .", "question_id": 12949}
{"snippet": "_thread.stack_size()", "intent": "Return the thread stack `size` used when creating new threads .", "question_id": 12950}
{"snippet": "_thread.TIMEOUT_MAX", "intent": "The maximum value allowed for the timeout parameter of Lock.acquire().", "question_id": 12951}
{"snippet": "lock.acquire()", "intent": "Without any optional argument , this method acquires the lock unconditionally , if necessary waiting until it is released by another thread ( only one thread at a time can acquire a lock \u2014 that \u2019 s their reason for existence ) .", "question_id": 12952}
{"snippet": "lock.acquire(waitflag=1)", "intent": "Without any optional argument , this method acquires the lock unconditionally , if necessary waiting until it is released by another thread ( only one thread at a time can acquire a lock \u2014 that \u2019 s their reason for existence ) . If the integer `waitflag` argument is present , the action depends on its value : if it is zero , the lock is only acquired if it can be acquired immediately without waiting , while if it is nonzero , the lock is acquired unconditionally as above .", "question_id": 12953}
{"snippet": "lock.acquire(timeout=-1)", "intent": "Without any optional argument , this method acquires the lock unconditionally , if necessary waiting until it is released by another thread ( only one thread at a time can acquire a lock \u2014 that \u2019 s their reason for existence ) . If the floating-point `timeout` argument is present and positive , it specifies the maximum wait time in seconds before returning .", "question_id": 12954}
{"snippet": "lock.acquire(waitflag=1, timeout=-1)", "intent": "Without any optional argument , this method acquires the lock unconditionally , if necessary waiting until it is released by another thread ( only one thread at a time can acquire a lock \u2014 that \u2019 s their reason for existence ) . If the integer `waitflag` argument is present , the action depends on its value : if it is zero , the lock is only acquired if it can be acquired immediately without waiting , while if it is nonzero , the lock is acquired unconditionally as above . If the floating-point `timeout` argument is present and positive , it specifies the maximum wait time in seconds before returning .", "question_id": 12955}
{"snippet": "lock.release()", "intent": "Releases the lock .", "question_id": 12956}
{"snippet": "lock.locked()", "intent": "Return the status of the lock : True if it has been acquired by some thread , False if not .", "question_id": 12957}
